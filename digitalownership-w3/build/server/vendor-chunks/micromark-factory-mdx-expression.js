"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-factory-mdx-expression";
exports.ids = ["vendor-chunks/micromark-factory-mdx-expression"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-factory-mdx-expression/dev/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-factory-mdx-expression/dev/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   factoryMdxExpression: () => (/* binding */ factoryMdxExpression)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_events_to_acorn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-util-events-to-acorn */ \"(ssr)/./node_modules/micromark-util-events-to-acorn/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var unist_util_position_from_estree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! unist-util-position-from-estree */ \"(ssr)/./node_modules/unist-util-position-from-estree/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @import {Program} from 'estree'\n * @import {Acorn, AcornOptions} from 'micromark-util-events-to-acorn'\n * @import {Effects, Point, State, TokenType, TokenizeContext} from 'micromark-util-types'\n */ /**\n * @typedef MdxSignalOk\n *   Good result.\n * @property {'ok'} type\n *   Type.\n * @property {Program | undefined} estree\n *   Value.\n *\n * @typedef MdxSignalNok\n *   Bad result.\n * @property {'nok'} type\n *   Type.\n * @property {VFileMessage} message\n *   Value.\n *\n * @typedef {MdxSignalNok | MdxSignalOk} MdxSignal\n */ \n\n\n\n\n\n\n// Tab-size to eat has to be the same as what we serialize as.\n// While in some places in markdown that’s 4, in JS it’s more common as 2.\n// Which is what’s also in `mdast-util-mdx-jsx`:\n// <https://github.com/syntax-tree/mdast-util-mdx-jsx/blob/40b951b/lib/index.js#L52>\nconst indentSize = 2;\nconst trouble = \"https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression\";\nconst unexpectedEndOfFileHash = \"#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-\";\nconst unexpectedLazyHash = \"#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed\";\nconst nonSpreadHash = \"#unexpected-type-in-code-expected-an-object-spread-spread\";\nconst spreadExtraHash = \"#unexpected-extra-content-in-spread-only-a-single-spread-is-supported\";\nconst acornHash = \"#could-not-parse-expression-with-acorn\";\n/**\n * @this {TokenizeContext}\n *   Context.\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful\n * @param {TokenType} type\n *   Token type for whole (`{}`).\n * @param {TokenType} markerType\n *   Token type for the markers (`{`, `}`).\n * @param {TokenType} chunkType\n *   Token type for the value (`1`).\n * @param {Acorn | null | undefined} [acorn]\n *   Object with `acorn.parse` and `acorn.parseExpressionAt`.\n * @param {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for acorn.\n * @param {boolean | null | undefined} [addResult=false]\n *   Add `estree` to token (default: `false`).\n * @param {boolean | null | undefined} [spread=false]\n *   Support a spread (`{...a}`) only (default: `false`).\n * @param {boolean | null | undefined} [allowEmpty=false]\n *   Support an empty expression (default: `false`).\n * @param {boolean | null | undefined} [allowLazy=false]\n *   Support lazy continuation of an expression (default: `false`).\n * @returns {State}\n */ // eslint-disable-next-line max-params\nfunction factoryMdxExpression(effects, ok, type, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {\n    const self = this;\n    const eventStart = this.events.length + 3 // Add main and marker token\n    ;\n    let size = 0;\n    /** @type {Point} */ let pointStart;\n    /** @type {Error} */ let lastCrash;\n    return start;\n    /**\n   * Start of an MDX expression.\n   *\n   * ```markdown\n   * > | a {Math.PI} c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function start(code) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.leftCurlyBrace, \"expected `{`\");\n        effects.enter(type);\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        pointStart = self.now();\n        return before;\n    }\n    /**\n   * Before data.\n   *\n   * ```markdown\n   * > | a {Math.PI} c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */ function before(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof) {\n            if (lastCrash) throw lastCrash;\n            const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Unexpected end of file in expression, expected a corresponding closing brace for `{`\", {\n                place: self.now(),\n                ruleId: \"unexpected-eof\",\n                source: \"micromark-extension-mdx-expression\"\n            });\n            error.url = trouble + unexpectedEndOfFileHash;\n            throw error;\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding);\n            effects.consume(code);\n            effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding);\n            return eolAfter;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.rightCurlyBrace && size === 0) {\n            /** @type {MdxSignal} */ const next = acorn ? mdxExpressionParse.call(self, acorn, acornOptions, chunkType, eventStart, pointStart, allowEmpty || false, spread || false) : {\n                type: \"ok\",\n                estree: undefined\n            };\n            if (next.type === \"ok\") {\n                effects.enter(markerType);\n                effects.consume(code);\n                effects.exit(markerType);\n                const token = effects.exit(type);\n                if (addResult && next.estree) {\n                    Object.assign(token, {\n                        estree: next.estree\n                    });\n                }\n                return ok;\n            }\n            lastCrash = next.message;\n            effects.enter(chunkType);\n            effects.consume(code);\n            return inside;\n        }\n        effects.enter(chunkType);\n        return inside(code);\n    }\n    /**\n   * In data.\n   *\n   * ```markdown\n   * > | a {Math.PI} c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */ function inside(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.rightCurlyBrace && size === 0 || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            effects.exit(chunkType);\n            return before(code);\n        }\n        // Don’t count if gnostic.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.leftCurlyBrace && !acorn) {\n            size += 1;\n        } else if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.rightCurlyBrace) {\n            size -= 1;\n        }\n        effects.consume(code);\n        return inside;\n    }\n    /**\n   * After eol.\n   *\n   * ```markdown\n   *   | a {b +\n   * > | c} d\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function eolAfter(code) {\n        const now = self.now();\n        // Lazy continuation in a flow expression (or flow tag) is a syntax error.\n        if (now.line !== pointStart.line && !allowLazy && self.parser.lazy[now.line]) {\n            const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc\", {\n                place: self.now(),\n                ruleId: \"unexpected-lazy\",\n                source: \"micromark-extension-mdx-expression\"\n            });\n            error.url = trouble + unexpectedLazyHash;\n            throw error;\n        }\n        // Note: `markdown-rs` uses `4`, but we use `2`.\n        //\n        // Idea: investigate if we’d need to use more complex stripping.\n        // Take this example:\n        //\n        // ```markdown\n        // >  aaa <b c={`\n        // >      d\n        // >  `} /> eee\n        // ```\n        //\n        // Currently, the “paragraph” starts at `> | aaa`, so for the next line\n        // here we split it into `>␠|␠␠|␠␠␠d` (prefix, this indent here,\n        // expression data).\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_5__.factorySpace)(effects, before, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix, indentSize + 1)(code);\n        }\n        return before(code);\n    }\n}\n/**\n * Mix of `markdown-rs`’s `parse_expression` and `MdxExpressionParse`\n * functionality, to wrap our `eventsToAcorn`.\n *\n * In the future, the plan is to realise the rust way, which allows arbitrary\n * parsers.\n *\n * @this {TokenizeContext}\n * @param {Acorn} acorn\n * @param {AcornOptions | null | undefined} acornOptions\n * @param {TokenType} chunkType\n * @param {number} eventStart\n * @param {Point} pointStart\n * @param {boolean} allowEmpty\n * @param {boolean} spread\n * @returns {MdxSignal}\n */ // eslint-disable-next-line max-params\nfunction mdxExpressionParse(acorn, acornOptions, chunkType, eventStart, pointStart, allowEmpty, spread) {\n    // Gnostic mode: parse w/ acorn.\n    const result = (0,micromark_util_events_to_acorn__WEBPACK_IMPORTED_MODULE_6__.eventsToAcorn)(this.events.slice(eventStart), {\n        acorn,\n        tokenTypes: [\n            chunkType\n        ],\n        acornOptions,\n        start: pointStart,\n        expression: true,\n        allowEmpty,\n        prefix: spread ? \"({\" : \"\",\n        suffix: spread ? \"})\" : \"\"\n    });\n    const estree = result.estree;\n    // Get the spread value.\n    if (spread && estree) {\n        // Should always be the case as we wrap in `d={}`\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(estree.type === \"Program\", \"expected program\");\n        const head = estree.body[0];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(head, \"expected body\");\n        if (head.type !== \"ExpressionStatement\" || head.expression.type !== \"ObjectExpression\") {\n            const place = (0,unist_util_position_from_estree__WEBPACK_IMPORTED_MODULE_7__.positionFromEstree)(head);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(place, \"expected position\");\n            const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Unexpected `\" + head.type + \"` in code: expected an object spread (`{...spread}`)\", {\n                place: place.start,\n                ruleId: \"non-spread\",\n                source: \"micromark-extension-mdx-expression\"\n            });\n            error.url = trouble + nonSpreadHash;\n            throw error;\n        }\n        if (head.expression.properties[1]) {\n            const place = (0,unist_util_position_from_estree__WEBPACK_IMPORTED_MODULE_7__.positionFromEstree)(head.expression.properties[1]);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(place, \"expected position\");\n            const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Unexpected extra content in spread: only a single spread is supported\", {\n                place: place.start,\n                ruleId: \"spread-extra\",\n                source: \"micromark-extension-mdx-expression\"\n            });\n            error.url = trouble + spreadExtraHash;\n            throw error;\n        }\n        if (head.expression.properties[0] && head.expression.properties[0].type !== \"SpreadElement\") {\n            const place = (0,unist_util_position_from_estree__WEBPACK_IMPORTED_MODULE_7__.positionFromEstree)(head.expression.properties[0]);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(place, \"expected position\");\n            const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Unexpected `\" + head.expression.properties[0].type + \"` in code: only spread elements are supported\", {\n                place: place.start,\n                ruleId: \"non-spread\",\n                source: \"micromark-extension-mdx-expression\"\n            });\n            error.url = trouble + nonSpreadHash;\n            throw error;\n        }\n    }\n    if (result.error) {\n        const error = new vfile_message__WEBPACK_IMPORTED_MODULE_2__.VFileMessage(\"Could not parse expression with acorn\", {\n            cause: result.error,\n            place: {\n                line: result.error.loc.line,\n                column: result.error.loc.column + 1,\n                offset: result.error.pos\n            },\n            ruleId: \"acorn\",\n            source: \"micromark-extension-mdx-expression\"\n        });\n        error.url = trouble + acornHash;\n        return {\n            type: \"nok\",\n            message: error\n        };\n    }\n    return {\n        type: \"ok\",\n        estree\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3RvcnktbWR4LWV4cHJlc3Npb24vZGV2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVrQztBQUNpQjtBQUNzQjtBQUNkO0FBQ1Y7QUFDZ0I7QUFDeEI7QUFFMUMsOERBQThEO0FBQzlELDBFQUEwRTtBQUMxRSxnREFBZ0Q7QUFDaEQsb0ZBQW9GO0FBQ3BGLE1BQU1VLGFBQWE7QUFFbkIsTUFBTUMsVUFDSjtBQUVGLE1BQU1DLDBCQUNKO0FBQ0YsTUFBTUMscUJBQ0o7QUFDRixNQUFNQyxnQkFDSjtBQUNGLE1BQU1DLGtCQUNKO0FBQ0YsTUFBTUMsWUFBWTtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FDRCxzQ0FBc0M7QUFDL0IsU0FBU0MscUJBQ2RDLE9BQU8sRUFDUGxCLEVBQUUsRUFDRm1CLElBQUksRUFDSkMsVUFBVSxFQUNWQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsWUFBWSxFQUNaQyxTQUFTLEVBQ1RDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxTQUFTO0lBRVQsTUFBTUMsT0FBTyxJQUFJO0lBQ2pCLE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxNQUFNLENBQUNDLE1BQU0sR0FBRyxFQUFFLDRCQUE0Qjs7SUFDdEUsSUFBSUMsT0FBTztJQUNYLGtCQUFrQixHQUNsQixJQUFJQztJQUNKLGtCQUFrQixHQUNsQixJQUFJQztJQUVKLE9BQU9DO0lBRVA7Ozs7Ozs7OztHQVNDLEdBQ0QsU0FBU0EsTUFBTUMsSUFBSTtRQUNqQm5DLDBDQUFNQSxDQUFDbUMsU0FBUzlCLHdEQUFLQSxDQUFDK0IsY0FBYyxFQUFFO1FBQ3RDbkIsUUFBUW9CLEtBQUssQ0FBQ25CO1FBQ2RELFFBQVFvQixLQUFLLENBQUNsQjtRQUNkRixRQUFRcUIsT0FBTyxDQUFDSDtRQUNoQmxCLFFBQVFzQixJQUFJLENBQUNw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RUZILE1BQU1JLEdBQUcsR0FBR3JDLFVBQVVHO1lBQ3RCLE1BQU04QjtRQUNSO0lBQ0Y7SUFFQSxJQUFJc0IsT0FBT3RCLEtBQUssRUFBRTtRQUNoQixNQUFNQSxRQUFRLElBQUluQyx1REFBWUEsQ0FBQyx5Q0FBeUM7WUFDdEVrRSxPQUFPVCxPQUFPdEIsS0FBSztZQUNuQkMsT0FBTztnQkFDTGlCLE1BQU1JLE9BQU90QixLQUFLLENBQUNnQyxHQUFHLENBQUNkLElBQUk7Z0JBQzNCZSxRQUFRWCxPQUFPdEIsS0FBSyxDQUFDZ0MsR0FBRyxDQUFDQyxNQUFNLEdBQUc7Z0JBQ2xDQyxRQUFRWixPQUFPdEIsS0FBSyxDQUFDbUMsR0FBRztZQUMxQjtZQUNBakMsUUFBUTtZQUNSQyxRQUFRO1FBQ1Y7UUFDQUgsTUFBTUksR0FBRyxHQUFHckMsVUFBVUs7UUFFdEIsT0FBTztZQUFDRyxNQUFNO1lBQU95QyxTQUFTaEI7UUFBSztJQUNyQztJQUVBLE9BQU87UUFBQ3pCLE1BQU07UUFBTW9DO0lBQU07QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWZhY3RvcnktbWR4LWV4cHJlc3Npb24vZGV2L2luZGV4LmpzP2MwM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtQcm9ncmFtfSBmcm9tICdlc3RyZWUnXG4gKiBAaW1wb3J0IHtBY29ybiwgQWNvcm5PcHRpb25zfSBmcm9tICdtaWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4nXG4gKiBAaW1wb3J0IHtFZmZlY3RzLCBQb2ludCwgU3RhdGUsIFRva2VuVHlwZSwgVG9rZW5pemVDb250ZXh0fSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE1keFNpZ25hbE9rXG4gKiAgIEdvb2QgcmVzdWx0LlxuICogQHByb3BlcnR5IHsnb2snfSB0eXBlXG4gKiAgIFR5cGUuXG4gKiBAcHJvcGVydHkge1Byb2dyYW0gfCB1bmRlZmluZWR9IGVzdHJlZVxuICogICBWYWx1ZS5cbiAqXG4gKiBAdHlwZWRlZiBNZHhTaWduYWxOb2tcbiAqICAgQmFkIHJlc3VsdC5cbiAqIEBwcm9wZXJ0eSB7J25vayd9IHR5cGVcbiAqICAgVHlwZS5cbiAqIEBwcm9wZXJ0eSB7VkZpbGVNZXNzYWdlfSBtZXNzYWdlXG4gKiAgIFZhbHVlLlxuICpcbiAqIEB0eXBlZGVmIHtNZHhTaWduYWxOb2sgfCBNZHhTaWduYWxPa30gTWR4U2lnbmFsXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2V2ZW50c1RvQWNvcm59IGZyb20gJ21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybidcbmltcG9ydCB7Y29kZXMsIHR5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5pbXBvcnQge3Bvc2l0aW9uRnJvbUVzdHJlZX0gZnJvbSAndW5pc3QtdXRpbC1wb3NpdGlvbi1mcm9tLWVzdHJlZSdcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vLyBUYWItc2l6ZSB0byBlYXQgaGFzIHRvIGJlIHRoZSBzYW1lIGFzIHdoYXQgd2Ugc2VyaWFsaXplIGFzLlxuLy8gV2hpbGUgaW4gc29tZSBwbGFjZXMgaW4gbWFya2Rvd24gdGhhdOKAmXMgNCwgaW4gSlMgaXTigJlzIG1vcmUgY29tbW9uIGFzIDIuXG4vLyBXaGljaCBpcyB3aGF04oCZcyBhbHNvIGluIGBtZGFzdC11dGlsLW1keC1qc3hgOlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLW1keC1qc3gvYmxvYi80MGI5NTFiL2xpYi9pbmRleC5qcyNMNTI+XG5jb25zdCBpbmRlbnRTaXplID0gMlxuXG5jb25zdCB0cm91YmxlID1cbiAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hcmsvbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbi90cmVlL21haW4vcGFja2FnZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbidcblxuY29uc3QgdW5leHBlY3RlZEVuZE9mRmlsZUhhc2ggPVxuICAnI3VuZXhwZWN0ZWQtZW5kLW9mLWZpbGUtaW4tZXhwcmVzc2lvbi1leHBlY3RlZC1hLWNvcnJlc3BvbmRpbmctY2xvc2luZy1icmFjZS1mb3ItJ1xuY29uc3QgdW5leHBlY3RlZExhenlIYXNoID1cbiAgJyN1bmV4cGVjdGVkLWxhenktbGluZS1pbi1leHByZXNzaW9uLWluLWNvbnRhaW5lci1leHBlY3RlZC1saW5lLXRvLWJlLXByZWZpeGVkJ1xuY29uc3Qgbm9uU3ByZWFkSGFzaCA9XG4gICcjdW5leHBlY3RlZC10eXBlLWluLWNvZGUtZXhwZWN0ZWQtYW4tb2JqZWN0LXNwcmVhZC1zcHJlYWQnXG5jb25zdCBzcHJlYWRFeHRyYUhhc2ggPVxuICAnI3VuZXhwZWN0ZWQtZXh0cmEtY29udGVudC1pbi1zcHJlYWQtb25seS1hLXNpbmdsZS1zcHJlYWQtaXMtc3VwcG9ydGVkJ1xuY29uc3QgYWNvcm5IYXNoID0gJyNjb3VsZC1ub3QtcGFyc2UtZXhwcmVzc2lvbi13aXRoLWFjb3JuJ1xuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7U3RhdGV9IG9rXG4gKiAgIFN0YXRlIHN3aXRjaGVkIHRvIHdoZW4gc3VjY2Vzc2Z1bFxuICogQHBhcmFtIHtUb2tlblR5cGV9IHR5cGVcbiAqICAgVG9rZW4gdHlwZSBmb3Igd2hvbGUgKGB7fWApLlxuICogQHBhcmFtIHtUb2tlblR5cGV9IG1hcmtlclR5cGVcbiAqICAgVG9rZW4gdHlwZSBmb3IgdGhlIG1hcmtlcnMgKGB7YCwgYH1gKS5cbiAqIEBwYXJhbSB7VG9rZW5UeXBlfSBjaHVua1R5cGVcbiAqICAgVG9rZW4gdHlwZSBmb3IgdGhlIHZhbHVlIChgMWApLlxuICogQHBhcmFtIHtBY29ybiB8IG51bGwgfCB1bmRlZmluZWR9IFthY29ybl1cbiAqICAgT2JqZWN0IHdpdGggYGFjb3JuLnBhcnNlYCBhbmQgYGFjb3JuLnBhcnNlRXhwcmVzc2lvbkF0YC5cbiAqIEBwYXJhbSB7QWNvcm5PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuT3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYWNvcm4uXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWRkUmVzdWx0PWZhbHNlXVxuICogICBBZGQgYGVzdHJlZWAgdG8gdG9rZW4gKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwcmVhZD1mYWxzZV1cbiAqICAgU3VwcG9ydCBhIHNwcmVhZCAoYHsuLi5hfWApIG9ubHkgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2FsbG93RW1wdHk9ZmFsc2VdXG4gKiAgIFN1cHBvcnQgYW4gZW1wdHkgZXhwcmVzc2lvbiAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dMYXp5PWZhbHNlXVxuICogICBTdXBwb3J0IGxhenkgY29udGludWF0aW9uIG9mIGFuIGV4cHJlc3Npb24gKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHJldHVybnMge1N0YXRlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcnlNZHhFeHByZXNzaW9uKFxuICBlZmZlY3RzLFxuICBvayxcbiAgdHlwZSxcbiAgbWFya2VyVHlwZSxcbiAgY2h1bmtUeXBlLFxuICBhY29ybixcbiAgYWNvcm5PcHRpb25zLFxuICBhZGRSZXN1bHQsXG4gIHNwcmVhZCxcbiAgYWxsb3dFbXB0eSxcbiAgYWxsb3dMYXp5XG4pIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgZXZlbnRTdGFydCA9IHRoaXMuZXZlbnRzLmxlbmd0aCArIDMgLy8gQWRkIG1haW4gYW5kIG1hcmtlciB0b2tlblxuICBsZXQgc2l6ZSA9IDBcbiAgLyoqIEB0eXBlIHtQb2ludH0gKi9cbiAgbGV0IHBvaW50U3RhcnRcbiAgLyoqIEB0eXBlIHtFcnJvcn0gKi9cbiAgbGV0IGxhc3RDcmFzaFxuXG4gIHJldHVybiBzdGFydFxuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBhbiBNRFggZXhwcmVzc2lvbi5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGEge01hdGguUEl9IGNcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGFzc2VydChjb2RlID09PSBjb2Rlcy5sZWZ0Q3VybHlCcmFjZSwgJ2V4cGVjdGVkIGB7YCcpXG4gICAgZWZmZWN0cy5lbnRlcih0eXBlKVxuICAgIGVmZmVjdHMuZW50ZXIobWFya2VyVHlwZSlcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQobWFya2VyVHlwZSlcbiAgICBwb2ludFN0YXJ0ID0gc2VsZi5ub3coKVxuICAgIHJldHVybiBiZWZvcmVcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgZGF0YS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGEge01hdGguUEl9IGNcbiAgICogICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZikge1xuICAgICAgaWYgKGxhc3RDcmFzaCkgdGhyb3cgbGFzdENyYXNoXG5cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgICAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUgaW4gZXhwcmVzc2lvbiwgZXhwZWN0ZWQgYSBjb3JyZXNwb25kaW5nIGNsb3NpbmcgYnJhY2UgZm9yIGB7YCcsXG4gICAgICAgIHtcbiAgICAgICAgICBwbGFjZTogc2VsZi5ub3coKSxcbiAgICAgICAgICBydWxlSWQ6ICd1bmV4cGVjdGVkLWVvZicsXG4gICAgICAgICAgc291cmNlOiAnbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbidcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgZXJyb3IudXJsID0gdHJvdWJsZSArIHVuZXhwZWN0ZWRFbmRPZkZpbGVIYXNoXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIodHlwZXMubGluZUVuZGluZylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICByZXR1cm4gZW9sQWZ0ZXJcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMucmlnaHRDdXJseUJyYWNlICYmIHNpemUgPT09IDApIHtcbiAgICAgIC8qKiBAdHlwZSB7TWR4U2lnbmFsfSAqL1xuICAgICAgY29uc3QgbmV4dCA9IGFjb3JuXG4gICAgICAgID8gbWR4RXhwcmVzc2lvblBhcnNlLmNhbGwoXG4gICAgICAgICAgICBzZWxmLFxuICAgICAgICAgICAgYWNvcm4sXG4gICAgICAgICAgICBhY29ybk9wdGlvbnMsXG4gICAgICAgICAgICBjaHVua1R5cGUsXG4gICAgICAgICAgICBldmVudFN0YXJ0LFxuICAgICAgICAgICAgcG9pbnRTdGFydCxcbiAgICAgICAgICAgIGFsbG93RW1wdHkgfHwgZmFsc2UsXG4gICAgICAgICAgICBzcHJlYWQgfHwgZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgIDoge3R5cGU6ICdvaycsIGVzdHJlZTogdW5kZWZpbmVkfVxuXG4gICAgICBpZiAobmV4dC50eXBlID09PSAnb2snKSB7XG4gICAgICAgIGVmZmVjdHMuZW50ZXIobWFya2VyVHlwZSlcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIGVmZmVjdHMuZXhpdChtYXJrZXJUeXBlKVxuICAgICAgICBjb25zdCB0b2tlbiA9IGVmZmVjdHMuZXhpdCh0eXBlKVxuXG4gICAgICAgIGlmIChhZGRSZXN1bHQgJiYgbmV4dC5lc3RyZWUpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7ZXN0cmVlOiBuZXh0LmVzdHJlZX0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2tcbiAgICAgIH1cblxuICAgICAgbGFzdENyYXNoID0gbmV4dC5tZXNzYWdlXG4gICAgICBlZmZlY3RzLmVudGVyKGNodW5rVHlwZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGluc2lkZVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoY2h1bmtUeXBlKVxuICAgIHJldHVybiBpbnNpZGUoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSB7TWF0aC5QSX0gY1xuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAoY29kZSA9PT0gY29kZXMucmlnaHRDdXJseUJyYWNlICYmIHNpemUgPT09IDApIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KGNodW5rVHlwZSlcbiAgICAgIHJldHVybiBiZWZvcmUoY29kZSlcbiAgICB9XG5cbiAgICAvLyBEb27igJl0IGNvdW50IGlmIGdub3N0aWMuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmxlZnRDdXJseUJyYWNlICYmICFhY29ybikge1xuICAgICAgc2l6ZSArPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBjb2Rlcy5yaWdodEN1cmx5QnJhY2UpIHtcbiAgICAgIHNpemUgLT0gMVxuICAgIH1cblxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBpbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBlb2wuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCBhIHtiICtcbiAgICogPiB8IGN9IGRcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVvbEFmdGVyKGNvZGUpIHtcbiAgICBjb25zdCBub3cgPSBzZWxmLm5vdygpXG5cbiAgICAvLyBMYXp5IGNvbnRpbnVhdGlvbiBpbiBhIGZsb3cgZXhwcmVzc2lvbiAob3IgZmxvdyB0YWcpIGlzIGEgc3ludGF4IGVycm9yLlxuICAgIGlmIChcbiAgICAgIG5vdy5saW5lICE9PSBwb2ludFN0YXJ0LmxpbmUgJiZcbiAgICAgICFhbGxvd0xhenkgJiZcbiAgICAgIHNlbGYucGFyc2VyLmxhenlbbm93LmxpbmVdXG4gICAgKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGxhenkgbGluZSBpbiBleHByZXNzaW9uIGluIGNvbnRhaW5lciwgZXhwZWN0ZWQgbGluZSB0byBiZSBwcmVmaXhlZCB3aXRoIGA+YCB3aGVuIGluIGEgYmxvY2sgcXVvdGUsIHdoaXRlc3BhY2Ugd2hlbiBpbiBhIGxpc3QsIGV0YycsXG4gICAgICAgIHtcbiAgICAgICAgICBwbGFjZTogc2VsZi5ub3coKSxcbiAgICAgICAgICBydWxlSWQ6ICd1bmV4cGVjdGVkLWxhenknLFxuICAgICAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIGVycm9yLnVybCA9IHRyb3VibGUgKyB1bmV4cGVjdGVkTGF6eUhhc2hcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgLy8gTm90ZTogYG1hcmtkb3duLXJzYCB1c2VzIGA0YCwgYnV0IHdlIHVzZSBgMmAuXG4gICAgLy9cbiAgICAvLyBJZGVhOiBpbnZlc3RpZ2F0ZSBpZiB3ZeKAmWQgbmVlZCB0byB1c2UgbW9yZSBjb21wbGV4IHN0cmlwcGluZy5cbiAgICAvLyBUYWtlIHRoaXMgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIGBgYG1hcmtkb3duXG4gICAgLy8gPiAgYWFhIDxiIGM9e2BcbiAgICAvLyA+ICAgICAgZFxuICAgIC8vID4gIGB9IC8+IGVlZVxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgLy8gQ3VycmVudGx5LCB0aGUg4oCccGFyYWdyYXBo4oCdIHN0YXJ0cyBhdCBgPiB8IGFhYWAsIHNvIGZvciB0aGUgbmV4dCBsaW5lXG4gICAgLy8gaGVyZSB3ZSBzcGxpdCBpdCBpbnRvIGA+4pCgfOKQoOKQoHzikKDikKDikKBkYCAocHJlZml4LCB0aGlzIGluZGVudCBoZXJlLFxuICAgIC8vIGV4cHJlc3Npb24gZGF0YSkuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGJlZm9yZSxcbiAgICAgICAgdHlwZXMubGluZVByZWZpeCxcbiAgICAgICAgaW5kZW50U2l6ZSArIDFcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gYmVmb3JlKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBNaXggb2YgYG1hcmtkb3duLXJzYOKAmXMgYHBhcnNlX2V4cHJlc3Npb25gIGFuZCBgTWR4RXhwcmVzc2lvblBhcnNlYFxuICogZnVuY3Rpb25hbGl0eSwgdG8gd3JhcCBvdXIgYGV2ZW50c1RvQWNvcm5gLlxuICpcbiAqIEluIHRoZSBmdXR1cmUsIHRoZSBwbGFuIGlzIHRvIHJlYWxpc2UgdGhlIHJ1c3Qgd2F5LCB3aGljaCBhbGxvd3MgYXJiaXRyYXJ5XG4gKiBwYXJzZXJzLlxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAcGFyYW0ge0Fjb3JufSBhY29yblxuICogQHBhcmFtIHtBY29ybk9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBhY29ybk9wdGlvbnNcbiAqIEBwYXJhbSB7VG9rZW5UeXBlfSBjaHVua1R5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFN0YXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludFN0YXJ0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ByZWFkXG4gKiBAcmV0dXJucyB7TWR4U2lnbmFsfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gbWR4RXhwcmVzc2lvblBhcnNlKFxuICBhY29ybixcbiAgYWNvcm5PcHRpb25zLFxuICBjaHVua1R5cGUsXG4gIGV2ZW50U3RhcnQsXG4gIHBvaW50U3RhcnQsXG4gIGFsbG93RW1wdHksXG4gIHNwcmVhZFxuKSB7XG4gIC8vIEdub3N0aWMgbW9kZTogcGFyc2Ugdy8gYWNvcm4uXG4gIGNvbnN0IHJlc3VsdCA9IGV2ZW50c1RvQWNvcm4odGhpcy5ldmVudHMuc2xpY2UoZXZlbnRTdGFydCksIHtcbiAgICBhY29ybixcbiAgICB0b2tlblR5cGVzOiBbY2h1bmtUeXBlXSxcbiAgICBhY29ybk9wdGlvbnMsXG4gICAgc3RhcnQ6IHBvaW50U3RhcnQsXG4gICAgZXhwcmVzc2lvbjogdHJ1ZSxcbiAgICBhbGxvd0VtcHR5LFxuICAgIHByZWZpeDogc3ByZWFkID8gJyh7JyA6ICcnLFxuICAgIHN1ZmZpeDogc3ByZWFkID8gJ30pJyA6ICcnXG4gIH0pXG4gIGNvbnN0IGVzdHJlZSA9IHJlc3VsdC5lc3RyZWVcblxuICAvLyBHZXQgdGhlIHNwcmVhZCB2YWx1ZS5cbiAgaWYgKHNwcmVhZCAmJiBlc3RyZWUpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHRoZSBjYXNlIGFzIHdlIHdyYXAgaW4gYGQ9e31gXG4gICAgYXNzZXJ0KGVzdHJlZS50eXBlID09PSAnUHJvZ3JhbScsICdleHBlY3RlZCBwcm9ncmFtJylcbiAgICBjb25zdCBoZWFkID0gZXN0cmVlLmJvZHlbMF1cbiAgICBhc3NlcnQoaGVhZCwgJ2V4cGVjdGVkIGJvZHknKVxuXG4gICAgaWYgKFxuICAgICAgaGVhZC50eXBlICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgIGhlYWQuZXhwcmVzc2lvbi50eXBlICE9PSAnT2JqZWN0RXhwcmVzc2lvbidcbiAgICApIHtcbiAgICAgIGNvbnN0IHBsYWNlID0gcG9zaXRpb25Gcm9tRXN0cmVlKGhlYWQpXG4gICAgICBhc3NlcnQocGxhY2UsICdleHBlY3RlZCBwb3NpdGlvbicpXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGAnICtcbiAgICAgICAgICBoZWFkLnR5cGUgK1xuICAgICAgICAgICdgIGluIGNvZGU6IGV4cGVjdGVkIGFuIG9iamVjdCBzcHJlYWQgKGB7Li4uc3ByZWFkfWApJyxcbiAgICAgICAge1xuICAgICAgICAgIHBsYWNlOiBwbGFjZS5zdGFydCxcbiAgICAgICAgICBydWxlSWQ6ICdub24tc3ByZWFkJyxcbiAgICAgICAgICBzb3VyY2U6ICdtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uJ1xuICAgICAgICB9XG4gICAgICApXG4gICAgICBlcnJvci51cmwgPSB0cm91YmxlICsgbm9uU3ByZWFkSGFzaFxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoaGVhZC5leHByZXNzaW9uLnByb3BlcnRpZXNbMV0pIHtcbiAgICAgIGNvbnN0IHBsYWNlID0gcG9zaXRpb25Gcm9tRXN0cmVlKGhlYWQuZXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzFdKVxuICAgICAgYXNzZXJ0KHBsYWNlLCAnZXhwZWN0ZWQgcG9zaXRpb24nKVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBleHRyYSBjb250ZW50IGluIHNwcmVhZDogb25seSBhIHNpbmdsZSBzcHJlYWQgaXMgc3VwcG9ydGVkJyxcbiAgICAgICAge1xuICAgICAgICAgIHBsYWNlOiBwbGFjZS5zdGFydCxcbiAgICAgICAgICBydWxlSWQ6ICdzcHJlYWQtZXh0cmEnLFxuICAgICAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIGVycm9yLnVybCA9IHRyb3VibGUgKyBzcHJlYWRFeHRyYUhhc2hcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgaGVhZC5leHByZXNzaW9uLnByb3BlcnRpZXNbMF0gJiZcbiAgICAgIGhlYWQuZXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzBdLnR5cGUgIT09ICdTcHJlYWRFbGVtZW50J1xuICAgICkge1xuICAgICAgY29uc3QgcGxhY2UgPSBwb3NpdGlvbkZyb21Fc3RyZWUoaGVhZC5leHByZXNzaW9uLnByb3BlcnRpZXNbMF0pXG4gICAgICBhc3NlcnQocGxhY2UsICdleHBlY3RlZCBwb3NpdGlvbicpXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGAnICtcbiAgICAgICAgICBoZWFkLmV4cHJlc3Npb24ucHJvcGVydGllc1swXS50eXBlICtcbiAgICAgICAgICAnYCBpbiBjb2RlOiBvbmx5IHNwcmVhZCBlbGVtZW50cyBhcmUgc3VwcG9ydGVkJyxcbiAgICAgICAge1xuICAgICAgICAgIHBsYWNlOiBwbGFjZS5zdGFydCxcbiAgICAgICAgICBydWxlSWQ6ICdub24tc3ByZWFkJyxcbiAgICAgICAgICBzb3VyY2U6ICdtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uJ1xuICAgICAgICB9XG4gICAgICApXG4gICAgICBlcnJvci51cmwgPSB0cm91YmxlICsgbm9uU3ByZWFkSGFzaFxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgVkZpbGVNZXNzYWdlKCdDb3VsZCBub3QgcGFyc2UgZXhwcmVzc2lvbiB3aXRoIGFjb3JuJywge1xuICAgICAgY2F1c2U6IHJlc3VsdC5lcnJvcixcbiAgICAgIHBsYWNlOiB7XG4gICAgICAgIGxpbmU6IHJlc3VsdC5lcnJvci5sb2MubGluZSxcbiAgICAgICAgY29sdW1uOiByZXN1bHQuZXJyb3IubG9jLmNvbHVtbiArIDEsXG4gICAgICAgIG9mZnNldDogcmVzdWx0LmVycm9yLnBvc1xuICAgICAgfSxcbiAgICAgIHJ1bGVJZDogJ2Fjb3JuJyxcbiAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgfSlcbiAgICBlcnJvci51cmwgPSB0cm91YmxlICsgYWNvcm5IYXNoXG5cbiAgICByZXR1cm4ge3R5cGU6ICdub2snLCBtZXNzYWdlOiBlcnJvcn1cbiAgfVxuXG4gIHJldHVybiB7dHlwZTogJ29rJywgZXN0cmVlfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiZmFjdG9yeVNwYWNlIiwibWFya2Rvd25MaW5lRW5kaW5nIiwibWFya2Rvd25TcGFjZSIsImV2ZW50c1RvQWNvcm4iLCJjb2RlcyIsInR5cGVzIiwicG9zaXRpb25Gcm9tRXN0cmVlIiwiVkZpbGVNZXNzYWdlIiwiaW5kZW50U2l6ZSIsInRyb3VibGUiLCJ1bmV4cGVjdGVkRW5kT2ZGaWxlSGFzaCIsInVuZXhwZWN0ZWRMYXp5SGFzaCIsIm5vblNwcmVhZEhhc2giLCJzcHJlYWRFeHRyYUhhc2giLCJhY29ybkhhc2giLCJmYWN0b3J5TWR4RXhwcmVzc2lvbiIsImVmZmVjdHMiLCJ0eXBlIiwibWFya2VyVHlwZSIsImNodW5rVHlwZSIsImFjb3JuIiwiYWNvcm5PcHRpb25zIiwiYWRkUmVzdWx0Iiwic3ByZWFkIiwiYWxsb3dFbXB0eSIsImFsbG93TGF6eSIsInNlbGYiLCJldmVudFN0YXJ0IiwiZXZlbnRzIiwibGVuZ3RoIiwic2l6ZSIsInBvaW50U3RhcnQiLCJsYXN0Q3Jhc2giLCJzdGFydCIsImNvZGUiLCJsZWZ0Q3VybHlCcmFjZSIsImVudGVyIiwiY29uc3VtZSIsImV4aXQiLCJub3ciLCJiZWZvcmUiLCJlb2YiLCJlcnJvciIsInBsYWNlIiwicnVsZUlkIiwic291cmNlIiwidXJsIiwibGluZUVuZGluZyIsImVvbEFmdGVyIiwicmlnaHRDdXJseUJyYWNlIiwibmV4dCIsIm1keEV4cHJlc3Npb25QYXJzZSIsImNhbGwiLCJlc3RyZWUiLCJ1bmRlZmluZWQiLCJ0b2tlbiIsIk9iamVjdCIsImFzc2lnbiIsIm1lc3NhZ2UiLCJpbnNpZGUiLCJsaW5lIiwicGFyc2VyIiwibGF6eSIsImxpbmVQcmVmaXgiLCJyZXN1bHQiLCJzbGljZSIsInRva2VuVHlwZXMiLCJleHByZXNzaW9uIiwicHJlZml4Iiwic3VmZml4IiwiaGVhZCIsImJvZHkiLCJwcm9wZXJ0aWVzIiwiY2F1c2UiLCJsb2MiLCJjb2x1bW4iLCJvZmZzZXQiLCJwb3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-factory-mdx-expression/dev/index.js\n");

/***/ })

};
;