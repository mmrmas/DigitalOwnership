"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-build-jsx";
exports.ids = ["vendor-chunks/estree-util-build-jsx"];
exports.modules = {

/***/ "(ssr)/./node_modules/estree-util-build-jsx/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/./node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */ \n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g;\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */ function buildJsx(tree, options) {\n    const config = options || {};\n    let automatic = config.runtime === \"automatic\";\n    /** @type {Annotations} */ const annotations = {};\n    /** @type {Imports} */ const imports = {};\n    (0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n        enter (node) {\n            if (node.type === \"Program\") {\n                const comments = node.comments || [];\n                let index = -1;\n                while(++index < comments.length){\n                    regex.lastIndex = 0;\n                    let match = regex.exec(comments[index].value);\n                    while(match){\n                        // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n                        // runtime is checked later.\n                        annotations[match[1]] = match[2];\n                        match = regex.exec(comments[index].value);\n                    }\n                }\n                if (annotations.jsxRuntime) {\n                    if (annotations.jsxRuntime === \"automatic\") {\n                        automatic = true;\n                        if (annotations.jsx) {\n                            throw new Error(\"Unexpected `@jsx` pragma w/ automatic runtime\");\n                        }\n                        if (annotations.jsxFrag) {\n                            throw new Error(\"Unexpected `@jsxFrag` pragma w/ automatic runtime\");\n                        }\n                    } else if (annotations.jsxRuntime === \"classic\") {\n                        automatic = false;\n                        if (annotations.jsxImportSource) {\n                            throw new Error(\"Unexpected `@jsxImportSource` w/ classic runtime\");\n                        }\n                    } else {\n                        throw new Error(\"Unexpected `jsxRuntime` `\" + annotations.jsxRuntime + \"`, expected `automatic` or `classic`\");\n                    }\n                }\n            }\n        },\n        // eslint-disable-next-line complexity\n        leave (node) {\n            if (node.type === \"Program\") {\n                /** @type {Array<ImportSpecifier>} */ const specifiers = [];\n                if (imports.fragment) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"Fragment\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_Fragment\"\n                        }\n                    });\n                }\n                if (imports.jsx) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsx\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsx\"\n                        }\n                    });\n                }\n                if (imports.jsxs) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsxs\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsxs\"\n                        }\n                    });\n                }\n                if (imports.jsxDEV) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsxDEV\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsxDEV\"\n                        }\n                    });\n                }\n                if (specifiers.length > 0) {\n                    let injectIndex = 0;\n                    while(injectIndex < node.body.length){\n                        const child = node.body[injectIndex];\n                        if (\"directive\" in child && child.directive) {\n                            injectIndex++;\n                        } else {\n                            break;\n                        }\n                    }\n                    node.body.splice(injectIndex, 0, {\n                        type: \"ImportDeclaration\",\n                        specifiers,\n                        source: {\n                            type: \"Literal\",\n                            value: (annotations.jsxImportSource || config.importSource || \"react\") + (config.development ? \"/jsx-dev-runtime\" : \"/jsx-runtime\")\n                        }\n                    });\n                }\n            }\n            if (node.type !== \"JSXElement\" && node.type !== \"JSXFragment\") {\n                return;\n            }\n            /** @type {Array<Expression>} */ const children = [];\n            let index = -1;\n            // Figure out `children`.\n            while(++index < node.children.length){\n                const child = node.children[index];\n                if (child.type === \"JSXExpressionContainer\") {\n                    // Ignore empty expressions.\n                    if (child.expression.type !== \"JSXEmptyExpression\") {\n                        children.push(child.expression);\n                    }\n                } else if (child.type === \"JSXText\") {\n                    const value = child.value// Replace tabs w/ spaces.\n                    .replace(/\\t/g, \" \")// Use line feeds, drop spaces around them.\n                    .replace(/ *(\\r?\\n|\\r) */g, \"\\n\")// Collapse multiple line feeds.\n                    .replace(/\\n+/g, \"\\n\")// Drop final line feeds.\n                    .replace(/\\n+$/, \"\")// Drop first line feeds.\n                    .replace(/^\\n+/, \"\")// Replace line feeds with spaces.\n                    .replace(/\\n/g, \" \");\n                    // Ignore collapsible text.\n                    if (value) {\n                        /** @type {Node} */ const text = {\n                            type: \"Literal\",\n                            value\n                        };\n                        create(child, text);\n                        children.push(text);\n                    }\n                } else {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(child.type !== \"JSXElement\" && child.type !== \"JSXFragment\" && child.type !== \"JSXSpreadChild\");\n                    children.push(child);\n                }\n            }\n            /** @type {Identifier | Literal | MemberExpression} */ let name;\n            /** @type {Array<Property | SpreadElement>} */ const fields = [];\n            /** @type {Array<Expression>} */ let parameters = [];\n            /** @type {Expression | undefined} */ let key;\n            // Do the stuff needed for elements.\n            if (node.type === \"JSXElement\") {\n                name = toIdentifier(node.openingElement.name);\n                // If the name could be an identifier, but start with a lowercase letter,\n                // itâ€™s not a component.\n                if (name.type === \"Identifier\" && /^[a-z]/.test(name.name)) {\n                    /** @type {Node} */ const next = {\n                        type: \"Literal\",\n                        value: name.name\n                    };\n                    create(name, next);\n                    name = next;\n                }\n                /** @type {boolean | undefined} */ let spread;\n                const attributes = node.openingElement.attributes;\n                let index = -1;\n                // Place props in the right order, because we might have duplicates\n                // in them and whatâ€™s spread in.\n                while(++index < attributes.length){\n                    const attribute = attributes[index];\n                    if (attribute.type === \"JSXSpreadAttribute\") {\n                        if (attribute.argument.type === \"ObjectExpression\") {\n                            fields.push(...attribute.argument.properties);\n                        } else {\n                            fields.push({\n                                type: \"SpreadElement\",\n                                argument: attribute.argument\n                            });\n                        }\n                        spread = true;\n                    } else {\n                        const prop = toProperty(attribute);\n                        if (automatic && prop.key.type === \"Identifier\" && prop.key.name === \"key\") {\n                            if (spread) {\n                                throw new Error(\"Expected `key` to come before any spread expressions\");\n                            }\n                            const value = prop.value;\n                            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(value.type !== \"AssignmentPattern\" && value.type !== \"ArrayPattern\" && value.type !== \"ObjectPattern\" && value.type !== \"RestElement\");\n                            key = value;\n                        } else {\n                            fields.push(prop);\n                        }\n                    }\n                }\n            } else if (automatic) {\n                imports.fragment = true;\n                name = {\n                    type: \"Identifier\",\n                    name: \"_Fragment\"\n                };\n            } else {\n                name = toMemberExpression(annotations.jsxFrag || config.pragmaFrag || \"React.Fragment\");\n            }\n            if (automatic) {\n                if (children.length > 0) {\n                    fields.push({\n                        type: \"Property\",\n                        key: {\n                            type: \"Identifier\",\n                            name: \"children\"\n                        },\n                        value: children.length > 1 ? {\n                            type: \"ArrayExpression\",\n                            elements: children\n                        } : children[0],\n                        kind: \"init\",\n                        method: false,\n                        shorthand: false,\n                        computed: false\n                    });\n                }\n            } else {\n                parameters = children;\n            }\n            /** @type {Identifier | Literal | MemberExpression} */ let callee;\n            if (automatic) {\n                parameters.push({\n                    type: \"ObjectExpression\",\n                    properties: fields\n                });\n                if (key) {\n                    parameters.push(key);\n                } else if (config.development) {\n                    parameters.push({\n                        type: \"Identifier\",\n                        name: \"undefined\"\n                    });\n                }\n                const isStaticChildren = children.length > 1;\n                if (config.development) {\n                    imports.jsxDEV = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsxDEV\"\n                    };\n                    parameters.push({\n                        type: \"Literal\",\n                        value: isStaticChildren\n                    });\n                    /** @type {ObjectExpression} */ const source = {\n                        type: \"ObjectExpression\",\n                        properties: [\n                            {\n                                type: \"Property\",\n                                method: false,\n                                shorthand: false,\n                                computed: false,\n                                kind: \"init\",\n                                key: {\n                                    type: \"Identifier\",\n                                    name: \"fileName\"\n                                },\n                                value: {\n                                    type: \"Literal\",\n                                    value: config.filePath || \"<source.js>\"\n                                }\n                            }\n                        ]\n                    };\n                    if (node.loc) {\n                        source.properties.push({\n                            type: \"Property\",\n                            method: false,\n                            shorthand: false,\n                            computed: false,\n                            kind: \"init\",\n                            key: {\n                                type: \"Identifier\",\n                                name: \"lineNumber\"\n                            },\n                            value: {\n                                type: \"Literal\",\n                                value: node.loc.start.line\n                            }\n                        }, {\n                            type: \"Property\",\n                            method: false,\n                            shorthand: false,\n                            computed: false,\n                            kind: \"init\",\n                            key: {\n                                type: \"Identifier\",\n                                name: \"columnNumber\"\n                            },\n                            value: {\n                                type: \"Literal\",\n                                value: node.loc.start.column + 1\n                            }\n                        });\n                    }\n                    parameters.push(source, {\n                        type: \"ThisExpression\"\n                    });\n                } else if (isStaticChildren) {\n                    imports.jsxs = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsxs\"\n                    };\n                } else {\n                    imports.jsx = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsx\"\n                    };\n                }\n            } else {\n                if (fields.length > 0) {\n                    parameters.unshift({\n                        type: \"ObjectExpression\",\n                        properties: fields\n                    });\n                } else if (parameters.length > 0) {\n                    parameters.unshift({\n                        type: \"Literal\",\n                        value: null\n                    });\n                }\n                callee = toMemberExpression(annotations.jsx || config.pragma || \"React.createElement\");\n            }\n            parameters.unshift(name);\n            /** @type {Node} */ const call = {\n                type: \"CallExpression\",\n                callee,\n                arguments: parameters,\n                optional: false\n            };\n            create(node, call);\n            this.replace(call);\n        }\n    });\n}\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */ function toProperty(node) {\n    /** @type {Expression} */ let value;\n    if (node.value) {\n        if (node.value.type === \"JSXExpressionContainer\") {\n            const valueExpression = node.value.expression;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(valueExpression.type !== \"JSXEmptyExpression\", \"`JSXEmptyExpression` is not allowed in props.\");\n            value = valueExpression;\n        } else {\n            const nodeValue = node.value;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(nodeValue.type !== \"JSXElement\" && nodeValue.type !== \"JSXFragment\", \"JSX{Element,Fragment} are already compiled to `CallExpression`\");\n            value = nodeValue;\n            delete value.raw;\n        }\n    } else {\n        value = {\n            type: \"Literal\",\n            value: true\n        };\n    }\n    /** @type {Property} */ const replacement = {\n        type: \"Property\",\n        key: toIdentifier(node.name),\n        value,\n        kind: \"init\",\n        method: false,\n        shorthand: false,\n        computed: false\n    };\n    create(node, replacement);\n    return replacement;\n}\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */ function toIdentifier(node) {\n    /** @type {Identifier | Literal | MemberExpression} */ let replace;\n    if (node.type === \"JSXMemberExpression\") {\n        // `property` is always a `JSXIdentifier`, but it could be something that\n        // isnâ€™t an ES identifier name.\n        const id = toIdentifier(node.property);\n        replace = {\n            type: \"MemberExpression\",\n            object: toIdentifier(node.object),\n            property: id,\n            computed: id.type === \"Literal\",\n            optional: false\n        };\n    } else if (node.type === \"JSXNamespacedName\") {\n        replace = {\n            type: \"Literal\",\n            value: node.namespace.name + \":\" + node.name.name\n        };\n    } else {\n        replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name) ? {\n            type: \"Identifier\",\n            name: node.name\n        } : {\n            type: \"Literal\",\n            value: node.name\n        };\n    }\n    create(node, replace);\n    return replace;\n}\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */ function toMemberExpression(id) {\n    const identifiers = id.split(\".\");\n    let index = -1;\n    /** @type {Identifier | Literal | MemberExpression | undefined} */ let result;\n    while(++index < identifiers.length){\n        /** @type {Identifier | Literal} */ const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index]) ? {\n            type: \"Identifier\",\n            name: identifiers[index]\n        } : {\n            type: \"Literal\",\n            value: identifiers[index]\n        };\n        result = result ? {\n            type: \"MemberExpression\",\n            object: result,\n            property: prop,\n            computed: Boolean(index && prop.type === \"Literal\"),\n            optional: false\n        } : prop;\n    }\n    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, \"always a result\");\n    return result;\n}\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */ function create(from, to) {\n    const fields = [\n        \"start\",\n        \"end\",\n        \"loc\",\n        \"range\",\n        \"comments\"\n    ];\n    let index = -1;\n    while(++index < fields.length){\n        const field = fields[index];\n        if (field in from) {\n            // @ts-expect-error: indexable.\n            to[field] = from[field];\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBGQyxHQUVrQztBQUNvQztBQUNyQztBQUVsQyxNQUFNSyxRQUFRO0FBRWQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxTQUFTQyxTQUFTQyxJQUFJLEVBQUVDLE9BQU87SUFDcEMsTUFBTUMsU0FBU0QsV0FBVyxDQUFDO0lBQzNCLElBQUlFLFlBQVlELE9BQU9FLE9BQU8sS0FBSztJQUNuQyx3QkFBd0IsR0FDeEIsTUFBTUMsY0FBYyxDQUFDO0lBQ3JCLG9CQUFvQixHQUNwQixNQUFNQyxVQUFVLENBQUM7SUFFakJULG1EQUFJQSxDQUFDRyxNQUFNO1FBQ1RPLE9BQU1DLElBQUk7WUFDUixJQUFJQSxLQUFLQyxJQUFJLEtBQUssV0FBVztnQkFDM0IsTUFBTUMsV0FBV0YsS0FBS0UsUUFBUSxJQUFJLEVBQUU7Z0JBQ3BDLElBQUlDLFFBQVEsQ0FBQztnQkFFYixNQUFPLEVBQUVBLFFBQVFELFNBQVNFLE1BQU0sQ0FBRTtvQkFDaENkLE1BQU1lLFNBQVMsR0FBRztvQkFFbEIsSUFBSUMsUUFBUWhCLE1BQU1pQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSyxLQUFLO29CQUU1QyxNQUFPRixNQUFPO3dCQUNaLGdFQUFnRTt3QkFDaEUsNEJBQTRCO3dCQUM1QlQsV0FBVyxDQUFDUyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUdBLEtBQUssQ0FBQyxFQUFFO3dCQUNoQ0EsUUFBUWhCLE1BQU1pQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSyxLQUFLO29CQUMxQztnQkFDRjtnQkFFQSxJQUFJWCxZQUFZWSxVQUFVLEVBQUU7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UUFDekI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4vbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLWJ1aWxkLWpzeC9saWIvaW5kZXguanM/M2Q0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5FeHByZXNzaW9ufSBFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSWRlbnRpZmllcn0gSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkltcG9ydFNwZWNpZmllcn0gSW1wb3J0U3BlY2lmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYQXR0cmlidXRlfSBKU1hBdHRyaWJ1dGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hJZGVudGlmaWVyfSBKU1hJZGVudGlmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYTWVtYmVyRXhwcmVzc2lvbn0gSlNYTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWE5hbWVzcGFjZWROYW1lfSBKU1hOYW1lc3BhY2VkTmFtZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkxpdGVyYWx9IExpdGVyYWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5NZW1iZXJFeHByZXNzaW9ufSBNZW1iZXJFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk9iamVjdEV4cHJlc3Npb259IE9iamVjdEV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5Qcm9wZXJ0eX0gUHJvcGVydHlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5TcHJlYWRFbGVtZW50fSBTcHJlYWRFbGVtZW50XG4gKlxuICogQHR5cGVkZWYgeydhdXRvbWF0aWMnIHwgJ2NsYXNzaWMnfSBSdW50aW1lXG4gKiAgIEhvdyB0byB0cmFuc2Zvcm0gSlNYLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogeW91IGNhbiBhbHNvIGNvbmZpZ3VyZSBgcnVudGltZWAsIGBpbXBvcnRTb3VyY2VgLCBgcHJhZ21hYCxcbiAqICAgPiBhbmQgYHByYWdtYUZyYWdgIGZyb20gd2l0aGluIGZpbGVzIHRocm91Z2ggY29tbWVudHMuXG4gKiBAcHJvcGVydHkge1J1bnRpbWUgfCBudWxsIHwgdW5kZWZpbmVkfSBbcnVudGltZT0nY2xhc3NpYyddXG4gKiAgIENob29zZSB0aGUgcnVudGltZSAoZGVmYXVsdDogYCdjbGFzc2ljJ2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeFJ1bnRpbWUgdGhlUnVudGltZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtpbXBvcnRTb3VyY2U9J3JlYWN0J11cbiAqICAgUGxhY2UgdG8gaW1wb3J0IGBqc3hgLCBganN4c2AsIGBqc3hERVZgLCBhbmQgYEZyYWdtZW50YCBmcm9tLCB3aGVuIHRoZVxuICogICBlZmZlY3RpdmUgcnVudGltZSBpcyBhdXRvbWF0aWMgKGRlZmF1bHQ6IGAncmVhY3QnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4SW1wb3J0U291cmNlIHRoZVNvdXJjZWAuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGAvanN4LXJ1bnRpbWVgIG9yIGAvanN4LWRldi1ydW50aW1lYCBpcyBhcHBlbmRlZCB0byB0aGlzXG4gKiAgID4gcHJvdmlkZWQgc291cmNlLlxuICogICA+IEluIENKUywgdGhhdCBjYW4gcmVzb2x2ZSB0byBhIGZpbGUgKGFzIGluIGB0aGVTb3VyY2UvanN4LXJ1bnRpbWUuanNgKSxcbiAqICAgPiBidXQgZm9yIEVTTSBhbiBleHBvcnQgbWFwIG5lZWRzIHRvIGJlIHNldCB1cCB0byBwb2ludCB0byBmaWxlczpcbiAqICAgPlxuICogICA+IGBgYGpzXG4gKiAgID4gLy8g4oCmXG4gKiAgID4gXCJleHBvcnRzXCI6IHtcbiAqICAgPiAgIC8vIOKAplxuICogICA+ICAgXCIuL2pzeC1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCIsXG4gKiAgID4gICBcIi4vanN4LWRldi1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCJcbiAqICAgPiAgIC8vIOKAplxuICogICA+IGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJhZ21hPSdSZWFjdC5jcmVhdGVFbGVtZW50J11cbiAqICAgSWRlbnRpZmllciBvciBtZW1iZXIgZXhwcmVzc2lvbiB0byBjYWxsIHdoZW4gdGhlIGVmZmVjdGl2ZSBydW50aW1lIGlzXG4gKiAgIGNsYXNzaWMgKGRlZmF1bHQ6IGAnUmVhY3QuY3JlYXRlRWxlbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3ggaWRlbnRpZmllcmAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtwcmFnbWFGcmFnPSdSZWFjdC5GcmFnbWVudCddXG4gKiAgIElkZW50aWZpZXIgb3IgbWVtYmVyIGV4cHJlc3Npb24gdG8gdXNlIGFzIGEgc3ltYm9sIGZvciBmcmFnbWVudHMgd2hlbiB0aGVcbiAqICAgZWZmZWN0aXZlIHJ1bnRpbWUgaXMgY2xhc3NpYyAoZGVmYXVsdDogYCdSZWFjdC5GcmFnbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hGcmFnIGlkZW50aWZpZXJgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RldmVsb3BtZW50PWZhbHNlXVxuICogICBXaGVuIGluIHRoZSBhdXRvbWF0aWMgcnVudGltZSwgd2hldGhlciB0byBpbXBvcnRcbiAqICAgYHRoZVNvdXJjZS9qc3gtZGV2LXJ1bnRpbWUuanNgLCB1c2UgYGpzeERFVmAsIGFuZCBwYXNzIGxvY2F0aW9uIGluZm8gd2hlblxuICogICBhdmFpbGFibGUgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgVGhpcyBoZWxwcyBkZWJ1Z2dpbmcgYnV0IGFkZHMgYSBsb3Qgb2YgY29kZSB0aGF0IHlvdSBkb27igJl0IHdhbnQgaW5cbiAqICAgcHJvZHVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ZpbGVQYXRoXVxuICogICBGaWxlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChvcHRpb25hbCkuXG4gKlxuICogICBQYXNzZWQgaW4gbG9jYXRpb24gaW5mbyB0byBganN4REVWYCB3aGVuIHVzaW5nIHRoZSBhdXRvbWF0aWMgcnVudGltZSB3aXRoXG4gKiAgIGBkZXZlbG9wbWVudDogdHJ1ZWAuXG4gKlxuICogQHR5cGVkZWYgQW5ub3RhdGlvbnNcbiAqICAgU3RhdGUgd2hlcmUgaW5mbyBmcm9tIGNvbW1lbnRzIGlzIGdhdGhlcmVkLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIEpTWCBpZGVudGlmaWVyIChgcHJhZ21hYCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2pzeEZyYWddXG4gKiAgIEpTWCBpZGVudGlmaWVyIG9mIGZyYWdtZW50IChgcHJhZ21hRnJhZ2ApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hJbXBvcnRTb3VyY2VdXG4gKiAgIFdoZXJlIHRvIGltcG9ydCBhbiBhdXRvbWF0aWMgSlNYIHJ1bnRpbWUgZnJvbS5cbiAqIEBwcm9wZXJ0eSB7UnVudGltZSB8IHVuZGVmaW5lZH0gW2pzeFJ1bnRpbWVdXG4gKiAgIFJ1bnRpbWUuXG4gKlxuICogQHR5cGVkZWYgSW1wb3J0c1xuICogICBTdGF0ZSBvZiB1c2VkIGlkZW50aWZpZXJzIGZyb20gdGhlIGF1dG9tYXRpYyBydW50aW1lLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbZnJhZ21lbnRdXG4gKiAgIFN5bWJvbCBvZiBgRnJhZ21lbnRgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBTeW1ib2wgb2YgYGpzeGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtqc3hzXVxuICogICBTeW1ib2wgb2YgYGpzeHNgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4REVWXVxuICogICBTeW1ib2wgb2YgYGpzeERFVmAuXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bmFtZSBhcyBpc0lkZW50aWZpZXJOYW1lfSBmcm9tICdlc3RyZWUtdXRpbC1pcy1pZGVudGlmaWVyLW5hbWUnXG5pbXBvcnQge3dhbGt9IGZyb20gJ2VzdHJlZS13YWxrZXInXG5cbmNvbnN0IHJlZ2V4ID0gL0AoanN4fGpzeEZyYWd8anN4SW1wb3J0U291cmNlfGpzeFJ1bnRpbWUpXFxzKyhcXFMrKS9nXG5cbi8qKlxuICogVHVybiBKU1ggaW4gYHRyZWVgIGludG8gZnVuY3Rpb24gY2FsbHM6IGA8eCAvPmAgLT4gYGgoJ3gnKWAhXG4gKlxuICogIyMjIyMjIEFsZ29yaXRobVxuICpcbiAqIEluIGFsbW9zdCBhbGwgY2FzZXMsIHRoaXMgdXRpbGl0eSBpcyB0aGUgc2FtZSBhcyB0aGUgQmFiZWwgcGx1Z2luLCBleGNlcHQgdGhhdFxuICogdGhleSB3b3JrIG9uIHNsaWdodGx5IGRpZmZlcmVudCBzeW50YXggdHJlZXMuXG4gKlxuICogU29tZSBkaWZmZXJlbmNlczpcbiAqXG4gKiAqICAgbm8gcHVyZSBhbm5vdGF0aW9ucyB0aGluZ3NcbiAqICogICBgdGhpc2AgaXMgbm90IGEgY29tcG9uZW50OiBgPHRoaXM+YCAtPiBgaCgndGhpcycpYCwgbm90IGBoKHRoaXMpYFxuICogKiAgIG5hbWVzcGFjZXMgYXJlIHN1cHBvcnRlZDogYDxhOmIgYzpkPmAgLT4gYGgoJ2E6YicsIHsnYzpkJzogdHJ1ZX0pYCxcbiAqICAgICB3aGljaCB0aHJvd3MgYnkgZGVmYXVsdCBpbiBCYWJlbCBvciBjYW4gYmUgdHVybmVkIG9uIHdpdGggYHRocm93SWZOYW1lc3BhY2VgXG4gKiAqICAgbm8gYHVzZVNwcmVhZGAsIGB1c2VCdWlsdEluc2AsIG9yIGBmaWx0ZXJgIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0gKHR5cGljYWxseSBgUHJvZ3JhbWApLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEpzeCh0cmVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG9wdGlvbnMgfHwge31cbiAgbGV0IGF1dG9tYXRpYyA9IGNvbmZpZy5ydW50aW1lID09PSAnYXV0b21hdGljJ1xuICAvKiogQHR5cGUge0Fubm90YXRpb25zfSAqL1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IHt9XG4gIC8qKiBAdHlwZSB7SW1wb3J0c30gKi9cbiAgY29uc3QgaW1wb3J0cyA9IHt9XG5cbiAgd2Fsayh0cmVlLCB7XG4gICAgZW50ZXIobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gbm9kZS5jb21tZW50cyB8fCBbXVxuICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gMFxuXG4gICAgICAgICAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhjb21tZW50c1tpbmRleF0udmFsdWUpXG5cbiAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXRjaFsxXWAgaXMgYWx3YXlzIGEga2V5LCBgbWF0Y2hbMl1gIHdoZW5cbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgaXMgY2hlY2tlZCBsYXRlci5cbiAgICAgICAgICAgIGFubm90YXRpb25zW21hdGNoWzFdXSA9IG1hdGNoWzJdXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoY29tbWVudHNbaW5kZXhdLnZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lKSB7XG4gICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdhdXRvbWF0aWMnKSB7XG4gICAgICAgICAgICBhdXRvbWF0aWMgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3gpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGBAanN4YCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4RnJhZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hGcmFnYCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdjbGFzc2ljJykge1xuICAgICAgICAgICAgYXV0b21hdGljID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hJbXBvcnRTb3VyY2VgIHcvIGNsYXNzaWMgcnVudGltZSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBqc3hSdW50aW1lYCBgJyArXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMuanN4UnVudGltZSArXG4gICAgICAgICAgICAgICAgJ2AsIGV4cGVjdGVkIGBhdXRvbWF0aWNgIG9yIGBjbGFzc2ljYCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgbGVhdmUobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8SW1wb3J0U3BlY2lmaWVyPn0gKi9cbiAgICAgICAgY29uc3Qgc3BlY2lmaWVycyA9IFtdXG5cbiAgICAgICAgaWYgKGltcG9ydHMuZnJhZ21lbnQpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ0ZyYWdtZW50J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19GcmFnbWVudCd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeCkge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3gnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3hzKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hzJ30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4REVWKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hERVYnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeERFVid9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgaW5qZWN0SW5kZXggPSAwXG5cbiAgICAgICAgICB3aGlsZSAoaW5qZWN0SW5kZXggPCBub2RlLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuYm9keVtpbmplY3RJbmRleF1cblxuICAgICAgICAgICAgaWYgKCdkaXJlY3RpdmUnIGluIGNoaWxkICYmIGNoaWxkLmRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBpbmplY3RJbmRleCsrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuYm9keS5zcGxpY2UoaW5qZWN0SW5kZXgsIDAsIHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgICAgICBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgJ3JlYWN0JykgK1xuICAgICAgICAgICAgICAgIChjb25maWcuZGV2ZWxvcG1lbnQgPyAnL2pzeC1kZXYtcnVudGltZScgOiAnL2pzeC1ydW50aW1lJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJiBub2RlLnR5cGUgIT09ICdKU1hGcmFnbWVudCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IGBjaGlsZHJlbmAuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpbmRleF1cblxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ0pTWEV4cHJlc3Npb25Db250YWluZXInKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGV4cHJlc3Npb25zLlxuICAgICAgICAgIGlmIChjaGlsZC5leHByZXNzaW9uLnR5cGUgIT09ICdKU1hFbXB0eUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmV4cHJlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09ICdKU1hUZXh0Jykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudmFsdWVcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGFicyB3LyBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICcgJylcbiAgICAgICAgICAgIC8vIFVzZSBsaW5lIGZlZWRzLCBkcm9wIHNwYWNlcyBhcm91bmQgdGhlbS5cbiAgICAgICAgICAgIC5yZXBsYWNlKC8gKihcXHI/XFxufFxccikgKi9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIENvbGxhcHNlIG11bHRpcGxlIGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIERyb3AgZmluYWwgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgICAgLy8gRHJvcCBmaXJzdCBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXG4rLywgJycpXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGxpbmUgZmVlZHMgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICcgJylcblxuICAgICAgICAgIC8vIElnbm9yZSBjb2xsYXBzaWJsZSB0ZXh0LlxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlfVxuICAgICAgICAgICAgY3JlYXRlKGNoaWxkLCB0ZXh0KVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYRWxlbWVudCcgJiZcbiAgICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWEZyYWdtZW50JyAmJlxuICAgICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYU3ByZWFkQ2hpbGQnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gICAgICBsZXQgbmFtZVxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxQcm9wZXJ0eSB8IFNwcmVhZEVsZW1lbnQ+fSAqL1xuICAgICAgY29uc3QgZmllbGRzID0gW11cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBsZXQgcGFyYW1ldGVycyA9IFtdXG4gICAgICAvKiogQHR5cGUge0V4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQga2V5XG5cbiAgICAgIC8vIERvIHRoZSBzdHVmZiBuZWVkZWQgZm9yIGVsZW1lbnRzLlxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWEVsZW1lbnQnKSB7XG4gICAgICAgIG5hbWUgPSB0b0lkZW50aWZpZXIobm9kZS5vcGVuaW5nRWxlbWVudC5uYW1lKVxuXG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGNvdWxkIGJlIGFuIGlkZW50aWZpZXIsIGJ1dCBzdGFydCB3aXRoIGEgbG93ZXJjYXNlIGxldHRlcixcbiAgICAgICAgLy8gaXTigJlzIG5vdCBhIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIC9eW2Etel0vLnRlc3QobmFtZS5uYW1lKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgICAgICBjb25zdCBuZXh0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5hbWUubmFtZX1cbiAgICAgICAgICBjcmVhdGUobmFtZSwgbmV4dClcbiAgICAgICAgICBuYW1lID0gbmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgc3ByZWFkXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXNcbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICAvLyBQbGFjZSBwcm9wcyBpbiB0aGUgcmlnaHQgb3JkZXIsIGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSBkdXBsaWNhdGVzXG4gICAgICAgIC8vIGluIHRoZW0gYW5kIHdoYXTigJlzIHNwcmVhZCBpbi5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXhdXG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdKU1hTcHJlYWRBdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmFyZ3VtZW50LnR5cGUgPT09ICdPYmplY3RFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5hdHRyaWJ1dGUuYXJndW1lbnQucHJvcGVydGllcylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHt0eXBlOiAnU3ByZWFkRWxlbWVudCcsIGFyZ3VtZW50OiBhdHRyaWJ1dGUuYXJndW1lbnR9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0b1Byb3BlcnR5KGF0dHJpYnV0ZSlcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBhdXRvbWF0aWMgJiZcbiAgICAgICAgICAgICAgcHJvcC5rZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICAgICAgICAgIHByb3Aua2V5Lm5hbWUgPT09ICdrZXknXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKHNwcmVhZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCBga2V5YCB0byBjb21lIGJlZm9yZSBhbnkgc3ByZWFkIGV4cHJlc3Npb25zJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcC52YWx1ZVxuXG4gICAgICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXNzaWdubWVudFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXJyYXlQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ09iamVjdFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnUmVzdEVsZW1lbnQnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBrZXkgPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2gocHJvcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIOKApmFuZCBmcmFnbWVudHMuXG4gICAgICBlbHNlIGlmIChhdXRvbWF0aWMpIHtcbiAgICAgICAgaW1wb3J0cy5mcmFnbWVudCA9IHRydWVcbiAgICAgICAgbmFtZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfRnJhZ21lbnQnfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3hGcmFnIHx8IGNvbmZpZy5wcmFnbWFGcmFnIHx8ICdSZWFjdC5GcmFnbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2NoaWxkcmVuJ30sXG4gICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8ge3R5cGU6ICdBcnJheUV4cHJlc3Npb24nLCBlbGVtZW50czogY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlblswXSxcbiAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICAgICAgbGV0IGNhbGxlZVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ09iamVjdEV4cHJlc3Npb24nLCBwcm9wZXJ0aWVzOiBmaWVsZHN9KVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goa2V5KVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZXZlbG9wbWVudCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAndW5kZWZpbmVkJ30pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMVxuXG4gICAgICAgIGlmIChjb25maWcuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeERFViA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiAnX2pzeERFVidcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpc1N0YXRpY0NoaWxkcmVufSlcblxuICAgICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0RXhwcmVzc2lvbn0gKi9cbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2ZpbGVOYW1lJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25maWcuZmlsZVBhdGggfHwgJzxzb3VyY2UuanM+J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgICAgc291cmNlLnByb3BlcnRpZXMucHVzaChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnbGluZU51bWJlcid9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5sb2Muc3RhcnQubGluZX1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnY29sdW1uTnVtYmVyJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBub2RlLmxvYy5zdGFydC5jb2x1bW4gKyAxfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHNvdXJjZSwge3R5cGU6ICdUaGlzRXhwcmVzc2lvbid9KVxuICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeHMgPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeCA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeCd9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsYXNzaWMuXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsIHByb3BlcnRpZXM6IGZpZWxkc30pXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBudWxsfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxlZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3ggfHwgY29uZmlnLnByYWdtYSB8fCAnUmVhY3QuY3JlYXRlRWxlbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQobmFtZSlcbiAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIGNhbGxlZSxcbiAgICAgICAgYXJndW1lbnRzOiBwYXJhbWV0ZXJzLFxuICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgIH1cbiAgICAgIGNyZWF0ZShub2RlLCBjYWxsKVxuICAgICAgdGhpcy5yZXBsYWNlKGNhbGwpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggYXR0cmlidXRlIGludG8gYSBKYXZhU2NyaXB0IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7SlNYQXR0cmlidXRlfSBub2RlXG4gKiAgIEpTWCBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyB7UHJvcGVydHl9XG4gKiAgIEpTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiB0b1Byb3BlcnR5KG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtFeHByZXNzaW9ufSAqL1xuICBsZXQgdmFsdWVcblxuICBpZiAobm9kZS52YWx1ZSkge1xuICAgIGlmIChub2RlLnZhbHVlLnR5cGUgPT09ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJykge1xuICAgICAgY29uc3QgdmFsdWVFeHByZXNzaW9uID0gbm9kZS52YWx1ZS5leHByZXNzaW9uXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbi50eXBlICE9PSAnSlNYRW1wdHlFeHByZXNzaW9uJyxcbiAgICAgICAgJ2BKU1hFbXB0eUV4cHJlc3Npb25gIGlzIG5vdCBhbGxvd2VkIGluIHByb3BzLidcbiAgICAgIClcbiAgICAgIHZhbHVlID0gdmFsdWVFeHByZXNzaW9uXG4gICAgfVxuICAgIC8vIExpdGVyYWwgb3IgY2FsbCBleHByZXNzaW9uLlxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gbm9kZS52YWx1ZVxuICAgICAgYXNzZXJ0KFxuICAgICAgICBub2RlVmFsdWUudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmIG5vZGVWYWx1ZS50eXBlICE9PSAnSlNYRnJhZ21lbnQnLFxuICAgICAgICAnSlNYe0VsZW1lbnQsRnJhZ21lbnR9IGFyZSBhbHJlYWR5IGNvbXBpbGVkIHRvIGBDYWxsRXhwcmVzc2lvbmAnXG4gICAgICApXG4gICAgICB2YWx1ZSA9IG5vZGVWYWx1ZVxuICAgICAgZGVsZXRlIHZhbHVlLnJhd1xuICAgIH1cbiAgfVxuICAvLyBCb29sZWFuIHByb3AuXG4gIGVsc2Uge1xuICAgIHZhbHVlID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IHRydWV9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb3BlcnR5fSAqL1xuICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgIGtleTogdG9JZGVudGlmaWVyKG5vZGUubmFtZSksXG4gICAgdmFsdWUsXG4gICAga2luZDogJ2luaXQnLFxuICAgIG1ldGhvZDogZmFsc2UsXG4gICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICBjb21wdXRlZDogZmFsc2VcbiAgfVxuICBjcmVhdGUobm9kZSwgcmVwbGFjZW1lbnQpXG4gIHJldHVybiByZXBsYWNlbWVudFxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggaWRlbnRpZmllciBpbnRvIGEgbm9ybWFsIEpTIGlkZW50aWZpZXIuXG4gKlxuICogQHBhcmFtIHtKU1hJZGVudGlmaWVyIHwgSlNYTWVtYmVyRXhwcmVzc2lvbiB8IEpTWE5hbWVzcGFjZWROYW1lfSBub2RlXG4gKiAgIEpTWCBpZGVudGlmaWVyLlxuICogQHJldHVybnMge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn1cbiAqICAgSlMgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gdG9JZGVudGlmaWVyKG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gIGxldCByZXBsYWNlXG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWE1lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgLy8gYHByb3BlcnR5YCBpcyBhbHdheXMgYSBgSlNYSWRlbnRpZmllcmAsIGJ1dCBpdCBjb3VsZCBiZSBzb21ldGhpbmcgdGhhdFxuICAgIC8vIGlzbuKAmXQgYW4gRVMgaWRlbnRpZmllciBuYW1lLlxuICAgIGNvbnN0IGlkID0gdG9JZGVudGlmaWVyKG5vZGUucHJvcGVydHkpXG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIG9iamVjdDogdG9JZGVudGlmaWVyKG5vZGUub2JqZWN0KSxcbiAgICAgIHByb3BlcnR5OiBpZCxcbiAgICAgIGNvbXB1dGVkOiBpZC50eXBlID09PSAnTGl0ZXJhbCcsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnSlNYTmFtZXNwYWNlZE5hbWUnKSB7XG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgIHZhbHVlOiBub2RlLm5hbWVzcGFjZS5uYW1lICsgJzonICsgbm9kZS5uYW1lLm5hbWVcbiAgICB9XG4gIH1cbiAgLy8gTXVzdCBiZSBgSlNYSWRlbnRpZmllcmAuXG4gIGVsc2Uge1xuICAgIHJlcGxhY2UgPSBpc0lkZW50aWZpZXJOYW1lKG5vZGUubmFtZSlcbiAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogbm9kZS5uYW1lfVxuICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5uYW1lfVxuICB9XG5cbiAgY3JlYXRlKG5vZGUsIHJlcGxhY2UpXG4gIHJldHVybiByZXBsYWNlXG59XG5cbi8qKlxuICogVHVybiBhIGRvdHRlZCBzdHJpbmcgaW50byBhIG1lbWJlciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogICBJZGVudGlmaWVycy5cbiAqIEByZXR1cm5zIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvTWVtYmVyRXhwcmVzc2lvbihpZCkge1xuICBjb25zdCBpZGVudGlmaWVycyA9IGlkLnNwbGl0KCcuJylcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gIGxldCByZXN1bHRcblxuICB3aGlsZSAoKytpbmRleCA8IGlkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWx9ICovXG4gICAgY29uc3QgcHJvcCA9IGlzSWRlbnRpZmllck5hbWUoaWRlbnRpZmllcnNbaW5kZXhdKVxuICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgcmVzdWx0ID0gcmVzdWx0XG4gICAgICA/IHtcbiAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgb2JqZWN0OiByZXN1bHQsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgY29tcHV0ZWQ6IEJvb2xlYW4oaW5kZXggJiYgcHJvcC50eXBlID09PSAnTGl0ZXJhbCcpLFxuICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgICAgICB9XG4gICAgICA6IHByb3BcbiAgfVxuXG4gIGFzc2VydChyZXN1bHQsICdhbHdheXMgYSByZXN1bHQnKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogSW5oZXJpdCBzb21lIGZpZWxkcyBmcm9tIGBmcm9tYCBpbnRvIGB0b2AuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBmcm9tXG4gKiAgIE5vZGUgdG8gaW5oZXJpdCBmcm9tLlxuICogQHBhcmFtIHtOb2RlfSB0b1xuICogICBOb2RlIHRvIGFkZCB0by5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShmcm9tLCB0bykge1xuICBjb25zdCBmaWVsZHMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdsb2MnLCAncmFuZ2UnLCAnY29tbWVudHMnXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZmllbGRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2luZGV4XVxuICAgIGlmIChmaWVsZCBpbiBmcm9tKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICB0b1tmaWVsZF0gPSBmcm9tW2ZpZWxkXVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwibmFtZSIsImlzSWRlbnRpZmllck5hbWUiLCJ3YWxrIiwicmVnZXgiLCJidWlsZEpzeCIsInRyZWUiLCJvcHRpb25zIiwiY29uZmlnIiwiYXV0b21hdGljIiwicnVudGltZSIsImFubm90YXRpb25zIiwiaW1wb3J0cyIsImVudGVyIiwibm9kZSIsInR5cGUiLCJjb21tZW50cyIsImluZGV4IiwibGVuZ3RoIiwibGFzdEluZGV4IiwibWF0Y2giLCJleGVjIiwidmFsdWUiLCJqc3hSdW50aW1lIiwianN4IiwiRXJyb3IiLCJqc3hGcmFnIiwianN4SW1wb3J0U291cmNlIiwibGVhdmUiLCJzcGVjaWZpZXJzIiwiZnJhZ21lbnQiLCJwdXNoIiwiaW1wb3J0ZWQiLCJsb2NhbCIsImpzeHMiLCJqc3hERVYiLCJpbmplY3RJbmRleCIsImJvZHkiLCJjaGlsZCIsImRpcmVjdGl2ZSIsInNwbGljZSIsInNvdXJjZSIsImltcG9ydFNvdXJjZSIsImRldmVsb3BtZW50IiwiY2hpbGRyZW4iLCJleHByZXNzaW9uIiwicmVwbGFjZSIsInRleHQiLCJjcmVhdGUiLCJmaWVsZHMiLCJwYXJhbWV0ZXJzIiwia2V5IiwidG9JZGVudGlmaWVyIiwib3BlbmluZ0VsZW1lbnQiLCJ0ZXN0IiwibmV4dCIsInNwcmVhZCIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGUiLCJhcmd1bWVudCIsInByb3BlcnRpZXMiLCJwcm9wIiwidG9Qcm9wZXJ0eSIsInRvTWVtYmVyRXhwcmVzc2lvbiIsInByYWdtYUZyYWciLCJlbGVtZW50cyIsImtpbmQiLCJtZXRob2QiLCJzaG9ydGhhbmQiLCJjb21wdXRlZCIsImNhbGxlZSIsImlzU3RhdGljQ2hpbGRyZW4iLCJmaWxlUGF0aCIsImxvYyIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsInVuc2hpZnQiLCJwcmFnbWEiLCJjYWxsIiwiYXJndW1lbnRzIiwib3B0aW9uYWwiLCJ2YWx1ZUV4cHJlc3Npb24iLCJub2RlVmFsdWUiLCJyYXciLCJyZXBsYWNlbWVudCIsImlkIiwicHJvcGVydHkiLCJvYmplY3QiLCJuYW1lc3BhY2UiLCJpZGVudGlmaWVycyIsInNwbGl0IiwicmVzdWx0IiwiQm9vbGVhbiIsImZyb20iLCJ0byIsImZpZWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/async.js":
/*!************************************************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/async.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncWalker: () => (/* binding */ AsyncWalker)\n/* harmony export */ });\n/* harmony import */ var _walker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./walker.js */ \"(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/walker.js\");\n\n/**\n * @typedef { import('estree').Node} Node\n * @typedef { import('./walker.js').WalkerContext} WalkerContext\n * @typedef {(\n *    this: WalkerContext,\n *    node: Node,\n *    parent: Node | null,\n *    key: string | number | symbol | null | undefined,\n *    index: number | null | undefined\n * ) => Promise<void>} AsyncHandler\n */ class AsyncWalker extends _walker_js__WEBPACK_IMPORTED_MODULE_0__.WalkerBase {\n    /**\n\t *\n\t * @param {AsyncHandler} [enter]\n\t * @param {AsyncHandler} [leave]\n\t */ constructor(enter, leave){\n        super();\n        /** @type {boolean} */ this.should_skip = false;\n        /** @type {boolean} */ this.should_remove = false;\n        /** @type {Node | null} */ this.replacement = null;\n        /** @type {WalkerContext} */ this.context = {\n            skip: ()=>this.should_skip = true,\n            remove: ()=>this.should_remove = true,\n            replace: (node)=>this.replacement = node\n        };\n        /** @type {AsyncHandler | undefined} */ this.enter = enter;\n        /** @type {AsyncHandler | undefined} */ this.leave = leave;\n    }\n    /**\n\t * @template {Node} Parent\n\t * @param {Node} node\n\t * @param {Parent | null} parent\n\t * @param {keyof Parent} [prop]\n\t * @param {number | null} [index]\n\t * @returns {Promise<Node | null>}\n\t */ async visit(node, parent, prop, index) {\n        if (node) {\n            if (this.enter) {\n                const _should_skip = this.should_skip;\n                const _should_remove = this.should_remove;\n                const _replacement = this.replacement;\n                this.should_skip = false;\n                this.should_remove = false;\n                this.replacement = null;\n                await this.enter.call(this.context, node, parent, prop, index);\n                if (this.replacement) {\n                    node = this.replacement;\n                    this.replace(parent, prop, index, node);\n                }\n                if (this.should_remove) {\n                    this.remove(parent, prop, index);\n                }\n                const skipped = this.should_skip;\n                const removed = this.should_remove;\n                this.should_skip = _should_skip;\n                this.should_remove = _should_remove;\n                this.replacement = _replacement;\n                if (skipped) return node;\n                if (removed) return null;\n            }\n            /** @type {keyof Node} */ let key;\n            for(key in node){\n                /** @type {unknown} */ const value = node[key];\n                if (value && typeof value === \"object\") {\n                    if (Array.isArray(value)) {\n                        const nodes = /** @type {Array<unknown>} */ value;\n                        for(let i = 0; i < nodes.length; i += 1){\n                            const item = nodes[i];\n                            if (isNode(item)) {\n                                if (!await this.visit(item, node, key, i)) {\n                                    // removed\n                                    i--;\n                                }\n                            }\n                        }\n                    } else if (isNode(value)) {\n                        await this.visit(value, node, key, null);\n                    }\n                }\n            }\n            if (this.leave) {\n                const _replacement = this.replacement;\n                const _should_remove = this.should_remove;\n                this.replacement = null;\n                this.should_remove = false;\n                await this.leave.call(this.context, node, parent, prop, index);\n                if (this.replacement) {\n                    node = this.replacement;\n                    this.replace(parent, prop, index, node);\n                }\n                if (this.should_remove) {\n                    this.remove(parent, prop, index);\n                }\n                const removed = this.should_remove;\n                this.replacement = _replacement;\n                this.should_remove = _should_remove;\n                if (removed) return null;\n            }\n        }\n        return node;\n    }\n}\n/**\n * Ducktype a node.\n *\n * @param {unknown} value\n * @returns {value is Node}\n */ function isNode(value) {\n    return value !== null && typeof value === \"object\" && \"type\" in value && typeof value.type === \"string\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L25vZGVfbW9kdWxlcy9lc3RyZWUtd2Fsa2VyL3NyYy9hc3luYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUV6Qzs7Ozs7Ozs7OztDQVVDLEdBRU0sTUFBTUMsb0JBQW9CRCxrREFBVUE7SUFDMUM7Ozs7RUFJQyxHQUNERSxZQUFZQyxLQUFLLEVBQUVDLEtBQUssQ0FBRTtRQUN6QixLQUFLO1FBRUwsb0JBQW9CLEdBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLG9CQUFvQixHQUNwQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUVyQix3QkFBd0IsR0FDeEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsMEJBQTBCLEdBQzFCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1lBQ2RDLE1BQU0sSUFBTyxJQUFJLENBQUNKLFdBQVcsR0FBRztZQUNoQ0ssUUFBUSxJQUFPLElBQUksQ0FBQ0osYUFBYSxHQUFHO1lBQ3BDSyxTQUFTLENBQUNDLE9BQVUsSUFBSSxDQUFDTCxXQUFXLEdBQUdLO1FBQ3hDO1FBRUEscUNBQXFDLEdBQ3JDLElBQUksQ0FBQ1QsS0FBSyxHQUFHQTtRQUViLHFDQUFxQyxHQUNyQyxJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDZDtJQUVBOzs7Ozs7O0VBT0MsR0FDRCxNQUFNUyxNQUFNRCxJQUFJLEVBQUVFLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDdEMsSUFBSUosTUFBTTtZQUNULElBQUksSUFBSSxDQUFDVCxLQUFLLEVBQUU7Z0JBQ2YsTUFBTWMsZUFBZSxJQUFJLENBQUNaLFdBQVc7Z0JBQ3JDLE1BQU1hLGlCQUFpQixJQUFJLENBQUNaLGFBQWE7Z0JBQ3pDLE1BQU1hLGVBQWUsSUFBSSxDQUFDWixXQUFXO2dCQUNyQyxJQUFJLENBQUNGLFdBQVcsR0FBRztnQkFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7Z0JBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO2dCQUVuQixNQUFNLElBQUksQ0FBQ0osS0FBSyxDQUFDaUIsSUFBSSxDQUFDLElBQUksQ0FBQ1osT0FBTyxFQUFFSSxNQUFNRSxRQUFRQyxNQUFNQztnQkFFeEQsSUFBSSxJQUFJLENBQUNULFdBQVcsRUFBRTtvQkFDckJLLE9BQU8sSUFBSSxDQUFDTCxXQUFXO29CQUN2QixJQUFJLENBQUNJLE9BQU8sQ0FBQ0csUUFBUUMsTUFBTUMsT0FBT0o7Z0JBQ25DO2dCQUVBLElBQUksSUFBSSxDQUFDTixhQUFhLEVBQUU7b0JBQ3ZCLElBQUksQ0FBQ0ksTUFBTSxDQUFDSSxRQUFRQyxNQUFNQztnQkFDM0I7Z0JBRUEsTUFBTUssVUFBVSxJQUFJLENBQUNoQixXQUFXO2dCQUNoQyxNQUFNaUIsVUFBVSxJQUFJLENBQUNoQixhQUFhO2dCQUVsQyxJQUFJLENBQUNELFdBQVcsR0FBR1k7Z0JBQ25CLElBQUksQ0FBQ1gsYUFBYSxHQUFHWTtnQkFDckIsSUFBSSxDQUFDWCxXQUFXLEdBQUdZO2dCQUVuQixJQUFJRSxTQUFTLE9BQU9UO2dCQUNwQixJQUFJVSxTQUFTLE9BQU87WUFDckI7WUFFQSx1QkFBdUIsR0FDdkIsSUFBSUM7WUFFSixJQUFLQSxPQUFPWCxLQUFNO2dCQUNqQixvQkFBb0IsR0FDcEIsTUFBTVksUUFBUVosSUFBSSxDQUFDVyxJQUFJO2dCQUV2QixJQUFJQyxTQUFTLE9BQU9BLFVBQVUsVUFBVTtvQkFDdkMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO3dCQUN6QixNQUFNRyxRQUFRLDJCQUEyQixHQUFJSDt3QkFDN0MsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsS0FBSyxFQUFHOzRCQUN6QyxNQUFNRSxPQUFPSCxLQUFLLENBQUNDLEVBQUU7NEJBQ3JCLElBQUlHLE9BQU9ELE9BQU87Z0NBQ2pCLElBQUksQ0FBRSxNQUFNLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ2lCLE1BQU1sQixNQUFNVyxLQUFLSyxJQUFLO29DQUM1QyxVQUFVO29DQUNWQTtnQ0FDRDs0QkFDRDt3QkFDRDtvQkFDRCxPQUFPLElBQUlHLE9BQU9QLFFBQVE7d0JBQ3pCLE1BQU0sSUFBSSxDQUFDWCxLQUFLLENBQUNXLE9BQU9aLE1BQU1XLEtBQUs7b0JBQ3BDO2dCQUNEO1lBQ0Q7WUFFQSxJQUFJLElBQUksQ0FBQ25CLEtBQUssRUFBRTtnQkFDZixNQUFNZSxlQUFlLElBQUksQ0FBQ1osV0FBVztnQkFDckMsTUFBTVcsaUJBQWlCLElBQUksQ0FBQ1osYUFBYTtnQkFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQ0QsYUFBYSxHQUFHO2dCQUVyQixNQUFNLElBQUksQ0FBQ0YsS0FBSyxDQUFDZ0IsSUFBSSxDQUFDLElBQUksQ0FBQ1osT0FBTyxFQUFFSSxNQUFNRSxRQUFRQyxNQUFNQztnQkFFeEQsSUFBSSxJQUFJLENBQUNULFdBQVcsRUFBRTtvQkFDckJLLE9BQU8sSUFBSSxDQUFDTCxXQUFXO29CQUN2QixJQUFJLENBQUNJLE9BQU8sQ0FBQ0csUUFBUUMsTUFBTUMsT0FBT0o7Z0JBQ25DO2dCQUVBLElBQUksSUFBSSxDQUFDTixhQUFhLEVBQUU7b0JBQ3ZCLElBQUksQ0FBQ0ksTUFBTSxDQUFDSSxRQUFRQyxNQUFNQztnQkFDM0I7Z0JBRUEsTUFBTU0sVUFBVSxJQUFJLENBQUNoQixhQUFhO2dCQUVsQyxJQUFJLENBQUNDLFdBQVcsR0FBR1k7Z0JBQ25CLElBQUksQ0FBQ2IsYUFBYSxHQUFHWTtnQkFFckIsSUFBSUksU0FBUyxPQUFPO1lBQ3JCO1FBQ0Q7UUFFQSxPQUFPVjtJQUNSO0FBQ0Q7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNtQixPQUFPUCxLQUFLO0lBQ3BCLE9BQ0NBLFVBQVUsUUFBUSxPQUFPQSxVQUFVLFlBQVksVUFBVUEsU0FBUyxPQUFPQSxNQUFNUSxJQUFJLEtBQUs7QUFFMUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L25vZGVfbW9kdWxlcy9lc3RyZWUtd2Fsa2VyL3NyYy9hc3luYy5qcz9kMWQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGtlckJhc2UgfSBmcm9tICcuL3dhbGtlci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2VzdHJlZScpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL3dhbGtlci5qcycpLldhbGtlckNvbnRleHR9IFdhbGtlckNvbnRleHRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgICB0aGlzOiBXYWxrZXJDb250ZXh0LFxuICogICAgbm9kZTogTm9kZSxcbiAqICAgIHBhcmVudDogTm9kZSB8IG51bGwsXG4gKiAgICBrZXk6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCB8IG51bGwgfCB1bmRlZmluZWQsXG4gKiAgICBpbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZFxuICogKSA9PiBQcm9taXNlPHZvaWQ+fSBBc3luY0hhbmRsZXJcbiAqL1xuXG5leHBvcnQgY2xhc3MgQXN5bmNXYWxrZXIgZXh0ZW5kcyBXYWxrZXJCYXNlIHtcblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXN5bmNIYW5kbGVyfSBbZW50ZXJdXG5cdCAqIEBwYXJhbSB7QXN5bmNIYW5kbGVyfSBbbGVhdmVdXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihlbnRlciwgbGVhdmUpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRcdHRoaXMuc2hvdWxkX3NraXAgPSBmYWxzZTtcblxuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLnNob3VsZF9yZW1vdmUgPSBmYWxzZTtcblxuXHRcdC8qKiBAdHlwZSB7Tm9kZSB8IG51bGx9ICovXG5cdFx0dGhpcy5yZXBsYWNlbWVudCA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUge1dhbGtlckNvbnRleHR9ICovXG5cdFx0dGhpcy5jb250ZXh0ID0ge1xuXHRcdFx0c2tpcDogKCkgPT4gKHRoaXMuc2hvdWxkX3NraXAgPSB0cnVlKSxcblx0XHRcdHJlbW92ZTogKCkgPT4gKHRoaXMuc2hvdWxkX3JlbW92ZSA9IHRydWUpLFxuXHRcdFx0cmVwbGFjZTogKG5vZGUpID0+ICh0aGlzLnJlcGxhY2VtZW50ID0gbm9kZSlcblx0XHR9O1xuXG5cdFx0LyoqIEB0eXBlIHtBc3luY0hhbmRsZXIgfCB1bmRlZmluZWR9ICovXG5cdFx0dGhpcy5lbnRlciA9IGVudGVyO1xuXG5cdFx0LyoqIEB0eXBlIHtBc3luY0hhbmRsZXIgfCB1bmRlZmluZWR9ICovXG5cdFx0dGhpcy5sZWF2ZSA9IGxlYXZlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7Tm9kZX0gUGFyZW50XG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge1BhcmVudCB8IG51bGx9IHBhcmVudFxuXHQgKiBAcGFyYW0ge2tleW9mIFBhcmVudH0gW3Byb3BdXG5cdCAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2luZGV4XVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxOb2RlIHwgbnVsbD59XG5cdCAqL1xuXHRhc3luYyB2aXNpdChub2RlLCBwYXJlbnQsIHByb3AsIGluZGV4KSB7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdGlmICh0aGlzLmVudGVyKSB7XG5cdFx0XHRcdGNvbnN0IF9zaG91bGRfc2tpcCA9IHRoaXMuc2hvdWxkX3NraXA7XG5cdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHRjb25zdCBfcmVwbGFjZW1lbnQgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHR0aGlzLnNob3VsZF9za2lwID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gbnVsbDtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLmVudGVyLmNhbGwodGhpcy5jb250ZXh0LCBub2RlLCBwYXJlbnQsIHByb3AsIGluZGV4KTtcblxuXHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdG5vZGUgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZShwYXJlbnQsIHByb3AsIGluZGV4LCBub2RlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLnNob3VsZF9yZW1vdmUpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZShwYXJlbnQsIHByb3AsIGluZGV4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNraXBwZWQgPSB0aGlzLnNob3VsZF9za2lwO1xuXHRcdFx0XHRjb25zdCByZW1vdmVkID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkX3NraXAgPSBfc2hvdWxkX3NraXA7XG5cdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IF9zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gX3JlcGxhY2VtZW50O1xuXG5cdFx0XHRcdGlmIChza2lwcGVkKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogQHR5cGUge2tleW9mIE5vZGV9ICovXG5cdFx0XHRsZXQga2V5O1xuXG5cdFx0XHRmb3IgKGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBub2RlW2tleV07XG5cblx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5vZGVzID0gLyoqIEB0eXBlIHtBcnJheTx1bmtub3duPn0gKi8gKHZhbHVlKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaXRlbSA9IG5vZGVzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOb2RlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCEoYXdhaXQgdGhpcy52aXNpdChpdGVtLCBub2RlLCBrZXksIGkpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlZFxuXHRcdFx0XHRcdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNOb2RlKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy52aXNpdCh2YWx1ZSwgbm9kZSwga2V5LCBudWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMubGVhdmUpIHtcblx0XHRcdFx0Y29uc3QgX3JlcGxhY2VtZW50ID0gdGhpcy5yZXBsYWNlbWVudDtcblx0XHRcdFx0Y29uc3QgX3Nob3VsZF9yZW1vdmUgPSB0aGlzLnNob3VsZF9yZW1vdmU7XG5cdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnNob3VsZF9yZW1vdmUgPSBmYWxzZTtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLmxlYXZlLmNhbGwodGhpcy5jb250ZXh0LCBub2RlLCBwYXJlbnQsIHByb3AsIGluZGV4KTtcblxuXHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdG5vZGUgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZShwYXJlbnQsIHByb3AsIGluZGV4LCBub2RlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLnNob3VsZF9yZW1vdmUpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZShwYXJlbnQsIHByb3AsIGluZGV4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJlbW92ZWQgPSB0aGlzLnNob3VsZF9yZW1vdmU7XG5cblx0XHRcdFx0dGhpcy5yZXBsYWNlbWVudCA9IF9yZXBsYWNlbWVudDtcblx0XHRcdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gX3Nob3VsZF9yZW1vdmU7XG5cblx0XHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9XG59XG5cbi8qKlxuICogRHVja3R5cGUgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBOb2RlfVxuICovXG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHR2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZydcblx0KTtcbn1cbiJdLCJuYW1lcyI6WyJXYWxrZXJCYXNlIiwiQXN5bmNXYWxrZXIiLCJjb25zdHJ1Y3RvciIsImVudGVyIiwibGVhdmUiLCJzaG91bGRfc2tpcCIsInNob3VsZF9yZW1vdmUiLCJyZXBsYWNlbWVudCIsImNvbnRleHQiLCJza2lwIiwicmVtb3ZlIiwicmVwbGFjZSIsIm5vZGUiLCJ2aXNpdCIsInBhcmVudCIsInByb3AiLCJpbmRleCIsIl9zaG91bGRfc2tpcCIsIl9zaG91bGRfcmVtb3ZlIiwiX3JlcGxhY2VtZW50IiwiY2FsbCIsInNraXBwZWQiLCJyZW1vdmVkIiwia2V5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlcyIsImkiLCJsZW5ndGgiLCJpdGVtIiwiaXNOb2RlIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asyncWalk: () => (/* binding */ asyncWalk),\n/* harmony export */   walk: () => (/* binding */ walk)\n/* harmony export */ });\n/* harmony import */ var _sync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sync.js */ \"(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/sync.js\");\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async.js */ \"(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/async.js\");\n\n\n/**\n * @typedef {import('estree').Node} Node\n * @typedef {import('./sync.js').SyncHandler} SyncHandler\n * @typedef {import('./async.js').AsyncHandler} AsyncHandler\n */ /**\n * @param {Node} ast\n * @param {{\n *   enter?: SyncHandler\n *   leave?: SyncHandler\n * }} walker\n * @returns {Node | null}\n */ function walk(ast, { enter, leave }) {\n    const instance = new _sync_js__WEBPACK_IMPORTED_MODULE_0__.SyncWalker(enter, leave);\n    return instance.visit(ast, null);\n}\n/**\n * @param {Node} ast\n * @param {{\n *   enter?: AsyncHandler\n *   leave?: AsyncHandler\n * }} walker\n * @returns {Promise<Node | null>}\n */ async function asyncWalk(ast, { enter, leave }) {\n    const instance = new _async_js__WEBPACK_IMPORTED_MODULE_1__.AsyncWalker(enter, leave);\n    return await instance.visit(ast, null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L25vZGVfbW9kdWxlcy9lc3RyZWUtd2Fsa2VyL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ0U7QUFFekM7Ozs7Q0FJQyxHQUVEOzs7Ozs7O0NBT0MsR0FDTSxTQUFTRSxLQUFLQyxHQUFHLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7SUFDekMsTUFBTUMsV0FBVyxJQUFJTixnREFBVUEsQ0FBQ0ksT0FBT0M7SUFDdkMsT0FBT0MsU0FBU0MsS0FBSyxDQUFDSixLQUFLO0FBQzVCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVLLFVBQVVMLEdBQUcsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUNwRCxNQUFNQyxXQUFXLElBQUlMLGtEQUFXQSxDQUFDRyxPQUFPQztJQUN4QyxPQUFPLE1BQU1DLFNBQVNDLEtBQUssQ0FBQ0osS0FBSztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lwdC13My8uL25vZGVfbW9kdWxlcy9lc3RyZWUtdXRpbC1idWlsZC1qc3gvbm9kZV9tb2R1bGVzL2VzdHJlZS13YWxrZXIvc3JjL2luZGV4LmpzPzgzNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3luY1dhbGtlciB9IGZyb20gJy4vc3luYy5qcyc7XG5pbXBvcnQgeyBBc3luY1dhbGtlciB9IGZyb20gJy4vYXN5bmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZScpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc3luYy5qcycpLlN5bmNIYW5kbGVyfSBTeW5jSGFuZGxlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9hc3luYy5qcycpLkFzeW5jSGFuZGxlcn0gQXN5bmNIYW5kbGVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGFzdFxuICogQHBhcmFtIHt7XG4gKiAgIGVudGVyPzogU3luY0hhbmRsZXJcbiAqICAgbGVhdmU/OiBTeW5jSGFuZGxlclxuICogfX0gd2Fsa2VyXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRjb25zdCBpbnN0YW5jZSA9IG5ldyBTeW5jV2Fsa2VyKGVudGVyLCBsZWF2ZSk7XG5cdHJldHVybiBpbnN0YW5jZS52aXNpdChhc3QsIG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYXN0XG4gKiBAcGFyYW0ge3tcbiAqICAgZW50ZXI/OiBBc3luY0hhbmRsZXJcbiAqICAgbGVhdmU/OiBBc3luY0hhbmRsZXJcbiAqIH19IHdhbGtlclxuICogQHJldHVybnMge1Byb21pc2U8Tm9kZSB8IG51bGw+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNXYWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRjb25zdCBpbnN0YW5jZSA9IG5ldyBBc3luY1dhbGtlcihlbnRlciwgbGVhdmUpO1xuXHRyZXR1cm4gYXdhaXQgaW5zdGFuY2UudmlzaXQoYXN0LCBudWxsKTtcbn1cbiJdLCJuYW1lcyI6WyJTeW5jV2Fsa2VyIiwiQXN5bmNXYWxrZXIiLCJ3YWxrIiwiYXN0IiwiZW50ZXIiLCJsZWF2ZSIsImluc3RhbmNlIiwidmlzaXQiLCJhc3luY1dhbGsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/sync.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/sync.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SyncWalker: () => (/* binding */ SyncWalker)\n/* harmony export */ });\n/* harmony import */ var _walker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./walker.js */ \"(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/walker.js\");\n\n/**\n * @typedef { import('estree').Node} Node\n * @typedef { import('./walker.js').WalkerContext} WalkerContext\n * @typedef {(\n *    this: WalkerContext,\n *    node: Node,\n *    parent: Node | null,\n *    key: string | number | symbol | null | undefined,\n *    index: number | null | undefined\n * ) => void} SyncHandler\n */ class SyncWalker extends _walker_js__WEBPACK_IMPORTED_MODULE_0__.WalkerBase {\n    /**\n\t *\n\t * @param {SyncHandler} [enter]\n\t * @param {SyncHandler} [leave]\n\t */ constructor(enter, leave){\n        super();\n        /** @type {boolean} */ this.should_skip = false;\n        /** @type {boolean} */ this.should_remove = false;\n        /** @type {Node | null} */ this.replacement = null;\n        /** @type {WalkerContext} */ this.context = {\n            skip: ()=>this.should_skip = true,\n            remove: ()=>this.should_remove = true,\n            replace: (node)=>this.replacement = node\n        };\n        /** @type {SyncHandler | undefined} */ this.enter = enter;\n        /** @type {SyncHandler | undefined} */ this.leave = leave;\n    }\n    /**\n\t * @template {Node} Parent\n\t * @param {Node} node\n\t * @param {Parent | null} parent\n\t * @param {keyof Parent} [prop]\n\t * @param {number | null} [index]\n\t * @returns {Node | null}\n\t */ visit(node, parent, prop, index) {\n        if (node) {\n            if (this.enter) {\n                const _should_skip = this.should_skip;\n                const _should_remove = this.should_remove;\n                const _replacement = this.replacement;\n                this.should_skip = false;\n                this.should_remove = false;\n                this.replacement = null;\n                this.enter.call(this.context, node, parent, prop, index);\n                if (this.replacement) {\n                    node = this.replacement;\n                    this.replace(parent, prop, index, node);\n                }\n                if (this.should_remove) {\n                    this.remove(parent, prop, index);\n                }\n                const skipped = this.should_skip;\n                const removed = this.should_remove;\n                this.should_skip = _should_skip;\n                this.should_remove = _should_remove;\n                this.replacement = _replacement;\n                if (skipped) return node;\n                if (removed) return null;\n            }\n            /** @type {keyof Node} */ let key;\n            for(key in node){\n                /** @type {unknown} */ const value = node[key];\n                if (value && typeof value === \"object\") {\n                    if (Array.isArray(value)) {\n                        const nodes = /** @type {Array<unknown>} */ value;\n                        for(let i = 0; i < nodes.length; i += 1){\n                            const item = nodes[i];\n                            if (isNode(item)) {\n                                if (!this.visit(item, node, key, i)) {\n                                    // removed\n                                    i--;\n                                }\n                            }\n                        }\n                    } else if (isNode(value)) {\n                        this.visit(value, node, key, null);\n                    }\n                }\n            }\n            if (this.leave) {\n                const _replacement = this.replacement;\n                const _should_remove = this.should_remove;\n                this.replacement = null;\n                this.should_remove = false;\n                this.leave.call(this.context, node, parent, prop, index);\n                if (this.replacement) {\n                    node = this.replacement;\n                    this.replace(parent, prop, index, node);\n                }\n                if (this.should_remove) {\n                    this.remove(parent, prop, index);\n                }\n                const removed = this.should_remove;\n                this.replacement = _replacement;\n                this.should_remove = _should_remove;\n                if (removed) return null;\n            }\n        }\n        return node;\n    }\n}\n/**\n * Ducktype a node.\n *\n * @param {unknown} value\n * @returns {value is Node}\n */ function isNode(value) {\n    return value !== null && typeof value === \"object\" && \"type\" in value && typeof value.type === \"string\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L25vZGVfbW9kdWxlcy9lc3RyZWUtd2Fsa2VyL3NyYy9zeW5jLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBRXpDOzs7Ozs7Ozs7O0NBVUMsR0FFTSxNQUFNQyxtQkFBbUJELGtEQUFVQTtJQUN6Qzs7OztFQUlDLEdBQ0RFLFlBQVlDLEtBQUssRUFBRUMsS0FBSyxDQUFFO1FBQ3pCLEtBQUs7UUFFTCxvQkFBb0IsR0FDcEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsb0JBQW9CLEdBQ3BCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBRXJCLHdCQUF3QixHQUN4QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUVuQiwwQkFBMEIsR0FDMUIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7WUFDZEMsTUFBTSxJQUFPLElBQUksQ0FBQ0osV0FBVyxHQUFHO1lBQ2hDSyxRQUFRLElBQU8sSUFBSSxDQUFDSixhQUFhLEdBQUc7WUFDcENLLFNBQVMsQ0FBQ0MsT0FBVSxJQUFJLENBQUNMLFdBQVcsR0FBR0s7UUFDeEM7UUFFQSxvQ0FBb0MsR0FDcEMsSUFBSSxDQUFDVCxLQUFLLEdBQUdBO1FBRWIsb0NBQW9DLEdBQ3BDLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNkO0lBRUE7Ozs7Ozs7RUFPQyxHQUNEUyxNQUFNRCxJQUFJLEVBQUVFLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDaEMsSUFBSUosTUFBTTtZQUNULElBQUksSUFBSSxDQUFDVCxLQUFLLEVBQUU7Z0JBQ2YsTUFBTWMsZUFBZSxJQUFJLENBQUNaLFdBQVc7Z0JBQ3JDLE1BQU1hLGlCQUFpQixJQUFJLENBQUNaLGFBQWE7Z0JBQ3pDLE1BQU1hLGVBQWUsSUFBSSxDQUFDWixXQUFXO2dCQUNyQyxJQUFJLENBQUNGLFdBQVcsR0FBRztnQkFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7Z0JBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO2dCQUVuQixJQUFJLENBQUNKLEtBQUssQ0FBQ2lCLElBQUksQ0FBQyxJQUFJLENBQUNaLE9BQU8sRUFBRUksTUFBTUUsUUFBUUMsTUFBTUM7Z0JBRWxELElBQUksSUFBSSxDQUFDVCxXQUFXLEVBQUU7b0JBQ3JCSyxPQUFPLElBQUksQ0FBQ0wsV0FBVztvQkFDdkIsSUFBSSxDQUFDSSxPQUFPLENBQUNHLFFBQVFDLE1BQU1DLE9BQU9KO2dCQUNuQztnQkFFQSxJQUFJLElBQUksQ0FBQ04sYUFBYSxFQUFFO29CQUN2QixJQUFJLENBQUNJLE1BQU0sQ0FBQ0ksUUFBUUMsTUFBTUM7Z0JBQzNCO2dCQUVBLE1BQU1LLFVBQVUsSUFBSSxDQUFDaEIsV0FBVztnQkFDaEMsTUFBTWlCLFVBQVUsSUFBSSxDQUFDaEIsYUFBYTtnQkFFbEMsSUFBSSxDQUFDRCxXQUFXLEdBQUdZO2dCQUNuQixJQUFJLENBQUNYLGFBQWEsR0FBR1k7Z0JBQ3JCLElBQUksQ0FBQ1gsV0FBVyxHQUFHWTtnQkFFbkIsSUFBSUUsU0FBUyxPQUFPVDtnQkFDcEIsSUFBSVUsU0FBUyxPQUFPO1lBQ3JCO1lBRUEsdUJBQXVCLEdBQ3ZCLElBQUlDO1lBRUosSUFBS0EsT0FBT1gsS0FBTTtnQkFDakIsb0JBQW9CLEdBQ3BCLE1BQU1ZLFFBQVFaLElBQUksQ0FBQ1csSUFBSTtnQkFFdkIsSUFBSUMsU0FBUyxPQUFPQSxVQUFVLFVBQVU7b0JBQ3ZDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTt3QkFDekIsTUFBTUcsUUFBUSwyQkFBMkIsR0FBSUg7d0JBQzdDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELEtBQUssRUFBRzs0QkFDekMsTUFBTUUsT0FBT0gsS0FBSyxDQUFDQyxFQUFFOzRCQUNyQixJQUFJRyxPQUFPRCxPQUFPO2dDQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDakIsS0FBSyxDQUFDaUIsTUFBTWxCLE1BQU1XLEtBQUtLLElBQUk7b0NBQ3BDLFVBQVU7b0NBQ1ZBO2dDQUNEOzRCQUNEO3dCQUNEO29CQUNELE9BQU8sSUFBSUcsT0FBT1AsUUFBUTt3QkFDekIsSUFBSSxDQUFDWCxLQUFLLENBQUNXLE9BQU9aLE1BQU1XLEtBQUs7b0JBQzlCO2dCQUNEO1lBQ0Q7WUFFQSxJQUFJLElBQUksQ0FBQ25CLEtBQUssRUFBRTtnQkFDZixNQUFNZSxlQUFlLElBQUksQ0FBQ1osV0FBVztnQkFDckMsTUFBTVcsaUJBQWlCLElBQUksQ0FBQ1osYUFBYTtnQkFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQ0QsYUFBYSxHQUFHO2dCQUVyQixJQUFJLENBQUNGLEtBQUssQ0FBQ2dCLElBQUksQ0FBQyxJQUFJLENBQUNaLE9BQU8sRUFBRUksTUFBTUUsUUFBUUMsTUFBTUM7Z0JBRWxELElBQUksSUFBSSxDQUFDVCxXQUFXLEVBQUU7b0JBQ3JCSyxPQUFPLElBQUksQ0FBQ0wsV0FBVztvQkFDdkIsSUFBSSxDQUFDSSxPQUFPLENBQUNHLFFBQVFDLE1BQU1DLE9BQU9KO2dCQUNuQztnQkFFQSxJQUFJLElBQUksQ0FBQ04sYUFBYSxFQUFFO29CQUN2QixJQUFJLENBQUNJLE1BQU0sQ0FBQ0ksUUFBUUMsTUFBTUM7Z0JBQzNCO2dCQUVBLE1BQU1NLFVBQVUsSUFBSSxDQUFDaEIsYUFBYTtnQkFFbEMsSUFBSSxDQUFDQyxXQUFXLEdBQUdZO2dCQUNuQixJQUFJLENBQUNiLGFBQWEsR0FBR1k7Z0JBRXJCLElBQUlJLFNBQVMsT0FBTztZQUNyQjtRQUNEO1FBRUEsT0FBT1Y7SUFDUjtBQUNEO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTbUIsT0FBT1AsS0FBSztJQUNwQixPQUNDQSxVQUFVLFFBQVEsT0FBT0EsVUFBVSxZQUFZLFVBQVVBLFNBQVMsT0FBT0EsTUFBTVEsSUFBSSxLQUFLO0FBRTFGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4vbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLWJ1aWxkLWpzeC9ub2RlX21vZHVsZXMvZXN0cmVlLXdhbGtlci9zcmMvc3luYy5qcz9lYTRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGtlckJhc2UgfSBmcm9tICcuL3dhbGtlci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2VzdHJlZScpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL3dhbGtlci5qcycpLldhbGtlckNvbnRleHR9IFdhbGtlckNvbnRleHRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgICB0aGlzOiBXYWxrZXJDb250ZXh0LFxuICogICAgbm9kZTogTm9kZSxcbiAqICAgIHBhcmVudDogTm9kZSB8IG51bGwsXG4gKiAgICBrZXk6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCB8IG51bGwgfCB1bmRlZmluZWQsXG4gKiAgICBpbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZFxuICogKSA9PiB2b2lkfSBTeW5jSGFuZGxlclxuICovXG5cbmV4cG9ydCBjbGFzcyBTeW5jV2Fsa2VyIGV4dGVuZHMgV2Fsa2VyQmFzZSB7XG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N5bmNIYW5kbGVyfSBbZW50ZXJdXG5cdCAqIEBwYXJhbSB7U3luY0hhbmRsZXJ9IFtsZWF2ZV1cblx0ICovXG5cdGNvbnN0cnVjdG9yKGVudGVyLCBsZWF2ZSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdFx0dGhpcy5zaG91bGRfc2tpcCA9IGZhbHNlO1xuXG5cdFx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXG5cdFx0LyoqIEB0eXBlIHtOb2RlIHwgbnVsbH0gKi9cblx0XHR0aGlzLnJlcGxhY2VtZW50ID0gbnVsbDtcblxuXHRcdC8qKiBAdHlwZSB7V2Fsa2VyQ29udGV4dH0gKi9cblx0XHR0aGlzLmNvbnRleHQgPSB7XG5cdFx0XHRza2lwOiAoKSA9PiAodGhpcy5zaG91bGRfc2tpcCA9IHRydWUpLFxuXHRcdFx0cmVtb3ZlOiAoKSA9PiAodGhpcy5zaG91bGRfcmVtb3ZlID0gdHJ1ZSksXG5cdFx0XHRyZXBsYWNlOiAobm9kZSkgPT4gKHRoaXMucmVwbGFjZW1lbnQgPSBub2RlKVxuXHRcdH07XG5cblx0XHQvKiogQHR5cGUge1N5bmNIYW5kbGVyIHwgdW5kZWZpbmVkfSAqL1xuXHRcdHRoaXMuZW50ZXIgPSBlbnRlcjtcblxuXHRcdC8qKiBAdHlwZSB7U3luY0hhbmRsZXIgfCB1bmRlZmluZWR9ICovXG5cdFx0dGhpcy5sZWF2ZSA9IGxlYXZlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7Tm9kZX0gUGFyZW50XG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge1BhcmVudCB8IG51bGx9IHBhcmVudFxuXHQgKiBAcGFyYW0ge2tleW9mIFBhcmVudH0gW3Byb3BdXG5cdCAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2luZGV4XVxuXHQgKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG5cdCAqL1xuXHR2aXNpdChub2RlLCBwYXJlbnQsIHByb3AsIGluZGV4KSB7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdGlmICh0aGlzLmVudGVyKSB7XG5cdFx0XHRcdGNvbnN0IF9zaG91bGRfc2tpcCA9IHRoaXMuc2hvdWxkX3NraXA7XG5cdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHRjb25zdCBfcmVwbGFjZW1lbnQgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHR0aGlzLnNob3VsZF9za2lwID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gbnVsbDtcblxuXHRcdFx0XHR0aGlzLmVudGVyLmNhbGwodGhpcy5jb250ZXh0LCBub2RlLCBwYXJlbnQsIHByb3AsIGluZGV4KTtcblxuXHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdG5vZGUgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZShwYXJlbnQsIHByb3AsIGluZGV4LCBub2RlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLnNob3VsZF9yZW1vdmUpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZShwYXJlbnQsIHByb3AsIGluZGV4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNraXBwZWQgPSB0aGlzLnNob3VsZF9za2lwO1xuXHRcdFx0XHRjb25zdCByZW1vdmVkID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkX3NraXAgPSBfc2hvdWxkX3NraXA7XG5cdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IF9zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gX3JlcGxhY2VtZW50O1xuXG5cdFx0XHRcdGlmIChza2lwcGVkKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogQHR5cGUge2tleW9mIE5vZGV9ICovXG5cdFx0XHRsZXQga2V5O1xuXG5cdFx0XHRmb3IgKGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBub2RlW2tleV07XG5cblx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5vZGVzID0gLyoqIEB0eXBlIHtBcnJheTx1bmtub3duPn0gKi8gKHZhbHVlKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaXRlbSA9IG5vZGVzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOb2RlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLnZpc2l0KGl0ZW0sIG5vZGUsIGtleSwgaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlbW92ZWRcblx0XHRcdFx0XHRcdFx0XHRcdGktLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHRoaXMudmlzaXQodmFsdWUsIG5vZGUsIGtleSwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmxlYXZlKSB7XG5cdFx0XHRcdGNvbnN0IF9yZXBsYWNlbWVudCA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gbnVsbDtcblx0XHRcdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gZmFsc2U7XG5cblx0XHRcdFx0dGhpcy5sZWF2ZS5jYWxsKHRoaXMuY29udGV4dCwgbm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCk7XG5cblx0XHRcdFx0aWYgKHRoaXMucmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0XHRub2RlID0gdGhpcy5yZXBsYWNlbWVudDtcblx0XHRcdFx0XHR0aGlzLnJlcGxhY2UocGFyZW50LCBwcm9wLCBpbmRleCwgbm9kZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5zaG91bGRfcmVtb3ZlKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByZW1vdmVkID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBfcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IF9zaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRcdGlmIChyZW1vdmVkKSByZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIER1Y2t0eXBlIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgTm9kZX1cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0dmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnXG5cdCk7XG59XG4iXSwibmFtZXMiOlsiV2Fsa2VyQmFzZSIsIlN5bmNXYWxrZXIiLCJjb25zdHJ1Y3RvciIsImVudGVyIiwibGVhdmUiLCJzaG91bGRfc2tpcCIsInNob3VsZF9yZW1vdmUiLCJyZXBsYWNlbWVudCIsImNvbnRleHQiLCJza2lwIiwicmVtb3ZlIiwicmVwbGFjZSIsIm5vZGUiLCJ2aXNpdCIsInBhcmVudCIsInByb3AiLCJpbmRleCIsIl9zaG91bGRfc2tpcCIsIl9zaG91bGRfcmVtb3ZlIiwiX3JlcGxhY2VtZW50IiwiY2FsbCIsInNraXBwZWQiLCJyZW1vdmVkIiwia2V5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlcyIsImkiLCJsZW5ndGgiLCJpdGVtIiwiaXNOb2RlIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/sync.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/walker.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/walker.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalkerBase: () => (/* binding */ WalkerBase)\n/* harmony export */ });\n/**\n * @typedef { import('estree').Node} Node\n * @typedef {{\n *   skip: () => void;\n *   remove: () => void;\n *   replace: (node: Node) => void;\n * }} WalkerContext\n */ class WalkerBase {\n    constructor(){\n        /** @type {boolean} */ this.should_skip = false;\n        /** @type {boolean} */ this.should_remove = false;\n        /** @type {Node | null} */ this.replacement = null;\n        /** @type {WalkerContext} */ this.context = {\n            skip: ()=>this.should_skip = true,\n            remove: ()=>this.should_remove = true,\n            replace: (node)=>this.replacement = node\n        };\n    }\n    /**\n\t * @template {Node} Parent\n\t * @param {Parent | null | undefined} parent\n\t * @param {keyof Parent | null | undefined} prop\n\t * @param {number | null | undefined} index\n\t * @param {Node} node\n\t */ replace(parent, prop, index, node) {\n        if (parent && prop) {\n            if (index != null) {\n                /** @type {Array<Node>} */ parent[prop][index] = node;\n            } else {\n                /** @type {Node} */ parent[prop] = node;\n            }\n        }\n    }\n    /**\n\t * @template {Node} Parent\n\t * @param {Parent | null | undefined} parent\n\t * @param {keyof Parent | null | undefined} prop\n\t * @param {number | null | undefined} index\n\t */ remove(parent, prop, index) {\n        if (parent && prop) {\n            if (index !== null && index !== undefined) {\n                /** @type {Array<Node>} */ parent[prop].splice(index, 1);\n            } else {\n                delete parent[prop];\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L25vZGVfbW9kdWxlcy9lc3RyZWUtd2Fsa2VyL3NyYy93YWxrZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7O0NBT0MsR0FFTSxNQUFNQTtJQUNaQyxhQUFjO1FBQ2Isb0JBQW9CLEdBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLG9CQUFvQixHQUNwQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUVyQix3QkFBd0IsR0FDeEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsMEJBQTBCLEdBQzFCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1lBQ2RDLE1BQU0sSUFBTyxJQUFJLENBQUNKLFdBQVcsR0FBRztZQUNoQ0ssUUFBUSxJQUFPLElBQUksQ0FBQ0osYUFBYSxHQUFHO1lBQ3BDSyxTQUFTLENBQUNDLE9BQVUsSUFBSSxDQUFDTCxXQUFXLEdBQUdLO1FBQ3hDO0lBQ0Q7SUFFQTs7Ozs7O0VBTUMsR0FDREQsUUFBUUUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUgsSUFBSSxFQUFFO1FBQ2xDLElBQUlDLFVBQVVDLE1BQU07WUFDbkIsSUFBSUMsU0FBUyxNQUFNO2dCQUNsQix3QkFBd0IsR0FBSUYsTUFBTSxDQUFDQyxLQUFLLENBQUVDLE1BQU0sR0FBR0g7WUFDcEQsT0FBTztnQkFDTixpQkFBaUIsR0FBSUMsTUFBTSxDQUFDQyxLQUFLLEdBQUlGO1lBQ3RDO1FBQ0Q7SUFDRDtJQUVBOzs7OztFQUtDLEdBQ0RGLE9BQU9HLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDM0IsSUFBSUYsVUFBVUMsTUFBTTtZQUNuQixJQUFJQyxVQUFVLFFBQVFBLFVBQVVDLFdBQVc7Z0JBQzFDLHdCQUF3QixHQUFJSCxNQUFNLENBQUNDLEtBQUssQ0FBRUcsTUFBTSxDQUFDRixPQUFPO1lBQ3pELE9BQU87Z0JBQ04sT0FBT0YsTUFBTSxDQUFDQyxLQUFLO1lBQ3BCO1FBQ0Q7SUFDRDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4vbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLWJ1aWxkLWpzeC9ub2RlX21vZHVsZXMvZXN0cmVlLXdhbGtlci9zcmMvd2Fsa2VyLmpzP2JjZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnZXN0cmVlJykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge3tcbiAqICAgc2tpcDogKCkgPT4gdm9pZDtcbiAqICAgcmVtb3ZlOiAoKSA9PiB2b2lkO1xuICogICByZXBsYWNlOiAobm9kZTogTm9kZSkgPT4gdm9pZDtcbiAqIH19IFdhbGtlckNvbnRleHRcbiAqL1xuXG5leHBvcnQgY2xhc3MgV2Fsa2VyQmFzZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLnNob3VsZF9za2lwID0gZmFsc2U7XG5cblx0XHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gZmFsc2U7XG5cblx0XHQvKiogQHR5cGUge05vZGUgfCBudWxsfSAqL1xuXHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0LyoqIEB0eXBlIHtXYWxrZXJDb250ZXh0fSAqL1xuXHRcdHRoaXMuY29udGV4dCA9IHtcblx0XHRcdHNraXA6ICgpID0+ICh0aGlzLnNob3VsZF9za2lwID0gdHJ1ZSksXG5cdFx0XHRyZW1vdmU6ICgpID0+ICh0aGlzLnNob3VsZF9yZW1vdmUgPSB0cnVlKSxcblx0XHRcdHJlcGxhY2U6IChub2RlKSA9PiAodGhpcy5yZXBsYWNlbWVudCA9IG5vZGUpXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUge05vZGV9IFBhcmVudFxuXHQgKiBAcGFyYW0ge1BhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudFxuXHQgKiBAcGFyYW0ge2tleW9mIFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3Bcblx0ICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBpbmRleFxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGVcblx0ICovXG5cdHJlcGxhY2UocGFyZW50LCBwcm9wLCBpbmRleCwgbm9kZSkge1xuXHRcdGlmIChwYXJlbnQgJiYgcHJvcCkge1xuXHRcdFx0aWYgKGluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtBcnJheTxOb2RlPn0gKi8gKHBhcmVudFtwcm9wXSlbaW5kZXhdID0gbm9kZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7Tm9kZX0gKi8gKHBhcmVudFtwcm9wXSkgPSBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUge05vZGV9IFBhcmVudFxuXHQgKiBAcGFyYW0ge1BhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudFxuXHQgKiBAcGFyYW0ge2tleW9mIFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3Bcblx0ICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBpbmRleFxuXHQgKi9cblx0cmVtb3ZlKHBhcmVudCwgcHJvcCwgaW5kZXgpIHtcblx0XHRpZiAocGFyZW50ICYmIHByb3ApIHtcblx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7QXJyYXk8Tm9kZT59ICovIChwYXJlbnRbcHJvcF0pLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgcGFyZW50W3Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIl0sIm5hbWVzIjpbIldhbGtlckJhc2UiLCJjb25zdHJ1Y3RvciIsInNob3VsZF9za2lwIiwic2hvdWxkX3JlbW92ZSIsInJlcGxhY2VtZW50IiwiY29udGV4dCIsInNraXAiLCJyZW1vdmUiLCJyZXBsYWNlIiwibm9kZSIsInBhcmVudCIsInByb3AiLCJpbmRleCIsInVuZGVmaW5lZCIsInNwbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/node_modules/estree-walker/src/walker.js\n");

/***/ })

};
;