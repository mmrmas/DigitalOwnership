"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-util-events-to-acorn";
exports.ids = ["vendor-chunks/micromark-util-events-to-acorn"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-util-events-to-acorn/dev/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/micromark-util-events-to-acorn/dev/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventsToAcorn: () => (/* binding */ eventsToAcorn)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-visit */ \"(ssr)/./node_modules/estree-util-visit/lib/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/values.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @typedef {import('acorn').Comment} Comment\n * @typedef {import('acorn').Node} AcornNode\n * @typedef {import('acorn').Options} AcornOptions\n * @typedef {import('acorn').Token} Token\n * @typedef {import('estree').Node} EstreeNode\n * @typedef {import('estree').Program} Program\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} MicromarkPoint\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('unist').Point} UnistPoint\n */ /**\n * @typedef Acorn\n *   Acorn-like interface.\n * @property {import('acorn').parse} parse\n *   Parse a program.\n * @property {import('acorn').parseExpressionAt} parseExpressionAt\n *   Parse an expression.\n *\n * @typedef AcornLoc\n * @property {number} line\n * @property {number} column\n *\n * @typedef AcornErrorFields\n * @property {number} raisedAt\n * @property {number} pos\n * @property {AcornLoc} loc\n *\n * @typedef {Error & AcornErrorFields} AcornError\n *\n * @typedef Options\n *   Configuration.\n * @property {Acorn} acorn\n *   Typically `acorn`, object with `parse` and `parseExpressionAt` fields (required).\n * @property {Array<TokenType>} tokenTypes\n *   Names of (void) tokens to consider as data; `'lineEnding'` is always\n *   included (required).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for `acorn` (optional).\n * @property {MicromarkPoint | null | undefined} [start]\n *   Place where events start (optional, required if `allowEmpty`).\n * @property {string | null | undefined} [prefix='']\n *   Text to place before events (default: `''`).\n * @property {string | null | undefined} [suffix='']\n *   Text to place after events (default: `''`).\n * @property {boolean | null | undefined} [expression=false]\n *   Whether this is a program or expression (default: `false`).\n * @property {boolean | null | undefined} [allowEmpty=false]\n *   Whether an empty expression is allowed (programs are always allowed to\n *   be empty) (default: `false`).\n *\n * @typedef Result\n *   Result.\n * @property {Program | undefined} estree\n *   Program.\n * @property {AcornError | undefined} error\n *   Error if unparseable\n * @property {boolean} swallow\n *   Whether the error, if there is one, can be swallowed and more JavaScript\n *   could be valid.\n *\n * @typedef {[number, MicromarkPoint]} Stop\n *\n * @typedef Collection\n * @property {string} value\n * @property {Array<Stop>} stops\n */ \n\n\n\n/**\n * Parse a list of micromark events with acorn.\n *\n * @param {Array<Event>} events\n *   Events.\n * @param {Options} options\n *   Configuration (required).\n * @returns {Result}\n *   Result.\n */ // eslint-disable-next-line complexity\nfunction eventsToAcorn(events, options) {\n    const prefix = options.prefix || \"\";\n    const suffix = options.suffix || \"\";\n    const acornOptions = Object.assign({}, options.acornOptions);\n    /** @type {Array<Comment>} */ const comments = [];\n    /** @type {Array<Token>} */ const tokens = [];\n    const onComment = acornOptions.onComment;\n    const onToken = acornOptions.onToken;\n    let swallow = false;\n    /** @type {AcornNode | undefined} */ let estree;\n    /** @type {AcornError | undefined} */ let exception;\n    /** @type {AcornOptions} */ const acornConfig = Object.assign({}, acornOptions, {\n        onComment: comments,\n        preserveParens: true\n    });\n    if (onToken) {\n        acornConfig.onToken = tokens;\n    }\n    const collection = collect(events, options.tokenTypes);\n    const source = collection.value;\n    const value = prefix + source + suffix;\n    const isEmptyExpression = options.expression && empty(source);\n    if (isEmptyExpression && !options.allowEmpty) {\n        throw new vfile_message__WEBPACK_IMPORTED_MODULE_0__.VFileMessage(\"Unexpected empty expression\", {\n            place: parseOffsetToUnistPoint(0),\n            ruleId: \"unexpected-empty-expression\",\n            source: \"micromark-extension-mdx-expression\"\n        });\n    }\n    try {\n        estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);\n    } catch (error_) {\n        const error = /** @type {AcornError} */ error_;\n        const point = parseOffsetToUnistPoint(error.pos);\n        error.message = String(error.message).replace(/ \\(\\d+:\\d+\\)$/, \"\");\n        // Always defined in our unist points that come from micromark.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, \"expected `offset`\");\n        error.pos = point.offset;\n        error.loc = {\n            line: point.line,\n            column: point.column - 1\n        };\n        exception = error;\n        swallow = error.raisedAt >= prefix.length + source.length || // Broken comments are raised at their start, not their end.\n        error.message === \"Unterminated comment\";\n    }\n    if (estree && options.expression && !isEmptyExpression) {\n        if (empty(value.slice(estree.end, value.length - suffix.length))) {\n            estree = {\n                type: \"Program\",\n                start: 0,\n                end: prefix.length + source.length,\n                // @ts-expect-error: It’s good.\n                body: [\n                    {\n                        type: \"ExpressionStatement\",\n                        expression: estree,\n                        start: 0,\n                        end: prefix.length + source.length\n                    }\n                ],\n                sourceType: \"module\",\n                comments: []\n            };\n        } else {\n            const point = parseOffsetToUnistPoint(estree.end);\n            const error = /** @type {AcornError} */ new Error(\"Unexpected content after expression\");\n            // Always defined in our unist points that come from micromark.\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, \"expected `offset`\");\n            error.pos = point.offset;\n            error.loc = {\n                line: point.line,\n                column: point.column - 1\n            };\n            exception = error;\n            estree = undefined;\n        }\n    }\n    if (estree) {\n        // @ts-expect-error: acorn *does* allow comments\n        estree.comments = comments;\n        // @ts-expect-error: acorn looks enough like estree.\n        (0,estree_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)(estree, function(esnode, field, index, parents) {\n            let context = /** @type {AcornNode | Array<AcornNode>} */ parents[parents.length - 1];\n            /** @type {number | string | undefined} */ let prop = field;\n            // Remove non-standard `ParenthesizedExpression`.\n            // @ts-expect-error: included in acorn.\n            if (esnode.type === \"ParenthesizedExpression\" && context && prop) {\n                /* c8 ignore next 5 */ if (typeof index === \"number\") {\n                    // @ts-expect-error: indexable.\n                    context = context[prop];\n                    prop = index;\n                }\n                // @ts-expect-error: indexable.\n                context[prop] = esnode.expression;\n            }\n            fixPosition(esnode);\n        });\n        // Comment positions are fixed by `visit` because they’re in the tree.\n        if (Array.isArray(onComment)) {\n            onComment.push(...comments);\n        } else if (typeof onComment === \"function\") {\n            for (const comment of comments){\n                (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(comment.loc, \"expected `loc` on comment\");\n                onComment(comment.type === \"Block\", comment.value, comment.start, comment.end, comment.loc.start, comment.loc.end);\n            }\n        }\n        for (const token of tokens){\n            // Ignore tokens that ends in prefix or start in suffix:\n            if (token.end <= prefix.length || token.start - prefix.length >= source.length) {\n                continue;\n            }\n            fixPosition(token);\n            if (Array.isArray(onToken)) {\n                onToken.push(token);\n            } else {\n                // `tokens` are not added if `onToken` is not defined, so it must be a\n                // function.\n                (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof onToken === \"function\", \"expected function\");\n                onToken(token);\n            }\n        }\n    }\n    // @ts-expect-error: It’s a program now.\n    return {\n        estree,\n        error: exception,\n        swallow\n    };\n    /**\n   * Update the position of a node.\n   *\n   * @param {AcornNode | EstreeNode | Token} nodeOrToken\n   * @returns {undefined}\n   */ function fixPosition(nodeOrToken) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\"start\" in nodeOrToken, \"expected `start` in node or token from acorn\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\"end\" in nodeOrToken, \"expected `end` in node or token from acorn\");\n        const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);\n        const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);\n        // Always defined in our unist points that come from micromark.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointStart.offset !== undefined, \"expected `offset`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointEnd.offset !== undefined, \"expected `offset`\");\n        nodeOrToken.start = pointStart.offset;\n        nodeOrToken.end = pointEnd.offset;\n        nodeOrToken.loc = {\n            start: {\n                line: pointStart.line,\n                column: pointStart.column - 1,\n                offset: pointStart.offset\n            },\n            end: {\n                line: pointEnd.line,\n                column: pointEnd.column - 1,\n                offset: pointEnd.offset\n            }\n        };\n        nodeOrToken.range = [\n            nodeOrToken.start,\n            nodeOrToken.end\n        ];\n    }\n    /**\n   * Turn an arbitrary offset into the parsed value, into a point in the source\n   * value.\n   *\n   * @param {number} acornOffset\n   * @returns {UnistPoint}\n   */ function parseOffsetToUnistPoint(acornOffset) {\n        let sourceOffset = acornOffset - prefix.length;\n        if (sourceOffset < 0) {\n            sourceOffset = 0;\n        } else if (sourceOffset > source.length) {\n            sourceOffset = source.length;\n        }\n        let point = relativeToPoint(collection.stops, sourceOffset);\n        if (!point) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(options.start, \"empty expressions are need `options.start` being passed\");\n            point = {\n                line: options.start.line,\n                column: options.start.column,\n                offset: options.start.offset\n            };\n        }\n        return point;\n    }\n}\n/**\n * @param {string} value\n * @returns {boolean}\n */ function empty(value) {\n    return /^\\s*$/.test(value// Multiline comments.\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\")// Line comments.\n    // EOF instead of EOL is specifically not allowed, because that would\n    // mean the closing brace is on the commented-out line\n    .replace(/\\/\\/[^\\r\\n]*(\\r\\n|\\n|\\r)/g, \"\"));\n}\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/mdx_collect.rs#L15>.\n/**\n * @param {Array<Event>} events\n * @param {Array<TokenType>} tokenTypes\n * @returns {Collection}\n */ function collect(events, tokenTypes) {\n    /** @type {Collection} */ const result = {\n        value: \"\",\n        stops: []\n    };\n    let index = -1;\n    while(++index < events.length){\n        const event = events[index];\n        // Assume void.\n        if (event[0] === \"enter\") {\n            const type = event[1].type;\n            if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tokenTypes.includes(type)) {\n                const chunks = event[2].sliceStream(event[1]);\n                // Drop virtual spaces.\n                while(chunks.length > 0 && chunks[0] === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace){\n                    chunks.shift();\n                }\n                const value = serializeChunks(chunks);\n                result.stops.push([\n                    result.value.length,\n                    event[1].start\n                ]);\n                result.value += value;\n                result.stops.push([\n                    result.value.length,\n                    event[1].end\n                ]);\n            }\n        }\n    }\n    return result;\n}\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/location.rs#L91>.\n/**\n * Turn a relative offset into an absolute offset.\n *\n * @param {Array<Stop>} stops\n * @param {number} relative\n * @returns {UnistPoint | undefined}\n */ function relativeToPoint(stops, relative) {\n    let index = 0;\n    while(index < stops.length && stops[index][0] <= relative){\n        index += 1;\n    }\n    // There are no points: that only occurs if there was an empty string.\n    if (index === 0) {\n        return undefined;\n    }\n    const [stopRelative, stopAbsolute] = stops[index - 1];\n    const rest = relative - stopRelative;\n    return {\n        line: stopAbsolute.line,\n        column: stopAbsolute.column + rest,\n        offset: stopAbsolute.offset + rest\n    };\n}\n// Copy from <https://github.com/micromark/micromark/blob/ce3593a/packages/micromark/dev/lib/create-tokenizer.js#L595>\n// To do: expose that?\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @returns {string}\n */ function serializeChunks(chunks) {\n    let index = -1;\n    /** @type {Array<string>} */ const result = [];\n    /** @type {boolean | undefined} */ let atTab;\n    while(++index < chunks.length){\n        const chunk = chunks[index];\n        /** @type {string} */ let value;\n        if (typeof chunk === \"string\") {\n            value = chunk;\n        } else switch(chunk){\n            case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn:\n                {\n                    value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr;\n                    break;\n                }\n            case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed:\n                {\n                    value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf;\n                    break;\n                }\n            case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed:\n                {\n                    value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf;\n                    break;\n                }\n            case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab:\n                {\n                    value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.ht;\n                    break;\n                }\n            /* c8 ignore next 6 */ case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace:\n                {\n                    if (atTab) continue;\n                    value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.space;\n                    break;\n                }\n            default:\n                {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof chunk === \"number\", \"expected number\");\n                    // Currently only replacement character.\n                    // eslint-disable-next-line unicorn/prefer-code-point\n                    value = String.fromCharCode(chunk);\n                }\n        }\n        atTab = chunk === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab;\n        result.push(value);\n    }\n    return result.join(\"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuL2Rldi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1REMsR0FFa0M7QUFDSTtBQUNtQjtBQUNoQjtBQUUxQzs7Ozs7Ozs7O0NBU0MsR0FDRCxzQ0FBc0M7QUFDL0IsU0FBU08sY0FBY0MsTUFBTSxFQUFFQyxPQUFPO0lBQzNDLE1BQU1DLFNBQVNELFFBQVFDLE1BQU0sSUFBSTtJQUNqQyxNQUFNQyxTQUFTRixRQUFRRSxNQUFNLElBQUk7SUFDakMsTUFBTUMsZUFBZUMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0wsUUFBUUcsWUFBWTtJQUMzRCwyQkFBMkIsR0FDM0IsTUFBTUcsV0FBVyxFQUFFO0lBQ25CLHlCQUF5QixHQUN6QixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBTUMsWUFBWUwsYUFBYUssU0FBUztJQUN4QyxNQUFNQyxVQUFVTixhQUFhTSxPQUFPO0lBQ3BDLElBQUlDLFVBQVU7SUFDZCxrQ0FBa0MsR0FDbEMsSUFBSUM7SUFDSixtQ0FBbUMsR0FDbkMsSUFBSUM7SUFDSix5QkFBeUIsR0FDekIsTUFBTUMsY0FBY1QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0YsY0FBYztRQUNsREssV0FBV0Y7UUFDWFEsZ0JBQWdCO0lBQ2xCO0lBRUEsSUFBSUwsU0FBUztRQUNYSSxZQUFZSixPQUFPLEdBQUdGO0lBQ3hCO0lBRUEsTUFBTVEsYUFBYUMsUUFBUWpCLFFBQVFDLFFBQVFpQixVQUFVO0lBRXJELE1BQU1DLFNBQVNILFdBQVdJLEtBQUs7SUFFL0IsTUFBTUEsUUFBUWxCLFNBQVNpQixTQUFTaEI7SUFDaEMsTUFBTWtCLG9CQUFvQnBCLFFBQVFxQixVQUFVLElBQUlDLE1BQU1KO0lBRXRELElBQUlFLHFCQUFxQixDQUFDcEIsUUFBUXVCLFVBQVUsRUFBRTtRQUM1QyxNQUFNLElBQUkxQix1REFBWUEsQ0FBQywrQkFBK0I7WUFDcEQyQixPQUFPQyx3QkFBd0I7WUFDL0JDLFFBQVE7WUFDUlIsUUFBUTtRQUNWO0lBQ0Y7SUFFQSxJQUFJO1FBQ0ZQLFNBQ0VYLFFBQVFxQixVQUFVLElBQUksQ0FBQ0Qsb0JBQ25CcEIsUUFBUTJCLEtBQUssQ0FBQ0MsaUJBQWlCLENBQUNULE9BQU8sR0FBR04sZUFDMUNiLFFBQVEyQixLQUFLLENBQUNFLEtBQUssQ0FBQ1YsT0FBT047SUFDbkMsRUFBRSxPQUFPaUIsUUFBUTtRQUNmLE1BQU1DLFFBQVEsdUJBQXVCLEdBQUlEO1FBQ3pDLE1BQU1FLFFBQVFQLHdCQUF3Qk0sTUFBTUUsR0FBRztRQUMvQ0YsTUFBTUcsT0FBTyxHQUFHQyxPQUFPSixNQUFNRyxPQUFPLEVBQUVFLE9BQU8sQ0FBQyxpQkFBaUI7UUFDL0QsK0RBQStEO1FBQy9ENUMsMENBQU1BLENBQUN3QyxNQUFNSyxNQUFNLEtBQUtDLFdBQVc7UUFDbkNQLE1BQU1FLEdBQUcsR0FBR0QsTUFBTUssTUFBTTtRQUN4Qk4sTUFBTVEsR0FBRyxHQUFHO1lBQUNDLE1BQU1SLE1BQU1RLElBQUk7WUFBRUMsUUFBUVQsTUFBTVMsTUFBTSxHQUFHO1FBQUM7UUFDdkQ3QixZQUFZbUI7UUFDWnJCLFVBQ0VxQixNQUFNVyxRQUFRLElBQUl6QyxPQUFPMEMsTUFBTSxHQUFHekIsT0FBT3lCLE1BQU0sSUFDL0MsNERBQTREO1FBQzVEWixNQUFNRyxPQUFPLEtBQUs7SUFDdEI7SUFFQSxJQUFJdkIsVUFBVVgsUUFBUXFCLFVBQVUsSUFBSSxDQUFDRCxtQkFBbUI7UUFDdEQsSUFBSUUsTUFBTUgsTUFBTXlCLEtBQUssQ0FBQ2pDLE9BQU9rQyxHQUFHLEVBQUUxQixNQUFNd0IsTUFBTSxHQUFHekMsT0FBT3lDLE1BQU0sSUFBSTtZQUNoRWhDLFNBQVM7Z0JBQ1BtQyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQRixLQUFLNUMsT0FBTzBDLE1BQU0sR0FBR3pCLE9BQU95QixNQUFNO2dCQUNsQywrQkFBK0I7Z0JBQy9CSyxNQUFNO29CQUNKO3dCQUNFRixNQUFNO3dCQUNOekIsWUFBWVY7d0JBQ1pvQyxPQUFPO3dCQUNQRixLQUFLNUMsT0FBTzBDLE1BQU0sR0FBR3pCLE9BQU95QixNQUFNO29CQUNwQztpQkFDRDtnQkFDRE0sWUFBWTtnQkFDWjNDLFVBQVUsRUFBRTtZQUNkO1FBQ0YsT0FBTztZQUNMLE1BQU0wQixRQUFRUCx3QkFBd0JkLE9BQU9rQyxHQUFHO1lBQ2hELE1BQU1kLFFBQVEsdUJBQXVCLEdBQ25DLElBQUltQixNQUFNO1lBRVosK0RBQStEO1lBQy9EMUQsMENBQU1BLENBQUN3QyxNQUFNSyxNQUFNLEtBQUtDLFdBQVc7WUFDbkNQLE1BQU1FLEdBQUcsR0FBR0QsTUFBTUssTUFBTTtZQUN4Qk4sTUFBTVEsR0FBRyxHQUFHO2dCQUFDQyxNQUFNUixNQUFNUSxJQUFJO2dCQUFFQyxRQUFRVCxNQUFNUyxNQUFNLEdBQUc7WUFBQztZQUN2RDdCLFlBQVltQjtZQUNacEIsU0FBUzJCO1FBQ1g7SUFDRjtJQUVBLElBQUkzQixRQUFRO1FBQ1YsZ0RBQWdEO1FBQ2hEQSxPQUFPTCxRQUFRLEdBQUdBO1FBRWxCLG9EQUFvRDtRQUNwRGIsd0RBQUtBLENBQUNrQixRQUFRLFNBQVV3QyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxPQUFPO1lBQ25ELElBQUlDLFVBQVUseUNBQXlDLEdBQ3JERCxPQUFPLENBQUNBLFFBQVFYLE1BQU0sR0FBRyxFQUFFO1lBRTdCLHdDQUF3QyxHQUN4QyxJQUFJYSxPQUFPSjtZQUVYLGlEQUFpRDtZQUNqRCx1Q0FBdUM7WUFDdkMsSUFBSUQsT0FBT0wsSUFBSSxLQUFLLDZCQUE2QlMsV0FBV0MsTUFBTTtnQkFDaEUsb0JBQW9CLEdBQ3BCLElBQUksT0FBT0gsVUFBVSxVQUFVO29CQUM3QiwrQkFBK0I7b0JBQy9CRSxVQUFVQSxPQUFPLENBQUNDLEtBQUs7b0JBQ3ZCQSxPQUFPSDtnQkFDVDtnQkFFQSwrQkFBK0I7Z0JBQy9CRSxPQUFPLENBQUNDLEtBQUssR0FBR0wsT0FBTzlCLFVBQVU7WUFDbkM7WUFFQW9DLFlBQVlOO1FBQ2Q7UUFFQSxzRUFBc0U7UUFDdEUsSUFBSU8sTUFBTUMsT0FBTyxDQUFDbkQsWUFBWTtZQUM1QkEsVUFBVW9ELElBQUksSUFBSXREO1FBQ3BCLE9BQU8sSUFBSSxPQUFPRSxjQUFjLFlBQVk7WUFDMUMsS0FBSyxNQUFNcUQsV0FBV3ZELFNBQVU7Z0JBQzlCZCwwQ0FBTUEsQ0FBQ3FFLFFBQVF0QixHQUFHLEVBQUU7Z0JBQ3BCL0IsVUFDRXFELFFBQVFmLElBQUksS0FBSyxTQUNqQmUsUUFBUTFDLEtBQUssRUFDYjBDLFFBQVFkLEtBQUssRUFDYmMsUUFBUWhCLEdBQUcsRUFDWGdCLFFBQVF0QixHQUFHLENBQUNRLEtBQUssRUFDakJjLFFBQVF0QixHQUFHLENBQUNNLEdBQUc7WUFFbkI7UUFDRjtRQUVBLEtBQUssTUFBTWlCLFNBQVN2RCxPQUFRO1lBQzFCLHdEQUF3RDtZQUN4RCxJQUNFdUQsTUFBTWpCLEdBQUcsSUFBSTVDLE9BQU8wQyxNQUFNLElBQzFCbUIsTUFBTWYsS0FBSyxHQUFHOUMsT0FBTzBDLE1BQU0sSUFBSXpCLE9BQU95QixNQUFNLEVBQzVDO2dCQUNBO1lBQ0Y7WUFFQWMsWUFBWUs7WUFFWixJQUFJSixNQUFNQyxPQUFPLENBQUNsRCxVQUFVO2dCQUMxQkEsUUFBUW1ELElBQUksQ0FBQ0U7WUFDZixPQUFPO2dCQUNMLHNFQUFzRTtnQkFDdEUsWUFBWTtnQkFDWnRFLDBDQUFNQSxDQUFDLE9BQU9pQixZQUFZLFlBQVk7Z0JBQ3RDQSxRQUFRcUQ7WUFDVjtRQUNGO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsT0FBTztRQUFDbkQ7UUFBUW9CLE9BQU9uQjtRQUFXRjtJQUFPO0lBRXpDOzs7OztHQUtDLEdBQ0QsU0FBUytDLFlBQVlNLFdBQVc7UUFDOUJ2RSwwQ0FBTUEsQ0FDSixXQUFXdUUsYUFDWDtRQUVGdkUsMENBQU1BLENBQUMsU0FBU3VFLGFBQWE7UUFDN0IsTUFBTUMsYUFBYXZDLHdCQUF3QnNDLFlBQVloQixLQUFLO1FBQzVELE1BQU1rQixXQUFXeEMsd0JBQXdCc0MsWUFBWWxCLEdBQUc7UUFDeEQsK0RBQStEO1FBQy9EckQsMENBQU1BLENBQUN3RSxXQUFXM0IsTUFBTSxLQUFLQyxXQUFXO1FBQ3hDOUMsMENBQU1BLENBQUN5RSxTQUFTNUIsTUFBTSxLQUFLQyxXQUFXO1FBQ3RDeUIsWUFBWWhCLEtBQUssR0FBR2lCLFdBQVczQixNQUFNO1FBQ3JDMEIsWUFBWWxCLEdBQUcsR0FBR29CLFNBQVM1QixNQUFNO1FBQ2pDMEIsWUFBWXhCLEdBQUcsR0FBRztZQUNoQlEsT0FBTztnQkFDTFAsTUFBTXdCLFdBQVd4QixJQUFJO2dCQUNyQkMsUUFBUXVCLFdBQVd2QixNQUFNLEdBQUc7Z0JBQzVCSixRQUFRMkIsV0FBVzNCLE1BQU07WUFDM0I7WUFDQVEsS0FBSztnQkFDSEwsTUFBTXlCLFNBQVN6QixJQUFJO2dCQUNuQkMsUUFBUXdCLFNBQVN4QixNQUFNLEdBQUc7Z0JBQzFCSixRQUFRNEIsU0FBUzVCLE1BQU07WUFDekI7UUFDRjtRQUNBMEIsWUFBWUcsS0FBSyxHQUFHO1lBQUNILFlBQVloQixLQUFLO1lBQUVnQixZQUFZbEIsR0FBRztTQUFDO0lBQzFEO0lBRUE7Ozs7OztHQU1DLEdBQ0QsU0FBU3BCLHdCQUF3QjBDLFdBQVc7UUFDMUMsSUFBSUMsZUFBZUQsY0FBY2xFLE9BQU8wQyxNQUFNO1FBRTlDLElBQUl5QixlQUFlLEdBQUc7WUFDcEJBLGVBQWU7UUFDakIsT0FBTyxJQUFJQSxlQUFlbEQsT0FBT3lCLE1BQU0sRUFBRTtZQUN2Q3lCLGVBQWVsRCxPQUFPeUIsTUFBTTtRQUM5QjtRQUVBLElBQUlYLFFBQVFxQyxnQkFBZ0J0RCxXQUFXdUQsS0FBSyxFQUFFRjtRQUU5QyxJQUFJLENBQUNwQyxPQUFPO1lBQ1Z4QywwQ0FBTUEsQ0FDSlEsUUFBUStDLEtBQUssRUFDYjtZQUVGZixRQUFRO2dCQUNOUSxNQUFNeEMsUUFBUStDLEtBQUssQ0FBQ1AsSUFBSTtnQkFDeEJDLFFBQVF6QyxRQUFRK0MsS0FBSyxDQUFDTixNQUFNO2dCQUM1QkosUUFBUXJDLFFBQVErQyxLQUFLLENBQUNWLE1BQU07WUFDOUI7UUFDRjtRQUVBLE9BQU9MO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNWLE1BQU1ILEtBQUs7SUFDbEIsT0FBTyxRQUFRb0QsSUFBSSxDQUNqQnBELEtBQ0Usc0JBQXNCO0tBQ3JCaUIsT0FBTyxDQUFDLHFCQUFxQixHQUM5QixpQkFBaUI7SUFDakIscUVBQXFFO0lBQ3JFLHNEQUFzRDtLQUNyREEsT0FBTyxDQUFDLDZCQUE2QjtBQUU1QztBQUVBLDhGQUE4RjtBQUM5Rjs7OztDQUlDLEdBQ0QsU0FBU3BCLFFBQVFqQixNQUFNLEVBQUVrQixVQUFVO0lBQ2pDLHVCQUF1QixHQUN2QixNQUFNdUQsU0FBUztRQUFDckQsT0FBTztRQUFJbUQsT0FBTyxFQUFFO0lBQUE7SUFDcEMsSUFBSWpCLFFBQVEsQ0FBQztJQUViLE1BQU8sRUFBRUEsUUFBUXRELE9BQU80QyxNQUFNLENBQUU7UUFDOUIsTUFBTThCLFFBQVExRSxNQUFNLENBQUNzRCxNQUFNO1FBRTNCLGVBQWU7UUFDZixJQUFJb0IsS0FBSyxDQUFDLEVBQUUsS0FBSyxTQUFTO1lBQ3hCLE1BQU0zQixPQUFPMkIsS0FBSyxDQUFDLEVBQUUsQ0FBQzNCLElBQUk7WUFFMUIsSUFBSUEsU0FBU25ELHdEQUFLQSxDQUFDK0UsVUFBVSxJQUFJekQsV0FBVzBELFFBQVEsQ0FBQzdCLE9BQU87Z0JBQzFELE1BQU04QixTQUFTSCxLQUFLLENBQUMsRUFBRSxDQUFDSSxXQUFXLENBQUNKLEtBQUssQ0FBQyxFQUFFO2dCQUU1Qyx1QkFBdUI7Z0JBQ3ZCLE1BQU9HLE9BQU9qQyxNQUFNLEdBQUcsS0FBS2lDLE1BQU0sQ0FBQyxFQUFFLEtBQUtsRix3REFBS0EsQ0FBQ29GLFlBQVksQ0FBRTtvQkFDNURGLE9BQU9HLEtBQUs7Z0JBQ2Q7Z0JBRUEsTUFBTTVELFFBQVE2RCxnQkFBZ0JKO2dCQUM5QkosT0FBT0YsS0FBSyxDQUFDVixJQUFJLENBQUM7b0JBQUNZLE9BQU9yRCxLQUFLLENBQUN3QixNQUFNO29CQUFFOEIsS0FBSyxDQUFDLEVBQUUsQ0FBQzFCLEtBQUs7aUJBQUM7Z0JBQ3ZEeUIsT0FBT3JELEtBQUssSUFBSUE7Z0JBQ2hCcUQsT0FBT0YsS0FBSyxDQUFDVixJQUFJLENBQUM7b0JBQUNZLE9BQU9yRCxLQUFLLENBQUN3QixNQUFNO29CQUFFOEIsS0FBSyxDQUFDLEVBQUUsQ0FBQzVCLEdBQUc7aUJBQUM7WUFDdkQ7UUFDRjtJQUNGO0lBRUEsT0FBTzJCO0FBQ1Q7QUFFQSwyRkFBMkY7QUFDM0Y7Ozs7OztDQU1DLEdBQ0QsU0FBU0gsZ0JBQWdCQyxLQUFLLEVBQUVXLFFBQVE7SUFDdEMsSUFBSTVCLFFBQVE7SUFFWixNQUFPQSxRQUFRaUIsTUFBTTNCLE1BQU0sSUFBSTJCLEtBQUssQ0FBQ2pCLE1BQU0sQ0FBQyxFQUFFLElBQUk0QixTQUFVO1FBQzFENUIsU0FBUztJQUNYO0lBRUEsc0VBQXNFO0lBQ3RFLElBQUlBLFVBQVUsR0FBRztRQUNmLE9BQU9mO0lBQ1Q7SUFFQSxNQUFNLENBQUM0QyxjQUFjQyxhQUFhLEdBQUdiLEtBQUssQ0FBQ2pCLFFBQVEsRUFBRTtJQUNyRCxNQUFNK0IsT0FBT0gsV0FBV0M7SUFDeEIsT0FBTztRQUNMMUMsTUFBTTJDLGFBQWEzQyxJQUFJO1FBQ3ZCQyxRQUFRMEMsYUFBYTFDLE1BQU0sR0FBRzJDO1FBQzlCL0MsUUFBUThDLGFBQWE5QyxNQUFNLEdBQUcrQztJQUNoQztBQUNGO0FBRUEsc0hBQXNIO0FBQ3RILHNCQUFzQjtBQUN0Qjs7Ozs7Q0FLQyxHQUNELFNBQVNKLGdCQUFnQkosTUFBTTtJQUM3QixJQUFJdkIsUUFBUSxDQUFDO0lBQ2IsMEJBQTBCLEdBQzFCLE1BQU1tQixTQUFTLEVBQUU7SUFDakIsZ0NBQWdDLEdBQ2hDLElBQUlhO0lBRUosTUFBTyxFQUFFaEMsUUFBUXVCLE9BQU9qQyxNQUFNLENBQUU7UUFDOUIsTUFBTTJDLFFBQVFWLE1BQU0sQ0FBQ3ZCLE1BQU07UUFDM0IsbUJBQW1CLEdBQ25CLElBQUlsQztRQUVKLElBQUksT0FBT21FLFVBQVUsVUFBVTtZQUM3Qm5FLFFBQVFtRTtRQUNWLE9BQ0UsT0FBUUE7WUFDTixLQUFLNUYsd0RBQUtBLENBQUM2RixjQUFjO2dCQUFFO29CQUN6QnBFLFFBQVF2Qix5REFBTUEsQ0FBQzRGLEVBQUU7b0JBRWpCO2dCQUNGO1lBRUEsS0FBSzlGLHdEQUFLQSxDQUFDK0YsUUFBUTtnQkFBRTtvQkFDbkJ0RSxRQUFRdkIseURBQU1BLENBQUM4RixFQUFFO29CQUVqQjtnQkFDRjtZQUVBLEtBQUtoRyx3REFBS0EsQ0FBQ2lHLHNCQUFzQjtnQkFBRTtvQkFDakN4RSxRQUFRdkIseURBQU1BLENBQUM0RixFQUFFLEdBQUc1Rix5REFBTUEsQ0FBQzhGLEVBQUU7b0JBRTdCO2dCQUNGO1lBRUEsS0FBS2hHLHdEQUFLQSxDQUFDa0csYUFBYTtnQkFBRTtvQkFDeEJ6RSxRQUFRdkIseURBQU1BLENBQUNpRyxFQUFFO29CQUVqQjtnQkFDRjtZQUVBLG9CQUFvQixHQUNwQixLQUFLbkcsd0RBQUtBLENBQUNvRixZQUFZO2dCQUFFO29CQUN2QixJQUFJTyxPQUFPO29CQUNYbEUsUUFBUXZCLHlEQUFNQSxDQUFDa0csS0FBSztvQkFFcEI7Z0JBQ0Y7WUFFQTtnQkFBUztvQkFDUHRHLDBDQUFNQSxDQUFDLE9BQU84RixVQUFVLFVBQVU7b0JBQ2xDLHdDQUF3QztvQkFDeEMscURBQXFEO29CQUNyRG5FLFFBQVFnQixPQUFPNEQsWUFBWSxDQUFDVDtnQkFDOUI7UUFDRjtRQUVGRCxRQUFRQyxVQUFVNUYsd0RBQUtBLENBQUNrRyxhQUFhO1FBQ3JDcEIsT0FBT1osSUFBSSxDQUFDekM7SUFDZDtJQUVBLE9BQU9xRCxPQUFPd0IsSUFBSSxDQUFDO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4vbm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybi9kZXYvaW5kZXguanM/MGY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuQ29tbWVudH0gQ29tbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnYWNvcm4nKS5Ob2RlfSBBY29ybk5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2Fjb3JuJykuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdhY29ybicpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTm9kZX0gRXN0cmVlTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuUHJvZ3JhbX0gUHJvZ3JhbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5DaHVua30gQ2h1bmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBvaW50fSBNaWNyb21hcmtQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlblR5cGV9IFRva2VuVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gVW5pc3RQb2ludFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgQWNvcm5cbiAqICAgQWNvcm4tbGlrZSBpbnRlcmZhY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnYWNvcm4nKS5wYXJzZX0gcGFyc2VcbiAqICAgUGFyc2UgYSBwcm9ncmFtLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJ2Fjb3JuJykucGFyc2VFeHByZXNzaW9uQXR9IHBhcnNlRXhwcmVzc2lvbkF0XG4gKiAgIFBhcnNlIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5Mb2NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sdW1uXG4gKlxuICogQHR5cGVkZWYgQWNvcm5FcnJvckZpZWxkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhaXNlZEF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zXG4gKiBAcHJvcGVydHkge0Fjb3JuTG9jfSBsb2NcbiAqXG4gKiBAdHlwZWRlZiB7RXJyb3IgJiBBY29ybkVycm9yRmllbGRzfSBBY29ybkVycm9yXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtBY29ybn0gYWNvcm5cbiAqICAgVHlwaWNhbGx5IGBhY29ybmAsIG9iamVjdCB3aXRoIGBwYXJzZWAgYW5kIGBwYXJzZUV4cHJlc3Npb25BdGAgZmllbGRzIChyZXF1aXJlZCkuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHlwZT59IHRva2VuVHlwZXNcbiAqICAgTmFtZXMgb2YgKHZvaWQpIHRva2VucyB0byBjb25zaWRlciBhcyBkYXRhOyBgJ2xpbmVFbmRpbmcnYCBpcyBhbHdheXNcbiAqICAgaW5jbHVkZWQgKHJlcXVpcmVkKS5cbiAqIEBwcm9wZXJ0eSB7QWNvcm5PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuT3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYGFjb3JuYCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtNaWNyb21hcmtQb2ludCB8IG51bGwgfCB1bmRlZmluZWR9IFtzdGFydF1cbiAqICAgUGxhY2Ugd2hlcmUgZXZlbnRzIHN0YXJ0IChvcHRpb25hbCwgcmVxdWlyZWQgaWYgYGFsbG93RW1wdHlgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByZWZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBiZWZvcmUgZXZlbnRzIChkZWZhdWx0OiBgJydgKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N1ZmZpeD0nJ11cbiAqICAgVGV4dCB0byBwbGFjZSBhZnRlciBldmVudHMgKGRlZmF1bHQ6IGAnJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2V4cHJlc3Npb249ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdGhpcyBpcyBhIHByb2dyYW0gb3IgZXhwcmVzc2lvbiAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT1mYWxzZV1cbiAqICAgV2hldGhlciBhbiBlbXB0eSBleHByZXNzaW9uIGlzIGFsbG93ZWQgKHByb2dyYW1zIGFyZSBhbHdheXMgYWxsb3dlZCB0b1xuICogICBiZSBlbXB0eSkgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqIEB0eXBlZGVmIFJlc3VsdFxuICogICBSZXN1bHQuXG4gKiBAcHJvcGVydHkge1Byb2dyYW0gfCB1bmRlZmluZWR9IGVzdHJlZVxuICogICBQcm9ncmFtLlxuICogQHByb3BlcnR5IHtBY29ybkVycm9yIHwgdW5kZWZpbmVkfSBlcnJvclxuICogICBFcnJvciBpZiB1bnBhcnNlYWJsZVxuICogQHByb3BlcnR5IHtib29sZWFufSBzd2FsbG93XG4gKiAgIFdoZXRoZXIgdGhlIGVycm9yLCBpZiB0aGVyZSBpcyBvbmUsIGNhbiBiZSBzd2FsbG93ZWQgYW5kIG1vcmUgSmF2YVNjcmlwdFxuICogICBjb3VsZCBiZSB2YWxpZC5cbiAqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgTWljcm9tYXJrUG9pbnRdfSBTdG9wXG4gKlxuICogQHR5cGVkZWYgQ29sbGVjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0FycmF5PFN0b3A+fSBzdG9wc1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3Zpc2l0fSBmcm9tICdlc3RyZWUtdXRpbC12aXNpdCdcbmltcG9ydCB7Y29kZXMsIHR5cGVzLCB2YWx1ZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBtaWNyb21hcmsgZXZlbnRzIHdpdGggYWNvcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogICBFdmVudHMuXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqICAgUmVzdWx0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50c1RvQWNvcm4oZXZlbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICcnXG4gIGNvbnN0IHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4IHx8ICcnXG4gIGNvbnN0IGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYWNvcm5PcHRpb25zKVxuICAvKiogQHR5cGUge0FycmF5PENvbW1lbnQ+fSAqL1xuICBjb25zdCBjb21tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8VG9rZW4+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuICBjb25zdCBvbkNvbW1lbnQgPSBhY29ybk9wdGlvbnMub25Db21tZW50XG4gIGNvbnN0IG9uVG9rZW4gPSBhY29ybk9wdGlvbnMub25Ub2tlblxuICBsZXQgc3dhbGxvdyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7QWNvcm5Ob2RlIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgZXN0cmVlXG4gIC8qKiBAdHlwZSB7QWNvcm5FcnJvciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGV4Y2VwdGlvblxuICAvKiogQHR5cGUge0Fjb3JuT3B0aW9uc30gKi9cbiAgY29uc3QgYWNvcm5Db25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBhY29ybk9wdGlvbnMsIHtcbiAgICBvbkNvbW1lbnQ6IGNvbW1lbnRzLFxuICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlXG4gIH0pXG5cbiAgaWYgKG9uVG9rZW4pIHtcbiAgICBhY29ybkNvbmZpZy5vblRva2VuID0gdG9rZW5zXG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uID0gY29sbGVjdChldmVudHMsIG9wdGlvbnMudG9rZW5UeXBlcylcblxuICBjb25zdCBzb3VyY2UgPSBjb2xsZWN0aW9uLnZhbHVlXG5cbiAgY29uc3QgdmFsdWUgPSBwcmVmaXggKyBzb3VyY2UgKyBzdWZmaXhcbiAgY29uc3QgaXNFbXB0eUV4cHJlc3Npb24gPSBvcHRpb25zLmV4cHJlc3Npb24gJiYgZW1wdHkoc291cmNlKVxuXG4gIGlmIChpc0VtcHR5RXhwcmVzc2lvbiAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZSgnVW5leHBlY3RlZCBlbXB0eSBleHByZXNzaW9uJywge1xuICAgICAgcGxhY2U6IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KDApLFxuICAgICAgcnVsZUlkOiAndW5leHBlY3RlZC1lbXB0eS1leHByZXNzaW9uJyxcbiAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgZXN0cmVlID1cbiAgICAgIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb25cbiAgICAgICAgPyBvcHRpb25zLmFjb3JuLnBhcnNlRXhwcmVzc2lvbkF0KHZhbHVlLCAwLCBhY29ybkNvbmZpZylcbiAgICAgICAgOiBvcHRpb25zLmFjb3JuLnBhcnNlKHZhbHVlLCBhY29ybkNvbmZpZylcbiAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAvKiogQHR5cGUge0Fjb3JuRXJyb3J9ICovIChlcnJvcl8pXG4gICAgY29uc3QgcG9pbnQgPSBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChlcnJvci5wb3MpXG4gICAgZXJyb3IubWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKS5yZXBsYWNlKC8gXFwoXFxkKzpcXGQrXFwpJC8sICcnKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICBlcnJvci5sb2MgPSB7bGluZTogcG9pbnQubGluZSwgY29sdW1uOiBwb2ludC5jb2x1bW4gLSAxfVxuICAgIGV4Y2VwdGlvbiA9IGVycm9yXG4gICAgc3dhbGxvdyA9XG4gICAgICBlcnJvci5yYWlzZWRBdCA+PSBwcmVmaXgubGVuZ3RoICsgc291cmNlLmxlbmd0aCB8fFxuICAgICAgLy8gQnJva2VuIGNvbW1lbnRzIGFyZSByYWlzZWQgYXQgdGhlaXIgc3RhcnQsIG5vdCB0aGVpciBlbmQuXG4gICAgICBlcnJvci5tZXNzYWdlID09PSAnVW50ZXJtaW5hdGVkIGNvbW1lbnQnXG4gIH1cblxuICBpZiAoZXN0cmVlICYmIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb24pIHtcbiAgICBpZiAoZW1wdHkodmFsdWUuc2xpY2UoZXN0cmVlLmVuZCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpKSB7XG4gICAgICBlc3RyZWUgPSB7XG4gICAgICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcHJlZml4Lmxlbmd0aCArIHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEl04oCZcyBnb29kLlxuICAgICAgICBib2R5OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXN0cmVlLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IHByZWZpeC5sZW5ndGggKyBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgY29tbWVudHM6IFtdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoZXN0cmVlLmVuZClcbiAgICAgIGNvbnN0IGVycm9yID0gLyoqIEB0eXBlIHtBY29ybkVycm9yfSAqLyAoXG4gICAgICAgIG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IGFmdGVyIGV4cHJlc3Npb24nKVxuICAgICAgKVxuICAgICAgLy8gQWx3YXlzIGRlZmluZWQgaW4gb3VyIHVuaXN0IHBvaW50cyB0aGF0IGNvbWUgZnJvbSBtaWNyb21hcmsuXG4gICAgICBhc3NlcnQocG9pbnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICAgIGVycm9yLmxvYyA9IHtsaW5lOiBwb2ludC5saW5lLCBjb2x1bW46IHBvaW50LmNvbHVtbiAtIDF9XG4gICAgICBleGNlcHRpb24gPSBlcnJvclxuICAgICAgZXN0cmVlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaWYgKGVzdHJlZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFjb3JuICpkb2VzKiBhbGxvdyBjb21tZW50c1xuICAgIGVzdHJlZS5jb21tZW50cyA9IGNvbW1lbnRzXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY29ybiBsb29rcyBlbm91Z2ggbGlrZSBlc3RyZWUuXG4gICAgdmlzaXQoZXN0cmVlLCBmdW5jdGlvbiAoZXNub2RlLCBmaWVsZCwgaW5kZXgsIHBhcmVudHMpIHtcbiAgICAgIGxldCBjb250ZXh0ID0gLyoqIEB0eXBlIHtBY29ybk5vZGUgfCBBcnJheTxBY29ybk5vZGU+fSAqLyAoXG4gICAgICAgIHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICAgLyoqIEB0eXBlIHtudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQgcHJvcCA9IGZpZWxkXG5cbiAgICAgIC8vIFJlbW92ZSBub24tc3RhbmRhcmQgYFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uYC5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluY2x1ZGVkIGluIGFjb3JuLlxuICAgICAgaWYgKGVzbm9kZS50eXBlID09PSAnUGFyZW50aGVzaXplZEV4cHJlc3Npb24nICYmIGNvbnRleHQgJiYgcHJvcCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3Byb3BdXG4gICAgICAgICAgcHJvcCA9IGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICAgIGNvbnRleHRbcHJvcF0gPSBlc25vZGUuZXhwcmVzc2lvblxuICAgICAgfVxuXG4gICAgICBmaXhQb3NpdGlvbihlc25vZGUpXG4gICAgfSlcblxuICAgIC8vIENvbW1lbnQgcG9zaXRpb25zIGFyZSBmaXhlZCBieSBgdmlzaXRgIGJlY2F1c2UgdGhleeKAmXJlIGluIHRoZSB0cmVlLlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9uQ29tbWVudCkpIHtcbiAgICAgIG9uQ29tbWVudC5wdXNoKC4uLmNvbW1lbnRzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9uQ29tbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XG4gICAgICAgIGFzc2VydChjb21tZW50LmxvYywgJ2V4cGVjdGVkIGBsb2NgIG9uIGNvbW1lbnQnKVxuICAgICAgICBvbkNvbW1lbnQoXG4gICAgICAgICAgY29tbWVudC50eXBlID09PSAnQmxvY2snLFxuICAgICAgICAgIGNvbW1lbnQudmFsdWUsXG4gICAgICAgICAgY29tbWVudC5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmVuZCxcbiAgICAgICAgICBjb21tZW50LmxvYy5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmxvYy5lbmRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAvLyBJZ25vcmUgdG9rZW5zIHRoYXQgZW5kcyBpbiBwcmVmaXggb3Igc3RhcnQgaW4gc3VmZml4OlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi5lbmQgPD0gcHJlZml4Lmxlbmd0aCB8fFxuICAgICAgICB0b2tlbi5zdGFydCAtIHByZWZpeC5sZW5ndGggPj0gc291cmNlLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGZpeFBvc2l0aW9uKHRva2VuKVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvblRva2VuKSkge1xuICAgICAgICBvblRva2VuLnB1c2godG9rZW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgdG9rZW5zYCBhcmUgbm90IGFkZGVkIGlmIGBvblRva2VuYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgbXVzdCBiZSBhXG4gICAgICAgIC8vIGZ1bmN0aW9uLlxuICAgICAgICBhc3NlcnQodHlwZW9mIG9uVG9rZW4gPT09ICdmdW5jdGlvbicsICdleHBlY3RlZCBmdW5jdGlvbicpXG4gICAgICAgIG9uVG9rZW4odG9rZW4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogSXTigJlzIGEgcHJvZ3JhbSBub3cuXG4gIHJldHVybiB7ZXN0cmVlLCBlcnJvcjogZXhjZXB0aW9uLCBzd2FsbG93fVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtBY29ybk5vZGUgfCBFc3RyZWVOb2RlIHwgVG9rZW59IG5vZGVPclRva2VuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBmaXhQb3NpdGlvbihub2RlT3JUb2tlbikge1xuICAgIGFzc2VydChcbiAgICAgICdzdGFydCcgaW4gbm9kZU9yVG9rZW4sXG4gICAgICAnZXhwZWN0ZWQgYHN0YXJ0YCBpbiBub2RlIG9yIHRva2VuIGZyb20gYWNvcm4nXG4gICAgKVxuICAgIGFzc2VydCgnZW5kJyBpbiBub2RlT3JUb2tlbiwgJ2V4cGVjdGVkIGBlbmRgIGluIG5vZGUgb3IgdG9rZW4gZnJvbSBhY29ybicpXG4gICAgY29uc3QgcG9pbnRTdGFydCA9IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KG5vZGVPclRva2VuLnN0YXJ0KVxuICAgIGNvbnN0IHBvaW50RW5kID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQobm9kZU9yVG9rZW4uZW5kKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludFN0YXJ0Lm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgIGFzc2VydChwb2ludEVuZC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBub2RlT3JUb2tlbi5zdGFydCA9IHBvaW50U3RhcnQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4uZW5kID0gcG9pbnRFbmQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4ubG9jID0ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogcG9pbnRTdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50U3RhcnQuY29sdW1uIC0gMSxcbiAgICAgICAgb2Zmc2V0OiBwb2ludFN0YXJ0Lm9mZnNldFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiBwb2ludEVuZC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50RW5kLmNvbHVtbiAtIDEsXG4gICAgICAgIG9mZnNldDogcG9pbnRFbmQub2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVPclRva2VuLnJhbmdlID0gW25vZGVPclRva2VuLnN0YXJ0LCBub2RlT3JUb2tlbi5lbmRdXG4gIH1cblxuICAvKipcbiAgICogVHVybiBhbiBhcmJpdHJhcnkgb2Zmc2V0IGludG8gdGhlIHBhcnNlZCB2YWx1ZSwgaW50byBhIHBvaW50IGluIHRoZSBzb3VyY2VcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY29ybk9mZnNldFxuICAgKiBAcmV0dXJucyB7VW5pc3RQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KGFjb3JuT2Zmc2V0KSB7XG4gICAgbGV0IHNvdXJjZU9mZnNldCA9IGFjb3JuT2Zmc2V0IC0gcHJlZml4Lmxlbmd0aFxuXG4gICAgaWYgKHNvdXJjZU9mZnNldCA8IDApIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IDBcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU9mZnNldCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHNvdXJjZU9mZnNldCA9IHNvdXJjZS5sZW5ndGhcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSByZWxhdGl2ZVRvUG9pbnQoY29sbGVjdGlvbi5zdG9wcywgc291cmNlT2Zmc2V0KVxuXG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBvcHRpb25zLnN0YXJ0LFxuICAgICAgICAnZW1wdHkgZXhwcmVzc2lvbnMgYXJlIG5lZWQgYG9wdGlvbnMuc3RhcnRgIGJlaW5nIHBhc3NlZCdcbiAgICAgIClcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBsaW5lOiBvcHRpb25zLnN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogb3B0aW9ucy5zdGFydC5jb2x1bW4sXG4gICAgICAgIG9mZnNldDogb3B0aW9ucy5zdGFydC5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiAvXlxccyokLy50ZXN0KFxuICAgIHZhbHVlXG4gICAgICAvLyBNdWx0aWxpbmUgY29tbWVudHMuXG4gICAgICAucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJylcbiAgICAgIC8vIExpbmUgY29tbWVudHMuXG4gICAgICAvLyBFT0YgaW5zdGVhZCBvZiBFT0wgaXMgc3BlY2lmaWNhbGx5IG5vdCBhbGxvd2VkLCBiZWNhdXNlIHRoYXQgd291bGRcbiAgICAgIC8vIG1lYW4gdGhlIGNsb3NpbmcgYnJhY2UgaXMgb24gdGhlIGNvbW1lbnRlZC1vdXQgbGluZVxuICAgICAgLnJlcGxhY2UoL1xcL1xcL1teXFxyXFxuXSooXFxyXFxufFxcbnxcXHIpL2csICcnKVxuICApXG59XG5cbi8vIFBvcnQgZnJvbSA8aHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL2U2OTJhYjAvc3JjL3V0aWwvbWR4X2NvbGxlY3QucnMjTDE1Pi5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHBhcmFtIHtBcnJheTxUb2tlblR5cGU+fSB0b2tlblR5cGVzXG4gKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAqL1xuZnVuY3Rpb24gY29sbGVjdChldmVudHMsIHRva2VuVHlwZXMpIHtcbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqL1xuICBjb25zdCByZXN1bHQgPSB7dmFsdWU6ICcnLCBzdG9wczogW119XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAvLyBBc3N1bWUgdm9pZC5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBldmVudFsxXS50eXBlXG5cbiAgICAgIGlmICh0eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8IHRva2VuVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gZXZlbnRbMl0uc2xpY2VTdHJlYW0oZXZlbnRbMV0pXG5cbiAgICAgICAgLy8gRHJvcCB2aXJ0dWFsIHNwYWNlcy5cbiAgICAgICAgd2hpbGUgKGNodW5rcy5sZW5ndGggPiAwICYmIGNodW5rc1swXSA9PT0gY29kZXMudmlydHVhbFNwYWNlKSB7XG4gICAgICAgICAgY2h1bmtzLnNoaWZ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplQ2h1bmtzKGNodW5rcylcbiAgICAgICAgcmVzdWx0LnN0b3BzLnB1c2goW3Jlc3VsdC52YWx1ZS5sZW5ndGgsIGV2ZW50WzFdLnN0YXJ0XSlcbiAgICAgICAgcmVzdWx0LnZhbHVlICs9IHZhbHVlXG4gICAgICAgIHJlc3VsdC5zdG9wcy5wdXNoKFtyZXN1bHQudmFsdWUubGVuZ3RoLCBldmVudFsxXS5lbmRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gUG9ydCBmcm9tIDxodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvZTY5MmFiMC9zcmMvdXRpbC9sb2NhdGlvbi5ycyNMOTE+LlxuLyoqXG4gKiBUdXJuIGEgcmVsYXRpdmUgb2Zmc2V0IGludG8gYW4gYWJzb2x1dGUgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RvcD59IHN0b3BzXG4gKiBAcGFyYW0ge251bWJlcn0gcmVsYXRpdmVcbiAqIEByZXR1cm5zIHtVbmlzdFBvaW50IHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWxhdGl2ZVRvUG9pbnQoc3RvcHMsIHJlbGF0aXZlKSB7XG4gIGxldCBpbmRleCA9IDBcblxuICB3aGlsZSAoaW5kZXggPCBzdG9wcy5sZW5ndGggJiYgc3RvcHNbaW5kZXhdWzBdIDw9IHJlbGF0aXZlKSB7XG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIG5vIHBvaW50czogdGhhdCBvbmx5IG9jY3VycyBpZiB0aGVyZSB3YXMgYW4gZW1wdHkgc3RyaW5nLlxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBbc3RvcFJlbGF0aXZlLCBzdG9wQWJzb2x1dGVdID0gc3RvcHNbaW5kZXggLSAxXVxuICBjb25zdCByZXN0ID0gcmVsYXRpdmUgLSBzdG9wUmVsYXRpdmVcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBzdG9wQWJzb2x1dGUubGluZSxcbiAgICBjb2x1bW46IHN0b3BBYnNvbHV0ZS5jb2x1bW4gKyByZXN0LFxuICAgIG9mZnNldDogc3RvcEFic29sdXRlLm9mZnNldCArIHJlc3RcbiAgfVxufVxuXG4vLyBDb3B5IGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hcmsvbWljcm9tYXJrL2Jsb2IvY2UzNTkzYS9wYWNrYWdlcy9taWNyb21hcmsvZGV2L2xpYi9jcmVhdGUtdG9rZW5pemVyLmpzI0w1OTU+XG4vLyBUbyBkbzogZXhwb3NlIHRoYXQ/XG4vKipcbiAqIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgc2xpY2Ugb2YgY2h1bmtzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Q2h1bms+fSBjaHVua3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNodW5rcyhjaHVua3MpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBhdFRhYlxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gY2h1bmtcbiAgICB9IGVsc2VcbiAgICAgIHN3aXRjaCAoY2h1bmspIHtcbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybjoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmNyXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5saW5lRmVlZDoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmxmXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybkxpbmVGZWVkOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuY3IgKyB2YWx1ZXMubGZcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIGNvZGVzLmhvcml6b250YWxUYWI6IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5odFxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDYgKi9cbiAgICAgICAgY2FzZSBjb2Rlcy52aXJ0dWFsU3BhY2U6IHtcbiAgICAgICAgICBpZiAoYXRUYWIpIGNvbnRpbnVlXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuc3BhY2VcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiBjaHVuayA9PT0gJ251bWJlcicsICdleHBlY3RlZCBudW1iZXInKVxuICAgICAgICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItY29kZS1wb2ludFxuICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHVuaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgYXRUYWIgPSBjaHVuayA9PT0gY29kZXMuaG9yaXpvbnRhbFRhYlxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwidmlzaXQiLCJjb2RlcyIsInR5cGVzIiwidmFsdWVzIiwiVkZpbGVNZXNzYWdlIiwiZXZlbnRzVG9BY29ybiIsImV2ZW50cyIsIm9wdGlvbnMiLCJwcmVmaXgiLCJzdWZmaXgiLCJhY29ybk9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb21tZW50cyIsInRva2VucyIsIm9uQ29tbWVudCIsIm9uVG9rZW4iLCJzd2FsbG93IiwiZXN0cmVlIiwiZXhjZXB0aW9uIiwiYWNvcm5Db25maWciLCJwcmVzZXJ2ZVBhcmVucyIsImNvbGxlY3Rpb24iLCJjb2xsZWN0IiwidG9rZW5UeXBlcyIsInNvdXJjZSIsInZhbHVlIiwiaXNFbXB0eUV4cHJlc3Npb24iLCJleHByZXNzaW9uIiwiZW1wdHkiLCJhbGxvd0VtcHR5IiwicGxhY2UiLCJwYXJzZU9mZnNldFRvVW5pc3RQb2ludCIsInJ1bGVJZCIsImFjb3JuIiwicGFyc2VFeHByZXNzaW9uQXQiLCJwYXJzZSIsImVycm9yXyIsImVycm9yIiwicG9pbnQiLCJwb3MiLCJtZXNzYWdlIiwiU3RyaW5nIiwicmVwbGFjZSIsIm9mZnNldCIsInVuZGVmaW5lZCIsImxvYyIsImxpbmUiLCJjb2x1bW4iLCJyYWlzZWRBdCIsImxlbmd0aCIsInNsaWNlIiwiZW5kIiwidHlwZSIsInN0YXJ0IiwiYm9keSIsInNvdXJjZVR5cGUiLCJFcnJvciIsImVzbm9kZSIsImZpZWxkIiwiaW5kZXgiLCJwYXJlbnRzIiwiY29udGV4dCIsInByb3AiLCJmaXhQb3NpdGlvbiIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJjb21tZW50IiwidG9rZW4iLCJub2RlT3JUb2tlbiIsInBvaW50U3RhcnQiLCJwb2ludEVuZCIsInJhbmdlIiwiYWNvcm5PZmZzZXQiLCJzb3VyY2VPZmZzZXQiLCJyZWxhdGl2ZVRvUG9pbnQiLCJzdG9wcyIsInRlc3QiLCJyZXN1bHQiLCJldmVudCIsImxpbmVFbmRpbmciLCJpbmNsdWRlcyIsImNodW5rcyIsInNsaWNlU3RyZWFtIiwidmlydHVhbFNwYWNlIiwic2hpZnQiLCJzZXJpYWxpemVDaHVua3MiLCJyZWxhdGl2ZSIsInN0b3BSZWxhdGl2ZSIsInN0b3BBYnNvbHV0ZSIsInJlc3QiLCJhdFRhYiIsImNodW5rIiwiY2FycmlhZ2VSZXR1cm4iLCJjciIsImxpbmVGZWVkIiwibGYiLCJjYXJyaWFnZVJldHVybkxpbmVGZWVkIiwiaG9yaXpvbnRhbFRhYiIsImh0Iiwic3BhY2UiLCJmcm9tQ2hhckNvZGUiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-util-events-to-acorn/dev/index.js\n");

/***/ })

};
;