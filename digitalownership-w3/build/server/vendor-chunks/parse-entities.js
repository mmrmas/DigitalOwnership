"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-entities";
exports.ids = ["vendor-chunks/parse-entities"];
exports.modules = {

/***/ "(ssr)/./node_modules/parse-entities/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/parse-entities/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseEntities: () => (/* binding */ parseEntities)\n/* harmony export */ });\n/* harmony import */ var character_entities_legacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! character-entities-legacy */ \"(ssr)/./node_modules/character-entities-legacy/index.js\");\n/* harmony import */ var character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! character-reference-invalid */ \"(ssr)/./node_modules/character-reference-invalid/index.js\");\n/* harmony import */ var is_decimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-decimal */ \"(ssr)/./node_modules/is-decimal/index.js\");\n/* harmony import */ var is_hexadecimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-hexadecimal */ \"(ssr)/./node_modules/is-hexadecimal/index.js\");\n/* harmony import */ var is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-alphanumerical */ \"(ssr)/./node_modules/is-alphanumerical/index.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! decode-named-character-reference */ \"(ssr)/./node_modules/decode-named-character-reference/index.js\");\n/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */ \n\n\n\n\n\nconst fromCharCode = String.fromCharCode;\n// Warning messages.\nconst messages = [\n    \"\",\n    /* 1: Non terminated (named) */ \"Named character references must be terminated by a semicolon\",\n    /* 2: Non terminated (numeric) */ \"Numeric character references must be terminated by a semicolon\",\n    /* 3: Empty (named) */ \"Named character references cannot be empty\",\n    /* 4: Empty (numeric) */ \"Numeric character references cannot be empty\",\n    /* 5: Unknown (named) */ \"Named character references must be known\",\n    /* 6: Disallowed (numeric) */ \"Numeric character references cannot be disallowed\",\n    /* 7: Prohibited (numeric) */ \"Numeric character references cannot be outside the permissible Unicode range\"\n];\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */ function parseEntities(value, options = {}) {\n    const additional = typeof options.additional === \"string\" ? options.additional.charCodeAt(0) : options.additional;\n    /** @type {Array<string>} */ const result = [];\n    let index = 0;\n    let lines = -1;\n    let queue = \"\";\n    /** @type {Point|undefined} */ let point;\n    /** @type {Array<number>|undefined} */ let indent;\n    if (options.position) {\n        if (\"start\" in options.position || \"indent\" in options.position) {\n            // @ts-expect-error: points don’t have indent.\n            indent = options.position.indent;\n            // @ts-expect-error: points don’t have indent.\n            point = options.position.start;\n        } else {\n            point = options.position;\n        }\n    }\n    let line = (point ? point.line : 0) || 1;\n    let column = (point ? point.column : 0) || 1;\n    // Cache the current point.\n    let previous = now();\n    /** @type {number|undefined} */ let character;\n    // Ensure the algorithm walks over the first character (inclusive).\n    index--;\n    while(++index <= value.length){\n        // If the previous character was a newline.\n        if (character === 10 /* `\\n` */ ) {\n            column = (indent ? indent[lines] : 0) || 1;\n        }\n        character = value.charCodeAt(index);\n        if (character === 38 /* `&` */ ) {\n            const following = value.charCodeAt(index + 1);\n            // The behavior depends on the identity of the next character.\n            if (following === 9 /* `\\t` */  || following === 10 /* `\\n` */  || following === 12 /* `\\f` */  || following === 32 /* ` ` */  || following === 38 /* `&` */  || following === 60 /* `<` */  || Number.isNaN(following) || additional && following === additional) {\n                // Not a character reference.\n                // No characters are consumed, and nothing is returned.\n                // This is not an error, either.\n                queue += fromCharCode(character);\n                column++;\n                continue;\n            }\n            const start = index + 1;\n            let begin = start;\n            let end = start;\n            /** @type {string} */ let type;\n            if (following === 35 /* `#` */ ) {\n                // Numerical reference.\n                end = ++begin;\n                // The behavior further depends on the next character.\n                const following = value.charCodeAt(end);\n                if (following === 88 /* `X` */  || following === 120 /* `x` */ ) {\n                    // ASCII hexadecimal digits.\n                    type = \"hexadecimal\";\n                    end = ++begin;\n                } else {\n                    // ASCII decimal digits.\n                    type = \"decimal\";\n                }\n            } else {\n                // Named reference.\n                type = \"named\";\n            }\n            let characterReferenceCharacters = \"\";\n            let characterReference = \"\";\n            let characters = \"\";\n            // Each type of character reference accepts different characters.\n            // This test is used to detect whether a reference has ended (as the semicolon\n            // is not strictly needed).\n            const test = type === \"named\" ? is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__.isAlphanumerical : type === \"decimal\" ? is_decimal__WEBPACK_IMPORTED_MODULE_1__.isDecimal : is_hexadecimal__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal;\n            end--;\n            while(++end <= value.length){\n                const following = value.charCodeAt(end);\n                if (!test(following)) {\n                    break;\n                }\n                characters += fromCharCode(following);\n                // Check if we can match a legacy named reference.\n                // If so, we cache that as the last viable named reference.\n                // This ensures we do not need to walk backwards later.\n                if (type === \"named\" && character_entities_legacy__WEBPACK_IMPORTED_MODULE_3__.characterEntitiesLegacy.includes(characters)) {\n                    characterReferenceCharacters = characters;\n                    // @ts-expect-error: always able to decode.\n                    characterReference = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__.decodeNamedCharacterReference)(characters);\n                }\n            }\n            let terminated = value.charCodeAt(end) === 59 /* `;` */ ;\n            if (terminated) {\n                end++;\n                const namedReference = type === \"named\" ? (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_4__.decodeNamedCharacterReference)(characters) : false;\n                if (namedReference) {\n                    characterReferenceCharacters = characters;\n                    characterReference = namedReference;\n                }\n            }\n            let diff = 1 + end - start;\n            let reference = \"\";\n            if (!terminated && options.nonTerminated === false) {\n            // Empty.\n            } else if (!characters) {\n                // An empty (possible) reference is valid, unless it’s numeric (thus an\n                // ampersand followed by an octothorp).\n                if (type !== \"named\") {\n                    warning(4 /* Empty (numeric) */ , diff);\n                }\n            } else if (type === \"named\") {\n                // An ampersand followed by anything unknown, and not terminated, is\n                // invalid.\n                if (terminated && !characterReference) {\n                    warning(5 /* Unknown (named) */ , 1);\n                } else {\n                    // If there’s something after an named reference which is not known,\n                    // cap the reference.\n                    if (characterReferenceCharacters !== characters) {\n                        end = begin + characterReferenceCharacters.length;\n                        diff = 1 + end - begin;\n                        terminated = false;\n                    }\n                    // If the reference is not terminated, warn.\n                    if (!terminated) {\n                        const reason = characterReferenceCharacters ? 1 /* Non terminated (named) */  : 3 /* Empty (named) */ ;\n                        if (options.attribute) {\n                            const following = value.charCodeAt(end);\n                            if (following === 61 /* `=` */ ) {\n                                warning(reason, diff);\n                                characterReference = \"\";\n                            } else if ((0,is_alphanumerical__WEBPACK_IMPORTED_MODULE_0__.isAlphanumerical)(following)) {\n                                characterReference = \"\";\n                            } else {\n                                warning(reason, diff);\n                            }\n                        } else {\n                            warning(reason, diff);\n                        }\n                    }\n                }\n                reference = characterReference;\n            } else {\n                if (!terminated) {\n                    // All nonterminated numeric references are not rendered, and emit a\n                    // warning.\n                    warning(2 /* Non terminated (numeric) */ , diff);\n                }\n                // When terminated and numerical, parse as either hexadecimal or\n                // decimal.\n                let referenceCode = Number.parseInt(characters, type === \"hexadecimal\" ? 16 : 10);\n                // Emit a warning when the parsed number is prohibited, and replace with\n                // replacement character.\n                if (prohibited(referenceCode)) {\n                    warning(7 /* Prohibited (numeric) */ , diff);\n                    reference = fromCharCode(65533 /* `�` */ );\n                } else if (referenceCode in character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__.characterReferenceInvalid) {\n                    // Emit a warning when the parsed number is disallowed, and replace by\n                    // an alternative.\n                    warning(6 /* Disallowed (numeric) */ , diff);\n                    reference = character_reference_invalid__WEBPACK_IMPORTED_MODULE_5__.characterReferenceInvalid[referenceCode];\n                } else {\n                    // Parse the number.\n                    let output = \"\";\n                    // Emit a warning when the parsed number should not be used.\n                    if (disallowed(referenceCode)) {\n                        warning(6 /* Disallowed (numeric) */ , diff);\n                    }\n                    // Serialize the number.\n                    if (referenceCode > 0xffff) {\n                        referenceCode -= 0x10000;\n                        output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n                        referenceCode = 0xdc00 | referenceCode & 0x3ff;\n                    }\n                    reference = output + fromCharCode(referenceCode);\n                }\n            }\n            // Found it!\n            // First eat the queued characters as normal text, then eat a reference.\n            if (reference) {\n                flush();\n                previous = now();\n                index = end - 1;\n                column += end - start + 1;\n                result.push(reference);\n                const next = now();\n                next.offset++;\n                if (options.reference) {\n                    options.reference.call(options.referenceContext, reference, {\n                        start: previous,\n                        end: next\n                    }, value.slice(start - 1, end));\n                }\n                previous = next;\n            } else {\n                // If we could not find a reference, queue the checked characters (as\n                // normal characters), and move the pointer to their end.\n                // This is possible because we can be certain neither newlines nor\n                // ampersands are included.\n                characters = value.slice(start - 1, end);\n                queue += characters;\n                column += characters.length;\n                index = end - 1;\n            }\n        } else {\n            // Handle anything other than an ampersand, including newlines and EOF.\n            if (character === 10 /* `\\n` */ ) {\n                line++;\n                lines++;\n                column = 0;\n            }\n            if (Number.isNaN(character)) {\n                flush();\n            } else {\n                queue += fromCharCode(character);\n                column++;\n            }\n        }\n    }\n    // Return the reduced nodes.\n    return result.join(\"\");\n    // Get current position.\n    function now() {\n        return {\n            line,\n            column,\n            offset: index + ((point ? point.offset : 0) || 0)\n        };\n    }\n    /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */ function warning(code, offset) {\n        /** @type {ReturnType<now>} */ let position;\n        if (options.warning) {\n            position = now();\n            position.column += offset;\n            position.offset += offset;\n            options.warning.call(options.warningContext, messages[code], position, code);\n        }\n    }\n    /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */ function flush() {\n        if (queue) {\n            result.push(queue);\n            if (options.text) {\n                options.text.call(options.textContext, queue, {\n                    start: previous,\n                    end: now()\n                });\n            }\n            queue = \"\";\n        }\n    }\n}\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */ function prohibited(code) {\n    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */ function disallowed(code) {\n    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyc2UtZW50aXRpZXMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFZ0U7QUFDSTtBQUNqQztBQUNRO0FBQ007QUFDNEI7QUFFOUUsTUFBTU0sZUFBZUMsT0FBT0QsWUFBWTtBQUV4QyxvQkFBb0I7QUFDcEIsTUFBTUUsV0FBVztJQUNmO0lBQ0EsNkJBQTZCLEdBQzdCO0lBQ0EsK0JBQStCLEdBQy9CO0lBQ0Esb0JBQW9CLEdBQ3BCO0lBQ0Esc0JBQXNCLEdBQ3RCO0lBQ0Esc0JBQXNCLEdBQ3RCO0lBQ0EsMkJBQTJCLEdBQzNCO0lBQ0EsMkJBQTJCLEdBQzNCO0NBQ0Q7QUFFRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsTUFBTUMsYUFDSixPQUFPRCxRQUFRQyxVQUFVLEtBQUssV0FDMUJELFFBQVFDLFVBQVUsQ0FBQ0MsVUFBVSxDQUFDLEtBQzlCRixRQUFRQyxVQUFVO0lBQ3hCLDBCQUEwQixHQUMxQixNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLFFBQVE7SUFDWiw0QkFBNEIsR0FDNUIsSUFBSUM7SUFDSixvQ0FBb0MsR0FDcEMsSUFBSUM7SUFFSixJQUFJUixRQUFRUyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxXQUFXVCxRQUFRUyxRQUFRLElBQUksWUFBWVQsUUFBUVMsUUFBUSxFQUFFO1lBQy9ELDhDQUE4QztZQUM5Q0QsU0FBU1IsUUFBUVMsUUFBUSxDQUFDRCxNQUFNO1lBQ2hDLDhDQUE4QztZQUM5Q0QsUUFBUVAsUUFBUVMsUUFBUSxDQUFDQyxLQUFLO1FBQ2hDLE9BQU87WUFDTEgsUUFBUVAsUUFBUVMsUUFBUTtRQUMxQjtJQUNGO0lBRUEsSUFBSUUsT0FBTyxDQUFDSixRQUFRQSxNQUFNSSxJQUFJLEdBQUcsTUFBTTtJQUN2QyxJQUFJ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LEVBQUU7Z0JBQ2hCbkQsUUFBUW1ELElBQUksQ0FBQ04sSUFBSSxDQUFDN0MsUUFBUW9ELFdBQVcsRUFBRTlDLE9BQU87b0JBQzVDSSxPQUFPRztvQkFDUFEsS0FBS1A7Z0JBQ1A7WUFDRjtZQUVBUixRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTZ0MsV0FBV1csSUFBSTtJQUN0QixPQUFPLFFBQVMsVUFBVUEsUUFBUSxVQUFXQSxPQUFPO0FBQ3REO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTVCxXQUFXUyxJQUFJO0lBQ3RCLE9BQ0UsUUFBUyxVQUFVQSxRQUFRLFVBQzNCQSxTQUFTLFVBQ1JBLFFBQVEsVUFBVUEsUUFBUSxVQUMxQkEsUUFBUSxVQUFVQSxRQUFRLFVBQzFCQSxRQUFRLFVBQVVBLFFBQVEsVUFDM0IsQ0FBQ0EsT0FBTyxNQUFLLE1BQU8sVUFDcEIsQ0FBQ0EsT0FBTyxNQUFLLE1BQU87QUFFeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi9ub2RlX21vZHVsZXMvcGFyc2UtZW50aXRpZXMvbGliL2luZGV4LmpzP2EzOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb3NpdGlvbn0gUG9zaXRpb25cbiAqL1xuXG5pbXBvcnQge2NoYXJhY3RlckVudGl0aWVzTGVnYWN5fSBmcm9tICdjaGFyYWN0ZXItZW50aXRpZXMtbGVnYWN5J1xuaW1wb3J0IHtjaGFyYWN0ZXJSZWZlcmVuY2VJbnZhbGlkfSBmcm9tICdjaGFyYWN0ZXItcmVmZXJlbmNlLWludmFsaWQnXG5pbXBvcnQge2lzRGVjaW1hbH0gZnJvbSAnaXMtZGVjaW1hbCdcbmltcG9ydCB7aXNIZXhhZGVjaW1hbH0gZnJvbSAnaXMtaGV4YWRlY2ltYWwnXG5pbXBvcnQge2lzQWxwaGFudW1lcmljYWx9IGZyb20gJ2lzLWFscGhhbnVtZXJpY2FsJ1xuaW1wb3J0IHtkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5cbmNvbnN0IGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcblxuLy8gV2FybmluZyBtZXNzYWdlcy5cbmNvbnN0IG1lc3NhZ2VzID0gW1xuICAnJyxcbiAgLyogMTogTm9uIHRlcm1pbmF0ZWQgKG5hbWVkKSAqL1xuICAnTmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgbXVzdCBiZSB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyxcbiAgLyogMjogTm9uIHRlcm1pbmF0ZWQgKG51bWVyaWMpICovXG4gICdOdW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicsXG4gIC8qIDM6IEVtcHR5IChuYW1lZCkgKi9cbiAgJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIGNhbm5vdCBiZSBlbXB0eScsXG4gIC8qIDQ6IEVtcHR5IChudW1lcmljKSAqL1xuICAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgZW1wdHknLFxuICAvKiA1OiBVbmtub3duIChuYW1lZCkgKi9cbiAgJ05hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIG11c3QgYmUga25vd24nLFxuICAvKiA2OiBEaXNhbGxvd2VkIChudW1lcmljKSAqL1xuICAnTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBjYW5ub3QgYmUgZGlzYWxsb3dlZCcsXG4gIC8qIDc6IFByb2hpYml0ZWQgKG51bWVyaWMpICovXG4gICdOdW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2VzIGNhbm5vdCBiZSBvdXRzaWRlIHRoZSBwZXJtaXNzaWJsZSBVbmljb2RlIHJhbmdlJ1xuXVxuXG4vKipcbiAqIFBhcnNlIEhUTUwgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW5kZXguanMnKS5PcHRpb25zfSBbb3B0aW9ucz17fV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRW50aXRpZXModmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhZGRpdGlvbmFsID1cbiAgICB0eXBlb2Ygb3B0aW9ucy5hZGRpdGlvbmFsID09PSAnc3RyaW5nJ1xuICAgICAgPyBvcHRpb25zLmFkZGl0aW9uYWwuY2hhckNvZGVBdCgwKVxuICAgICAgOiBvcHRpb25zLmFkZGl0aW9uYWxcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBsZXQgaW5kZXggPSAwXG4gIGxldCBsaW5lcyA9IC0xXG4gIGxldCBxdWV1ZSA9ICcnXG4gIC8qKiBAdHlwZSB7UG9pbnR8dW5kZWZpbmVkfSAqL1xuICBsZXQgcG9pbnRcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gKi9cbiAgbGV0IGluZGVudFxuXG4gIGlmIChvcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgaWYgKCdzdGFydCcgaW4gb3B0aW9ucy5wb3NpdGlvbiB8fCAnaW5kZW50JyBpbiBvcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwb2ludHMgZG9u4oCZdCBoYXZlIGluZGVudC5cbiAgICAgIGluZGVudCA9IG9wdGlvbnMucG9zaXRpb24uaW5kZW50XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwb2ludHMgZG9u4oCZdCBoYXZlIGluZGVudC5cbiAgICAgIHBvaW50ID0gb3B0aW9ucy5wb3NpdGlvbi5zdGFydFxuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludCA9IG9wdGlvbnMucG9zaXRpb25cbiAgICB9XG4gIH1cblxuICBsZXQgbGluZSA9IChwb2ludCA/IHBvaW50LmxpbmUgOiAwKSB8fCAxXG4gIGxldCBjb2x1bW4gPSAocG9pbnQgPyBwb2ludC5jb2x1bW4gOiAwKSB8fCAxXG5cbiAgLy8gQ2FjaGUgdGhlIGN1cnJlbnQgcG9pbnQuXG4gIGxldCBwcmV2aW91cyA9IG5vdygpXG4gIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGNoYXJhY3RlclxuXG4gIC8vIEVuc3VyZSB0aGUgYWxnb3JpdGhtIHdhbGtzIG92ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciAoaW5jbHVzaXZlKS5cbiAgaW5kZXgtLVxuXG4gIHdoaWxlICgrK2luZGV4IDw9IHZhbHVlLmxlbmd0aCkge1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIGEgbmV3bGluZS5cbiAgICBpZiAoY2hhcmFjdGVyID09PSAxMCAvKiBgXFxuYCAqLykge1xuICAgICAgY29sdW1uID0gKGluZGVudCA/IGluZGVudFtsaW5lc10gOiAwKSB8fCAxXG4gICAgfVxuXG4gICAgY2hhcmFjdGVyID0gdmFsdWUuY2hhckNvZGVBdChpbmRleClcblxuICAgIGlmIChjaGFyYWN0ZXIgPT09IDM4IC8qIGAmYCAqLykge1xuICAgICAgY29uc3QgZm9sbG93aW5nID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCArIDEpXG5cbiAgICAgIC8vIFRoZSBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBpZGVudGl0eSBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoXG4gICAgICAgIGZvbGxvd2luZyA9PT0gOSAvKiBgXFx0YCAqLyB8fFxuICAgICAgICBmb2xsb3dpbmcgPT09IDEwIC8qIGBcXG5gICovIHx8XG4gICAgICAgIGZvbGxvd2luZyA9PT0gMTIgLyogYFxcZmAgKi8gfHxcbiAgICAgICAgZm9sbG93aW5nID09PSAzMiAvKiBgIGAgKi8gfHxcbiAgICAgICAgZm9sbG93aW5nID09PSAzOCAvKiBgJmAgKi8gfHxcbiAgICAgICAgZm9sbG93aW5nID09PSA2MCAvKiBgPGAgKi8gfHxcbiAgICAgICAgTnVtYmVyLmlzTmFOKGZvbGxvd2luZykgfHxcbiAgICAgICAgKGFkZGl0aW9uYWwgJiYgZm9sbG93aW5nID09PSBhZGRpdGlvbmFsKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdCBhIGNoYXJhY3RlciByZWZlcmVuY2UuXG4gICAgICAgIC8vIE5vIGNoYXJhY3RlcnMgYXJlIGNvbnN1bWVkLCBhbmQgbm90aGluZyBpcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgYW4gZXJyb3IsIGVpdGhlci5cbiAgICAgICAgcXVldWUgKz0gZnJvbUNoYXJDb2RlKGNoYXJhY3RlcilcbiAgICAgICAgY29sdW1uKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnQgPSBpbmRleCArIDFcbiAgICAgIGxldCBiZWdpbiA9IHN0YXJ0XG4gICAgICBsZXQgZW5kID0gc3RhcnRcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgbGV0IHR5cGVcblxuICAgICAgaWYgKGZvbGxvd2luZyA9PT0gMzUgLyogYCNgICovKSB7XG4gICAgICAgIC8vIE51bWVyaWNhbCByZWZlcmVuY2UuXG4gICAgICAgIGVuZCA9ICsrYmVnaW5cblxuICAgICAgICAvLyBUaGUgYmVoYXZpb3IgZnVydGhlciBkZXBlbmRzIG9uIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgY29uc3QgZm9sbG93aW5nID0gdmFsdWUuY2hhckNvZGVBdChlbmQpXG5cbiAgICAgICAgaWYgKGZvbGxvd2luZyA9PT0gODggLyogYFhgICovIHx8IGZvbGxvd2luZyA9PT0gMTIwIC8qIGB4YCAqLykge1xuICAgICAgICAgIC8vIEFTQ0lJIGhleGFkZWNpbWFsIGRpZ2l0cy5cbiAgICAgICAgICB0eXBlID0gJ2hleGFkZWNpbWFsJ1xuICAgICAgICAgIGVuZCA9ICsrYmVnaW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBU0NJSSBkZWNpbWFsIGRpZ2l0cy5cbiAgICAgICAgICB0eXBlID0gJ2RlY2ltYWwnXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5hbWVkIHJlZmVyZW5jZS5cbiAgICAgICAgdHlwZSA9ICduYW1lZCdcbiAgICAgIH1cblxuICAgICAgbGV0IGNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnMgPSAnJ1xuICAgICAgbGV0IGNoYXJhY3RlclJlZmVyZW5jZSA9ICcnXG4gICAgICBsZXQgY2hhcmFjdGVycyA9ICcnXG4gICAgICAvLyBFYWNoIHR5cGUgb2YgY2hhcmFjdGVyIHJlZmVyZW5jZSBhY2NlcHRzIGRpZmZlcmVudCBjaGFyYWN0ZXJzLlxuICAgICAgLy8gVGhpcyB0ZXN0IGlzIHVzZWQgdG8gZGV0ZWN0IHdoZXRoZXIgYSByZWZlcmVuY2UgaGFzIGVuZGVkIChhcyB0aGUgc2VtaWNvbG9uXG4gICAgICAvLyBpcyBub3Qgc3RyaWN0bHkgbmVlZGVkKS5cbiAgICAgIGNvbnN0IHRlc3QgPVxuICAgICAgICB0eXBlID09PSAnbmFtZWQnXG4gICAgICAgICAgPyBpc0FscGhhbnVtZXJpY2FsXG4gICAgICAgICAgOiB0eXBlID09PSAnZGVjaW1hbCdcbiAgICAgICAgICA/IGlzRGVjaW1hbFxuICAgICAgICAgIDogaXNIZXhhZGVjaW1hbFxuXG4gICAgICBlbmQtLVxuXG4gICAgICB3aGlsZSAoKytlbmQgPD0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKVxuXG4gICAgICAgIGlmICghdGVzdChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJhY3RlcnMgKz0gZnJvbUNoYXJDb2RlKGZvbGxvd2luZylcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gbWF0Y2ggYSBsZWdhY3kgbmFtZWQgcmVmZXJlbmNlLlxuICAgICAgICAvLyBJZiBzbywgd2UgY2FjaGUgdGhhdCBhcyB0aGUgbGFzdCB2aWFibGUgbmFtZWQgcmVmZXJlbmNlLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG8gbm90IG5lZWQgdG8gd2FsayBiYWNrd2FyZHMgbGF0ZXIuXG4gICAgICAgIGlmICh0eXBlID09PSAnbmFtZWQnICYmIGNoYXJhY3RlckVudGl0aWVzTGVnYWN5LmluY2x1ZGVzKGNoYXJhY3RlcnMpKSB7XG4gICAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlQ2hhcmFjdGVycyA9IGNoYXJhY3RlcnNcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhbHdheXMgYWJsZSB0byBkZWNvZGUuXG4gICAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlID0gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoY2hhcmFjdGVycylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdGVybWluYXRlZCA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKSA9PT0gNTkgLyogYDtgICovXG5cbiAgICAgIGlmICh0ZXJtaW5hdGVkKSB7XG4gICAgICAgIGVuZCsrXG5cbiAgICAgICAgY29uc3QgbmFtZWRSZWZlcmVuY2UgPVxuICAgICAgICAgIHR5cGUgPT09ICduYW1lZCcgPyBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZShjaGFyYWN0ZXJzKSA6IGZhbHNlXG5cbiAgICAgICAgaWYgKG5hbWVkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlQ2hhcmFjdGVycyA9IGNoYXJhY3RlcnNcbiAgICAgICAgICBjaGFyYWN0ZXJSZWZlcmVuY2UgPSBuYW1lZFJlZmVyZW5jZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkaWZmID0gMSArIGVuZCAtIHN0YXJ0XG4gICAgICBsZXQgcmVmZXJlbmNlID0gJydcblxuICAgICAgaWYgKCF0ZXJtaW5hdGVkICYmIG9wdGlvbnMubm9uVGVybWluYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2UgaWYgKCFjaGFyYWN0ZXJzKSB7XG4gICAgICAgIC8vIEFuIGVtcHR5IChwb3NzaWJsZSkgcmVmZXJlbmNlIGlzIHZhbGlkLCB1bmxlc3MgaXTigJlzIG51bWVyaWMgKHRodXMgYW5cbiAgICAgICAgLy8gYW1wZXJzYW5kIGZvbGxvd2VkIGJ5IGFuIG9jdG90aG9ycCkuXG4gICAgICAgIGlmICh0eXBlICE9PSAnbmFtZWQnKSB7XG4gICAgICAgICAgd2FybmluZyg0IC8qIEVtcHR5IChudW1lcmljKSAqLywgZGlmZilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZWQnKSB7XG4gICAgICAgIC8vIEFuIGFtcGVyc2FuZCBmb2xsb3dlZCBieSBhbnl0aGluZyB1bmtub3duLCBhbmQgbm90IHRlcm1pbmF0ZWQsIGlzXG4gICAgICAgIC8vIGludmFsaWQuXG4gICAgICAgIGlmICh0ZXJtaW5hdGVkICYmICFjaGFyYWN0ZXJSZWZlcmVuY2UpIHtcbiAgICAgICAgICB3YXJuaW5nKDUgLyogVW5rbm93biAobmFtZWQpICovLCAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJl4oCZcyBzb21ldGhpbmcgYWZ0ZXIgYW4gbmFtZWQgcmVmZXJlbmNlIHdoaWNoIGlzIG5vdCBrbm93bixcbiAgICAgICAgICAvLyBjYXAgdGhlIHJlZmVyZW5jZS5cbiAgICAgICAgICBpZiAoY2hhcmFjdGVyUmVmZXJlbmNlQ2hhcmFjdGVycyAhPT0gY2hhcmFjdGVycykge1xuICAgICAgICAgICAgZW5kID0gYmVnaW4gKyBjaGFyYWN0ZXJSZWZlcmVuY2VDaGFyYWN0ZXJzLmxlbmd0aFxuICAgICAgICAgICAgZGlmZiA9IDEgKyBlbmQgLSBiZWdpblxuICAgICAgICAgICAgdGVybWluYXRlZCA9IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBub3QgdGVybWluYXRlZCwgd2Fybi5cbiAgICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGNoYXJhY3RlclJlZmVyZW5jZUNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgPyAxIC8qIE5vbiB0ZXJtaW5hdGVkIChuYW1lZCkgKi9cbiAgICAgICAgICAgICAgOiAzIC8qIEVtcHR5IChuYW1lZCkgKi9cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvbGxvd2luZyA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kKVxuXG4gICAgICAgICAgICAgIGlmIChmb2xsb3dpbmcgPT09IDYxIC8qIGA9YCAqLykge1xuICAgICAgICAgICAgICAgIHdhcm5pbmcocmVhc29uLCBkaWZmKVxuICAgICAgICAgICAgICAgIGNoYXJhY3RlclJlZmVyZW5jZSA9ICcnXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBbHBoYW51bWVyaWNhbChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlID0gJydcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nKHJlYXNvbiwgZGlmZilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybmluZyhyZWFzb24sIGRpZmYpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVmZXJlbmNlID0gY2hhcmFjdGVyUmVmZXJlbmNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAvLyBBbGwgbm9udGVybWluYXRlZCBudW1lcmljIHJlZmVyZW5jZXMgYXJlIG5vdCByZW5kZXJlZCwgYW5kIGVtaXQgYVxuICAgICAgICAgIC8vIHdhcm5pbmcuXG4gICAgICAgICAgd2FybmluZygyIC8qIE5vbiB0ZXJtaW5hdGVkIChudW1lcmljKSAqLywgZGlmZilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdGVybWluYXRlZCBhbmQgbnVtZXJpY2FsLCBwYXJzZSBhcyBlaXRoZXIgaGV4YWRlY2ltYWwgb3JcbiAgICAgICAgLy8gZGVjaW1hbC5cbiAgICAgICAgbGV0IHJlZmVyZW5jZUNvZGUgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgICAgY2hhcmFjdGVycyxcbiAgICAgICAgICB0eXBlID09PSAnaGV4YWRlY2ltYWwnID8gMTYgOiAxMFxuICAgICAgICApXG5cbiAgICAgICAgLy8gRW1pdCBhIHdhcm5pbmcgd2hlbiB0aGUgcGFyc2VkIG51bWJlciBpcyBwcm9oaWJpdGVkLCBhbmQgcmVwbGFjZSB3aXRoXG4gICAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKHByb2hpYml0ZWQocmVmZXJlbmNlQ29kZSkpIHtcbiAgICAgICAgICB3YXJuaW5nKDcgLyogUHJvaGliaXRlZCAobnVtZXJpYykgKi8sIGRpZmYpXG4gICAgICAgICAgcmVmZXJlbmNlID0gZnJvbUNoYXJDb2RlKDY1NTMzIC8qIGDvv71gICovKVxuICAgICAgICB9IGVsc2UgaWYgKHJlZmVyZW5jZUNvZGUgaW4gY2hhcmFjdGVyUmVmZXJlbmNlSW52YWxpZCkge1xuICAgICAgICAgIC8vIEVtaXQgYSB3YXJuaW5nIHdoZW4gdGhlIHBhcnNlZCBudW1iZXIgaXMgZGlzYWxsb3dlZCwgYW5kIHJlcGxhY2UgYnlcbiAgICAgICAgICAvLyBhbiBhbHRlcm5hdGl2ZS5cbiAgICAgICAgICB3YXJuaW5nKDYgLyogRGlzYWxsb3dlZCAobnVtZXJpYykgKi8sIGRpZmYpXG4gICAgICAgICAgcmVmZXJlbmNlID0gY2hhcmFjdGVyUmVmZXJlbmNlSW52YWxpZFtyZWZlcmVuY2VDb2RlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSBudW1iZXIuXG4gICAgICAgICAgbGV0IG91dHB1dCA9ICcnXG5cbiAgICAgICAgICAvLyBFbWl0IGEgd2FybmluZyB3aGVuIHRoZSBwYXJzZWQgbnVtYmVyIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICBpZiAoZGlzYWxsb3dlZChyZWZlcmVuY2VDb2RlKSkge1xuICAgICAgICAgICAgd2FybmluZyg2IC8qIERpc2FsbG93ZWQgKG51bWVyaWMpICovLCBkaWZmKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgbnVtYmVyLlxuICAgICAgICAgIGlmIChyZWZlcmVuY2VDb2RlID4gMHhmZmZmKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VDb2RlIC09IDB4MTAwMDBcbiAgICAgICAgICAgIG91dHB1dCArPSBmcm9tQ2hhckNvZGUoKHJlZmVyZW5jZUNvZGUgPj4+ICgxMCAmIDB4M2ZmKSkgfCAweGQ4MDApXG4gICAgICAgICAgICByZWZlcmVuY2VDb2RlID0gMHhkYzAwIHwgKHJlZmVyZW5jZUNvZGUgJiAweDNmZilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWZlcmVuY2UgPSBvdXRwdXQgKyBmcm9tQ2hhckNvZGUocmVmZXJlbmNlQ29kZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIC8vIEZpcnN0IGVhdCB0aGUgcXVldWVkIGNoYXJhY3RlcnMgYXMgbm9ybWFsIHRleHQsIHRoZW4gZWF0IGEgcmVmZXJlbmNlLlxuICAgICAgaWYgKHJlZmVyZW5jZSkge1xuICAgICAgICBmbHVzaCgpXG5cbiAgICAgICAgcHJldmlvdXMgPSBub3coKVxuICAgICAgICBpbmRleCA9IGVuZCAtIDFcbiAgICAgICAgY29sdW1uICs9IGVuZCAtIHN0YXJ0ICsgMVxuICAgICAgICByZXN1bHQucHVzaChyZWZlcmVuY2UpXG4gICAgICAgIGNvbnN0IG5leHQgPSBub3coKVxuICAgICAgICBuZXh0Lm9mZnNldCsrXG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZWZlcmVuY2UuY2FsbChcbiAgICAgICAgICAgIG9wdGlvbnMucmVmZXJlbmNlQ29udGV4dCxcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIHtzdGFydDogcHJldmlvdXMsIGVuZDogbmV4dH0sXG4gICAgICAgICAgICB2YWx1ZS5zbGljZShzdGFydCAtIDEsIGVuZClcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cyA9IG5leHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcmVmZXJlbmNlLCBxdWV1ZSB0aGUgY2hlY2tlZCBjaGFyYWN0ZXJzIChhc1xuICAgICAgICAvLyBub3JtYWwgY2hhcmFjdGVycyksIGFuZCBtb3ZlIHRoZSBwb2ludGVyIHRvIHRoZWlyIGVuZC5cbiAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIHdlIGNhbiBiZSBjZXJ0YWluIG5laXRoZXIgbmV3bGluZXMgbm9yXG4gICAgICAgIC8vIGFtcGVyc2FuZHMgYXJlIGluY2x1ZGVkLlxuICAgICAgICBjaGFyYWN0ZXJzID0gdmFsdWUuc2xpY2Uoc3RhcnQgLSAxLCBlbmQpXG4gICAgICAgIHF1ZXVlICs9IGNoYXJhY3RlcnNcbiAgICAgICAgY29sdW1uICs9IGNoYXJhY3RlcnMubGVuZ3RoXG4gICAgICAgIGluZGV4ID0gZW5kIC0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgYW55dGhpbmcgb3RoZXIgdGhhbiBhbiBhbXBlcnNhbmQsIGluY2x1ZGluZyBuZXdsaW5lcyBhbmQgRU9GLlxuICAgICAgaWYgKGNoYXJhY3RlciA9PT0gMTAgLyogYFxcbmAgKi8pIHtcbiAgICAgICAgbGluZSsrXG4gICAgICAgIGxpbmVzKytcbiAgICAgICAgY29sdW1uID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGNoYXJhY3RlcikpIHtcbiAgICAgICAgZmx1c2goKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUgKz0gZnJvbUNoYXJDb2RlKGNoYXJhY3RlcilcbiAgICAgICAgY29sdW1uKytcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHJlZHVjZWQgbm9kZXMuXG4gIHJldHVybiByZXN1bHQuam9pbignJylcblxuICAvLyBHZXQgY3VycmVudCBwb3NpdGlvbi5cbiAgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uLFxuICAgICAgb2Zmc2V0OiBpbmRleCArICgocG9pbnQgPyBwb2ludC5vZmZzZXQgOiAwKSB8fCAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7MXwyfDN8NHw1fDZ8N30gY29kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuaW5nKGNvZGUsIG9mZnNldCkge1xuICAgIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTxub3c+fSAqL1xuICAgIGxldCBwb3NpdGlvblxuXG4gICAgaWYgKG9wdGlvbnMud2FybmluZykge1xuICAgICAgcG9zaXRpb24gPSBub3coKVxuICAgICAgcG9zaXRpb24uY29sdW1uICs9IG9mZnNldFxuICAgICAgcG9zaXRpb24ub2Zmc2V0ICs9IG9mZnNldFxuXG4gICAgICBvcHRpb25zLndhcm5pbmcuY2FsbChcbiAgICAgICAgb3B0aW9ucy53YXJuaW5nQ29udGV4dCxcbiAgICAgICAgbWVzc2FnZXNbY29kZV0sXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBjb2RlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIGBxdWV1ZWAgKG5vcm1hbCB0ZXh0KS5cbiAgICogTWFjcm8gaW52b2tlZCBiZWZvcmUgZWFjaCByZWZlcmVuY2UgYW5kIGF0IHRoZSBlbmQgb2YgYHZhbHVlYC5cbiAgICogRG9lcyBub3RoaW5nIHdoZW4gYHF1ZXVlYCBpcyBlbXB0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGlmIChxdWV1ZSkge1xuICAgICAgcmVzdWx0LnB1c2gocXVldWUpXG5cbiAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgb3B0aW9ucy50ZXh0LmNhbGwob3B0aW9ucy50ZXh0Q29udGV4dCwgcXVldWUsIHtcbiAgICAgICAgICBzdGFydDogcHJldmlvdXMsXG4gICAgICAgICAgZW5kOiBub3coKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9ICcnXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYGNoYXJhY3RlcmAgaXMgb3V0c2lkZSB0aGUgcGVybWlzc2libGUgdW5pY29kZSByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHByb2hpYml0ZWQoY29kZSkge1xuICByZXR1cm4gKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkZmZmKSB8fCBjb2RlID4gMHgxMGZmZmZcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgY2hhcmFjdGVyYCBpcyBkaXNhbGxvd2VkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGlzYWxsb3dlZChjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMHgwMDAxICYmIGNvZGUgPD0gMHgwMDA4KSB8fFxuICAgIGNvZGUgPT09IDB4MDAwYiB8fFxuICAgIChjb2RlID49IDB4MDAwZCAmJiBjb2RlIDw9IDB4MDAxZikgfHxcbiAgICAoY29kZSA+PSAweDAwN2YgJiYgY29kZSA8PSAweDAwOWYpIHx8XG4gICAgKGNvZGUgPj0gMHhmZGQwICYmIGNvZGUgPD0gMHhmZGVmKSB8fFxuICAgIChjb2RlICYgMHhmZmZmKSA9PT0gMHhmZmZmIHx8XG4gICAgKGNvZGUgJiAweGZmZmYpID09PSAweGZmZmVcbiAgKVxufVxuIl0sIm5hbWVzIjpbImNoYXJhY3RlckVudGl0aWVzTGVnYWN5IiwiY2hhcmFjdGVyUmVmZXJlbmNlSW52YWxpZCIsImlzRGVjaW1hbCIsImlzSGV4YWRlY2ltYWwiLCJpc0FscGhhbnVtZXJpY2FsIiwiZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UiLCJmcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJtZXNzYWdlcyIsInBhcnNlRW50aXRpZXMiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJhZGRpdGlvbmFsIiwiY2hhckNvZGVBdCIsInJlc3VsdCIsImluZGV4IiwibGluZXMiLCJxdWV1ZSIsInBvaW50IiwiaW5kZW50IiwicG9zaXRpb24iLCJzdGFydCIsImxpbmUiLCJjb2x1bW4iLCJwcmV2aW91cyIsIm5vdyIsImNoYXJhY3RlciIsImxlbmd0aCIsImZvbGxvd2luZyIsIk51bWJlciIsImlzTmFOIiwiYmVnaW4iLCJlbmQiLCJ0eXBlIiwiY2hhcmFjdGVyUmVmZXJlbmNlQ2hhcmFjdGVycyIsImNoYXJhY3RlclJlZmVyZW5jZSIsImNoYXJhY3RlcnMiLCJ0ZXN0IiwiaW5jbHVkZXMiLCJ0ZXJtaW5hdGVkIiwibmFtZWRSZWZlcmVuY2UiLCJkaWZmIiwicmVmZXJlbmNlIiwibm9uVGVybWluYXRlZCIsIndhcm5pbmciLCJyZWFzb24iLCJhdHRyaWJ1dGUiLCJyZWZlcmVuY2VDb2RlIiwicGFyc2VJbnQiLCJwcm9oaWJpdGVkIiwib3V0cHV0IiwiZGlzYWxsb3dlZCIsImZsdXNoIiwicHVzaCIsIm5leHQiLCJvZmZzZXQiLCJjYWxsIiwicmVmZXJlbmNlQ29udGV4dCIsInNsaWNlIiwiam9pbiIsImNvZGUiLCJ3YXJuaW5nQ29udGV4dCIsInRleHQiLCJ0ZXh0Q29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parse-entities/lib/index.js\n");

/***/ })

};
;