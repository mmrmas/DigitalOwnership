"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/astring";
exports.ids = ["vendor-chunks/astring"];
exports.modules = {

/***/ "(ssr)/./node_modules/astring/dist/astring.mjs":
/*!***********************************************!*\
  !*** ./node_modules/astring/dist/astring.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\nconst { stringify } = JSON;\n/* c8 ignore if */ if (!String.prototype.repeat) {\n    /* c8 ignore next */ throw new Error(\"String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation\");\n}\n/* c8 ignore if */ if (!String.prototype.endsWith) {\n    /* c8 ignore next */ throw new Error(\"String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation\");\n}\nconst OPERATOR_PRECEDENCE = {\n    \"||\": 2,\n    \"??\": 3,\n    \"&&\": 4,\n    \"|\": 5,\n    \"^\": 6,\n    \"&\": 7,\n    \"==\": 8,\n    \"!=\": 8,\n    \"===\": 8,\n    \"!==\": 8,\n    \"<\": 9,\n    \">\": 9,\n    \"<=\": 9,\n    \">=\": 9,\n    in: 9,\n    instanceof: 9,\n    \"<<\": 10,\n    \">>\": 10,\n    \">>>\": 10,\n    \"+\": 11,\n    \"-\": 11,\n    \"*\": 12,\n    \"%\": 12,\n    \"/\": 12,\n    \"**\": 13\n};\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17;\nconst EXPRESSIONS_PRECEDENCE = {\n    // Definitions\n    ArrayExpression: 20,\n    TaggedTemplateExpression: 20,\n    ThisExpression: 20,\n    Identifier: 20,\n    PrivateIdentifier: 20,\n    Literal: 18,\n    TemplateLiteral: 20,\n    Super: 20,\n    SequenceExpression: 20,\n    // Operations\n    MemberExpression: 19,\n    ChainExpression: 19,\n    CallExpression: 19,\n    NewExpression: 19,\n    // Other definitions\n    ArrowFunctionExpression: NEEDS_PARENTHESES,\n    ClassExpression: NEEDS_PARENTHESES,\n    FunctionExpression: NEEDS_PARENTHESES,\n    ObjectExpression: NEEDS_PARENTHESES,\n    // Other operations\n    UpdateExpression: 16,\n    UnaryExpression: 15,\n    AwaitExpression: 15,\n    BinaryExpression: 14,\n    LogicalExpression: 13,\n    ConditionalExpression: 4,\n    AssignmentExpression: 3,\n    YieldExpression: 2,\n    RestElement: 1\n};\nfunction formatSequence(state, nodes) {\n    /*\n  Writes into `state` a sequence of `nodes`.\n  */ const { generator } = state;\n    state.write(\"(\");\n    if (nodes != null && nodes.length > 0) {\n        generator[nodes[0].type](nodes[0], state);\n        const { length } = nodes;\n        for(let i = 1; i < length; i++){\n            const param = nodes[i];\n            state.write(\", \");\n            generator[param.type](param, state);\n        }\n    }\n    state.write(\")\");\n}\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n    const nodePrecedence = state.expressionsPrecedence[node.type];\n    if (nodePrecedence === NEEDS_PARENTHESES) {\n        return true;\n    }\n    const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];\n    if (nodePrecedence !== parentNodePrecedence) {\n        // Different node types\n        return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === \"**\" || nodePrecedence < parentNodePrecedence;\n    }\n    if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n        // Not a `LogicalExpression` or `BinaryExpression`\n        return false;\n    }\n    if (node.operator === \"**\" && parentNode.operator === \"**\") {\n        // Exponentiation operator has right-to-left associativity\n        return !isRightHand;\n    }\n    if (nodePrecedence === 13 && parentNodePrecedence === 13 && (node.operator === \"??\" || parentNode.operator === \"??\")) {\n        // Nullish coalescing and boolean operators cannot be combined\n        return true;\n    }\n    if (isRightHand) {\n        // Parenthesis are used if both operators have the same precedence\n        return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];\n    }\n    return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];\n}\nfunction formatExpression(state, node, parentNode, isRightHand) {\n    /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */ const { generator } = state;\n    if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n        state.write(\"(\");\n        generator[node.type](node, state);\n        state.write(\")\");\n    } else {\n        generator[node.type](node, state);\n    }\n}\nfunction reindent(state, text, indent, lineEnd) {\n    /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */ const lines = text.split(\"\\n\");\n    const end = lines.length - 1;\n    state.write(lines[0].trim());\n    if (end > 0) {\n        state.write(lineEnd);\n        for(let i = 1; i < end; i++){\n            state.write(indent + lines[i].trim() + lineEnd);\n        }\n        state.write(indent + lines[end].trim());\n    }\n}\nfunction formatComments(state, comments, indent, lineEnd) {\n    /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */ const { length } = comments;\n    for(let i = 0; i < length; i++){\n        const comment = comments[i];\n        state.write(indent);\n        if (comment.type[0] === \"L\") {\n            // Line comment\n            state.write(\"// \" + comment.value.trim() + \"\\n\", comment);\n        } else {\n            // Block comment\n            state.write(\"/*\");\n            reindent(state, comment.value, indent, lineEnd);\n            state.write(\"*/\" + lineEnd);\n        }\n    }\n}\nfunction hasCallExpression(node) {\n    /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */ let currentNode = node;\n    while(currentNode != null){\n        const { type } = currentNode;\n        if (type[0] === \"C\" && type[1] === \"a\") {\n            // Is CallExpression\n            return true;\n        } else if (type[0] === \"M\" && type[1] === \"e\" && type[2] === \"m\") {\n            // Is MemberExpression\n            currentNode = currentNode.object;\n        } else {\n            return false;\n        }\n    }\n}\nfunction formatVariableDeclaration(state, node) {\n    /*\n  Writes into `state` a variable declaration.\n  */ const { generator } = state;\n    const { declarations } = node;\n    state.write(node.kind + \" \");\n    const { length } = declarations;\n    if (length > 0) {\n        generator.VariableDeclarator(declarations[0], state);\n        for(let i = 1; i < length; i++){\n            state.write(\", \");\n            generator.VariableDeclarator(declarations[i], state);\n        }\n    }\n}\nlet ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement;\nconst GENERATOR = {\n    /*\n  Default generator.\n  */ Program (node, state) {\n        const indent = state.indent.repeat(state.indentLevel);\n        const { lineEnd, writeComments } = state;\n        if (writeComments && node.comments != null) {\n            formatComments(state, node.comments, indent, lineEnd);\n        }\n        const statements = node.body;\n        const { length } = statements;\n        for(let i = 0; i < length; i++){\n            const statement = statements[i];\n            if (writeComments && statement.comments != null) {\n                formatComments(state, statement.comments, indent, lineEnd);\n            }\n            state.write(indent);\n            this[statement.type](statement, state);\n            state.write(lineEnd);\n        }\n        if (writeComments && node.trailingComments != null) {\n            formatComments(state, node.trailingComments, indent, lineEnd);\n        }\n    },\n    BlockStatement: BlockStatement = function(node, state) {\n        const indent = state.indent.repeat(state.indentLevel++);\n        const { lineEnd, writeComments } = state;\n        const statementIndent = indent + state.indent;\n        state.write(\"{\");\n        const statements = node.body;\n        if (statements != null && statements.length > 0) {\n            state.write(lineEnd);\n            if (writeComments && node.comments != null) {\n                formatComments(state, node.comments, statementIndent, lineEnd);\n            }\n            const { length } = statements;\n            for(let i = 0; i < length; i++){\n                const statement = statements[i];\n                if (writeComments && statement.comments != null) {\n                    formatComments(state, statement.comments, statementIndent, lineEnd);\n                }\n                state.write(statementIndent);\n                this[statement.type](statement, state);\n                state.write(lineEnd);\n            }\n            state.write(indent);\n        } else {\n            if (writeComments && node.comments != null) {\n                state.write(lineEnd);\n                formatComments(state, node.comments, statementIndent, lineEnd);\n                state.write(indent);\n            }\n        }\n        if (writeComments && node.trailingComments != null) {\n            formatComments(state, node.trailingComments, statementIndent, lineEnd);\n        }\n        state.write(\"}\");\n        state.indentLevel--;\n    },\n    ClassBody: BlockStatement,\n    StaticBlock (node, state) {\n        state.write(\"static \");\n        this.BlockStatement(node, state);\n    },\n    EmptyStatement (node, state) {\n        state.write(\";\");\n    },\n    ExpressionStatement (node, state) {\n        const precedence = state.expressionsPrecedence[node.expression.type];\n        if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === \"O\") {\n            // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n            state.write(\"(\");\n            this[node.expression.type](node.expression, state);\n            state.write(\")\");\n        } else {\n            this[node.expression.type](node.expression, state);\n        }\n        state.write(\";\");\n    },\n    IfStatement (node, state) {\n        state.write(\"if (\");\n        this[node.test.type](node.test, state);\n        state.write(\") \");\n        this[node.consequent.type](node.consequent, state);\n        if (node.alternate != null) {\n            state.write(\" else \");\n            this[node.alternate.type](node.alternate, state);\n        }\n    },\n    LabeledStatement (node, state) {\n        this[node.label.type](node.label, state);\n        state.write(\": \");\n        this[node.body.type](node.body, state);\n    },\n    BreakStatement (node, state) {\n        state.write(\"break\");\n        if (node.label != null) {\n            state.write(\" \");\n            this[node.label.type](node.label, state);\n        }\n        state.write(\";\");\n    },\n    ContinueStatement (node, state) {\n        state.write(\"continue\");\n        if (node.label != null) {\n            state.write(\" \");\n            this[node.label.type](node.label, state);\n        }\n        state.write(\";\");\n    },\n    WithStatement (node, state) {\n        state.write(\"with (\");\n        this[node.object.type](node.object, state);\n        state.write(\") \");\n        this[node.body.type](node.body, state);\n    },\n    SwitchStatement (node, state) {\n        const indent = state.indent.repeat(state.indentLevel++);\n        const { lineEnd, writeComments } = state;\n        state.indentLevel++;\n        const caseIndent = indent + state.indent;\n        const statementIndent = caseIndent + state.indent;\n        state.write(\"switch (\");\n        this[node.discriminant.type](node.discriminant, state);\n        state.write(\") {\" + lineEnd);\n        const { cases: occurences } = node;\n        const { length: occurencesCount } = occurences;\n        for(let i = 0; i < occurencesCount; i++){\n            const occurence = occurences[i];\n            if (writeComments && occurence.comments != null) {\n                formatComments(state, occurence.comments, caseIndent, lineEnd);\n            }\n            if (occurence.test) {\n                state.write(caseIndent + \"case \");\n                this[occurence.test.type](occurence.test, state);\n                state.write(\":\" + lineEnd);\n            } else {\n                state.write(caseIndent + \"default:\" + lineEnd);\n            }\n            const { consequent } = occurence;\n            const { length: consequentCount } = consequent;\n            for(let i = 0; i < consequentCount; i++){\n                const statement = consequent[i];\n                if (writeComments && statement.comments != null) {\n                    formatComments(state, statement.comments, statementIndent, lineEnd);\n                }\n                state.write(statementIndent);\n                this[statement.type](statement, state);\n                state.write(lineEnd);\n            }\n        }\n        state.indentLevel -= 2;\n        state.write(indent + \"}\");\n    },\n    ReturnStatement (node, state) {\n        state.write(\"return\");\n        if (node.argument) {\n            state.write(\" \");\n            this[node.argument.type](node.argument, state);\n        }\n        state.write(\";\");\n    },\n    ThrowStatement (node, state) {\n        state.write(\"throw \");\n        this[node.argument.type](node.argument, state);\n        state.write(\";\");\n    },\n    TryStatement (node, state) {\n        state.write(\"try \");\n        this[node.block.type](node.block, state);\n        if (node.handler) {\n            const { handler } = node;\n            if (handler.param == null) {\n                state.write(\" catch \");\n            } else {\n                state.write(\" catch (\");\n                this[handler.param.type](handler.param, state);\n                state.write(\") \");\n            }\n            this[handler.body.type](handler.body, state);\n        }\n        if (node.finalizer) {\n            state.write(\" finally \");\n            this[node.finalizer.type](node.finalizer, state);\n        }\n    },\n    WhileStatement (node, state) {\n        state.write(\"while (\");\n        this[node.test.type](node.test, state);\n        state.write(\") \");\n        this[node.body.type](node.body, state);\n    },\n    DoWhileStatement (node, state) {\n        state.write(\"do \");\n        this[node.body.type](node.body, state);\n        state.write(\" while (\");\n        this[node.test.type](node.test, state);\n        state.write(\");\");\n    },\n    ForStatement (node, state) {\n        state.write(\"for (\");\n        if (node.init != null) {\n            const { init } = node;\n            if (init.type[0] === \"V\") {\n                formatVariableDeclaration(state, init);\n            } else {\n                this[init.type](init, state);\n            }\n        }\n        state.write(\"; \");\n        if (node.test) {\n            this[node.test.type](node.test, state);\n        }\n        state.write(\"; \");\n        if (node.update) {\n            this[node.update.type](node.update, state);\n        }\n        state.write(\") \");\n        this[node.body.type](node.body, state);\n    },\n    ForInStatement: ForInStatement = function(node, state) {\n        state.write(`for ${node.await ? \"await \" : \"\"}(`);\n        const { left } = node;\n        if (left.type[0] === \"V\") {\n            formatVariableDeclaration(state, left);\n        } else {\n            this[left.type](left, state);\n        }\n        // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n        state.write(node.type[3] === \"I\" ? \" in \" : \" of \");\n        this[node.right.type](node.right, state);\n        state.write(\") \");\n        this[node.body.type](node.body, state);\n    },\n    ForOfStatement: ForInStatement,\n    DebuggerStatement (node, state) {\n        state.write(\"debugger;\", node);\n    },\n    FunctionDeclaration: FunctionDeclaration = function(node, state) {\n        state.write((node.async ? \"async \" : \"\") + (node.generator ? \"function* \" : \"function \") + (node.id ? node.id.name : \"\"), node);\n        formatSequence(state, node.params);\n        state.write(\" \");\n        this[node.body.type](node.body, state);\n    },\n    FunctionExpression: FunctionDeclaration,\n    VariableDeclaration (node, state) {\n        formatVariableDeclaration(state, node);\n        state.write(\";\");\n    },\n    VariableDeclarator (node, state) {\n        this[node.id.type](node.id, state);\n        if (node.init != null) {\n            state.write(\" = \");\n            this[node.init.type](node.init, state);\n        }\n    },\n    ClassDeclaration (node, state) {\n        state.write(\"class \" + (node.id ? `${node.id.name} ` : \"\"), node);\n        if (node.superClass) {\n            state.write(\"extends \");\n            const { superClass } = node;\n            const { type } = superClass;\n            const precedence = state.expressionsPrecedence[type];\n            if ((type[0] !== \"C\" || type[1] !== \"l\" || type[5] !== \"E\") && (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.ClassExpression)) {\n                // Not a ClassExpression that needs parentheses\n                state.write(\"(\");\n                this[node.superClass.type](superClass, state);\n                state.write(\")\");\n            } else {\n                this[superClass.type](superClass, state);\n            }\n            state.write(\" \");\n        }\n        this.ClassBody(node.body, state);\n    },\n    ImportDeclaration (node, state) {\n        state.write(\"import \");\n        const { specifiers, attributes } = node;\n        const { length } = specifiers;\n        // TODO: Once babili is fixed, put this after condition\n        // https://github.com/babel/babili/issues/430\n        let i = 0;\n        if (length > 0) {\n            for(; i < length;){\n                if (i > 0) {\n                    state.write(\", \");\n                }\n                const specifier = specifiers[i];\n                const type = specifier.type[6];\n                if (type === \"D\") {\n                    // ImportDefaultSpecifier\n                    state.write(specifier.local.name, specifier);\n                    i++;\n                } else if (type === \"N\") {\n                    // ImportNamespaceSpecifier\n                    state.write(\"* as \" + specifier.local.name, specifier);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            if (i < length) {\n                state.write(\"{\");\n                for(;;){\n                    const specifier = specifiers[i];\n                    const { name } = specifier.imported;\n                    state.write(name, specifier);\n                    if (name !== specifier.local.name) {\n                        state.write(\" as \" + specifier.local.name);\n                    }\n                    if (++i < length) {\n                        state.write(\", \");\n                    } else {\n                        break;\n                    }\n                }\n                state.write(\"}\");\n            }\n            state.write(\" from \");\n        }\n        this.Literal(node.source, state);\n        if (attributes && attributes.length > 0) {\n            state.write(\" with { \");\n            for(let i = 0; i < attributes.length; i++){\n                this.ImportAttribute(attributes[i], state);\n                if (i < attributes.length - 1) state.write(\", \");\n            }\n            state.write(\" }\");\n        }\n        state.write(\";\");\n    },\n    ImportAttribute (node, state) {\n        this.Identifier(node.key, state);\n        state.write(\": \");\n        this.Literal(node.value, state);\n    },\n    ImportExpression (node, state) {\n        state.write(\"import(\");\n        this[node.source.type](node.source, state);\n        state.write(\")\");\n    },\n    ExportDefaultDeclaration (node, state) {\n        state.write(\"export default \");\n        this[node.declaration.type](node.declaration, state);\n        if (state.expressionsPrecedence[node.declaration.type] != null && node.declaration.type[0] !== \"F\") {\n            // All expression nodes except `FunctionExpression`\n            state.write(\";\");\n        }\n    },\n    ExportNamedDeclaration (node, state) {\n        state.write(\"export \");\n        if (node.declaration) {\n            this[node.declaration.type](node.declaration, state);\n        } else {\n            state.write(\"{\");\n            const { specifiers } = node, { length } = specifiers;\n            if (length > 0) {\n                for(let i = 0;;){\n                    const specifier = specifiers[i];\n                    const { name } = specifier.local;\n                    state.write(name, specifier);\n                    if (name !== specifier.exported.name) {\n                        state.write(\" as \" + specifier.exported.name);\n                    }\n                    if (++i < length) {\n                        state.write(\", \");\n                    } else {\n                        break;\n                    }\n                }\n            }\n            state.write(\"}\");\n            if (node.source) {\n                state.write(\" from \");\n                this.Literal(node.source, state);\n            }\n            if (node.attributes && node.attributes.length > 0) {\n                state.write(\" with { \");\n                for(let i = 0; i < node.attributes.length; i++){\n                    this.ImportAttribute(node.attributes[i], state);\n                    if (i < node.attributes.length - 1) state.write(\", \");\n                }\n                state.write(\" }\");\n            }\n            state.write(\";\");\n        }\n    },\n    ExportAllDeclaration (node, state) {\n        if (node.exported != null) {\n            state.write(\"export * as \" + node.exported.name + \" from \");\n        } else {\n            state.write(\"export * from \");\n        }\n        this.Literal(node.source, state);\n        if (node.attributes && node.attributes.length > 0) {\n            state.write(\" with { \");\n            for(let i = 0; i < node.attributes.length; i++){\n                this.ImportAttribute(node.attributes[i], state);\n                if (i < node.attributes.length - 1) state.write(\", \");\n            }\n            state.write(\" }\");\n        }\n        state.write(\";\");\n    },\n    MethodDefinition (node, state) {\n        if (node.static) {\n            state.write(\"static \");\n        }\n        const kind = node.kind[0];\n        if (kind === \"g\" || kind === \"s\") {\n            // Getter or setter\n            state.write(node.kind + \" \");\n        }\n        if (node.value.async) {\n            state.write(\"async \");\n        }\n        if (node.value.generator) {\n            state.write(\"*\");\n        }\n        if (node.computed) {\n            state.write(\"[\");\n            this[node.key.type](node.key, state);\n            state.write(\"]\");\n        } else {\n            this[node.key.type](node.key, state);\n        }\n        formatSequence(state, node.value.params);\n        state.write(\" \");\n        this[node.value.body.type](node.value.body, state);\n    },\n    ClassExpression (node, state) {\n        this.ClassDeclaration(node, state);\n    },\n    ArrowFunctionExpression (node, state) {\n        state.write(node.async ? \"async \" : \"\", node);\n        const { params } = node;\n        if (params != null) {\n            // Omit parenthesis if only one named parameter\n            if (params.length === 1 && params[0].type[0] === \"I\") {\n                // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n                state.write(params[0].name, params[0]);\n            } else {\n                formatSequence(state, node.params);\n            }\n        }\n        state.write(\" => \");\n        if (node.body.type[0] === \"O\") {\n            // Body is an object expression\n            state.write(\"(\");\n            this.ObjectExpression(node.body, state);\n            state.write(\")\");\n        } else {\n            this[node.body.type](node.body, state);\n        }\n    },\n    ThisExpression (node, state) {\n        state.write(\"this\", node);\n    },\n    Super (node, state) {\n        state.write(\"super\", node);\n    },\n    RestElement: RestElement = function(node, state) {\n        state.write(\"...\");\n        this[node.argument.type](node.argument, state);\n    },\n    SpreadElement: RestElement,\n    YieldExpression (node, state) {\n        state.write(node.delegate ? \"yield*\" : \"yield\");\n        if (node.argument) {\n            state.write(\" \");\n            this[node.argument.type](node.argument, state);\n        }\n    },\n    AwaitExpression (node, state) {\n        state.write(\"await \", node);\n        formatExpression(state, node.argument, node);\n    },\n    TemplateLiteral (node, state) {\n        const { quasis, expressions } = node;\n        state.write(\"`\");\n        const { length } = expressions;\n        for(let i = 0; i < length; i++){\n            const expression = expressions[i];\n            const quasi = quasis[i];\n            state.write(quasi.value.raw, quasi);\n            state.write(\"${\");\n            this[expression.type](expression, state);\n            state.write(\"}\");\n        }\n        const quasi = quasis[quasis.length - 1];\n        state.write(quasi.value.raw, quasi);\n        state.write(\"`\");\n    },\n    TemplateElement (node, state) {\n        state.write(node.value.raw, node);\n    },\n    TaggedTemplateExpression (node, state) {\n        formatExpression(state, node.tag, node);\n        this[node.quasi.type](node.quasi, state);\n    },\n    ArrayExpression: ArrayExpression = function(node, state) {\n        state.write(\"[\");\n        if (node.elements.length > 0) {\n            const { elements } = node, { length } = elements;\n            for(let i = 0;;){\n                const element = elements[i];\n                if (element != null) {\n                    this[element.type](element, state);\n                }\n                if (++i < length) {\n                    state.write(\", \");\n                } else {\n                    if (element == null) {\n                        state.write(\", \");\n                    }\n                    break;\n                }\n            }\n        }\n        state.write(\"]\");\n    },\n    ArrayPattern: ArrayExpression,\n    ObjectExpression (node, state) {\n        const indent = state.indent.repeat(state.indentLevel++);\n        const { lineEnd, writeComments } = state;\n        const propertyIndent = indent + state.indent;\n        state.write(\"{\");\n        if (node.properties.length > 0) {\n            state.write(lineEnd);\n            if (writeComments && node.comments != null) {\n                formatComments(state, node.comments, propertyIndent, lineEnd);\n            }\n            const comma = \",\" + lineEnd;\n            const { properties } = node, { length } = properties;\n            for(let i = 0;;){\n                const property = properties[i];\n                if (writeComments && property.comments != null) {\n                    formatComments(state, property.comments, propertyIndent, lineEnd);\n                }\n                state.write(propertyIndent);\n                this[property.type](property, state);\n                if (++i < length) {\n                    state.write(comma);\n                } else {\n                    break;\n                }\n            }\n            state.write(lineEnd);\n            if (writeComments && node.trailingComments != null) {\n                formatComments(state, node.trailingComments, propertyIndent, lineEnd);\n            }\n            state.write(indent + \"}\");\n        } else if (writeComments) {\n            if (node.comments != null) {\n                state.write(lineEnd);\n                formatComments(state, node.comments, propertyIndent, lineEnd);\n                if (node.trailingComments != null) {\n                    formatComments(state, node.trailingComments, propertyIndent, lineEnd);\n                }\n                state.write(indent + \"}\");\n            } else if (node.trailingComments != null) {\n                state.write(lineEnd);\n                formatComments(state, node.trailingComments, propertyIndent, lineEnd);\n                state.write(indent + \"}\");\n            } else {\n                state.write(\"}\");\n            }\n        } else {\n            state.write(\"}\");\n        }\n        state.indentLevel--;\n    },\n    Property (node, state) {\n        if (node.method || node.kind[0] !== \"i\") {\n            // Either a method or of kind `set` or `get` (not `init`)\n            this.MethodDefinition(node, state);\n        } else {\n            if (!node.shorthand) {\n                if (node.computed) {\n                    state.write(\"[\");\n                    this[node.key.type](node.key, state);\n                    state.write(\"]\");\n                } else {\n                    this[node.key.type](node.key, state);\n                }\n                state.write(\": \");\n            }\n            this[node.value.type](node.value, state);\n        }\n    },\n    PropertyDefinition (node, state) {\n        if (node.static) {\n            state.write(\"static \");\n        }\n        if (node.computed) {\n            state.write(\"[\");\n        }\n        this[node.key.type](node.key, state);\n        if (node.computed) {\n            state.write(\"]\");\n        }\n        if (node.value == null) {\n            if (node.key.type[0] !== \"F\") {\n                state.write(\";\");\n            }\n            return;\n        }\n        state.write(\" = \");\n        this[node.value.type](node.value, state);\n        state.write(\";\");\n    },\n    ObjectPattern (node, state) {\n        state.write(\"{\");\n        if (node.properties.length > 0) {\n            const { properties } = node, { length } = properties;\n            for(let i = 0;;){\n                this[properties[i].type](properties[i], state);\n                if (++i < length) {\n                    state.write(\", \");\n                } else {\n                    break;\n                }\n            }\n        }\n        state.write(\"}\");\n    },\n    SequenceExpression (node, state) {\n        formatSequence(state, node.expressions);\n    },\n    UnaryExpression (node, state) {\n        if (node.prefix) {\n            const { operator, argument, argument: { type } } = node;\n            state.write(operator);\n            const needsParentheses = expressionNeedsParenthesis(state, argument, node);\n            if (!needsParentheses && (operator.length > 1 || type[0] === \"U\" && (type[1] === \"n\" || type[1] === \"p\") && argument.prefix && argument.operator[0] === operator && (operator === \"+\" || operator === \"-\"))) {\n                // Large operator or argument is UnaryExpression or UpdateExpression node\n                state.write(\" \");\n            }\n            if (needsParentheses) {\n                state.write(operator.length > 1 ? \" (\" : \"(\");\n                this[type](argument, state);\n                state.write(\")\");\n            } else {\n                this[type](argument, state);\n            }\n        } else {\n            // FIXME: This case never occurs\n            this[node.argument.type](node.argument, state);\n            state.write(node.operator);\n        }\n    },\n    UpdateExpression (node, state) {\n        // Always applied to identifiers or members, no parenthesis check needed\n        if (node.prefix) {\n            state.write(node.operator);\n            this[node.argument.type](node.argument, state);\n        } else {\n            this[node.argument.type](node.argument, state);\n            state.write(node.operator);\n        }\n    },\n    AssignmentExpression (node, state) {\n        this[node.left.type](node.left, state);\n        state.write(\" \" + node.operator + \" \");\n        this[node.right.type](node.right, state);\n    },\n    AssignmentPattern (node, state) {\n        this[node.left.type](node.left, state);\n        state.write(\" = \");\n        this[node.right.type](node.right, state);\n    },\n    BinaryExpression: BinaryExpression = function(node, state) {\n        const isIn = node.operator === \"in\";\n        if (isIn) {\n            // Avoids confusion in `for` loops initializers\n            state.write(\"(\");\n        }\n        formatExpression(state, node.left, node, false);\n        state.write(\" \" + node.operator + \" \");\n        formatExpression(state, node.right, node, true);\n        if (isIn) {\n            state.write(\")\");\n        }\n    },\n    LogicalExpression: BinaryExpression,\n    ConditionalExpression (node, state) {\n        const { test } = node;\n        const precedence = state.expressionsPrecedence[test.type];\n        if (precedence === NEEDS_PARENTHESES || precedence <= state.expressionsPrecedence.ConditionalExpression) {\n            state.write(\"(\");\n            this[test.type](test, state);\n            state.write(\")\");\n        } else {\n            this[test.type](test, state);\n        }\n        state.write(\" ? \");\n        this[node.consequent.type](node.consequent, state);\n        state.write(\" : \");\n        this[node.alternate.type](node.alternate, state);\n    },\n    NewExpression (node, state) {\n        state.write(\"new \");\n        const precedence = state.expressionsPrecedence[node.callee.type];\n        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {\n            state.write(\"(\");\n            this[node.callee.type](node.callee, state);\n            state.write(\")\");\n        } else {\n            this[node.callee.type](node.callee, state);\n        }\n        formatSequence(state, node[\"arguments\"]);\n    },\n    CallExpression (node, state) {\n        const precedence = state.expressionsPrecedence[node.callee.type];\n        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression) {\n            state.write(\"(\");\n            this[node.callee.type](node.callee, state);\n            state.write(\")\");\n        } else {\n            this[node.callee.type](node.callee, state);\n        }\n        if (node.optional) {\n            state.write(\"?.\");\n        }\n        formatSequence(state, node[\"arguments\"]);\n    },\n    ChainExpression (node, state) {\n        this[node.expression.type](node.expression, state);\n    },\n    MemberExpression (node, state) {\n        const precedence = state.expressionsPrecedence[node.object.type];\n        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.MemberExpression) {\n            state.write(\"(\");\n            this[node.object.type](node.object, state);\n            state.write(\")\");\n        } else {\n            this[node.object.type](node.object, state);\n        }\n        if (node.computed) {\n            if (node.optional) {\n                state.write(\"?.\");\n            }\n            state.write(\"[\");\n            this[node.property.type](node.property, state);\n            state.write(\"]\");\n        } else {\n            if (node.optional) {\n                state.write(\"?.\");\n            } else {\n                state.write(\".\");\n            }\n            this[node.property.type](node.property, state);\n        }\n    },\n    MetaProperty (node, state) {\n        state.write(node.meta.name + \".\" + node.property.name, node);\n    },\n    Identifier (node, state) {\n        state.write(node.name, node);\n    },\n    PrivateIdentifier (node, state) {\n        state.write(`#${node.name}`, node);\n    },\n    Literal (node, state) {\n        if (node.raw != null) {\n            // Non-standard property\n            state.write(node.raw, node);\n        } else if (node.regex != null) {\n            this.RegExpLiteral(node, state);\n        } else if (node.bigint != null) {\n            state.write(node.bigint + \"n\", node);\n        } else {\n            state.write(stringify(node.value), node);\n        }\n    },\n    RegExpLiteral (node, state) {\n        const { regex } = node;\n        state.write(`/${regex.pattern}/${regex.flags}`, node);\n    }\n};\nconst EMPTY_OBJECT = {};\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/ const baseGenerator = GENERATOR;\nclass State {\n    constructor(options){\n        const setup = options == null ? EMPTY_OBJECT : options;\n        this.output = \"\";\n        // Functional options\n        if (setup.output != null) {\n            this.output = setup.output;\n            this.write = this.writeToStream;\n        } else {\n            this.output = \"\";\n        }\n        this.generator = setup.generator != null ? setup.generator : GENERATOR;\n        this.expressionsPrecedence = setup.expressionsPrecedence != null ? setup.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;\n        // Formating setup\n        this.indent = setup.indent != null ? setup.indent : \"  \";\n        this.lineEnd = setup.lineEnd != null ? setup.lineEnd : \"\\n\";\n        this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;\n        this.writeComments = setup.comments ? setup.comments : false;\n        // Source map\n        if (setup.sourceMap != null) {\n            this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;\n            this.sourceMap = setup.sourceMap;\n            this.line = 1;\n            this.column = 0;\n            this.lineEndSize = this.lineEnd.split(\"\\n\").length - 1;\n            this.mapping = {\n                original: null,\n                // Uses the entire state to avoid generating ephemeral objects\n                generated: this,\n                name: undefined,\n                source: setup.sourceMap.file || setup.sourceMap._file\n            };\n        }\n    }\n    write(code) {\n        this.output += code;\n    }\n    writeToStream(code) {\n        this.output.write(code);\n    }\n    writeAndMap(code, node) {\n        this.output += code;\n        this.map(code, node);\n    }\n    writeToStreamAndMap(code, node) {\n        this.output.write(code);\n        this.map(code, node);\n    }\n    map(code, node) {\n        if (node != null) {\n            const { type } = node;\n            if (type[0] === \"L\" && type[2] === \"n\") {\n                // LineComment\n                this.column = 0;\n                this.line++;\n                return;\n            }\n            if (node.loc != null) {\n                const { mapping } = this;\n                mapping.original = node.loc.start;\n                mapping.name = node.name;\n                this.sourceMap.addMapping(mapping);\n            }\n            if (type[0] === \"T\" && type[8] === \"E\" || type[0] === \"L\" && type[1] === \"i\" && typeof node.value === \"string\") {\n                // TemplateElement or Literal string node\n                const { length } = code;\n                let { column, line } = this;\n                for(let i = 0; i < length; i++){\n                    if (code[i] === \"\\n\") {\n                        column = 0;\n                        line++;\n                    } else {\n                        column++;\n                    }\n                }\n                this.column = column;\n                this.line = line;\n                return;\n            }\n        }\n        const { length } = code;\n        const { lineEnd } = this;\n        if (length > 0) {\n            if (this.lineEndSize > 0 && (lineEnd.length === 1 ? code[length - 1] === lineEnd : code.endsWith(lineEnd))) {\n                this.line += this.lineEndSize;\n                this.column = 0;\n            } else {\n                this.column += length;\n            }\n        }\n    }\n    toString() {\n        return this.output;\n    }\n}\nfunction generate(node, options) {\n    /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */ const state = new State(options);\n    // Travel through the AST node and generate the code\n    state.generator[node.type](node, state);\n    return state.output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXN0cmluZy9kaXN0L2FzdHJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEscUZBQXFGO0FBQ3JGLEVBQUU7QUFDRix5RUFBeUU7QUFDekUsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLHNEQUFzRDtBQUN0RCxnREFBZ0Q7QUFFaEQsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0M7QUFFdEIsZ0JBQWdCLEdBQ2hCLElBQUksQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDQyxNQUFNLEVBQUU7SUFDNUIsa0JBQWtCLEdBQ2xCLE1BQU0sSUFBSUMsTUFDUjtBQUVKO0FBRUEsZ0JBQWdCLEdBQ2hCLElBQUksQ0FBQ0gsT0FBT0MsU0FBUyxDQUFDRyxRQUFRLEVBQUU7SUFDOUIsa0JBQWtCLEdBQ2xCLE1BQU0sSUFBSUQsTUFDUjtBQUVKO0FBRUEsTUFBTUUsc0JBQXNCO0lBQzFCLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLE1BQU07SUFDTixNQUFNO0lBQ04sT0FBTztJQUNQLE9BQU87SUFDUCxLQUFLO0lBQ0wsS0FBSztJQUNMLE1BQU07SUFDTixNQUFNO0lBQ05DLElBQUk7SUFDSkMsWUFBWTtJQUNaLE1BQU07SUFDTixNQUFNO0lBQ04sT0FBTztJQUNQLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsTUFBTTtBQUNSO0FBRUEsK0NBQStDO0FBQ3hDLE1BQU1DLG9CQUFvQixHQUFFO0FBRTVCLE1BQU1DLHlCQUF5QjtJQUNwQyxjQUFjO0lBQ2RDLGlCQUFpQjtJQUNqQkMsMEJBQTBCO0lBQzFCQyxnQkFBZ0I7SUFDaEJDLFlBQVk7SUFDWkMsbUJBQW1CO0lBQ25CQyxTQUFTO0lBQ1RDLGlCQUFpQjtJQUNqQkMsT0FBTztJQUNQQyxvQkFBb0I7SUFDcEIsYUFBYTtJQUNiQyxrQkFB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bmcubWpzP2IzMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXN0cmluZyBpcyBhIHRpbnkgYW5kIGZhc3QgSmF2YVNjcmlwdCBjb2RlIGdlbmVyYXRvciBmcm9tIGFuIEVTVHJlZS1jb21wbGlhbnQgQVNULlxuLy9cbi8vIEFzdHJpbmcgd2FzIHdyaXR0ZW4gYnkgRGF2aWQgQm9ubmV0IGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbi8vXG4vLyBUaGUgR2l0IHJlcG9zaXRvcnkgZm9yIEFzdHJpbmcgaXMgYXZhaWxhYmxlIGF0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcuZ2l0XG4vL1xuLy8gUGxlYXNlIHVzZSB0aGUgR2l0SHViIGJ1ZyB0cmFja2VyIHRvIHJlcG9ydCBpc3N1ZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRib25uZXQvYXN0cmluZy9pc3N1ZXNcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IEpTT05cblxuLyogYzggaWdub3JlIGlmICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUucmVwZWF0KSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgaXMgdW5kZWZpbmVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcjaW5zdGFsbGF0aW9uJyxcbiAgKVxufVxuXG4vKiBjOCBpZ25vcmUgaWYgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCkge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggaXMgdW5kZWZpbmVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcjaW5zdGFsbGF0aW9uJyxcbiAgKVxufVxuXG5jb25zdCBPUEVSQVRPUl9QUkVDRURFTkNFID0ge1xuICAnfHwnOiAyLFxuICAnPz8nOiAzLFxuICAnJiYnOiA0LFxuICAnfCc6IDUsXG4gICdeJzogNixcbiAgJyYnOiA3LFxuICAnPT0nOiA4LFxuICAnIT0nOiA4LFxuICAnPT09JzogOCxcbiAgJyE9PSc6IDgsXG4gICc8JzogOSxcbiAgJz4nOiA5LFxuICAnPD0nOiA5LFxuICAnPj0nOiA5LFxuICBpbjogOSxcbiAgaW5zdGFuY2VvZjogOSxcbiAgJzw8JzogMTAsXG4gICc+Pic6IDEwLFxuICAnPj4+JzogMTAsXG4gICcrJzogMTEsXG4gICctJzogMTEsXG4gICcqJzogMTIsXG4gICclJzogMTIsXG4gICcvJzogMTIsXG4gICcqKic6IDEzLFxufVxuXG4vLyBFbmFibGVzIHBhcmVudGhlc2lzIHJlZ2FyZGxlc3Mgb2YgcHJlY2VkZW5jZVxuZXhwb3J0IGNvbnN0IE5FRURTX1BBUkVOVEhFU0VTID0gMTdcblxuZXhwb3J0IGNvbnN0IEVYUFJFU1NJT05TX1BSRUNFREVOQ0UgPSB7XG4gIC8vIERlZmluaXRpb25zXG4gIEFycmF5RXhwcmVzc2lvbjogMjAsXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogMjAsXG4gIFRoaXNFeHByZXNzaW9uOiAyMCxcbiAgSWRlbnRpZmllcjogMjAsXG4gIFByaXZhdGVJZGVudGlmaWVyOiAyMCxcbiAgTGl0ZXJhbDogMTgsXG4gIFRlbXBsYXRlTGl0ZXJhbDogMjAsXG4gIFN1cGVyOiAyMCxcbiAgU2VxdWVuY2VFeHByZXNzaW9uOiAyMCxcbiAgLy8gT3BlcmF0aW9uc1xuICBNZW1iZXJFeHByZXNzaW9uOiAxOSxcbiAgQ2hhaW5FeHByZXNzaW9uOiAxOSxcbiAgQ2FsbEV4cHJlc3Npb246IDE5LFxuICBOZXdFeHByZXNzaW9uOiAxOSxcbiAgLy8gT3RoZXIgZGVmaW5pdGlvbnNcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBDbGFzc0V4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICBPYmplY3RFeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgLy8gT3RoZXIgb3BlcmF0aW9uc1xuICBVcGRhdGVFeHByZXNzaW9uOiAxNixcbiAgVW5hcnlFeHByZXNzaW9uOiAxNSxcbiAgQXdhaXRFeHByZXNzaW9uOiAxNSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogMTQsXG4gIExvZ2ljYWxFeHByZXNzaW9uOiAxMyxcbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiA0LFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogMyxcbiAgWWllbGRFeHByZXNzaW9uOiAyLFxuICBSZXN0RWxlbWVudDogMSxcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGVzKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgYSBzZXF1ZW5jZSBvZiBgbm9kZXNgLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgc3RhdGUud3JpdGUoJygnKVxuICBpZiAobm9kZXMgIT0gbnVsbCAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgZ2VuZXJhdG9yW25vZGVzWzBdLnR5cGVdKG5vZGVzWzBdLCBzdGF0ZSlcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IG5vZGVzW2ldXG4gICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgZ2VuZXJhdG9yW3BhcmFtLnR5cGVdKHBhcmFtLCBzdGF0ZSlcbiAgICB9XG4gIH1cbiAgc3RhdGUud3JpdGUoJyknKVxufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpIHtcbiAgY29uc3Qgbm9kZVByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS50eXBlXVxuICBpZiAobm9kZVByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlUHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtwYXJlbnROb2RlLnR5cGVdXG4gIGlmIChub2RlUHJlY2VkZW5jZSAhPT0gcGFyZW50Tm9kZVByZWNlZGVuY2UpIHtcbiAgICAvLyBEaWZmZXJlbnQgbm9kZSB0eXBlc1xuICAgIHJldHVybiAoXG4gICAgICAoIWlzUmlnaHRIYW5kICYmXG4gICAgICAgIG5vZGVQcmVjZWRlbmNlID09PSAxNSAmJlxuICAgICAgICBwYXJlbnROb2RlUHJlY2VkZW5jZSA9PT0gMTQgJiZcbiAgICAgICAgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJyoqJykgfHxcbiAgICAgIG5vZGVQcmVjZWRlbmNlIDwgcGFyZW50Tm9kZVByZWNlZGVuY2VcbiAgICApXG4gIH1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlICE9PSAxMyAmJiBub2RlUHJlY2VkZW5jZSAhPT0gMTQpIHtcbiAgICAvLyBOb3QgYSBgTG9naWNhbEV4cHJlc3Npb25gIG9yIGBCaW5hcnlFeHByZXNzaW9uYFxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLm9wZXJhdG9yID09PSAnKionICYmIHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICcqKicpIHtcbiAgICAvLyBFeHBvbmVudGlhdGlvbiBvcGVyYXRvciBoYXMgcmlnaHQtdG8tbGVmdCBhc3NvY2lhdGl2aXR5XG4gICAgcmV0dXJuICFpc1JpZ2h0SGFuZFxuICB9XG4gIGlmIChcbiAgICBub2RlUHJlY2VkZW5jZSA9PT0gMTMgJiZcbiAgICBwYXJlbnROb2RlUHJlY2VkZW5jZSA9PT0gMTMgJiZcbiAgICAobm9kZS5vcGVyYXRvciA9PT0gJz8/JyB8fCBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnPz8nKVxuICApIHtcbiAgICAvLyBOdWxsaXNoIGNvYWxlc2NpbmcgYW5kIGJvb2xlYW4gb3BlcmF0b3JzIGNhbm5vdCBiZSBjb21iaW5lZFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmlnaHRIYW5kKSB7XG4gICAgLy8gUGFyZW50aGVzaXMgYXJlIHVzZWQgaWYgYm90aCBvcGVyYXRvcnMgaGF2ZSB0aGUgc2FtZSBwcmVjZWRlbmNlXG4gICAgcmV0dXJuIChcbiAgICAgIE9QRVJBVE9SX1BSRUNFREVOQ0Vbbm9kZS5vcGVyYXRvcl0gPD1cbiAgICAgIE9QRVJBVE9SX1BSRUNFREVOQ0VbcGFyZW50Tm9kZS5vcGVyYXRvcl1cbiAgICApXG4gIH1cbiAgcmV0dXJuIChcbiAgICBPUEVSQVRPUl9QUkVDRURFTkNFW25vZGUub3BlcmF0b3JdIDxcbiAgICBPUEVSQVRPUl9QUkVDRURFTkNFW3BhcmVudE5vZGUub3BlcmF0b3JdXG4gIClcbn1cblxuZnVuY3Rpb24gZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgcHJvdmlkZWQgYG5vZGVgLCBhZGRpbmcgcGFyZW50aGVzaXMgYXJvdW5kIGlmIHRoZSBwcm92aWRlZCBgcGFyZW50Tm9kZWAgbmVlZHMgaXQuIElmIGBub2RlYCBpcyBhIHJpZ2h0LWhhbmQgYXJndW1lbnQsIHRoZSBwcm92aWRlZCBgaXNSaWdodEhhbmRgIHBhcmFtZXRlciBzaG91bGQgYmUgYHRydWVgLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgaWYgKGV4cHJlc3Npb25OZWVkc1BhcmVudGhlc2lzKHN0YXRlLCBub2RlLCBwYXJlbnROb2RlLCBpc1JpZ2h0SGFuZCkpIHtcbiAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgZ2VuZXJhdG9yW25vZGUudHlwZV0obm9kZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyknKVxuICB9IGVsc2Uge1xuICAgIGdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlaW5kZW50KHN0YXRlLCB0ZXh0LCBpbmRlbnQsIGxpbmVFbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgYHRleHRgIHN0cmluZyByZWluZGVudGVkIHdpdGggdGhlIHByb3ZpZGVkIGBpbmRlbnRgLlxuICAqL1xuICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGVuZCA9IGxpbmVzLmxlbmd0aCAtIDFcbiAgc3RhdGUud3JpdGUobGluZXNbMF0udHJpbSgpKVxuICBpZiAoZW5kID4gMCkge1xuICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgbGluZXNbaV0udHJpbSgpICsgbGluZUVuZClcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoaW5kZW50ICsgbGluZXNbZW5kXS50cmltKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Q29tbWVudHMoc3RhdGUsIGNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCB0aGUgcHJvdmlkZWQgbGlzdCBvZiBgY29tbWVudHNgLCB3aXRoIHRoZSBnaXZlbiBgaW5kZW50YCBhbmQgYGxpbmVFbmRgIHN0cmluZ3MuXG4gIExpbmUgY29tbWVudHMgd2lsbCBlbmQgd2l0aCBgXCJcXG5cImAgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYGxpbmVFbmRgLlxuICBFeHBlY3RzIHRvIHN0YXJ0IG9uIGEgbmV3IHVuaW5kZW50ZWQgbGluZS5cbiAgKi9cbiAgY29uc3QgeyBsZW5ndGggfSA9IGNvbW1lbnRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV1cbiAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgaWYgKGNvbW1lbnQudHlwZVswXSA9PT0gJ0wnKSB7XG4gICAgICAvLyBMaW5lIGNvbW1lbnRcbiAgICAgIHN0YXRlLndyaXRlKCcvLyAnICsgY29tbWVudC52YWx1ZS50cmltKCkgKyAnXFxuJywgY29tbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmxvY2sgY29tbWVudFxuICAgICAgc3RhdGUud3JpdGUoJy8qJylcbiAgICAgIHJlaW5kZW50KHN0YXRlLCBjb21tZW50LnZhbHVlLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgICBzdGF0ZS53cml0ZSgnKi8nICsgbGluZUVuZClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAvKlxuICBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvdmlkZWQgYG5vZGVgIGNvbnRhaW5zIGEgY2FsbCBleHByZXNzaW9uIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgKi9cbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVxuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gY3VycmVudE5vZGVcbiAgICBpZiAodHlwZVswXSA9PT0gJ0MnICYmIHR5cGVbMV0gPT09ICdhJykge1xuICAgICAgLy8gSXMgQ2FsbEV4cHJlc3Npb25cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmICh0eXBlWzBdID09PSAnTScgJiYgdHlwZVsxXSA9PT0gJ2UnICYmIHR5cGVbMl0gPT09ICdtJykge1xuICAgICAgLy8gSXMgTWVtYmVyRXhwcmVzc2lvblxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5vYmplY3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIG5vZGUpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uLlxuICAqL1xuICBjb25zdCB7IGdlbmVyYXRvciB9ID0gc3RhdGVcbiAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IG5vZGVcbiAgc3RhdGUud3JpdGUobm9kZS5raW5kICsgJyAnKVxuICBjb25zdCB7IGxlbmd0aCB9ID0gZGVjbGFyYXRpb25zXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgZ2VuZXJhdG9yLlZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXJhdGlvbnNbMF0sIHN0YXRlKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICBnZW5lcmF0b3IuVmFyaWFibGVEZWNsYXJhdG9yKGRlY2xhcmF0aW9uc1tpXSwgc3RhdGUpXG4gICAgfVxuICB9XG59XG5cbmxldCBGb3JJblN0YXRlbWVudCxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgUmVzdEVsZW1lbnQsXG4gIEJpbmFyeUV4cHJlc3Npb24sXG4gIEFycmF5RXhwcmVzc2lvbixcbiAgQmxvY2tTdGF0ZW1lbnRcblxuZXhwb3J0IGNvbnN0IEdFTkVSQVRPUiA9IHtcbiAgLypcbiAgRGVmYXVsdCBnZW5lcmF0b3IuXG4gICovXG4gIFByb2dyYW0obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgfVxuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBub2RlLmJvZHlcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RhdGVtZW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV1cbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHN0YXRlbWVudC5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKGluZGVudClcbiAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgIH1cbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgfSxcbiAgQmxvY2tTdGF0ZW1lbnQ6IChCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGluZGVudCA9IHN0YXRlLmluZGVudC5yZXBlYXQoc3RhdGUuaW5kZW50TGV2ZWwrKylcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgY29uc3Qgc3RhdGVtZW50SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBub2RlLmJvZHlcbiAgICBpZiAoc3RhdGVtZW50cyAhPSBudWxsICYmIHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHN0YXRlbWVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShzdGF0ZW1lbnRJbmRlbnQpXG4gICAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0pLFxuICBDbGFzc0JvZHk6IEJsb2NrU3RhdGVtZW50LFxuICBTdGF0aWNCbG9jayhub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdGF0aWMgJylcbiAgICB0aGlzLkJsb2NrU3RhdGVtZW50KG5vZGUsIHN0YXRlKVxuICB9LFxuICBFbXB0eVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5leHByZXNzaW9uLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIChwcmVjZWRlbmNlID09PSAzICYmIG5vZGUuZXhwcmVzc2lvbi5sZWZ0LnR5cGVbMF0gPT09ICdPJylcbiAgICApIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgaGF2ZSBwYXJlbnRoZXNlcyBvciBpcyBhbiBBc3NpZ25tZW50RXhwcmVzc2lvbiB0byBhbiBPYmplY3RQYXR0ZXJuXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuZXhwcmVzc2lvbi50eXBlXShub2RlLmV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuZXhwcmVzc2lvbi50eXBlXShub2RlLmV4cHJlc3Npb24sIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIElmU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2lmICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuY29uc2VxdWVudC50eXBlXShub2RlLmNvbnNlcXVlbnQsIHN0YXRlKVxuICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnIGVsc2UgJylcbiAgICAgIHRoaXNbbm9kZS5hbHRlcm5hdGUudHlwZV0obm9kZS5hbHRlcm5hdGUsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgTGFiZWxlZFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5sYWJlbC50eXBlXShub2RlLmxhYmVsLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOiAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIEJyZWFrU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2JyZWFrJylcbiAgICBpZiAobm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnY29udGludWUnKVxuICAgIGlmIChub2RlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5sYWJlbC50eXBlXShub2RlLmxhYmVsLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBXaXRoU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3dpdGggKCcpXG4gICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBTd2l0Y2hTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIHN0YXRlLmluZGVudExldmVsKytcbiAgICBjb25zdCBjYXNlSW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgY29uc3Qgc3RhdGVtZW50SW5kZW50ID0gY2FzZUluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCdzd2l0Y2ggKCcpXG4gICAgdGhpc1tub2RlLmRpc2NyaW1pbmFudC50eXBlXShub2RlLmRpc2NyaW1pbmFudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgeycgKyBsaW5lRW5kKVxuICAgIGNvbnN0IHsgY2FzZXM6IG9jY3VyZW5jZXMgfSA9IG5vZGVcbiAgICBjb25zdCB7IGxlbmd0aDogb2NjdXJlbmNlc0NvdW50IH0gPSBvY2N1cmVuY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvY2N1cmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgb2NjdXJlbmNlID0gb2NjdXJlbmNlc1tpXVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgb2NjdXJlbmNlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG9jY3VyZW5jZS5jb21tZW50cywgY2FzZUluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGlmIChvY2N1cmVuY2UudGVzdCkge1xuICAgICAgICBzdGF0ZS53cml0ZShjYXNlSW5kZW50ICsgJ2Nhc2UgJylcbiAgICAgICAgdGhpc1tvY2N1cmVuY2UudGVzdC50eXBlXShvY2N1cmVuY2UudGVzdCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCc6JyArIGxpbmVFbmQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZShjYXNlSW5kZW50ICsgJ2RlZmF1bHQ6JyArIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvbnNlcXVlbnQgfSA9IG9jY3VyZW5jZVxuICAgICAgY29uc3QgeyBsZW5ndGg6IGNvbnNlcXVlbnRDb3VudCB9ID0gY29uc2VxdWVudFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zZXF1ZW50Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBjb25zZXF1ZW50W2ldXG4gICAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHN0YXRlbWVudC5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIHN0YXRlbWVudC5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKHN0YXRlbWVudEluZGVudClcbiAgICAgICAgdGhpc1tzdGF0ZW1lbnQudHlwZV0oc3RhdGVtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuaW5kZW50TGV2ZWwgLT0gMlxuICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgfSxcbiAgUmV0dXJuU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3JldHVybicpXG4gICAgaWYgKG5vZGUuYXJndW1lbnQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBUaHJvd1N0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd0aHJvdyAnKVxuICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFRyeVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd0cnkgJylcbiAgICB0aGlzW25vZGUuYmxvY2sudHlwZV0obm9kZS5ibG9jaywgc3RhdGUpXG4gICAgaWYgKG5vZGUuaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBoYW5kbGVyIH0gPSBub2RlXG4gICAgICBpZiAoaGFuZGxlci5wYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgY2F0Y2ggJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgY2F0Y2ggKCcpXG4gICAgICAgIHRoaXNbaGFuZGxlci5wYXJhbS50eXBlXShoYW5kbGVyLnBhcmFtLCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJykgJylcbiAgICAgIH1cbiAgICAgIHRoaXNbaGFuZGxlci5ib2R5LnR5cGVdKGhhbmRsZXIuYm9keSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLmZpbmFsaXplcikge1xuICAgICAgc3RhdGUud3JpdGUoJyBmaW5hbGx5ICcpXG4gICAgICB0aGlzW25vZGUuZmluYWxpemVyLnR5cGVdKG5vZGUuZmluYWxpemVyLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFdoaWxlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3doaWxlICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBEb1doaWxlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2RvICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIHdoaWxlICgnKVxuICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyk7JylcbiAgfSxcbiAgRm9yU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2ZvciAoJylcbiAgICBpZiAobm9kZS5pbml0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gbm9kZVxuICAgICAgaWYgKGluaXQudHlwZVswXSA9PT0gJ1YnKSB7XG4gICAgICAgIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIGluaXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2luaXQudHlwZV0oaW5pdCwgc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7ICcpXG4gICAgaWYgKG5vZGUudGVzdCkge1xuICAgICAgdGhpc1tub2RlLnRlc3QudHlwZV0obm9kZS50ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsgJylcbiAgICBpZiAobm9kZS51cGRhdGUpIHtcbiAgICAgIHRoaXNbbm9kZS51cGRhdGUudHlwZV0obm9kZS51cGRhdGUsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIEZvckluU3RhdGVtZW50OiAoRm9ySW5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShgZm9yICR7bm9kZS5hd2FpdCA/ICdhd2FpdCAnIDogJyd9KGApXG4gICAgY29uc3QgeyBsZWZ0IH0gPSBub2RlXG4gICAgaWYgKGxlZnQudHlwZVswXSA9PT0gJ1YnKSB7XG4gICAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBsZWZ0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2xlZnQudHlwZV0obGVmdCwgc3RhdGUpXG4gICAgfVxuICAgIC8vIElkZW50aWZ5aW5nIHdoZXRoZXIgbm9kZS50eXBlIGlzIGBGb3JJblN0YXRlbWVudGAgb3IgYEZvck9mU3RhdGVtZW50YFxuICAgIHN0YXRlLndyaXRlKG5vZGUudHlwZVszXSA9PT0gJ0knID8gJyBpbiAnIDogJyBvZiAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0pLFxuICBGb3JPZlN0YXRlbWVudDogRm9ySW5TdGF0ZW1lbnQsXG4gIERlYnVnZ2VyU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2RlYnVnZ2VyOycsIG5vZGUpXG4gIH0sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IChGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoXG4gICAgICAobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycpICtcbiAgICAgICAgKG5vZGUuZ2VuZXJhdG9yID8gJ2Z1bmN0aW9uKiAnIDogJ2Z1bmN0aW9uICcpICtcbiAgICAgICAgKG5vZGUuaWQgPyBub2RlLmlkLm5hbWUgOiAnJyksXG4gICAgICBub2RlLFxuICAgIClcbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZS5wYXJhbXMpXG4gICAgc3RhdGUud3JpdGUoJyAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0pLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBub2RlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmlkLnR5cGVdKG5vZGUuaWQsIHN0YXRlKVxuICAgIGlmIChub2RlLmluaXQgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyA9ICcpXG4gICAgICB0aGlzW25vZGUuaW5pdC50eXBlXShub2RlLmluaXQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdjbGFzcyAnICsgKG5vZGUuaWQgPyBgJHtub2RlLmlkLm5hbWV9IGAgOiAnJyksIG5vZGUpXG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcykge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4dGVuZHMgJylcbiAgICAgIGNvbnN0IHsgc3VwZXJDbGFzcyB9ID0gbm9kZVxuICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdXBlckNsYXNzXG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3R5cGVdXG4gICAgICBpZiAoXG4gICAgICAgICh0eXBlWzBdICE9PSAnQycgfHwgdHlwZVsxXSAhPT0gJ2wnIHx8IHR5cGVbNV0gIT09ICdFJykgJiZcbiAgICAgICAgKHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICAgICAgcHJlY2VkZW5jZSA8IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5DbGFzc0V4cHJlc3Npb24pXG4gICAgICApIHtcbiAgICAgICAgLy8gTm90IGEgQ2xhc3NFeHByZXNzaW9uIHRoYXQgbmVlZHMgcGFyZW50aGVzZXNcbiAgICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgICB0aGlzW25vZGUuc3VwZXJDbGFzcy50eXBlXShzdXBlckNsYXNzLCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzdXBlckNsYXNzLnR5cGVdKHN1cGVyQ2xhc3MsIHN0YXRlKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgIH1cbiAgICB0aGlzLkNsYXNzQm9keShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBJbXBvcnREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpbXBvcnQgJylcbiAgICBjb25zdCB7IHNwZWNpZmllcnMsIGF0dHJpYnV0ZXMgfSA9IG5vZGVcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3BlY2lmaWVyc1xuICAgIC8vIFRPRE86IE9uY2UgYmFiaWxpIGlzIGZpeGVkLCBwdXQgdGhpcyBhZnRlciBjb25kaXRpb25cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiaWxpL2lzc3Vlcy80MzBcbiAgICBsZXQgaSA9IDBcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICkge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgY29uc3QgdHlwZSA9IHNwZWNpZmllci50eXBlWzZdXG4gICAgICAgIGlmICh0eXBlID09PSAnRCcpIHtcbiAgICAgICAgICAvLyBJbXBvcnREZWZhdWx0U3BlY2lmaWVyXG4gICAgICAgICAgc3RhdGUud3JpdGUoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTicpIHtcbiAgICAgICAgICAvLyBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnKiBhcyAnICsgc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbXBvcnRTcGVjaWZpZXJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzcGVjaWZpZXIuaW1wb3J0ZWRcbiAgICAgICAgICBzdGF0ZS53cml0ZShuYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaWYgKG5hbWUgIT09IHNwZWNpZmllci5sb2NhbC5uYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnIGFzICcgKyBzcGVjaWZpZXIubG9jYWwubmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJyBmcm9tICcpXG4gICAgfVxuICAgIHRoaXMuTGl0ZXJhbChub2RlLnNvdXJjZSwgc3RhdGUpXG5cbiAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgd2l0aCB7ICcpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5JbXBvcnRBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXSwgc3RhdGUpXG4gICAgICAgIGlmIChpIDwgYXR0cmlidXRlcy5sZW5ndGggLSAxKSBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS53cml0ZSgnIH0nKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIEltcG9ydEF0dHJpYnV0ZShub2RlLCBzdGF0ZSkge1xuICAgIHRoaXMuSWRlbnRpZmllcihub2RlLmtleSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzogJylcbiAgICB0aGlzLkxpdGVyYWwobm9kZS52YWx1ZSwgc3RhdGUpXG4gIH0sXG4gIEltcG9ydEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaW1wb3J0KCcpXG4gICAgdGhpc1tub2RlLnNvdXJjZS50eXBlXShub2RlLnNvdXJjZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyknKVxuICB9LFxuICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZXhwb3J0IGRlZmF1bHQgJylcbiAgICB0aGlzW25vZGUuZGVjbGFyYXRpb24udHlwZV0obm9kZS5kZWNsYXJhdGlvbiwgc3RhdGUpXG4gICAgaWYgKFxuICAgICAgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuZGVjbGFyYXRpb24udHlwZV0gIT0gbnVsbCAmJlxuICAgICAgbm9kZS5kZWNsYXJhdGlvbi50eXBlWzBdICE9PSAnRidcbiAgICApIHtcbiAgICAgIC8vIEFsbCBleHByZXNzaW9uIG5vZGVzIGV4Y2VwdCBgRnVuY3Rpb25FeHByZXNzaW9uYFxuICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgIH1cbiAgfSxcbiAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdleHBvcnQgJylcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgdGhpc1tub2RlLmRlY2xhcmF0aW9uLnR5cGVdKG5vZGUuZGVjbGFyYXRpb24sIHN0YXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgICBjb25zdCB7IHNwZWNpZmllcnMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBzcGVjaWZpZXJzXG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgOyApIHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzcGVjaWZpZXIubG9jYWxcbiAgICAgICAgICBzdGF0ZS53cml0ZShuYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaWYgKG5hbWUgIT09IHNwZWNpZmllci5leHBvcnRlZC5uYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnIGFzICcgKyBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGZyb20gJylcbiAgICAgICAgdGhpcy5MaXRlcmFsKG5vZGUuc291cmNlLCBzdGF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIHdpdGggeyAnKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuSW1wb3J0QXR0cmlidXRlKG5vZGUuYXR0cmlidXRlc1tpXSwgc3RhdGUpXG4gICAgICAgICAgaWYgKGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMSkgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLndyaXRlKCcgfScpXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICB9XG4gIH0sXG4gIEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUuZXhwb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAqIGFzICcgKyBub2RlLmV4cG9ydGVkLm5hbWUgKyAnIGZyb20gJylcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAqIGZyb20gJylcbiAgICB9XG4gICAgdGhpcy5MaXRlcmFsKG5vZGUuc291cmNlLCBzdGF0ZSlcblxuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgd2l0aCB7ICcpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLkltcG9ydEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0sIHN0YXRlKVxuICAgICAgICBpZiAoaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGggLSAxKSBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS53cml0ZSgnIH0nKVxuICAgIH1cblxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kWzBdXG4gICAgaWYgKGtpbmQgPT09ICdnJyB8fCBraW5kID09PSAncycpIHtcbiAgICAgIC8vIEdldHRlciBvciBzZXR0ZXJcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUuYXN5bmMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdhc3luYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcqJylcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUudmFsdWUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUudmFsdWUuYm9keS50eXBlXShub2RlLnZhbHVlLmJvZHksIHN0YXRlKVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzLkNsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpXG4gIH0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5hc3luYyA/ICdhc3luYyAnIDogJycsIG5vZGUpXG4gICAgY29uc3QgeyBwYXJhbXMgfSA9IG5vZGVcbiAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcbiAgICAgIC8vIE9taXQgcGFyZW50aGVzaXMgaWYgb25seSBvbmUgbmFtZWQgcGFyYW1ldGVyXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0udHlwZVswXSA9PT0gJ0knKSB7XG4gICAgICAgIC8vIElmIHBhcmFtc1swXS50eXBlWzBdIHN0YXJ0cyB3aXRoICdJJywgaXQgY2FuJ3QgYmUgYEltcG9ydERlY2xhcmF0aW9uYCBub3IgYElmU3RhdGVtZW50YCBhbmQgdGh1cyBpcyBgSWRlbnRpZmllcmBcbiAgICAgICAgc3RhdGUud3JpdGUocGFyYW1zWzBdLm5hbWUsIHBhcmFtc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnBhcmFtcylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA9PiAnKVxuICAgIGlmIChub2RlLmJvZHkudHlwZVswXSA9PT0gJ08nKSB7XG4gICAgICAvLyBCb2R5IGlzIGFuIG9iamVjdCBleHByZXNzaW9uXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzLk9iamVjdEV4cHJlc3Npb24obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFRoaXNFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3RoaXMnLCBub2RlKVxuICB9LFxuICBTdXBlcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdzdXBlcicsIG5vZGUpXG4gIH0sXG4gIFJlc3RFbGVtZW50OiAoUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnLi4uJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gIH0pLFxuICBTcHJlYWRFbGVtZW50OiBSZXN0RWxlbWVudCxcbiAgWWllbGRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5kZWxlZ2F0ZSA/ICd5aWVsZConIDogJ3lpZWxkJylcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgQXdhaXRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2F3YWl0ICcsIG5vZGUpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5hcmd1bWVudCwgbm9kZSlcbiAgfSxcbiAgVGVtcGxhdGVMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBxdWFzaXMsIGV4cHJlc3Npb25zIH0gPSBub2RlXG4gICAgc3RhdGUud3JpdGUoJ2AnKVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBleHByZXNzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXVxuICAgICAgY29uc3QgcXVhc2kgPSBxdWFzaXNbaV1cbiAgICAgIHN0YXRlLndyaXRlKHF1YXNpLnZhbHVlLnJhdywgcXVhc2kpXG4gICAgICBzdGF0ZS53cml0ZSgnJHsnKVxuICAgICAgdGhpc1tleHByZXNzaW9uLnR5cGVdKGV4cHJlc3Npb24sIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBjb25zdCBxdWFzaSA9IHF1YXNpc1txdWFzaXMubGVuZ3RoIC0gMV1cbiAgICBzdGF0ZS53cml0ZShxdWFzaS52YWx1ZS5yYXcsIHF1YXNpKVxuICAgIHN0YXRlLndyaXRlKCdgJylcbiAgfSxcbiAgVGVtcGxhdGVFbGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS52YWx1ZS5yYXcsIG5vZGUpXG4gIH0sXG4gIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUudGFnLCBub2RlKVxuICAgIHRoaXNbbm9kZS5xdWFzaS50eXBlXShub2RlLnF1YXNpLCBzdGF0ZSlcbiAgfSxcbiAgQXJyYXlFeHByZXNzaW9uOiAoQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgZWxlbWVudHMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBlbGVtZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpc1tlbGVtZW50LnR5cGVdKGVsZW1lbnQsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ10nKVxuICB9KSxcbiAgQXJyYXlQYXR0ZXJuOiBBcnJheUV4cHJlc3Npb24sXG4gIE9iamVjdEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BlcnR5SW5kZW50ID0gaW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYSA9ICcsJyArIGxpbmVFbmRcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgcHJvcGVydHkuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBwcm9wZXJ0eS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocHJvcGVydHlJbmRlbnQpXG4gICAgICAgIHRoaXNbcHJvcGVydHkudHlwZV0ocHJvcGVydHksIHN0YXRlKVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoY29tbWEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgIH0gZWxzZSBpZiAod3JpdGVDb21tZW50cykge1xuICAgICAgaWYgKG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIH1cbiAgICBzdGF0ZS5pbmRlbnRMZXZlbC0tXG4gIH0sXG4gIFByb3BlcnR5KG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kIHx8IG5vZGUua2luZFswXSAhPT0gJ2knKSB7XG4gICAgICAvLyBFaXRoZXIgYSBtZXRob2Qgb3Igb2Yga2luZCBgc2V0YCBvciBgZ2V0YCAobm90IGBpbml0YClcbiAgICAgIHRoaXMuTWV0aG9kRGVmaW5pdGlvbihub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFub2RlLnNob3J0aGFuZCkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoJzogJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS52YWx1ZS50eXBlXShub2RlLnZhbHVlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIFByb3BlcnR5RGVmaW5pdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnN0YXRpYykge1xuICAgICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgIH1cbiAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5rZXkudHlwZVswXSAhPT0gJ0YnKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICB0aGlzW25vZGUudmFsdWUudHlwZV0obm9kZS52YWx1ZSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBPYmplY3RQYXR0ZXJuKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3snKVxuICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydGllc1tpXS50eXBlXShwcm9wZXJ0aWVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gIH0sXG4gIFNlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLmV4cHJlc3Npb25zKVxuICB9LFxuICBVbmFyeUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgIGFyZ3VtZW50LFxuICAgICAgICBhcmd1bWVudDogeyB0eXBlIH0sXG4gICAgICB9ID0gbm9kZVxuICAgICAgc3RhdGUud3JpdGUob3BlcmF0b3IpXG4gICAgICBjb25zdCBuZWVkc1BhcmVudGhlc2VzID0gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIGFyZ3VtZW50LCBub2RlKVxuICAgICAgaWYgKFxuICAgICAgICAhbmVlZHNQYXJlbnRoZXNlcyAmJlxuICAgICAgICAob3BlcmF0b3IubGVuZ3RoID4gMSB8fFxuICAgICAgICAgICh0eXBlWzBdID09PSAnVScgJiZcbiAgICAgICAgICAgICh0eXBlWzFdID09PSAnbicgfHwgdHlwZVsxXSA9PT0gJ3AnKSAmJlxuICAgICAgICAgICAgYXJndW1lbnQucHJlZml4ICYmXG4gICAgICAgICAgICBhcmd1bWVudC5vcGVyYXRvclswXSA9PT0gb3BlcmF0b3IgJiZcbiAgICAgICAgICAgIChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnLScpKSlcbiAgICAgICkge1xuICAgICAgICAvLyBMYXJnZSBvcGVyYXRvciBvciBhcmd1bWVudCBpcyBVbmFyeUV4cHJlc3Npb24gb3IgVXBkYXRlRXhwcmVzc2lvbiBub2RlXG4gICAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1BhcmVudGhlc2VzKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKG9wZXJhdG9yLmxlbmd0aCA+IDEgPyAnICgnIDogJygnKVxuICAgICAgICB0aGlzW3R5cGVdKGFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1t0eXBlXShhcmd1bWVudCwgc3RhdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGNhc2UgbmV2ZXIgb2NjdXJzXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgIH1cbiAgfSxcbiAgVXBkYXRlRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIC8vIEFsd2F5cyBhcHBsaWVkIHRvIGlkZW50aWZpZXJzIG9yIG1lbWJlcnMsIG5vIHBhcmVudGhlc2lzIGNoZWNrIG5lZWRlZFxuICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICB9XG4gIH0sXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxlZnQudHlwZV0obm9kZS5sZWZ0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnICcgKyBub2RlLm9wZXJhdG9yICsgJyAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQXNzaWdubWVudFBhdHRlcm4obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGVmdC50eXBlXShub2RlLmxlZnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgIHRoaXNbbm9kZS5yaWdodC50eXBlXShub2RlLnJpZ2h0LCBzdGF0ZSlcbiAgfSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogKEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpc0luID0gbm9kZS5vcGVyYXRvciA9PT0gJ2luJ1xuICAgIGlmIChpc0luKSB7XG4gICAgICAvLyBBdm9pZHMgY29uZnVzaW9uIGluIGBmb3JgIGxvb3BzIGluaXRpYWxpemVyc1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgIH1cbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLmxlZnQsIG5vZGUsIGZhbHNlKVxuICAgIHN0YXRlLndyaXRlKCcgJyArIG5vZGUub3BlcmF0b3IgKyAnICcpXG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5yaWdodCwgbm9kZSwgdHJ1ZSlcbiAgICBpZiAoaXNJbikge1xuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH1cbiAgfSksXG4gIExvZ2ljYWxFeHByZXNzaW9uOiBCaW5hcnlFeHByZXNzaW9uLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHRlc3QgfSA9IG5vZGVcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3Rlc3QudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8PSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW3Rlc3QudHlwZV0odGVzdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbdGVzdC50eXBlXSh0ZXN0LCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA/ICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnIDogJylcbiAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgfSxcbiAgTmV3RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCduZXcgJylcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuY2FsbGVlLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUuY2FsbGVlKVxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmNhbGxlZS50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNhbGxFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZVsnYXJndW1lbnRzJ10pXG4gIH0sXG4gIENoYWluRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gIH0sXG4gIE1lbWJlckV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUub2JqZWN0LnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuTWVtYmVyRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcuJylcbiAgICAgIH1cbiAgICAgIHRoaXNbbm9kZS5wcm9wZXJ0eS50eXBlXShub2RlLnByb3BlcnR5LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUubWV0YS5uYW1lICsgJy4nICsgbm9kZS5wcm9wZXJ0eS5uYW1lLCBub2RlKVxuICB9LFxuICBJZGVudGlmaWVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5uYW1lLCBub2RlKVxuICB9LFxuICBQcml2YXRlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKGAjJHtub2RlLm5hbWV9YCwgbm9kZSlcbiAgfSxcbiAgTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnJhdyAhPSBudWxsKSB7XG4gICAgICAvLyBOb24tc3RhbmRhcmQgcHJvcGVydHlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUucmF3LCBub2RlKVxuICAgIH0gZWxzZSBpZiAobm9kZS5yZWdleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLlJlZ0V4cExpdGVyYWwobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLmJpZ2ludCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZShub2RlLmJpZ2ludCArICduJywgbm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoc3RyaW5naWZ5KG5vZGUudmFsdWUpLCBub2RlKVxuICAgIH1cbiAgfSxcbiAgUmVnRXhwTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgcmVnZXggfSA9IG5vZGVcbiAgICBzdGF0ZS53cml0ZShgLyR7cmVnZXgucGF0dGVybn0vJHtyZWdleC5mbGFnc31gLCBub2RlKVxuICB9LFxufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fVxuXG4vKlxuREVQUkVDQVRFRDogQWx0ZXJuYXRlIGV4cG9ydCBvZiBgR0VORVJBVE9SYC5cbiovXG5leHBvcnQgY29uc3QgYmFzZUdlbmVyYXRvciA9IEdFTkVSQVRPUlxuXG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXR1cCA9IG9wdGlvbnMgPT0gbnVsbCA/IEVNUFRZX09CSkVDVCA6IG9wdGlvbnNcbiAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgLy8gRnVuY3Rpb25hbCBvcHRpb25zXG4gICAgaWYgKHNldHVwLm91dHB1dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm91dHB1dCA9IHNldHVwLm91dHB1dFxuICAgICAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGVUb1N0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dCA9ICcnXG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdG9yID0gc2V0dXAuZ2VuZXJhdG9yICE9IG51bGwgPyBzZXR1cC5nZW5lcmF0b3IgOiBHRU5FUkFUT1JcbiAgICB0aGlzLmV4cHJlc3Npb25zUHJlY2VkZW5jZSA9XG4gICAgICBzZXR1cC5leHByZXNzaW9uc1ByZWNlZGVuY2UgIT0gbnVsbFxuICAgICAgICA/IHNldHVwLmV4cHJlc3Npb25zUHJlY2VkZW5jZVxuICAgICAgICA6IEVYUFJFU1NJT05TX1BSRUNFREVOQ0VcbiAgICAvLyBGb3JtYXRpbmcgc2V0dXBcbiAgICB0aGlzLmluZGVudCA9IHNldHVwLmluZGVudCAhPSBudWxsID8gc2V0dXAuaW5kZW50IDogJyAgJ1xuICAgIHRoaXMubGluZUVuZCA9IHNldHVwLmxpbmVFbmQgIT0gbnVsbCA/IHNldHVwLmxpbmVFbmQgOiAnXFxuJ1xuICAgIHRoaXMuaW5kZW50TGV2ZWwgPVxuICAgICAgc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCAhPSBudWxsID8gc2V0dXAuc3RhcnRpbmdJbmRlbnRMZXZlbCA6IDBcbiAgICB0aGlzLndyaXRlQ29tbWVudHMgPSBzZXR1cC5jb21tZW50cyA/IHNldHVwLmNvbW1lbnRzIDogZmFsc2VcbiAgICAvLyBTb3VyY2UgbWFwXG4gICAgaWYgKHNldHVwLnNvdXJjZU1hcCAhPSBudWxsKSB7XG4gICAgICB0aGlzLndyaXRlID1cbiAgICAgICAgc2V0dXAub3V0cHV0ID09IG51bGwgPyB0aGlzLndyaXRlQW5kTWFwIDogdGhpcy53cml0ZVRvU3RyZWFtQW5kTWFwXG4gICAgICB0aGlzLnNvdXJjZU1hcCA9IHNldHVwLnNvdXJjZU1hcFxuICAgICAgdGhpcy5saW5lID0gMVxuICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB0aGlzLmxpbmVFbmRTaXplID0gdGhpcy5saW5lRW5kLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxXG4gICAgICB0aGlzLm1hcHBpbmcgPSB7XG4gICAgICAgIG9yaWdpbmFsOiBudWxsLFxuICAgICAgICAvLyBVc2VzIHRoZSBlbnRpcmUgc3RhdGUgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcGhlbWVyYWwgb2JqZWN0c1xuICAgICAgICBnZW5lcmF0ZWQ6IHRoaXMsXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc291cmNlOiBzZXR1cC5zb3VyY2VNYXAuZmlsZSB8fCBzZXR1cC5zb3VyY2VNYXAuX2ZpbGUsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd3JpdGUoY29kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IGNvZGVcbiAgfVxuXG4gIHdyaXRlVG9TdHJlYW0oY29kZSkge1xuICAgIHRoaXMub3V0cHV0LndyaXRlKGNvZGUpXG4gIH1cblxuICB3cml0ZUFuZE1hcChjb2RlLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY29kZVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICB3cml0ZVRvU3RyZWFtQW5kTWFwKGNvZGUsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dC53cml0ZShjb2RlKVxuICAgIHRoaXMubWFwKGNvZGUsIG5vZGUpXG4gIH1cblxuICBtYXAoY29kZSwgbm9kZSkge1xuICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZVxuICAgICAgaWYgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzJdID09PSAnbicpIHtcbiAgICAgICAgLy8gTGluZUNvbW1lbnRcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICAgIHRoaXMubGluZSsrXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubG9jICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBtYXBwaW5nIH0gPSB0aGlzXG4gICAgICAgIG1hcHBpbmcub3JpZ2luYWwgPSBub2RlLmxvYy5zdGFydFxuICAgICAgICBtYXBwaW5nLm5hbWUgPSBub2RlLm5hbWVcbiAgICAgICAgdGhpcy5zb3VyY2VNYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSA9PT0gJ1QnICYmIHR5cGVbOF0gPT09ICdFJykgfHxcbiAgICAgICAgKHR5cGVbMF0gPT09ICdMJyAmJiB0eXBlWzFdID09PSAnaScgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFRlbXBsYXRlRWxlbWVudCBvciBMaXRlcmFsIHN0cmluZyBub2RlXG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2RlXG4gICAgICAgIGxldCB7IGNvbHVtbiwgbGluZSB9ID0gdGhpc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvZGVbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSAwXG4gICAgICAgICAgICBsaW5lKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW5cbiAgICAgICAgdGhpcy5saW5lID0gbGluZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGNvZGVcbiAgICBjb25zdCB7IGxpbmVFbmQgfSA9IHRoaXNcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxpbmVFbmRTaXplID4gMCAmJlxuICAgICAgICAobGluZUVuZC5sZW5ndGggPT09IDFcbiAgICAgICAgICA/IGNvZGVbbGVuZ3RoIC0gMV0gPT09IGxpbmVFbmRcbiAgICAgICAgICA6IGNvZGUuZW5kc1dpdGgobGluZUVuZCkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5saW5lICs9IHRoaXMubGluZUVuZFNpemVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiArPSBsZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSwgb3B0aW9ucykge1xuICAvKlxuICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgY29kZSBvZiB0aGUgcHJvdmlkZWQgQVNUIGBub2RlYC5cbiAgVGhlIGBvcHRpb25zYCBhcmU6XG5cbiAgLSBgaW5kZW50YDogc3RyaW5nIHRvIHVzZSBmb3IgaW5kZW50YXRpb24gKGRlZmF1bHRzIHRvIGDikKPikKNgKVxuICAtIGBsaW5lRW5kYDogc3RyaW5nIHRvIHVzZSBmb3IgbGluZSBlbmRpbmdzIChkZWZhdWx0cyB0byBgXFxuYClcbiAgLSBgc3RhcnRpbmdJbmRlbnRMZXZlbGA6IGluZGVudCBsZXZlbCB0byBzdGFydCBmcm9tIChkZWZhdWx0cyB0byBgMGApXG4gIC0gYGNvbW1lbnRzYDogZ2VuZXJhdGUgY29tbWVudHMgaWYgYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKVxuICAtIGBvdXRwdXRgOiBvdXRwdXQgc3RyZWFtIHRvIHdyaXRlIHRoZSByZW5kZXJlZCBjb2RlIHRvIChkZWZhdWx0cyB0byBgbnVsbGApXG4gIC0gYGdlbmVyYXRvcmA6IGN1c3RvbSBjb2RlIGdlbmVyYXRvciAoZGVmYXVsdHMgdG8gYEdFTkVSQVRPUmApXG4gIC0gYGV4cHJlc3Npb25zUHJlY2VkZW5jZWA6IGN1c3RvbSBtYXAgb2Ygbm9kZSB0eXBlcyBhbmQgdGhlaXIgcHJlY2VkZW5jZSBsZXZlbCAoZGVmYXVsdHMgdG8gYEVYUFJFU1NJT05TX1BSRUNFREVOQ0VgKVxuICAqL1xuICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKVxuICAvLyBUcmF2ZWwgdGhyb3VnaCB0aGUgQVNUIG5vZGUgYW5kIGdlbmVyYXRlIHRoZSBjb2RlXG4gIHN0YXRlLmdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICByZXR1cm4gc3RhdGUub3V0cHV0XG59XG4iXSwibmFtZXMiOlsic3RyaW5naWZ5IiwiSlNPTiIsIlN0cmluZyIsInByb3RvdHlwZSIsInJlcGVhdCIsIkVycm9yIiwiZW5kc1dpdGgiLCJPUEVSQVRPUl9QUkVDRURFTkNFIiwiaW4iLCJpbnN0YW5jZW9mIiwiTkVFRFNfUEFSRU5USEVTRVMiLCJFWFBSRVNTSU9OU19QUkVDRURFTkNFIiwiQXJyYXlFeHByZXNzaW9uIiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwiVGhpc0V4cHJlc3Npb24iLCJJZGVudGlmaWVyIiwiUHJpdmF0ZUlkZW50aWZpZXIiLCJMaXRlcmFsIiwiVGVtcGxhdGVMaXRlcmFsIiwiU3VwZXIiLCJTZXF1ZW5jZUV4cHJlc3Npb24iLCJNZW1iZXJFeHByZXNzaW9uIiwiQ2hhaW5FeHByZXNzaW9uIiwiQ2FsbEV4cHJlc3Npb24iLCJOZXdFeHByZXNzaW9uIiwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJDbGFzc0V4cHJlc3Npb24iLCJGdW5jdGlvbkV4cHJlc3Npb24iLCJPYmplY3RFeHByZXNzaW9uIiwiVXBkYXRlRXhwcmVzc2lvbiIsIlVuYXJ5RXhwcmVzc2lvbiIsIkF3YWl0RXhwcmVzc2lvbiIsIkJpbmFyeUV4cHJlc3Npb24iLCJMb2dpY2FsRXhwcmVzc2lvbiIsIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsIkFzc2lnbm1lbnRFeHByZXNzaW9uIiwiWWllbGRFeHByZXNzaW9uIiwiUmVzdEVsZW1lbnQiLCJmb3JtYXRTZXF1ZW5jZSIsInN0YXRlIiwibm9kZXMiLCJnZW5lcmF0b3IiLCJ3cml0ZSIsImxlbmd0aCIsInR5cGUiLCJpIiwicGFyYW0iLCJleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyIsIm5vZGUiLCJwYXJlbnROb2RlIiwiaXNSaWdodEhhbmQiLCJub2RlUHJlY2VkZW5jZSIsImV4cHJlc3Npb25zUHJlY2VkZW5jZSIsInBhcmVudE5vZGVQcmVjZWRlbmNlIiwib3BlcmF0b3IiLCJmb3JtYXRFeHByZXNzaW9uIiwicmVpbmRlbnQiLCJ0ZXh0IiwiaW5kZW50IiwibGluZUVuZCIsImxpbmVzIiwic3BsaXQiLCJlbmQiLCJ0cmltIiwiZm9ybWF0Q29tbWVudHMiLCJjb21tZW50cyIsImNvbW1lbnQiLCJ2YWx1ZSIsImhhc0NhbGxFeHByZXNzaW9uIiwiY3VycmVudE5vZGUiLCJvYmplY3QiLCJmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb25zIiwia2luZCIsIlZhcmlhYmxlRGVjbGFyYXRvciIsIkZvckluU3RhdGVtZW50IiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIkJsb2NrU3RhdGVtZW50IiwiR0VORVJBVE9SIiwiUHJvZ3JhbSIsImluZGVudExldmVsIiwid3JpdGVDb21tZW50cyIsInN0YXRlbWVudHMiLCJib2R5Iiwic3RhdGVtZW50IiwidHJhaWxpbmdDb21tZW50cyIsInN0YXRlbWVudEluZGVudCIsIkNsYXNzQm9keSIsIlN0YXRpY0Jsb2NrIiwiRW1wdHlTdGF0ZW1lbnQiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwicHJlY2VkZW5jZSIsImV4cHJlc3Npb24iLCJsZWZ0IiwiSWZTdGF0ZW1lbnQiLCJ0ZXN0IiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJsYWJlbCIsIkJyZWFrU3RhdGVtZW50IiwiQ29udGludWVTdGF0ZW1lbnQiLCJXaXRoU3RhdGVtZW50IiwiU3dpdGNoU3RhdGVtZW50IiwiY2FzZUluZGVudCIsImRpc2NyaW1pbmFudCIsImNhc2VzIiwib2NjdXJlbmNlcyIsIm9jY3VyZW5jZXNDb3VudCIsIm9jY3VyZW5jZSIsImNvbnNlcXVlbnRDb3VudCIsIlJldHVyblN0YXRlbWVudCIsImFyZ3VtZW50IiwiVGhyb3dTdGF0ZW1lbnQiLCJUcnlTdGF0ZW1lbnQiLCJibG9jayIsImhhbmRsZXIiLCJmaW5hbGl6ZXIiLCJXaGlsZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiLCJpbml0IiwidXBkYXRlIiwiYXdhaXQiLCJyaWdodCIsIkZvck9mU3RhdGVtZW50IiwiRGVidWdnZXJTdGF0ZW1lbnQiLCJhc3luYyIsImlkIiwibmFtZSIsInBhcmFtcyIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJDbGFzc0RlY2xhcmF0aW9uIiwic3VwZXJDbGFzcyIsIkltcG9ydERlY2xhcmF0aW9uIiwic3BlY2lmaWVycyIsImF0dHJpYnV0ZXMiLCJzcGVjaWZpZXIiLCJsb2NhbCIsImltcG9ydGVkIiwic291cmNlIiwiSW1wb3J0QXR0cmlidXRlIiwia2V5IiwiSW1wb3J0RXhwcmVzc2lvbiIsIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiIsImRlY2xhcmF0aW9uIiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsImV4cG9ydGVkIiwiRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJNZXRob2REZWZpbml0aW9uIiwic3RhdGljIiwiY29tcHV0ZWQiLCJTcHJlYWRFbGVtZW50IiwiZGVsZWdhdGUiLCJxdWFzaXMiLCJleHByZXNzaW9ucyIsInF1YXNpIiwicmF3IiwiVGVtcGxhdGVFbGVtZW50IiwidGFnIiwiZWxlbWVudHMiLCJlbGVtZW50IiwiQXJyYXlQYXR0ZXJuIiwicHJvcGVydHlJbmRlbnQiLCJwcm9wZXJ0aWVzIiwiY29tbWEiLCJwcm9wZXJ0eSIsIlByb3BlcnR5IiwibWV0aG9kIiwic2hvcnRoYW5kIiwiUHJvcGVydHlEZWZpbml0aW9uIiwiT2JqZWN0UGF0dGVybiIsInByZWZpeCIsIm5lZWRzUGFyZW50aGVzZXMiLCJBc3NpZ25tZW50UGF0dGVybiIsImlzSW4iLCJjYWxsZWUiLCJvcHRpb25hbCIsIk1ldGFQcm9wZXJ0eSIsIm1ldGEiLCJyZWdleCIsIlJlZ0V4cExpdGVyYWwiLCJiaWdpbnQiLCJwYXR0ZXJuIiwiZmxhZ3MiLCJFTVBUWV9PQkpFQ1QiLCJiYXNlR2VuZXJhdG9yIiwiU3RhdGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzZXR1cCIsIm91dHB1dCIsIndyaXRlVG9TdHJlYW0iLCJzdGFydGluZ0luZGVudExldmVsIiwic291cmNlTWFwIiwid3JpdGVBbmRNYXAiLCJ3cml0ZVRvU3RyZWFtQW5kTWFwIiwibGluZSIsImNvbHVtbiIsImxpbmVFbmRTaXplIiwibWFwcGluZyIsIm9yaWdpbmFsIiwiZ2VuZXJhdGVkIiwidW5kZWZpbmVkIiwiZmlsZSIsIl9maWxlIiwiY29kZSIsIm1hcCIsImxvYyIsInN0YXJ0IiwiYWRkTWFwcGluZyIsInRvU3RyaW5nIiwiZ2VuZXJhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/astring/dist/astring.mjs\n");

/***/ })

};
;