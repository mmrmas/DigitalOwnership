"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/alchemy-sdk";
exports.ids = ["vendor-chunks/alchemy-sdk"];
exports.modules = {

/***/ "(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-provider-7ab90821.js":
/*!*************************************************************************!*\
  !*** ../node_modules/alchemy-sdk/dist/cjs/alchemy-provider-7ab90821.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-769e52b6.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar web = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/../node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/../node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js\");\n/** Maximum size of a batch on the rpc provider. */ const DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n/** Timeout interval before the pending batch is sent. */ const DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */ class RequestBatcher {\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE){\n        this.sendBatchFn = sendBatchFn;\n        this.maxBatchSize = maxBatchSize;\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */ this.pendingBatch = [];\n    }\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */ enqueueRequest(request) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const inflightRequest = {\n                request,\n                resolve: undefined,\n                reject: undefined\n            };\n            const promise = new Promise((resolve, reject)=>{\n                inflightRequest.resolve = resolve;\n                inflightRequest.reject = reject;\n            });\n            this.pendingBatch.push(inflightRequest);\n            if (this.pendingBatch.length === this.maxBatchSize) {\n                // Send batch immediately if we are at the maximum batch size.\n                void this.sendBatchRequest();\n            } else if (!this.pendingBatchTimer) {\n                // Schedule batch for next event loop + short duration\n                this.pendingBatchTimer = setTimeout(()=>this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\n            }\n            return promise;\n        });\n    }\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */ sendBatchRequest() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Get the current batch and clear it, so new requests\n            // go into the next batch\n            const batch = this.pendingBatch;\n            this.pendingBatch = [];\n            if (this.pendingBatchTimer) {\n                clearTimeout(this.pendingBatchTimer);\n                this.pendingBatchTimer = undefined;\n            }\n            // Get the request as an array of requests\n            const request = batch.map((inflight)=>inflight.request);\n            return this.sendBatchFn(request).then((result)=>{\n                // For each result, feed it to the correct Promise, depending\n                // on whether it was a success or error\n                batch.forEach((inflightRequest, index)=>{\n                    const payload = result[index];\n                    if (payload.error) {\n                        const error = new Error(payload.error.message);\n                        error.code = payload.error.code;\n                        error.data = payload.error.data;\n                        inflightRequest.reject(error);\n                    } else {\n                        inflightRequest.resolve(payload.result);\n                    }\n                });\n            }, (error)=>{\n                batch.forEach((inflightRequest)=>{\n                    inflightRequest.reject(error);\n                });\n            });\n        });\n    }\n}\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyProvider extends providers.JsonRpcProvider {\n    /** @internal */ constructor(config){\n        // Normalize the API Key to a string.\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"http\");\n        // If a hardcoded url was specified in the config, use that instead of the\n        // provided apiKey or network.\n        if (config.url !== undefined) {\n            connection.url = config.url;\n        }\n        connection.throttleLimit = config.maxRetries;\n        // Add user provided overrides if they exist.\n        if (config.connectionInfoOverrides) {\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\n        }\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        super(connection, ethersNetwork);\n        this.apiKey = config.apiKey;\n        this.maxRetries = config.maxRetries;\n        this.batchRequests = config.batchRequests;\n        // TODO: support individual headers when calling batch\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), {\n            headers: Object.assign(Object.assign({}, this.connection.headers), {\n                \"Alchemy-Ethers-Sdk-Method\": \"batchSend\"\n            })\n        });\n        const sendBatchFn = (requests)=>{\n            return web.fetchJson(batcherConnection, JSON.stringify(requests));\n        };\n        this.batcher = new RequestBatcher(sendBatchFn);\n        this.modifyFormatter();\n    }\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return index.DEFAULT_ALCHEMY_API_KEY;\n        }\n        if (apiKey && typeof apiKey !== \"string\") {\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\n        }\n        return apiKey;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyNetwork(network) {\n        if (network === undefined) {\n            return index.DEFAULT_NETWORK;\n        }\n        if (typeof network === \"number\") {\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\n        }\n        // Guaranteed that `typeof network === 'string`.\n        const isValidNetwork = Object.values(index.Network).includes(network);\n        if (!isValidNetwork) {\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` + `${Object.values(index.Network).join(\", \")}.`);\n        }\n        return network;\n    }\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyConnectionInfo(network, apiKey, type) {\n        const url = type === \"http\" ? index.getAlchemyHttpUrl(network, apiKey) : index.getAlchemyWsUrl(network, apiKey);\n        return {\n            headers: index.IS_BROWSER ? {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION\n            } : {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION,\n                \"Accept-Encoding\": \"gzip\"\n            },\n            allowGzip: true,\n            url\n        };\n    }\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */ detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: {\n                get: ()=>super.detectNetwork\n            }\n        });\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    throw new Error(\"No network detected\");\n                }\n            }\n            return network;\n        });\n    }\n    _startPending() {\n        index.logWarn(\"WARNING: Alchemy Provider does not support pending filters\");\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Add headers for `perform()` override.\n    send(method, params) {\n        return this._send(method, params, \"send\");\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */ _send(method, params, methodName, forceBatch = false) {\n        const request = {\n            method,\n            params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        // START MODIFIED CODE\n        const connection = Object.assign({}, this.connection);\n        connection.headers[\"Alchemy-Ethers-Sdk-Method\"] = methodName;\n        if (this.batchRequests || forceBatch) {\n            return this.batcher.enqueueRequest(request);\n        }\n        // END MODIFIED CODE\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: index.deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = web.fetchJson(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error,\n                request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                // @ts-ignore - This is done by ethers.\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */ modifyFormatter() {\n        this.formatter.formats[\"receiptLog\"][\"removed\"] = (val)=>{\n            if (typeof val === \"boolean\") {\n                return val;\n            }\n            return undefined;\n        };\n    }\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */ function getResult(payload) {\n    if (payload.error) {\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nexports.AlchemyProvider = AlchemyProvider; //# sourceMappingURL=alchemy-provider-7ab90821.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FsY2hlbXktcHJvdmlkZXItN2FiOTA4MjEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQztBQUN4QixJQUFJRyxNQUFNSCxtQkFBT0EsQ0FBQztBQUNsQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixpREFBaUQsR0FDakQsTUFBTUksaUNBQWlDO0FBQ3ZDLHVEQUF1RCxHQUN2RCxNQUFNQyxpQ0FBaUM7QUFDdkM7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1DO0lBQ0ZDLFlBQVlDLFdBQVcsRUFBRUMsZUFBZUwsOEJBQThCLENBQUU7UUFDcEUsSUFBSSxDQUFDSSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxFQUFFO0lBQzFCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLGVBQWVDLE9BQU8sRUFBRTtRQUNwQixPQUFPYixNQUFNYyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDekMsTUFBTUMsa0JBQWtCO2dCQUNwQkY7Z0JBQ0FHLFNBQVNDO2dCQUNUQyxRQUFRRDtZQUNaO1lBQ0EsTUFBTUUsVUFBVSxJQUFJQyxRQUFRLENBQUNKLFNBQVNFO2dCQUNsQ0gsZ0JBQWdCQyxPQUFPLEdBQUdBO2dCQUMxQkQsZ0JBQWdCRyxNQUFNLEdBQUdBO1lBQzdCO1lBQ0EsSUFBSSxDQUFDUCxZQUFZLENBQUNVLElBQUksQ0FBQ047WUFDdkIsSUFBSSxJQUFJLENBQUNKLFlBQVksQ0FBQ1cs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Q0UsT0FBTztRQUM3Q0YsTUFBTUcsSUFBSSxHQUFHSixRQUFRQyxLQUFLLENBQUNHLElBQUk7UUFDL0JILE1BQU1JLElBQUksR0FBR0wsUUFBUUMsS0FBSyxDQUFDSSxJQUFJO1FBQy9CLE1BQU1KO0lBQ1Y7SUFDQSxPQUFPRCxRQUFRRixNQUFNO0FBQ3pCO0FBRUErRSx1QkFBdUIsR0FBR3ZFLGlCQUMxQixxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FsY2hlbXktcHJvdmlkZXItN2FiOTA4MjEuanM/YzNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vaW5kZXgtNzY5ZTUyYjYuanMnKTtcbnZhciBuZXR3b3JrcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJyk7XG52YXIgcHJvdmlkZXJzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJyk7XG52YXIgd2ViID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2ViJyk7XG5yZXF1aXJlKCcuL2FwaS91dGlscycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG5yZXF1aXJlKCdheGlvcycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJyk7XG5cbi8qKiBNYXhpbXVtIHNpemUgb2YgYSBiYXRjaCBvbiB0aGUgcnBjIHByb3ZpZGVyLiAqL1xyXG5jb25zdCBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUgPSAxMDA7XHJcbi8qKiBUaW1lb3V0IGludGVydmFsIGJlZm9yZSB0aGUgcGVuZGluZyBiYXRjaCBpcyBzZW50LiAqL1xyXG5jb25zdCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMgPSAxMDtcclxuLyoqXHJcbiAqIEludGVybmFsIGNsYXNzIHRvIGVucXVldWUgcmVxdWVzdHMgYW5kIGF1dG9tYXRpY2FsbHkgc2VuZC9wcm9jZXNzIGJhdGNoZXMuXHJcbiAqXHJcbiAqIFRoZSB1bmRlcmx5aW5nIGJhdGNoaW5nIG1lY2hhbmlzbSBpcyBsb29zZWx5IGJhc2VkIG9uIGV0aGVycy5qcydzXHJcbiAqIGBKc29uUnBjQmF0Y2hQcm92aWRlcmAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUmVxdWVzdEJhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2VuZEJhdGNoRm4sIG1heEJhdGNoU2l6ZSA9IERFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSkge1xyXG4gICAgICAgIHRoaXMuc2VuZEJhdGNoRm4gPSBzZW5kQmF0Y2hGbjtcclxuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcnJheSBvZiBlbnF1ZXVlZCByZXF1ZXN0cyBhbG9uZyB3aXRoIHRoZSBjb25zdHJ1Y3RlZCBwcm9taXNlIGhhbmRsZXJzIGZvclxyXG4gICAgICAgICAqIGVhY2ggcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyB0aGUgcHJvdmlkZWQgcmVxdWVzdC4gVGhlIGJhdGNoIGlzIGltbWVkaWF0ZWx5IHNlbnQgaWYgdGhlIG1heGltdW1cclxuICAgICAqIGJhdGNoIHNpemUgaXMgcmVhY2hlZC4gT3RoZXJ3aXNlLCB0aGUgcmVxdWVzdCBpcyBlbnF1ZXVlZCBvbnRvIGEgYmF0Y2ggdGhhdFxyXG4gICAgICogaXMgc2VudCBhZnRlciAxMG1zLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2gucHVzaChpbmZsaWdodFJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQmF0Y2gubGVuZ3RoID09PSB0aGlzLm1heEJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBiYXRjaCBpbW1lZGlhdGVseSBpZiB3ZSBhcmUgYXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZS5cclxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGJhdGNoIGZvciBuZXh0IGV2ZW50IGxvb3AgKyBzaG9ydCBkdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCksIERFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBjdXJyZW50bHkgcXVldWVkIGJhdGNoZXMgYW5kIHJlc2V0cyB0aGUgYmF0Y2ggYW5kIHRpbWVyLiBQcm9jZXNzZXNcclxuICAgICAqIHRoZSBiYXRjaGVkIHJlc3BvbnNlIHJlc3VsdHMgYmFjayB0byB0aGUgb3JpZ2luYWwgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuICAgIHNlbmRCYXRjaFJlcXVlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXHJcbiAgICAgICAgICAgIC8vIGdvIGludG8gdGhlIG5leHQgYmF0Y2hcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLnBlbmRpbmdCYXRjaDtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBiYXRjaC5tYXAoaW5mbGlnaHQgPT4gaW5mbGlnaHQucmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCYXRjaEZuKHJlcXVlc3QpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcclxuICAgICAgICAgICAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaCgoaW5mbGlnaHRSZXF1ZXN0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKGluZmxpZ2h0UmVxdWVzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMuanMncyAnQWxjaGVteVByb3ZpZGVyJy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2ZcclxuICoge0BsaW5rIEFsY2hlbXl9IGFuZCBjYWxsIHtAbGluayBBbGNoZW15LmNvbmZpZy5nZXRQcm92aWRlcigpfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteVByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGxldCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnaHR0cCcpO1xyXG4gICAgICAgIC8vIElmIGEgaGFyZGNvZGVkIHVybCB3YXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgYXBpS2V5IG9yIG5ldHdvcmsuXHJcbiAgICAgICAgaWYgKGNvbmZpZy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIC8vIEFkZCB1c2VyIHByb3ZpZGVkIG92ZXJyaWRlcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgIGlmIChjb25maWcuY29ubmVjdGlvbkluZm9PdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbiksIGNvbmZpZy5jb25uZWN0aW9uSW5mb092ZXJyaWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gaW5kZXguRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IGNvbmZpZy5iYXRjaFJlcXVlc3RzO1xyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5kaXZpZHVhbCBoZWFkZXJzIHdoZW4gY2FsbGluZyBiYXRjaFxyXG4gICAgICAgIGNvbnN0IGJhdGNoZXJDb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uLmhlYWRlcnMpLCB7ICdBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJzogJ2JhdGNoU2VuZCcgfSkgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VuZEJhdGNoRm4gPSAocmVxdWVzdHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlYi5mZXRjaEpzb24oYmF0Y2hlckNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoc2VuZEJhdGNoRm4pO1xyXG4gICAgICAgIHRoaXMubW9kaWZ5Rm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFVybEpzb25ScGNQcm92aWRlci5nZXRBcGlLZXlgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieVxyXG4gICAgICogZXRoZXJzLmpzLiBSZXR1cm5zIHRoZSBBUEkga2V5IGZvciBhbiBBbGNoZW15IHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5ERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXBpS2V5ICcke2FwaUtleX0nIHByb3ZpZGVkLiBhcGlLZXkgbXVzdCBiZSBhIHN0cmluZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmtgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBvdmVycmlkZSBhbGxvd3MgdGhlIFNESyB0byBzZXQgdGhlIHByb3ZpZGVyJ3MgbmV0d29yayB0byB2YWx1ZXMgbm90XHJcbiAgICAgKiB5ZXQgc3VwcG9ydGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJyAmJiBuZXR3b3JrIGluIGluZGV4LkN1c3RvbU5ldHdvcmtzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5DdXN0b21OZXR3b3Jrc1tuZXR3b3JrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3RhbmRhcmQgZXRoZXJzLmpzIGdldE5ldHdvcmsgbWV0aG9kIGZvciBvdGhlciBuZXR3b3Jrcy5cclxuICAgICAgICByZXR1cm4gbmV0d29ya3MuZ2V0TmV0d29yayhuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGBOZXR3b3JraXNoYCBpbnB1dCB0byB0aGUgbmV0d29yayBlbnVtIHVzZWQgYnkgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlOZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAobmV0d29yayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5ERUZBVUxUX05FVFdPUks7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcmsgJyR7bmV0d29ya30nIHByb3ZpZGVkLiBOZXR3b3JrIG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdGhhdCBgdHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmdgLlxyXG4gICAgICAgIGNvbnN0IGlzVmFsaWROZXR3b3JrID0gT2JqZWN0LnZhbHVlcyhpbmRleC5OZXR3b3JrKS5pbmNsdWRlcyhuZXR3b3JrKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIG9uZSBvZjogYCArXHJcbiAgICAgICAgICAgICAgICBgJHtPYmplY3QudmFsdWVzKGluZGV4Lk5ldHdvcmspLmpvaW4oJywgJyl9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBDb25uZWN0aW9uSW5mb30gb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBldGhlcnMgdGhhdCBjb250YWluc1xyXG4gICAgICogdGhlIGNvcnJlY3QgVVJMcyBmb3IgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhuZXR3b3JrLCBhcGlLZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSB0eXBlID09PSAnaHR0cCdcclxuICAgICAgICAgICAgPyBpbmRleC5nZXRBbGNoZW15SHR0cFVybChuZXR3b3JrLCBhcGlLZXkpXHJcbiAgICAgICAgICAgIDogaW5kZXguZ2V0QWxjaGVteVdzVXJsKG5ldHdvcmssIGFwaUtleSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGVhZGVyczogaW5kZXguSVNfQlJPV1NFUlxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogaW5kZXguVkVSU0lPTlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogaW5kZXguVkVSU0lPTixcclxuICAgICAgICAgICAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXHJcbiAgICAgICAgICAgIHVybFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWV0aG9kIGluIGV0aGVycy5qcydzIGBTdGF0aWNKc29uUnBjUHJvdmlkZXJgIGNsYXNzLiBUaGlzXHJcbiAgICAgKiBtZXRob2QgaXMgY2FsbGVkIHdoZW4gY2FsbGluZyBtZXRob2RzIG9uIHRoZSBwYXJlbnQgY2xhc3MgYEJhc2VQcm92aWRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRldGVjdE5ldHdvcmsoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgICAgICAgIGRldGVjdE5ldHdvcms6IHsgZ2V0OiAoKSA9PiBzdXBlci5kZXRlY3ROZXR3b3JrIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgbmV0d29yayA9IHRoaXMubmV0d29yaztcclxuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIF9zdXBlci5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5ldHdvcmsgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9zdGFydFBlbmRpbmcoKSB7XHJcbiAgICAgICAgaW5kZXgubG9nV2FybignV0FSTklORzogQWxjaGVteSBQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVycycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gaW5kZXguREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYmFzZSB7QGxpbmsgSnNvblJwY1Byb3ZpZGVyLnNlbmR9IG1ldGhvZCB0byBpbXBsZW1lbnQgY3VzdG9tXHJcbiAgICAgKiBsb2dpYyBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogQWRkIGhlYWRlcnMgZm9yIGBwZXJmb3JtKClgIG92ZXJyaWRlLlxyXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG1ldGhvZCwgcGFyYW1zLCAnc2VuZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBKc29uUnBjUHJvdmlkZXIuc2VuZCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgY3VzdG9tIGhlYWRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3NlbmQobWV0aG9kLCBwYXJhbXMsIG1ldGhvZE5hbWUsIGZvcmNlQmF0Y2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXHJcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbik7XHJcbiAgICAgICAgY29ubmVjdGlvbi5oZWFkZXJzWydBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJ10gPSBtZXRob2ROYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoUmVxdWVzdHMgfHwgZm9yY2VCYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXRjaGVyLmVucXVldWVSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ3JlcXVlc3QnLFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBpbmRleC5kZWVwQ29weShyZXF1ZXN0KSxcclxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoaXMgaW4gdGhlIGZ1dHVyZSB0byBhbnkgY2FsbCwgYnV0IGZvciBub3cgdGhlc2VcclxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBbJ2V0aF9jaGFpbklkJywgJ2V0aF9ibG9ja051bWJlciddLmluZGV4T2YobWV0aG9kKSA+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB3ZWIuZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxyXG4gICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIGRvbmUgYnkgZXRoZXJzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2UgYEZvcm1hdHRlcmAgY2xhc3MgaW5oZXJpdGVkIGZyb20gZXRoZXJzIHRvIHN1cHBvcnRcclxuICAgICAqIHJldHVybmluZyBjdXN0b20gZmllbGRzIGluIEV0aGVycyByZXNwb25zZSB0eXBlcy5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udGV4dCwgZXRoZXJzIGhhcyBhIGBGb3JtYXR0ZXJgIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBmb3JtYXQgdGhlXHJcbiAgICAgKiByZXNwb25zZSBmcm9tIGEgSlNPTi1SUEMgcmVxdWVzdC4gQW55IGZpZWxkcyB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiB0aGVcclxuICAgICAqIGBGb3JtYXR0ZXJgIGNsYXNzIGFyZSByZW1vdmVkIGZyb20gdGhlIHJldHVybmVkIHJlc3BvbnNlLiBCeSBtb2RpZnlpbmcgdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBpbiB0aGlzIG1ldGhvZCwgd2UgY2FuIGFkZCBzdXBwb3J0IGZvciBmaWVsZHMgdGhhdCBhcmVcclxuICAgICAqIG5vdCBkZWZpbmVkIGluIGV0aGVycy5cclxuICAgICAqL1xyXG4gICAgbW9kaWZ5Rm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdHNbJ3JlY2VpcHRMb2cnXVsncmVtb3ZlZCddID0gdmFsID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzXHJcbiAqIGBAZXRoZXJzcHJvamVjdC93ZWIvc3JjLnRzL2luZGV4LnRzYC4gVXNlZCB0byBzdXBwb3J0XHJcbiAqIHtAbGluayBBbGNoZW15UHJvdmlkZXIuX3NlbmR9LCB3aGljaCBpcyBhbHNvIGNvcGllZCBvdmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcclxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XHJcbn1cblxuZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBBbGNoZW15UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXByb3ZpZGVyLTdhYjkwODIxLmpzLm1hcFxuIl0sIm5hbWVzIjpbImluZGV4IiwicmVxdWlyZSIsIm5ldHdvcmtzIiwicHJvdmlkZXJzIiwid2ViIiwiREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFIiwiREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TIiwiUmVxdWVzdEJhdGNoZXIiLCJjb25zdHJ1Y3RvciIsInNlbmRCYXRjaEZuIiwibWF4QmF0Y2hTaXplIiwicGVuZGluZ0JhdGNoIiwiZW5xdWV1ZVJlcXVlc3QiLCJyZXF1ZXN0IiwiX19hd2FpdGVyIiwiaW5mbGlnaHRSZXF1ZXN0IiwicmVzb2x2ZSIsInVuZGVmaW5lZCIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicHVzaCIsImxlbmd0aCIsInNlbmRCYXRjaFJlcXVlc3QiLCJwZW5kaW5nQmF0Y2hUaW1lciIsInNldFRpbWVvdXQiLCJiYXRjaCIsImNsZWFyVGltZW91dCIsIm1hcCIsImluZmxpZ2h0IiwidGhlbiIsInJlc3VsdCIsImZvckVhY2giLCJwYXlsb2FkIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiZGF0YSIsIkFsY2hlbXlQcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsImNvbmZpZyIsImFwaUtleSIsImdldEFwaUtleSIsImFsY2hlbXlOZXR3b3JrIiwiZ2V0QWxjaGVteU5ldHdvcmsiLCJuZXR3b3JrIiwiY29ubmVjdGlvbiIsImdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyIsInVybCIsInRocm90dGxlTGltaXQiLCJtYXhSZXRyaWVzIiwiY29ubmVjdGlvbkluZm9PdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJldGhlcnNOZXR3b3JrIiwiRXRoZXJzTmV0d29yayIsImJhdGNoUmVxdWVzdHMiLCJiYXRjaGVyQ29ubmVjdGlvbiIsImhlYWRlcnMiLCJyZXF1ZXN0cyIsImZldGNoSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJiYXRjaGVyIiwibW9kaWZ5Rm9ybWF0dGVyIiwiREVGQVVMVF9BTENIRU1ZX0FQSV9LRVkiLCJnZXROZXR3b3JrIiwiQ3VzdG9tTmV0d29ya3MiLCJERUZBVUxUX05FVFdPUksiLCJpc1ZhbGlkTmV0d29yayIsInZhbHVlcyIsIk5ldHdvcmsiLCJpbmNsdWRlcyIsImpvaW4iLCJ0eXBlIiwiZ2V0QWxjaGVteUh0dHBVcmwiLCJnZXRBbGNoZW15V3NVcmwiLCJJU19CUk9XU0VSIiwiVkVSU0lPTiIsImFsbG93R3ppcCIsImRldGVjdE5ldHdvcmsiLCJfc3VwZXIiLCJjcmVhdGUiLCJnZXQiLCJjYWxsIiwiX3N0YXJ0UGVuZGluZyIsImxvZ1dhcm4iLCJpc0NvbW11bml0eVJlc291cmNlIiwic2VuZCIsIm1ldGhvZCIsInBhcmFtcyIsIl9zZW5kIiwibWV0aG9kTmFtZSIsImZvcmNlQmF0Y2giLCJpZCIsIl9uZXh0SWQiLCJqc29ucnBjIiwiZW1pdCIsImFjdGlvbiIsImRlZXBDb3B5IiwicHJvdmlkZXIiLCJjYWNoZSIsImluZGV4T2YiLCJfY2FjaGUiLCJnZXRSZXN1bHQiLCJyZXNwb25zZSIsImZvcm1hdHRlciIsImZvcm1hdHMiLCJ2YWwiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-provider-7ab90821.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-44df3739.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-44df3739.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-769e52b6.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js\");\nvar SturdyWebSocket = __webpack_require__(/*! sturdy-websocket */ \"(ssr)/../node_modules/sturdy-websocket/dist/index.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/../node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar alchemyProvider = __webpack_require__(/*! ./alchemy-provider-7ab90821.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-provider-7ab90821.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! axios */ \"(ssr)/../node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/../node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/web */ \"(ssr)/../node_modules/@ethersproject/web/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar SturdyWebSocket__default = /*#__PURE__*/ _interopDefaultLegacy(SturdyWebSocket);\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */ const MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */ class WebsocketBackfiller {\n    constructor(provider){\n        this.provider = provider;\n        // TODO: Use HTTP provider to do backfill.\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n    }\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */ getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous heads to fetch, return new heads since\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n            if (previousHeads.length === 0) {\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted event is too far back in the past, there's no need\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n            // new heads.\n            const lastSeenBlockNumber = index.fromHex(previousHeads[previousHeads.length - 1].number);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber <= minBlockNumber) {\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n            }\n            // To capture all `newHeads` events, return all head events from the last\n            // seen block number to current + any of the previous heads that were re-orged.\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n            throwIfCancelled(isCancelled);\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n            throwIfCancelled(isCancelled);\n            return [\n                ...reorgHeads,\n                ...intermediateHeads\n            ];\n        });\n    }\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */ getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous logs to fetch, return new logs since\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n            if (previousLogs.length === 0) {\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted log is too far back in the past, there's no need\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n            // worth of logs.\n            const lastSeenBlockNumber = index.fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber < minBlockNumber) {\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n            }\n            // Return all log events that have happened along with log events that have\n            // been removed due to a chain reorg.\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n            throwIfCancelled(isCancelled);\n            // All previous logs with a block number greater than the common ancestor\n            // were part of a re-org, so mark them as such.\n            const removedLogs = previousLogs.filter((log)=>index.fromHex(log.blockNumber) > commonAncestor.blockNumber).map((log)=>Object.assign(Object.assign({}, log), {\n                    removed: true\n                }));\n            // If no common ancestor was found, start backfill from the oldest log's\n            // block number.\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? index.fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n            // De-dupe any logs that were already emitted.\n            addedLogs = addedLogs.filter((log)=>log && (index.fromHex(log.blockNumber) > commonAncestor.blockNumber || index.fromHex(log.logIndex) > commonAncestor.logIndex));\n            throwIfCancelled(isCancelled);\n            return [\n                ...removedLogs,\n                ...addedLogs\n            ];\n        });\n    }\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ setMaxBackfillBlock(newMax) {\n        this.maxBackfillBlocks = newMax;\n    }\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */ getBlockNumber() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const blockNumberHex = yield this.provider.send(\"eth_blockNumber\");\n            return index.fromHex(blockNumberHex);\n        });\n    }\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */ getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const batchParts = [];\n            for(let i = fromBlockInclusive; i < toBlockExclusive; i++){\n                batchParts.push({\n                    method: \"eth_getBlockByNumber\",\n                    params: [\n                        index.toHex(i),\n                        false\n                    ]\n                });\n            }\n            // TODO: handle errors\n            const blockHeads = yield this.provider.sendBatch(batchParts);\n            return blockHeads.map(toNewHeadsEvent);\n        });\n    }\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */ getReorgHeads(isCancelled, previousHeads) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const result = [];\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            for(let i = previousHeads.length - 1; i >= 0; i--){\n                const oldEvent = previousHeads[i];\n                const blockHead = yield this.getBlockByNumber(index.fromHex(oldEvent.number));\n                throwIfCancelled(isCancelled);\n                // If the hashes match, then current head in the iteration was not re-orged.\n                if (oldEvent.hash === blockHead.hash) {\n                    break;\n                }\n                result.push(toNewHeadsEvent(blockHead));\n            }\n            return result.reverse();\n        });\n    }\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */ getBlockByNumber(blockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return this.provider.send(\"eth_getBlockByNumber\", [\n                index.toHex(blockNumber),\n                false\n            ]);\n        });\n    }\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */ getCommonAncestor(isCancelled, previousLogs) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            let blockHead = yield this.getBlockByNumber(index.fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n            throwIfCancelled(isCancelled);\n            for(let i = previousLogs.length - 1; i >= 0; i--){\n                const oldLog = previousLogs[i];\n                // Ensure that updated blocks are fetched every time the log's block number\n                // changes.\n                if (oldLog.blockNumber !== blockHead.number) {\n                    blockHead = yield this.getBlockByNumber(index.fromHex(oldLog.blockNumber));\n                }\n                // Since logs are ordered in ascending order, the first log that matches\n                // the hash should be the largest logIndex.\n                if (oldLog.blockHash === blockHead.hash) {\n                    return {\n                        blockNumber: index.fromHex(oldLog.blockNumber),\n                        logIndex: index.fromHex(oldLog.logIndex)\n                    };\n                }\n            }\n            return {\n                blockNumber: Number.NEGATIVE_INFINITY,\n                logIndex: Number.NEGATIVE_INFINITY\n            };\n        });\n    }\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const rangeFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: index.toHex(fromBlockInclusive),\n                toBlock: index.toHex(toBlockExclusive - 1)\n            });\n            return this.provider.send(\"eth_getLogs\", [\n                rangeFilter\n            ]);\n        });\n    }\n}\nfunction toNewHeadsEvent(head) {\n    const result = Object.assign({}, head);\n    delete result.totalDifficulty;\n    delete result.transactions;\n    delete result.uncles;\n    return result;\n}\nfunction dedupeNewHeads(events) {\n    return dedupe(events, (event)=>event.hash);\n}\nfunction dedupeLogs(events) {\n    return dedupe(events, (event)=>`${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n    const keysSeen = new Set();\n    const result = [];\n    items.forEach((item)=>{\n        const key = getKey(item);\n        if (!keysSeen.has(key)) {\n            keysSeen.add(key);\n            result.push(item);\n        }\n    });\n    return result;\n}\nconst CANCELLED = new Error(\"Cancelled\");\nfunction throwIfCancelled(isCancelled) {\n    if (isCancelled()) {\n        throw CANCELLED;\n    }\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */ const RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyWebSocketProvider extends providers.WebSocketProvider {\n    /** @internal */ constructor(config, wsConstructor){\n        var _a;\n        // Normalize the API Key to a string.\n        const apiKey = alchemyProvider.AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = alchemyProvider.AlchemyProvider.getAlchemyNetwork(config.network);\n        const connection = alchemyProvider.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"wss\");\n        const protocol = `alchemy-sdk-${index.VERSION}`;\n        // Use the provided config URL override if it exists, otherwise use the created one.\n        const ws = new SturdyWebSocket__default[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n        });\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        super(ws, ethersNetwork);\n        this._events = [];\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\n        // create new ones to replace them, but we want to create the illusion that\n        // the original subscriptions persist. Thus, maintain a mapping from the\n        // \"virtual\" subscription ids which are visible to the consumer to the\n        // \"physical\" subscription ids of the actual connections. This terminology is\n        // borrowed from virtual and physical memory, which has a similar mapping.\n        /** @internal */ this.virtualSubscriptionsById = new Map();\n        /** @internal */ this.virtualIdsByPhysicalId = new Map();\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleMessage = (event)=>{\n            const message = JSON.parse(event.data);\n            if (!isSubscriptionEvent(message)) {\n                return;\n            }\n            const physicalId = message.params.subscription;\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n            if (!virtualId) {\n                return;\n            }\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\n            if (subscription.method !== \"eth_subscribe\") {\n                return;\n            }\n            switch(subscription.params[0]){\n                case \"newHeads\":\n                    {\n                        const newHeadsSubscription = subscription;\n                        const newHeadsMessage = message;\n                        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n                        const { result } = newHeadsMessage.params;\n                        if (isBackfilling) {\n                            addToNewHeadsEventsBuffer(backfillBuffer, result);\n                        } else if (physicalId !== virtualId) {\n                            // In the case of a re-opened subscription, ethers will not emit the\n                            // event, so the SDK has to.\n                            this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        } else {\n                            // Ethers subscription mapping will emit the event, just store it.\n                            this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        }\n                        break;\n                    }\n                case \"logs\":\n                    {\n                        const logsSubscription = subscription;\n                        const logsMessage = message;\n                        const { isBackfilling, backfillBuffer } = logsSubscription;\n                        const { result } = logsMessage.params;\n                        if (isBackfilling) {\n                            addToLogsEventsBuffer(backfillBuffer, result);\n                        } else if (virtualId !== physicalId) {\n                            this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n                        } else {\n                            this.rememberEvent(virtualId, result, getLogsBlockNumber);\n                        }\n                        break;\n                    }\n                default:\n                    if (physicalId !== virtualId) {\n                        // In the case of a re-opened subscription, ethers will not emit the\n                        // event, so the SDK has to.\n                        const { result } = message.params;\n                        this.emitEvent(virtualId, result);\n                    }\n            }\n        };\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleReopen = ()=>{\n            this.virtualIdsByPhysicalId.clear();\n            const { cancel, isCancelled } = makeCancelToken();\n            this.cancelBackfill = cancel;\n            for (const subscription of this.virtualSubscriptionsById.values()){\n                void (()=>index.__awaiter(this, void 0, void 0, function*() {\n                        try {\n                            yield this.resubscribeAndBackfill(isCancelled, subscription);\n                        } catch (error) {\n                            if (!isCancelled()) {\n                                console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n                            }\n                        }\n                    }))();\n            }\n            this.startHeartbeat();\n        };\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.stopHeartbeatAndBackfill = ()=>{\n            if (this.heartbeatIntervalId != null) {\n                clearInterval(this.heartbeatIntervalId);\n                this.heartbeatIntervalId = undefined;\n            }\n            this.cancelBackfill();\n        };\n        this.apiKey = apiKey;\n        // Start heartbeat and backfiller for the websocket connection.\n        this.backfiller = new WebsocketBackfiller(this);\n        this.addSocketListeners();\n        this.startHeartbeat();\n        this.cancelBackfill = index.noop;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */ off(eventName, listener) {\n        if (index.isAlchemyEvent(eventName)) {\n            return this._off(eventName, listener);\n        } else {\n            return super.off(eventName, listener);\n        }\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._removeAllListeners(eventName);\n        } else {\n            return super.removeAllListeners(eventName);\n        }\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */ listenerCount(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listenerCount(eventName);\n        } else {\n            return super.listenerCount(eventName);\n        }\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */ listeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listeners(eventName);\n        } else {\n            return super.listeners(eventName);\n        }\n    }\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _addEventListener(eventName, listener, once) {\n        if (index.isAlchemyEvent(eventName)) {\n            index.verifyAlchemyEventName(eventName);\n            const event = new index.EthersEvent(index.getAlchemyEventTag(eventName), listener, once);\n            this._events.push(event);\n            this._startEvent(event);\n            return this;\n        } else {\n            return super._addEventListener(eventName, listener, once);\n        }\n    }\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */ _startEvent(event) {\n        // Check if the event type is a custom Alchemy subscription.\n        const customLogicTypes = [\n            ...index.ALCHEMY_EVENT_TYPES,\n            \"block\",\n            \"filter\"\n        ];\n        if (customLogicTypes.includes(event.type)) {\n            this.customStartEvent(event);\n        } else {\n            super._startEvent(event);\n        }\n    }\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _subscribe(tag, param, processFunc, event) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            // BEGIN MODIFIED CODE\n            const startingBlockNumber = yield this.getBlockNumber();\n            // END MODIFIED CODE\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            // BEGIN MODIFIED CODE\n            const resolvedParams = yield Promise.all(param);\n            this.virtualSubscriptionsById.set(subId, {\n                event: event,\n                method: \"eth_subscribe\",\n                params: resolvedParams,\n                startingBlockNumber,\n                virtualId: subId,\n                physicalId: subId,\n                sentEvents: [],\n                isBackfilling: false,\n                backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(subId, subId);\n            // END MODIFIED CODE\n            this._subs[subId] = {\n                tag,\n                processFunc\n            };\n        });\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ emit(eventName, ...args) {\n        if (index.isAlchemyEvent(eventName)) {\n            let result = false;\n            const stopped = [];\n            // This line is the only modified line from the original method.\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                setTimeout(()=>{\n                    event.listener.apply(this, args);\n                }, 0);\n                result = true;\n                if (event.once) {\n                    stopped.push(event);\n                    return false;\n                }\n                return true;\n            });\n            stopped.forEach((event)=>{\n                this._stopEvent(event);\n            });\n            return result;\n        } else {\n            return super.emit(eventName, ...args);\n        }\n    }\n    /** @internal */ sendBatch(parts) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let nextId = 0;\n            const payload = parts.map(({ method, params })=>{\n                return {\n                    method,\n                    params,\n                    jsonrpc: \"2.0\",\n                    id: `alchemy-sdk:${nextId++}`\n                };\n            });\n            return this.sendBatchConcurrently(payload);\n        });\n    }\n    /** @override */ destroy() {\n        this.removeSocketListeners();\n        this.stopHeartbeatAndBackfill();\n        return super.destroy();\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */ _stopEvent(event) {\n        let tag = event.tag;\n        // START MODIFIED CODE\n        if (index.ALCHEMY_EVENT_TYPES.includes(event.type)) {\n            // There are remaining pending transaction listeners.\n            if (this._events.filter((e)=>index.ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\n                return;\n            }\n        // END MODIFIED CODE\n        } else if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        void subId.then((subId)=>{\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            void this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    /** @internal */ addSocketListeners() {\n        this._websocket.addEventListener(\"message\", this.handleMessage);\n        this._websocket.addEventListener(\"reopen\", this.handleReopen);\n        this._websocket.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /** @internal */ removeSocketListeners() {\n        this._websocket.removeEventListener(\"message\", this.handleMessage);\n        this._websocket.removeEventListener(\"reopen\", this.handleReopen);\n        this._websocket.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */ resubscribeAndBackfill(isCancelled, subscription) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            try {\n                const physicalId = yield this.send(method, params);\n                throwIfCancelled(isCancelled);\n                subscription.physicalId = physicalId;\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n                switch(params[0]){\n                    case \"newHeads\":\n                        {\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeNewHeads([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitNewHeadsEvent(virtualId, event));\n                            break;\n                        }\n                    case \"logs\":\n                        {\n                            const filter = params[1] || {};\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeLogs([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitLogsEvent(virtualId, event));\n                            break;\n                        }\n                    default:\n                        break;\n                }\n            } finally{\n                subscription.isBackfilling = false;\n                backfillBuffer.length = 0;\n            }\n        });\n    }\n    /** @internal */ emitNewHeadsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n    }\n    /** @internal */ emitLogsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n    }\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */ emitAndRememberEvent(virtualId, result, getBlockNumber) {\n        this.rememberEvent(virtualId, result, getBlockNumber);\n        this.emitEvent(virtualId, result);\n    }\n    emitEvent(virtualId, result) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        this.emitGenericEvent(subscription, result);\n    }\n    /** @internal */ rememberEvent(virtualId, result, getBlockNumber) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        // Web3 modifies these event objects once we pass them on (changing hex\n        // numbers to numbers). We want the original event, so make a defensive\n        // copy.\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n    }\n    /** @internal */ emitGenericEvent(subscription, result) {\n        const emitFunction = this.emitProcessFn(subscription.event);\n        emitFunction(result);\n    }\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */ startHeartbeat() {\n        if (this.heartbeatIntervalId != null) {\n            return;\n        }\n        this.heartbeatIntervalId = setInterval(()=>index.__awaiter(this, void 0, void 0, function*() {\n                try {\n                    yield withTimeout(this.send(\"net_version\"), HEARTBEAT_WAIT_TIME);\n                } catch (_a) {\n                    this._websocket.reconnect();\n                }\n            }), HEARTBEAT_INTERVAL);\n    }\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */ // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n    // TODO(errors): Use allSettled() once we have more error handling.\n    sendBatchConcurrently(payload) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return Promise.all(payload.map((req)=>this.send(req.method, req.params)));\n        });\n    }\n    /** @internal */ customStartEvent(event) {\n        if (event.type === index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            const { fromAddress, toAddress, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.PENDING_TRANSACTIONS,\n                {\n                    fromAddress,\n                    toAddress,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            const { addresses, includeRemoved, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.MINED_TRANSACTIONS,\n                {\n                    addresses,\n                    includeRemoved,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"block\") {\n            void this._subscribe(\"block\", [\n                \"newHeads\"\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"filter\") {\n            void this._subscribe(event.tag, [\n                \"logs\",\n                this._getFilter(event.filter)\n            ], this.emitProcessFn(event), event);\n        }\n    }\n    /** @internal */ emitProcessFn(event) {\n        switch(event.type){\n            case index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.PENDING_TRANSACTIONS,\n                        fromAddress: event.fromAddress,\n                        toAddress: event.toAddress,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.MINED_TRANSACTIONS,\n                        addresses: event.addresses,\n                        includeRemoved: event.includeRemoved,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case \"block\":\n                return (result)=>{\n                    const blockNumber = bignumber.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                };\n            case \"filter\":\n                return (result)=>{\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                };\n            default:\n                throw new Error(\"Invalid event type to `emitProcessFn()`\");\n        }\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        const eventTag = index.getAlchemyEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n}\nfunction getWebsocketConstructor() {\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"(ssr)/../node_modules/websocket/index.js\").w3cwebsocket) : WebSocket;\n}\nfunction isNodeEnvironment() {\n    return typeof process !== \"undefined\" && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n    let cancelled = false;\n    return {\n        cancel: ()=>cancelled = true,\n        isCancelled: ()=>cancelled\n    };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount, shouldRetry = ()=>true) {\n    return index.__awaiter(this, void 0, void 0, function*() {\n        let nextWaitTime = 0;\n        let i = 0;\n        while(true){\n            try {\n                return yield f();\n            } catch (error) {\n                i++;\n                if (i >= retryCount || !shouldRetry(error)) {\n                    throw error;\n                }\n                yield delay(nextWaitTime);\n                if (!shouldRetry(error)) {\n                    throw error;\n                }\n                nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n            }\n        }\n    });\n}\nfunction delay(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), ms))\n    ]);\n}\nfunction getNewHeadsBlockNumber(event) {\n    return index.fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n    return index.fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n    return Array.isArray(message) || message.jsonrpc === \"2.0\" && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n    return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */ function addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n    const currentBlockNumber = getBlockNumber(event);\n    // Find first index of an event recent enough to retain, then drop everything\n    // at a lower index.\n    const firstGoodIndex = pastEvents.findIndex((e)=>getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n    if (firstGoodIndex === -1) {\n        pastEvents.length = 0;\n    } else {\n        pastEvents.splice(0, firstGoodIndex);\n    }\n    pastEvents.push(event);\n}\nexports.AlchemyWebSocketProvider = AlchemyWebSocketProvider; //# sourceMappingURL=alchemy-websocket-provider-44df3739.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLTQ0ZGYzNzM5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QixJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQztBQUN4QixJQUFJRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJSSxZQUFZSixtQkFBT0EsQ0FBQztBQUN4QixJQUFJSyxrQkFBa0JMLG1CQUFPQSxDQUFDO0FBQzlCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLFNBQVNNLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsMkJBQTJCLFdBQVcsR0FBRUYsc0JBQXNCTDtBQUVsRTs7OztDQUlDLEdBQ0QsTUFBTVEsc0JBQXNCO0FBQzVCOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUM7SUFDRkMsWUFBWUMsUUFBUSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNoQiwwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0o7SUFDN0I7SUFDQTs7Ozs7OztLQU9DLEdBQ0RLLG9CQUFvQkMsV0FBVyxFQUFFQyxhQUFhLEVBQUVDLGVBQWUsRUFBRTtRQUM3RCxPQUFPbEIsTUFBTW1CLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUN6Q0MsaUJBQWlCSjtZQUNqQixNQUFNSyxnQkFBZ0IsTUFBTSxJQUFJLENBQUNDLGNBQWM7WUFDL0NGLGlCQUFpQko7WUFD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Q3ZCO0FBQ0EsU0FBU2EsMEJBQTBCOEksVUFBVSxFQUFFdE0sS0FBSztJQUNoRG9KLHNCQUFzQmtELFlBQVl0TSxPQUFPMEQ7QUFDN0M7QUFDQSxTQUFTSSxzQkFBc0J3SSxVQUFVLEVBQUV0TSxLQUFLO0lBQzVDb0osc0JBQXNCa0QsWUFBWXRNLE9BQU8rRDtBQUM3QztBQUNBOzs7Q0FHQyxHQUNELFNBQVNxRixzQkFBc0JrRCxVQUFVLEVBQUV0TSxLQUFLLEVBQUU5RCxjQUFjO0lBQzVELE1BQU1xUSxxQkFBcUJyUSxlQUFlOEQ7SUFDMUMsNkVBQTZFO0lBQzdFLG9CQUFvQjtJQUNwQixNQUFNd00saUJBQWlCRixXQUFXRyxTQUFTLENBQUNyUixDQUFBQSxJQUFLYyxlQUFlZCxLQUFLbVIscUJBQXFCdEw7SUFDMUYsSUFBSXVMLG1CQUFtQixDQUFDLEdBQUc7UUFDdkJGLFdBQVduUSxNQUFNLEdBQUc7SUFDeEIsT0FDSztRQUNEbVEsV0FBV0ksTUFBTSxDQUFDLEdBQUdGO0lBQ3pCO0lBQ0FGLFdBQVcvTixJQUFJLENBQUN5QjtBQUNwQjtBQUVBMk0sZ0NBQWdDLEdBQUd6TCwwQkFDbkMsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2Nqcy9hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci00NGRmMzczOS5qcz85YmEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC03NjllNTJiNi5qcycpO1xudmFyIFN0dXJkeVdlYlNvY2tldCA9IHJlcXVpcmUoJ3N0dXJkeS13ZWJzb2NrZXQnKTtcbnZhciBiaWdudW1iZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnZhciBuZXR3b3JrcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJyk7XG52YXIgcHJvdmlkZXJzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJyk7XG52YXIgYWxjaGVteVByb3ZpZGVyID0gcmVxdWlyZSgnLi9hbGNoZW15LXByb3ZpZGVyLTdhYjkwODIxLmpzJyk7XG5yZXF1aXJlKCcuL2FwaS91dGlscycpO1xucmVxdWlyZSgnYXhpb3MnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93YWxsZXQnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2ViJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgU3R1cmR5V2ViU29ja2V0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShTdHVyZHlXZWJTb2NrZXQpO1xuXG4vKipcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJsb2NrcyB0byBiYWNrZmlsbC4gSWYgbW9yZSB0aGFuIHRoaXMgbWFueSBibG9ja3MgaGF2ZVxyXG4gKiBiZWVuIG1pc3NlZCwgdGhlbiB3ZSdsbCBzYWRseSBtaXNzIGRhdGEsIGJ1dCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBkb24ndFxyXG4gKiBlbmQgdXAgcmVxdWVzdGluZyB0aG91c2FuZHMgb2YgYmxvY2tzIGlmIHNvbWVib2R5IGxlZnQgdGhlaXIgbGFwdG9wIGNsb3NlZCBmb3IgYSB3ZWVrLlxyXG4gKi9cclxuY29uc3QgTUFYX0JBQ0tGSUxMX0JMT0NLUyA9IDEyMDtcclxuLyoqXHJcbiAqIFRoZSBXZWJzb2NrZXRCYWNrZmlsbGVyIGZldGNoZXMgZXZlbnRzIHRoYXQgd2VyZSBzZW50IHNpbmNlIGEgcHJvdmlkZWQgYmxvY2tcclxuICogbnVtYmVyLiBUaGlzIGlzIHVzZWQgaW4gdGhlIHtAbGluayBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXJ9IHRvIGJhY2tmaWxsXHJcbiAqIGV2ZW50cyB0aGF0IHdlcmUgdHJhbnNtaXR0ZWQgd2hpbGUgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkb3duLlxyXG4gKlxyXG4gKiBUaGUgYmFja2ZpbGxlciBiYWNrZmlsbHMgdHdvIG1haW4gZXRoX3N1YnNjcmliZSBldmVudHM6IGBsb2dzYCBhbmQgYG5ld0hlYWRzYC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBXZWJzb2NrZXRCYWNrZmlsbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIC8vIFRPRE86IFVzZSBIVFRQIHByb3ZpZGVyIHRvIGRvIGJhY2tmaWxsLlxyXG4gICAgICAgIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgPSBNQVhfQkFDS0ZJTExfQkxPQ0tTO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGJhY2tmaWxsIGZvciBgbmV3SGVhZHNgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNIZWFkcyBQcmV2aW91cyBoZWFkIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgYG5ld0hlYWRzYCBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgdGhlIGxhc3QgYmFja2ZpbGwuXHJcbiAgICAgKi9cclxuICAgIGdldE5ld0hlYWRzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGhlYWRzIHRvIGZldGNoLCByZXR1cm4gbmV3IGhlYWRzIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIGBmcm9tQmxvY2tOdW1iZXJgLCBvciB1cCB0byBtYXhCYWNrZmlsbEJsb2NrcyBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0hlYWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZEV2ZW50c0luUmFuZ2UoTWF0aC5tYXgoZnJvbUJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcykgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZW1pdHRlZCBldmVudCBpcyB0b28gZmFyIGJhY2sgaW4gdGhlIHBhc3QsIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBiYWNrZmlsbCBmb3IgcmVvcmdzLiBKdXN0IGZldGNoIHRoZSBsYXN0IGBtYXhCYWNrZmlsbEJsb2Nrc2Agd29ydGggb2ZcclxuICAgICAgICAgICAgLy8gbmV3IGhlYWRzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gaW5kZXguZnJvbUhleChwcmV2aW91c0hlYWRzW3ByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMV0ubnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDw9IG1pbkJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShtaW5CbG9ja051bWJlciwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRvIGNhcHR1cmUgYWxsIGBuZXdIZWFkc2AgZXZlbnRzLCByZXR1cm4gYWxsIGhlYWQgZXZlbnRzIGZyb20gdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gc2VlbiBibG9jayBudW1iZXIgdG8gY3VycmVudCArIGFueSBvZiB0aGUgcHJldmlvdXMgaGVhZHMgdGhhdCB3ZXJlIHJlLW9yZ2VkLlxyXG4gICAgICAgICAgICBjb25zdCByZW9yZ0hlYWRzID0geWllbGQgdGhpcy5nZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUhlYWRzID0geWllbGQgdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShsYXN0U2VlbkJsb2NrTnVtYmVyICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5yZW9yZ0hlYWRzLCAuLi5pbnRlcm1lZGlhdGVIZWFkc107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBsb2dzYCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkIFdoZXRoZXIgdGhlIGJhY2tmaWxsIHJlcXVlc3QgaXMgY2FuY2VsbGVkLlxyXG4gICAgICogQHBhcmFtIGZpbHRlciBUaGUgZmlsdGVyIG9iamVjdCB0aGF0IGFjY29tcGFuaWVzIGEgbG9ncyBzdWJzY3JpcHRpb24uXHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNMb2dzIFByZXZpb3VzIGxvZyByZXF1ZXN0cyB0aGF0IHdlcmUgc2VudC5cclxuICAgICAqIEBwYXJhbSBmcm9tQmxvY2tOdW1iZXIgVGhlIGJsb2NrIG51bWJlciB0byBzdGFydCBiYWNrZmlsbGluZyBmcm9tLlxyXG4gICAgICovXHJcbiAgICBnZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlciwgcHJldmlvdXNMb2dzLCBmcm9tQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgdG9CbG9ja051bWJlciA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwcmV2aW91cyBsb2dzIHRvIGZldGNoLCByZXR1cm4gbmV3IGxvZ3Mgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIGBtYXhCYWNrZmlsbEJsb2Nrc2AgZnJvbSB0aGUgY3VycmVudCBoZWFkLlxyXG4gICAgICAgICAgICBpZiAocHJldmlvdXNMb2dzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGxvZyBpcyB0b28gZmFyIGJhY2sgaW4gdGhlIHBhc3QsIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBiYWNrZmlsbCBmb3IgcmVtb3ZlZCBsb2dzLiBKdXN0IGZldGNoIHRoZSBsYXN0IGBtYXhCYWNrZmlsbEJsb2Nrc2BcclxuICAgICAgICAgICAgLy8gd29ydGggb2YgbG9ncy5cclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlZW5CbG9ja051bWJlciA9IGluZGV4LmZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbkJsb2NrTnVtYmVyID0gdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgKyAxO1xyXG4gICAgICAgICAgICBpZiAobGFzdFNlZW5CbG9ja051bWJlciA8IG1pbkJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBsb2cgZXZlbnRzIHRoYXQgaGF2ZSBoYXBwZW5lZCBhbG9uZyB3aXRoIGxvZyBldmVudHMgdGhhdCBoYXZlXHJcbiAgICAgICAgICAgIC8vIGJlZW4gcmVtb3ZlZCBkdWUgdG8gYSBjaGFpbiByZW9yZy5cclxuICAgICAgICAgICAgY29uc3QgY29tbW9uQW5jZXN0b3IgPSB5aWVsZCB0aGlzLmdldENvbW1vbkFuY2VzdG9yKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gQWxsIHByZXZpb3VzIGxvZ3Mgd2l0aCBhIGJsb2NrIG51bWJlciBncmVhdGVyIHRoYW4gdGhlIGNvbW1vbiBhbmNlc3RvclxyXG4gICAgICAgICAgICAvLyB3ZXJlIHBhcnQgb2YgYSByZS1vcmcsIHNvIG1hcmsgdGhlbSBhcyBzdWNoLlxyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkTG9ncyA9IHByZXZpb3VzTG9nc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihsb2cgPT4gaW5kZXguZnJvbUhleChsb2cuYmxvY2tOdW1iZXIpID4gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICAubWFwKGxvZyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2cpLCB7IHJlbW92ZWQ6IHRydWUgfSkpKTtcclxuICAgICAgICAgICAgLy8gSWYgbm8gY29tbW9uIGFuY2VzdG9yIHdhcyBmb3VuZCwgc3RhcnQgYmFja2ZpbGwgZnJvbSB0aGUgb2xkZXN0IGxvZydzXHJcbiAgICAgICAgICAgIC8vIGJsb2NrIG51bWJlci5cclxuICAgICAgICAgICAgY29uc3QgZnJvbUJsb2NrSW5jbHVzaXZlID0gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gICAgICAgICAgICAgICAgPyBpbmRleC5mcm9tSGV4KHByZXZpb3VzTG9nc1swXS5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIDogY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBhZGRlZExvZ3MgPSB5aWVsZCB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgZnJvbUJsb2NrSW5jbHVzaXZlLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIC8vIERlLWR1cGUgYW55IGxvZ3MgdGhhdCB3ZXJlIGFscmVhZHkgZW1pdHRlZC5cclxuICAgICAgICAgICAgYWRkZWRMb2dzID0gYWRkZWRMb2dzLmZpbHRlcihsb2cgPT4gbG9nICYmXHJcbiAgICAgICAgICAgICAgICAoaW5kZXguZnJvbUhleChsb2cuYmxvY2tOdW1iZXIpID4gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleC5mcm9tSGV4KGxvZy5sb2dJbmRleCkgPiBjb21tb25BbmNlc3Rvci5sb2dJbmRleCkpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5yZW1vdmVkTG9ncywgLi4uYWRkZWRMb2dzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIG5ldyBtYXggYmFja2ZpbGwgYmxvY2tzLiBWSVNJQkxFIE9OTFkgRk9SIFRFU1RJTkcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHNldE1heEJhY2tmaWxsQmxvY2sobmV3TWF4KSB7XHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IG5ld01heDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBibG9jayBudW1iZXIgYXMgYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9ibG9ja051bWJlcicpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXguZnJvbUhleChibG9ja051bWJlckhleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGBuZXdIZWFkYCBldmVudHMgaW4gdGhlIHByb3ZpZGVkIHJhbmdlLiBOb3RlIHRoYXQgdGhlIHJldHVybmVkXHJcbiAgICAgKiBoZWFkcyBkbyBub3QgaW5jbHVkZSByZS1vcmdlZCBoZWFkcy4gVXNlIHtAbGluayBnZXRSZW9yZ0hlYWRzfSB0byBmaW5kIGhlYWRzXHJcbiAgICAgKiB0aGF0IHdlcmUgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRIZWFkRXZlbnRzSW5SYW5nZShmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSW5jbHVzaXZlID49IHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiYXRjaFBhcnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmxvY2tJbmNsdXNpdmU7IGkgPCB0b0Jsb2NrRXhjbHVzaXZlOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoUGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2luZGV4LnRvSGV4KGkpLCBmYWxzZV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvcnNcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWFkcyA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZEJhdGNoKGJhdGNoUGFydHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2tIZWFkcy5tYXAodG9OZXdIZWFkc0V2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgaGVhZHMgdGhhdCB3ZXJlIHBhcnQgb2YgYSByZW9yZyBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgZnJvbSB0aGUgbW9zdCByZWNlbnQgaGVhZCBiYWNrd2FyZHMgaW4gb3JkZXIgdG8gZmluZCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgLy8gYmxvY2sgdGhhdCB3YXMgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50ID0gcHJldmlvdXNIZWFkc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihpbmRleC5mcm9tSGV4KG9sZEV2ZW50Lm51bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGFzaGVzIG1hdGNoLCB0aGVuIGN1cnJlbnQgaGVhZCBpbiB0aGUgaXRlcmF0aW9uIHdhcyBub3QgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkRXZlbnQuaGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvTmV3SGVhZHNFdmVudChibG9ja0hlYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGBldGhfZ2V0QmxvY2tCeU51bWJlcmAgdGhhdCByZXR1cm5zIHRoZSBjb21wbGV0ZVxyXG4gICAgICogYmxvY2sgaW5mb3JtYXRpb24gZm9yIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgW1xyXG4gICAgICAgICAgICAgICAgaW5kZXgudG9IZXgoYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgZmFsc2VcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBwcmV2aW91cyBsb2cgZXZlbnRzLCBmaW5kcyB0aGUgY29tbW9uIGJsb2NrIG51bWJlciBmcm9tIHRoZVxyXG4gICAgICogbG9ncyB0aGF0IG1hdGNoZXMgdGhlIGJsb2NrIGhlYWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB3aGljaCBsb2dzIGFyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgMSBsZXNzIHRoYW4gdGhlIG9sZGVzdCBsb2cncyBibG9jayBudW1iZXIgaWYgbm8gY29tbW9uIGFuY2VzdG9yIHdhcyBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRDb21tb25BbmNlc3Rvcihpc0NhbmNlbGxlZCwgcHJldmlvdXNMb2dzKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBsZXQgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGluZGV4LmZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzTG9ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTG9nID0gcHJldmlvdXNMb2dzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdXBkYXRlZCBibG9ja3MgYXJlIGZldGNoZWQgZXZlcnkgdGltZSB0aGUgbG9nJ3MgYmxvY2sgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZExvZy5ibG9ja051bWJlciAhPT0gYmxvY2tIZWFkLm51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihpbmRleC5mcm9tSGV4KG9sZExvZy5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgbG9ncyBhcmUgb3JkZXJlZCBpbiBhc2NlbmRpbmcgb3JkZXIsIHRoZSBmaXJzdCBsb2cgdGhhdCBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaGFzaCBzaG91bGQgYmUgdGhlIGxhcmdlc3QgbG9nSW5kZXguXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrSGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogaW5kZXguZnJvbUhleChvbGRMb2cuYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dJbmRleDogaW5kZXguZnJvbUhleChvbGRMb2cubG9nSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYGxvZ3NgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWQgbG9nc1xyXG4gICAgICogZG8gbm90IGluY2x1ZGUgcmVtb3ZlZCBsb2dzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi8gZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSW5jbHVzaXZlID49IHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUZpbHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyKSwgeyBmcm9tQmxvY2s6IGluZGV4LnRvSGV4KGZyb21CbG9ja0luY2x1c2l2ZSksIHRvQmxvY2s6IGluZGV4LnRvSGV4KHRvQmxvY2tFeGNsdXNpdmUgLSAxKSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldExvZ3MnLCBbcmFuZ2VGaWx0ZXJdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b05ld0hlYWRzRXZlbnQoaGVhZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZCk7XHJcbiAgICBkZWxldGUgcmVzdWx0LnRvdGFsRGlmZmljdWx0eTtcclxuICAgIGRlbGV0ZSByZXN1bHQudHJhbnNhY3Rpb25zO1xyXG4gICAgZGVsZXRlIHJlc3VsdC51bmNsZXM7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZU5ld0hlYWRzKGV2ZW50cykge1xyXG4gICAgcmV0dXJuIGRlZHVwZShldmVudHMsIGV2ZW50ID0+IGV2ZW50Lmhhc2gpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZUxvZ3MoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gYCR7ZXZlbnQuYmxvY2tIYXNofS8ke2V2ZW50LmxvZ0luZGV4fWApO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZShpdGVtcywgZ2V0S2V5KSB7XHJcbiAgICBjb25zdCBrZXlzU2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaXRlbSk7XHJcbiAgICAgICAgaWYgKCFrZXlzU2Vlbi5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICBrZXlzU2Vlbi5hZGQoa2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IENBTkNFTExFRCA9IG5ldyBFcnJvcignQ2FuY2VsbGVkJyk7XHJcbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpIHtcclxuICAgIGlmIChpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgdGhyb3cgQ0FOQ0VMTEVEO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEhFQVJUQkVBVF9JTlRFUlZBTCA9IDMwMDAwO1xyXG5jb25zdCBIRUFSVEJFQVRfV0FJVF9USU1FID0gMTAwMDA7XHJcbmNvbnN0IEJBQ0tGSUxMX1RJTUVPVVQgPSA2MDAwMDtcclxuY29uc3QgQkFDS0ZJTExfUkVUUklFUyA9IDU7XHJcbi8qKlxyXG4gKiBTdWJzY3JpcHRpb25zIGhhdmUgYSBtZW1vcnkgb2YgcmVjZW50IGV2ZW50cyB0aGV5IGhhdmUgc2VudCBzbyB0aGF0IGluIHRoZVxyXG4gKiBldmVudCB0aGF0IHRoZXkgZGlzY29ubmVjdCBhbmQgbmVlZCB0byBiYWNrZmlsbCwgdGhleSBjYW4gZGV0ZWN0IHJlLW9yZ3MuXHJcbiAqIEtlZXAgYSBidWZmZXIgdGhhdCBnb2VzIGJhY2sgYXQgbGVhc3QgdGhlc2UgbWFueSBibG9ja3MsIHRoZSBtYXhpbXVtIGFtb3VudFxyXG4gKiBhdCB3aGljaCB3ZSBtaWdodCBjb25jZWl2YWJseSBzZWUgYSByZS1vcmcuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBvdXIgYnVmZmVyIGdvZXMgYmFjayB0aGlzIG1hbnkgYmxvY2tzLCBpdCBtYXkgY29udGFpbiBtb3JlXHJcbiAqIHRoYW4gdGhpcyBtYW55IGVsZW1lbnRzLCBzaW5jZSBpbiB0aGUgY2FzZSBvZiBsb2dzIHN1YnNjcmlwdGlvbnMgbW9yZSB0aGFuXHJcbiAqIG9uZSBldmVudCBtYXkgYmUgZW1pdHRlZCBmb3IgYSBibG9jay5cclxuICovXHJcbmNvbnN0IFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UID0gMTA7XHJcbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gZm8gdGhlIGV0aGVycy5qcydzICdBbGNoZW15V2ViU29ja2V0UHJvdmlkZXInLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZlxyXG4gKiB7QGxpbmsgQWxjaGVteX0gYW5kIGNhbGwge0BsaW5rIEFsY2hlbXkuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCl9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcnMuV2ViU29ja2V0UHJvdmlkZXIge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCB3c0NvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQVBJIEtleSB0byBhIHN0cmluZy5cclxuICAgICAgICBjb25zdCBhcGlLZXkgPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlOZXR3b3JrKGNvbmZpZy5uZXR3b3JrKTtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYWxjaGVteVByb3ZpZGVyLkFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15Q29ubmVjdGlvbkluZm8oYWxjaGVteU5ldHdvcmssIGFwaUtleSwgJ3dzcycpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gYGFsY2hlbXktc2RrLSR7aW5kZXguVkVSU0lPTn1gO1xyXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgY29uZmlnIFVSTCBvdmVycmlkZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIGNyZWF0ZWQgb25lLlxyXG4gICAgICAgIGNvbnN0IHdzID0gbmV3IFN0dXJkeVdlYlNvY2tldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oKF9hID0gY29uZmlnLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29ubmVjdGlvbi51cmwsIHByb3RvY29sLCB7XHJcbiAgICAgICAgICAgIHdzQ29uc3RydWN0b3I6IHdzQ29uc3RydWN0b3IgIT09IG51bGwgJiYgd3NDb25zdHJ1Y3RvciAhPT0gdm9pZCAwID8gd3NDb25zdHJ1Y3RvciA6IGdldFdlYnNvY2tldENvbnN0cnVjdG9yKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFsY2hlbXkgbmFtZWQgbmV0d29yayBpbnB1dCB0byB0aGUgbmV0d29yayBuYW1lcyB1c2VkIGJ5XHJcbiAgICAgICAgLy8gZXRoZXJzLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IHN1cGVyIGNvbnN0cnVjdG9yIGluIEpzb25ScGNQcm92aWRlciB0b1xyXG4gICAgICAgIC8vIGNvcnJlY3RseSBzZXQgdGhlIG5ldHdvcmsuXHJcbiAgICAgICAgY29uc3QgZXRoZXJzTmV0d29yayA9IGluZGV4LkV0aGVyc05ldHdvcmtbYWxjaGVteU5ldHdvcmtdO1xyXG4gICAgICAgIHN1cGVyKHdzLCBldGhlcnNOZXR3b3JrKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcclxuICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIFdlYlNvY2tldCByZWNvbm5lY3Rpb24sIGFsbCBzdWJzY3JpcHRpb25zIGFyZSBsb3N0IGFuZCB3ZVxyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb25lcyB0byByZXBsYWNlIHRoZW0sIGJ1dCB3ZSB3YW50IHRvIGNyZWF0ZSB0aGUgaWxsdXNpb24gdGhhdFxyXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBzdWJzY3JpcHRpb25zIHBlcnNpc3QuIFRodXMsIG1haW50YWluIGEgbWFwcGluZyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIFwidmlydHVhbFwiIHN1YnNjcmlwdGlvbiBpZHMgd2hpY2ggYXJlIHZpc2libGUgdG8gdGhlIGNvbnN1bWVyIHRvIHRoZVxyXG4gICAgICAgIC8vIFwicGh5c2ljYWxcIiBzdWJzY3JpcHRpb24gaWRzIG9mIHRoZSBhY3R1YWwgY29ubmVjdGlvbnMuIFRoaXMgdGVybWlub2xvZ3kgaXNcclxuICAgICAgICAvLyBib3Jyb3dlZCBmcm9tIHZpcnR1YWwgYW5kIHBoeXNpY2FsIG1lbW9yeSwgd2hpY2ggaGFzIGEgc2ltaWxhciBtYXBwaW5nLlxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGV0aGVycyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9IGFscmVhZHkgaGFuZGxlcyBhbmQgZW1pdHNcclxuICAgICAgICAgKiBtZXNzYWdlcy4gVG8gYWxsb3cgYmFja2ZpbGxpbmcsIHRyYWNrIGFsbCBtZXNzYWdlcyB0aGF0IGFyZSBlbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICghaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBoeXNpY2FsSWQgPSBtZXNzYWdlLnBhcmFtcy5zdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJZCA9IHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5nZXQocGh5c2ljYWxJZCk7XHJcbiAgICAgICAgICAgIGlmICghdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ubWV0aG9kICE9PSAnZXRoX3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5wYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc0JhY2tmaWxsaW5nLCBiYWNrZmlsbEJ1ZmZlciB9ID0gbmV3SGVhZHNTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IG5ld0hlYWRzTWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFja2ZpbGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxJZCAhPT0gdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcmUtb3BlbmVkIHN1YnNjcmlwdGlvbiwgZXRoZXJzIHdpbGwgbm90IGVtaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LCBzbyB0aGUgU0RLIGhhcyB0by5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdGhlcnMgc3Vic2NyaXB0aW9uIG1hcHBpbmcgd2lsbCBlbWl0IHRoZSBldmVudCwganVzdCBzdG9yZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2dzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3NTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nc01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgfSA9IGxvZ3NTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGxvZ3NNZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0xvZ3NFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZpcnR1YWxJZCAhPT0gcGh5c2ljYWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBoeXNpY2FsSWQgIT09IHZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIHJlLW9wZW5lZCBzdWJzY3JpcHRpb24sIGV0aGVycyB3aWxsIG5vdCBlbWl0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudCwgc28gdGhlIFNESyBoYXMgdG8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBtZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gcmVvcGVuczpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDEuIFJlc3Vic2NyaWJlIHRvIGFsbCBleGlzdGluZyBzdWJzY3JpcHRpb25zIGFuZCBzdGFydCBiYWNrZmlsbGluZ1xyXG4gICAgICAgICAqIDIuIFJlc3RhcnQgaGVhcnQgYmVhdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZW9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5jbGVhcigpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbmNlbCwgaXNDYW5jZWxsZWQgfSA9IG1ha2VDYW5jZWxUb2tlbigpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsID0gY2FuY2VsO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAoKCkgPT4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgYmFja2ZpbGxpbmcgXCIke3N1YnNjcmlwdGlvbi5wYXJhbXNbMF19XCIgc3Vic2NyaXB0aW9uLiBTb21lIGV2ZW50cyBtYXkgYmUgbWlzc2luZy5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBoZWFydGJlYXQgYW5kIGFueSBwZW5kaW5nIGJhY2tmaWxscyBiZWluZyBwZXJmb3JtZWQuIFRoaXMgaXNcclxuICAgICAgICAgKiBjYWxsZWQgd2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gZ29lcyBkb3duIG9yIGlzIGRpc2Nvbm5lY3RlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIC8vIFN0YXJ0IGhlYXJ0YmVhdCBhbmQgYmFja2ZpbGxlciBmb3IgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxyXG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IG5ldyBXZWJzb2NrZXRCYWNrZmlsbGVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWRkU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwgPSBpbmRleC5ub29wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBCYXNlUHJvdmlkZXIuZ2V0TmV0d29ya2AgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG92ZXJyaWRlIGFsbG93cyB0aGUgU0RLIHRvIHNldCB0aGUgcHJvdmlkZXIncyBuZXR3b3JrIHRvIHZhbHVlcyBub3RcclxuICAgICAqIHlldCBzdXBwb3J0ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmcnICYmIG5ldHdvcmsgaW4gaW5kZXguQ3VzdG9tTmV0d29ya3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4LkN1c3RvbU5ldHdvcmtzW25ldHdvcmtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBzdGFuZGFyZCBldGhlcnMuanMgZ2V0TmV0d29yayBtZXRob2QgZm9yIG90aGVyIG5ldHdvcmtzLlxyXG4gICAgICAgIHJldHVybiBuZXR3b3Jrcy5nZXROZXR3b3JrKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycyB0aGF0IGluY2x1ZGVzIEFsY2hlbXkgYmFzZWQgc3Vic2NyaXB0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMgdGhhdCBpbmNsdWRlcyBBbGNoZW15IGJhc2VkXHJcbiAgICAgKiBzdWJzY3JpcHRpb25zLiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIHRyaWdnZXJlZCBmb3Igb25seSB0aGUgbmV4dFxyXG4gICAgICoge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQsIGFmdGVyIHdoaWNoIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBsaXN0ZW5lcn0gZm9yIHRoZSB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm9cclxuICAgICAqIGxpc3RlbmVyIGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gdW5saXN0ZW4gdG8uXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm8gZXZlbnRcclxuICAgICAqIGlzIHByb3ZpZGVkLCBhbGwgZXZlbnRzIGFuZCB0aGVpciBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgdGhlIHRvdGFsIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBgQmFzZVByb3ZpZGVyYCBpbiBvcmRlciB0byBwcm9wZXJseSBmb3JtYXQgdGhlXHJcbiAgICAgKiBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xyXG4gICAgICAgIGlmIChpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGluZGV4LnZlcmlmeUFsY2hlbXlFdmVudE5hbWUoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgaW5kZXguRXRoZXJzRXZlbnQoaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBfc3RhcnRFdmVudCgpYCBtZXRob2QgaW4gZXRoZXJzLmpzJ3NcclxuICAgICAqIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn0gdG8gaW5jbHVkZSBhZGRpdGlvbmFsIGFsY2hlbXkgbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IHR5cGUgaXMgYSBjdXN0b20gQWxjaGVteSBzdWJzY3JpcHRpb24uXHJcbiAgICAgICAgY29uc3QgY3VzdG9tTG9naWNUeXBlcyA9IFsuLi5pbmRleC5BTENIRU1ZX0VWRU5UX1RZUEVTLCAnYmxvY2snLCAnZmlsdGVyJ107XHJcbiAgICAgICAgaWYgKGN1c3RvbUxvZ2ljVHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21TdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gZnJvbSBldGhlcnMuanMncyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9XHJcbiAgICAgKlxyXG4gICAgICogTW9kaWZpZWQgaW4gb3JkZXIgdG8gYWRkIG1hcHBpbmdzIGZvciBiYWNrZmlsbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBfc3Vic2NyaWJlKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jLCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBpZiAoc3ViSWRQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKHBhcmFtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKCdldGhfc3Vic2NyaWJlJywgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IHlpZWxkIFByb21pc2UuYWxsKHBhcmFtKTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuc2V0KHN1YklkLCB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc3Vic2NyaWJlJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogcmVzb2x2ZWRQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBzdGFydGluZ0Jsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgdmlydHVhbElkOiBzdWJJZCxcclxuICAgICAgICAgICAgICAgIHBoeXNpY2FsSWQ6IHN1YklkLFxyXG4gICAgICAgICAgICAgICAgc2VudEV2ZW50czogW10sXHJcbiAgICAgICAgICAgICAgICBpc0JhY2tmaWxsaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyOiBbXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChzdWJJZCwgc3ViSWQpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnLCBwcm9jZXNzRnVuYyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbGluZSBpcyB0aGUgb25seSBtb2RpZmllZCBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNlbmRCYXRjaChwYXJ0cykge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0SWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFydHMubWFwKCh7IG1ldGhvZCwgcGFyYW1zIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcclxuICAgICAgICAgICAgICAgICAgICBpZDogYGFsY2hlbXktc2RrOiR7bmV4dElkKyt9YFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCYXRjaENvbmN1cnJlbnRseShwYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCgpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgZXRoZXIncyBgaXNDb21tdW5pdHlSZXNvdXJjZSgpYCBtZXRob2QuIFJldHVybnMgdHJ1ZSBpZiB0aGVcclxuICAgICAqIGN1cnJlbnQgYXBpIGtleSBpcyB0aGUgZGVmYXVsdCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpS2V5ID09PSBpbmRleC5ERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgV2ViU29ja2V0UHJvdmlkZXIuX3N0b3BFdmVudCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBzdXBwb3J0IEFsY2hlbXknc1xyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGUgYnkgYWxsb3dpbmcgdGhlIHByb3ZpZGVyIHRvIHByb3Blcmx5IHN0b3AgQWxjaGVteSdzXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IHRhZyA9IGV2ZW50LnRhZztcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgaWYgKGluZGV4LkFMQ0hFTVlfRVZFTlRfVFlQRVMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBwZW5kaW5nIHRyYW5zYWN0aW9uIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoZSA9PiBpbmRleC5BTENIRU1ZX0VWRU5UX1RZUEVTLmluY2x1ZGVzKGUudHlwZSkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd0eCcpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyB0cmFuc2FjdGlvbiBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoZSA9PiBlLnR5cGUgPT09ICd0eCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhZyA9ICd0eCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdWJJZCA9IHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgIGlmICghc3ViSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgdm9pZCBzdWJJZC50aGVuKHN1YklkID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdWJzW3N1YklkXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzW3N1YklkXTtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQoJ2V0aF91bnN1YnNjcmliZScsIFtzdWJJZF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYWRkU29ja2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVvcGVuJywgdGhpcy5oYW5kbGVSZW9wZW4pO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdkb3duJywgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVvcGVuJywgdGhpcy5oYW5kbGVSZW9wZW4pO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkb3duJywgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW9wZW5zIHRoZSBiYWNrZmlsbCBiYXNlZCBvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZFxyXG4gICAgICogQHBhcmFtIHN1YnNjcmlwdGlvblxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHJlc3Vic2NyaWJlQW5kQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmlydHVhbElkLCBtZXRob2QsIHBhcmFtcywgc2VudEV2ZW50cywgYmFja2ZpbGxCdWZmZXIsIHN0YXJ0aW5nQmxvY2tOdW1iZXIgfSA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGh5c2ljYWxJZCA9IHlpZWxkIHRoaXMuc2VuZChtZXRob2QsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5waHlzaWNhbElkID0gcGh5c2ljYWxJZDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5zZXQocGh5c2ljYWxJZCwgdmlydHVhbElkKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV3SGVhZHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tmaWxsRXZlbnRzID0geWllbGQgd2l0aEJhY2tvZmZSZXRyaWVzKCgpID0+IHdpdGhUaW1lb3V0KHRoaXMuYmFja2ZpbGxlci5nZXROZXdIZWFkc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCksIEJBQ0tGSUxMX1JFVFJJRVMsICgpID0+ICFpc0NhbmNlbGxlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGRlZHVwZU5ld0hlYWRzKFsuLi5iYWNrZmlsbEV2ZW50cywgLi4uYmFja2ZpbGxCdWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbWl0TmV3SGVhZHNFdmVudCh2aXJ0dWFsSWQsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsb2dzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBwYXJhbXNbMV0gfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tmaWxsRXZlbnRzID0geWllbGQgd2l0aEJhY2tvZmZSZXRyaWVzKCgpID0+IHdpdGhUaW1lb3V0KHRoaXMuYmFja2ZpbGxlci5nZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlciwgc2VudEV2ZW50cywgc3RhcnRpbmdCbG9ja051bWJlciksIEJBQ0tGSUxMX1RJTUVPVVQpLCBCQUNLRklMTF9SRVRSSUVTLCAoKSA9PiAhaXNDYW5jZWxsZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBkZWR1cGVMb2dzKFsuLi5iYWNrZmlsbEV2ZW50cywgLi4uYmFja2ZpbGxCdWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW1pdHMgYW4gZXZlbnQgdG8gY29uc3VtZXJzLCBidXQgYWxzbyByZW1lbWJlcnMgaXQgaW4gaXRzIHN1YnNjcmlwdGlvbnMnc1xyXG4gICAgICogYHNlbnRFdmVudHNgIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBkZXRlY3QgcmUtb3JncyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wc1xyXG4gICAgICogYW5kIG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBlbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKTtcclxuICAgICAgICB0aGlzLmVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBlbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdEdlbmVyaWNFdmVudChzdWJzY3JpcHRpb24sIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2ViMyBtb2RpZmllcyB0aGVzZSBldmVudCBvYmplY3RzIG9uY2Ugd2UgcGFzcyB0aGVtIG9uIChjaGFuZ2luZyBoZXhcclxuICAgICAgICAvLyBudW1iZXJzIHRvIG51bWJlcnMpLiBXZSB3YW50IHRoZSBvcmlnaW5hbCBldmVudCwgc28gbWFrZSBhIGRlZmVuc2l2ZVxyXG4gICAgICAgIC8vIGNvcHkuXHJcbiAgICAgICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHN1YnNjcmlwdGlvbi5zZW50RXZlbnRzLCBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCBnZXRCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0R2VuZXJpY0V2ZW50KHN1YnNjcmlwdGlvbiwgcmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3QgZW1pdEZ1bmN0aW9uID0gdGhpcy5lbWl0UHJvY2Vzc0ZuKHN1YnNjcmlwdGlvbi5ldmVudCk7XHJcbiAgICAgICAgZW1pdEZ1bmN0aW9uKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGhlYXJ0YmVhdCB0aGF0IHBpbmdzIHRoZSB3ZWJzb2NrZXQgc2VydmVyIHBlcmlvZGljYWxseSB0byBlbnN1cmVcclxuICAgICAqIHRoYXQgdGhlIGNvbm5lY3Rpb24gc3RheXMgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhcnRIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgd2l0aFRpbWVvdXQodGhpcy5zZW5kKCduZXRfdmVyc2lvbicpLCBIRUFSVEJFQVRfV0FJVF9USU1FKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZWNvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCBIRUFSVEJFQVRfSU5URVJWQUwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzZW5kcyB0aGUgYmF0Y2ggY29uY3VycmVudGx5IGFzIGluZGl2aWR1YWwgcmVxdWVzdHMgcmF0aGVyIHRoYW5cclxuICAgICAqIGFzIGEgYmF0Y2gsIHdoaWNoIHdhcyB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24uIFRoZSBvcmlnaW5hbCBiYXRjaCBsb2dpY1xyXG4gICAgICogaXMgcHJlc2VydmVkIGluIHRoaXMgaW1wbGVtZW50YXRpb24gaW4gb3JkZXIgZm9yIGZhc3RlciBwb3J0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXlsb2FkXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyhjbGVhbnVwKTogUmVmYWN0b3IgYW5kIHJlbW92ZSB1c2FnZXMgb2YgYHNlbmRCYXRjaCgpYC5cclxuICAgIC8vIFRPRE8oZXJyb3JzKTogVXNlIGFsbFNldHRsZWQoKSBvbmNlIHdlIGhhdmUgbW9yZSBlcnJvciBoYW5kbGluZy5cclxuICAgIHNlbmRCYXRjaENvbmN1cnJlbnRseShwYXlsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBheWxvYWQubWFwKHJlcSA9PiB0aGlzLnNlbmQocmVxLm1ldGhvZCwgcmVxLnBhcmFtcykpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGN1c3RvbVN0YXJ0RXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gaW5kZXguQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgaGFzaGVzT25seSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1xyXG4gICAgICAgICAgICAgICAgaW5kZXguQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgIHsgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgaGFzaGVzT25seSB9XHJcbiAgICAgICAgICAgIF0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gaW5kZXguQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGFkZHJlc3NlcywgaW5jbHVkZVJlbW92ZWQsIGhhc2hlc09ubHkgfSA9IGV2ZW50O1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFtcclxuICAgICAgICAgICAgICAgIGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgeyBhZGRyZXNzZXMsIGluY2x1ZGVSZW1vdmVkLCBoYXNoZXNPbmx5IH1cclxuICAgICAgICAgICAgXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnYmxvY2snKSB7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKCdibG9jaycsIFsnbmV3SGVhZHMnXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnZmlsdGVyJykge1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFsnbG9ncycsIHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRQcm9jZXNzRm4oZXZlbnQpIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBpbmRleC5BTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHRoaXMuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBpbmRleC5BbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21BZGRyZXNzOiBldmVudC5mcm9tQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICB0b0FkZHJlc3M6IGV2ZW50LnRvQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXNPbmx5OiBldmVudC5oYXNoZXNPbmx5XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICBjYXNlIGluZGV4LkFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHRoaXMuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBpbmRleC5BbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IGV2ZW50LmFkZHJlc3NlcyxcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUmVtb3ZlZDogZXZlbnQuaW5jbHVkZVJlbW92ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzT25seTogZXZlbnQuaGFzaGVzT25seVxyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdibG9jaycsIGJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQuZmlsdGVyLCB0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cocmVzdWx0KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGUgdG8gYGVtaXRQcm9jZXNzRm4oKWAnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5vZmYoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIucmVtb3ZlQWxsTGlzdGVuZXJzKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLmxpc3RlbmVyQ291bnQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQudGFnID09PSBldmVudFRhZztcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5saXN0ZW5lcnMoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQubGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcclxuICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PiBldmVudC50YWcgPT09IGV2ZW50VGFnKVxyXG4gICAgICAgICAgICAubWFwKGV2ZW50ID0+IGV2ZW50Lmxpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRXZWJzb2NrZXRDb25zdHJ1Y3RvcigpIHtcclxuICAgIHJldHVybiBpc05vZGVFbnZpcm9ubWVudCgpID8gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0IDogV2ViU29ja2V0O1xyXG59XHJcbmZ1bmN0aW9uIGlzTm9kZUVudmlyb25tZW50KCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBwcm9jZXNzICE9IG51bGwgJiZcclxuICAgICAgICBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiZcclxuICAgICAgICBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbCk7XHJcbn1cclxuLy8gVE9ETyhjbGVhbnVwKTogVXNlIGNsYXNzIHZhcmlhYmxlIHJhdGhlciB0aGFuIHBhc3NpbmcgYGlzQ2FuY2VsbGVkYCBldmVyeXdoZXJlLlxyXG5mdW5jdGlvbiBtYWtlQ2FuY2VsVG9rZW4oKSB7XHJcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICByZXR1cm4geyBjYW5jZWw6ICgpID0+IChjYW5jZWxsZWQgPSB0cnVlKSwgaXNDYW5jZWxsZWQ6ICgpID0+IGNhbmNlbGxlZCB9O1xyXG59XHJcbi8vIFRPRE8oY2xlYW51cCk6IHJlcGxhY2Ugd2l0aCBTREsncyBiYWNrb2ZmIGltcGxlbWVudGF0aW9uXHJcbmNvbnN0IE1JTl9SRVRSWV9ERUxBWSA9IDEwMDA7XHJcbmNvbnN0IFJFVFJZX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuY29uc3QgTUFYX1JFVFJZX0RFTEFZID0gMzAwMDA7XHJcbmZ1bmN0aW9uIHdpdGhCYWNrb2ZmUmV0cmllcyhmLCByZXRyeUNvdW50LCBzaG91bGRSZXRyeSA9ICgpID0+IHRydWUpIHtcclxuICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgbGV0IG5leHRXYWl0VGltZSA9IDA7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcmV0cnlDb3VudCB8fCAhc2hvdWxkUmV0cnkoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBkZWxheShuZXh0V2FpdFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTUlOX1JFVFJZX0RFTEFZXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oTUFYX1JFVFJZX0RFTEFZLCBSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiAqIG5leHRXYWl0VGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZWxheShtcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xyXG59XHJcbmZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1zKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICBwcm9taXNlLFxyXG4gICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKSwgbXMpKVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV3SGVhZHNCbG9ja051bWJlcihldmVudCkge1xyXG4gICAgcmV0dXJuIGluZGV4LmZyb21IZXgoZXZlbnQubnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBnZXRMb2dzQmxvY2tOdW1iZXIoZXZlbnQpIHtcclxuICAgIHJldHVybiBpbmRleC5mcm9tSGV4KGV2ZW50LmJsb2NrTnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSB8fFxyXG4gICAgICAgIChtZXNzYWdlLmpzb25ycGMgPT09ICcyLjAnICYmIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uRXZlbnQobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuICFpc1Jlc3BvbnNlKG1lc3NhZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFRvTmV3SGVhZHNFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQpIHtcclxuICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gYWRkVG9Mb2dzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XHJcbiAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYSBuZXcgZXZlbnQgdG8gYW4gYXJyYXkgb2YgZXZlbnRzLCBldmljdGluZyBhbnkgZXZlbnRzIHdoaWNoIGFyZSBzbyBvbGRcclxuICogdGhhdCB0aGV5IHdpbGwgbm8gbG9uZ2VyIGZlYXNpYmx5IGJlIHBhcnQgb2YgYSByZW9yZy5cclxuICovXHJcbmZ1bmN0aW9uIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bWJlciA9IGdldEJsb2NrTnVtYmVyKGV2ZW50KTtcclxuICAgIC8vIEZpbmQgZmlyc3QgaW5kZXggb2YgYW4gZXZlbnQgcmVjZW50IGVub3VnaCB0byByZXRhaW4sIHRoZW4gZHJvcCBldmVyeXRoaW5nXHJcbiAgICAvLyBhdCBhIGxvd2VyIGluZGV4LlxyXG4gICAgY29uc3QgZmlyc3RHb29kSW5kZXggPSBwYXN0RXZlbnRzLmZpbmRJbmRleChlID0+IGdldEJsb2NrTnVtYmVyKGUpID4gY3VycmVudEJsb2NrTnVtYmVyIC0gUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQpO1xyXG4gICAgaWYgKGZpcnN0R29vZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHBhc3RFdmVudHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhc3RFdmVudHMuc3BsaWNlKDAsIGZpcnN0R29vZEluZGV4KTtcclxuICAgIH1cclxuICAgIHBhc3RFdmVudHMucHVzaChldmVudCk7XHJcbn1cblxuZXhwb3J0cy5BbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgPSBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci00NGRmMzczOS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpbmRleCIsInJlcXVpcmUiLCJTdHVyZHlXZWJTb2NrZXQiLCJiaWdudW1iZXIiLCJuZXR3b3JrcyIsInByb3ZpZGVycyIsImFsY2hlbXlQcm92aWRlciIsIl9pbnRlcm9wRGVmYXVsdExlZ2FjeSIsImUiLCJTdHVyZHlXZWJTb2NrZXRfX2RlZmF1bHQiLCJNQVhfQkFDS0ZJTExfQkxPQ0tTIiwiV2Vic29ja2V0QmFja2ZpbGxlciIsImNvbnN0cnVjdG9yIiwicHJvdmlkZXIiLCJtYXhCYWNrZmlsbEJsb2NrcyIsImdldE5ld0hlYWRzQmFja2ZpbGwiLCJpc0NhbmNlbGxlZCIsInByZXZpb3VzSGVhZHMiLCJmcm9tQmxvY2tOdW1iZXIiLCJfX2F3YWl0ZXIiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwidG9CbG9ja051bWJlciIsImdldEJsb2NrTnVtYmVyIiwibGVuZ3RoIiwiZ2V0SGVhZEV2ZW50c0luUmFuZ2UiLCJNYXRoIiwibWF4IiwibGFzdFNlZW5CbG9ja051bWJlciIsImZyb21IZXgiLCJudW1iZXIiLCJtaW5CbG9ja051bWJlciIsInJlb3JnSGVhZHMiLCJnZXRSZW9yZ0hlYWRzIiwiaW50ZXJtZWRpYXRlSGVhZHMiLCJnZXRMb2dzQmFja2ZpbGwiLCJmaWx0ZXIiLCJwcmV2aW91c0xvZ3MiLCJnZXRMb2dzSW5SYW5nZSIsImJsb2NrTnVtYmVyIiwiY29tbW9uQW5jZXN0b3IiLCJnZXRDb21tb25BbmNlc3RvciIsInJlbW92ZWRMb2dzIiwibG9nIiwibWFwIiwiT2JqZWN0IiwiYXNzaWduIiwicmVtb3ZlZCIsImZyb21CbG9ja0luY2x1c2l2ZSIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiYWRkZWRMb2dzIiwibG9nSW5kZXgiLCJzZXRNYXhCYWNrZmlsbEJsb2NrIiwibmV3TWF4IiwiYmxvY2tOdW1iZXJIZXgiLCJzZW5kIiwidG9CbG9ja0V4Y2x1c2l2ZSIsImJhdGNoUGFydHMiLCJpIiwicHVzaCIsIm1ldGhvZCIsInBhcmFtcyIsInRvSGV4IiwiYmxvY2tIZWFkcyIsInNlbmRCYXRjaCIsInRvTmV3SGVhZHNFdmVudCIsInJlc3VsdCIsIm9sZEV2ZW50IiwiYmxvY2tIZWFkIiwiZ2V0QmxvY2tCeU51bWJlciIsImhhc2giLCJyZXZlcnNlIiwib2xkTG9nIiwiYmxvY2tIYXNoIiwicmFuZ2VGaWx0ZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiaGVhZCIsInRvdGFsRGlmZmljdWx0eSIsInRyYW5zYWN0aW9ucyIsInVuY2xlcyIsImRlZHVwZU5ld0hlYWRzIiwiZXZlbnRzIiwiZGVkdXBlIiwiZXZlbnQiLCJkZWR1cGVMb2dzIiwiaXRlbXMiLCJnZXRLZXkiLCJrZXlzU2VlbiIsIlNldCIsImZvckVhY2giLCJpdGVtIiwia2V5IiwiaGFzIiwiYWRkIiwiQ0FOQ0VMTEVEIiwiRXJyb3IiLCJIRUFSVEJFQVRfSU5URVJWQUwiLCJIRUFSVEJFQVRfV0FJVF9USU1FIiwiQkFDS0ZJTExfVElNRU9VVCIsIkJBQ0tGSUxMX1JFVFJJRVMiLCJSRVRBSU5FRF9FVkVOVF9CTE9DS19DT1VOVCIsIkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciIsIldlYlNvY2tldFByb3ZpZGVyIiwiY29uZmlnIiwid3NDb25zdHJ1Y3RvciIsIl9hIiwiYXBpS2V5IiwiQWxjaGVteVByb3ZpZGVyIiwiZ2V0QXBpS2V5IiwiYWxjaGVteU5ldHdvcmsiLCJnZXRBbGNoZW15TmV0d29yayIsIm5ldHdvcmsiLCJjb25uZWN0aW9uIiwiZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvIiwicHJvdG9jb2wiLCJWRVJTSU9OIiwid3MiLCJ1cmwiLCJnZXRXZWJzb2NrZXRDb25zdHJ1Y3RvciIsImV0aGVyc05ldHdvcmsiLCJFdGhlcnNOZXR3b3JrIiwiX2V2ZW50cyIsInZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZCIsIk1hcCIsInZpcnR1YWxJZHNCeVBoeXNpY2FsSWQiLCJoYW5kbGVNZXNzYWdlIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJpc1N1YnNjcmlwdGlvbkV2ZW50IiwicGh5c2ljYWxJZCIsInN1YnNjcmlwdGlvbiIsInZpcnR1YWxJZCIsImdldCIsIm5ld0hlYWRzU3Vic2NyaXB0aW9uIiwibmV3SGVhZHNNZXNzYWdlIiwiaXNCYWNrZmlsbGluZyIsImJhY2tmaWxsQnVmZmVyIiwiYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlciIsImVtaXRBbmRSZW1lbWJlckV2ZW50IiwiZ2V0TmV3SGVhZHNCbG9ja051bWJlciIsInJlbWVtYmVyRXZlbnQiLCJsb2dzU3Vic2NyaXB0aW9uIiwibG9nc01lc3NhZ2UiLCJhZGRUb0xvZ3NFdmVudHNCdWZmZXIiLCJnZXRMb2dzQmxvY2tOdW1iZXIiLCJlbWl0RXZlbnQiLCJoYW5kbGVSZW9wZW4iLCJjbGVhciIsImNhbmNlbCIsIm1ha2VDYW5jZWxUb2tlbiIsImNhbmNlbEJhY2tmaWxsIiwidmFsdWVzIiwicmVzdWJzY3JpYmVBbmRCYWNrZmlsbCIsImVycm9yIiwiY29uc29sZSIsInN0YXJ0SGVhcnRiZWF0Iiwic3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsIiwiaGVhcnRiZWF0SW50ZXJ2YWxJZCIsImNsZWFySW50ZXJ2YWwiLCJ1bmRlZmluZWQiLCJiYWNrZmlsbGVyIiwiYWRkU29ja2V0TGlzdGVuZXJzIiwibm9vcCIsImdldE5ldHdvcmsiLCJDdXN0b21OZXR3b3JrcyIsIm9uIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJfYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJpc0FsY2hlbXlFdmVudCIsIl9vZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfcmVtb3ZlQWxsTGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsIl9saXN0ZW5lckNvdW50IiwibGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInZlcmlmeUFsY2hlbXlFdmVudE5hbWUiLCJFdGhlcnNFdmVudCIsImdldEFsY2hlbXlFdmVudFRhZyIsIl9zdGFydEV2ZW50IiwiY3VzdG9tTG9naWNUeXBlcyIsIkFMQ0hFTVlfRVZFTlRfVFlQRVMiLCJpbmNsdWRlcyIsInR5cGUiLCJjdXN0b21TdGFydEV2ZW50IiwiX3N1YnNjcmliZSIsInRhZyIsInBhcmFtIiwicHJvY2Vzc0Z1bmMiLCJzdWJJZFByb21pc2UiLCJfc3ViSWRzIiwic3RhcnRpbmdCbG9ja051bWJlciIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwic3ViSWQiLCJyZXNvbHZlZFBhcmFtcyIsInNldCIsInNlbnRFdmVudHMiLCJfc3VicyIsImVtaXQiLCJhcmdzIiwic3RvcHBlZCIsImV2ZW50VGFnIiwic2V0VGltZW91dCIsImFwcGx5IiwiX3N0b3BFdmVudCIsInBhcnRzIiwibmV4dElkIiwicGF5bG9hZCIsImpzb25ycGMiLCJpZCIsInNlbmRCYXRjaENvbmN1cnJlbnRseSIsImRlc3Ryb3kiLCJyZW1vdmVTb2NrZXRMaXN0ZW5lcnMiLCJpc0NvbW11bml0eVJlc291cmNlIiwiREVGQVVMVF9BTENIRU1ZX0FQSV9LRVkiLCJfd2Vic29ja2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJiYWNrZmlsbEV2ZW50cyIsIndpdGhCYWNrb2ZmUmV0cmllcyIsIndpdGhUaW1lb3V0IiwiZW1pdE5ld0hlYWRzRXZlbnQiLCJlbWl0TG9nc0V2ZW50IiwiZW1pdEdlbmVyaWNFdmVudCIsImFkZFRvUGFzdEV2ZW50c0J1ZmZlciIsImVtaXRGdW5jdGlvbiIsImVtaXRQcm9jZXNzRm4iLCJzZXRJbnRlcnZhbCIsInJlY29ubmVjdCIsInJlcSIsIkFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSIsImZyb21BZGRyZXNzIiwidG9BZGRyZXNzIiwiaGFzaGVzT25seSIsIkFsY2hlbXlTdWJzY3JpcHRpb24iLCJQRU5ESU5HX1RSQU5TQUNUSU9OUyIsIkFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUiLCJhZGRyZXNzZXMiLCJpbmNsdWRlUmVtb3ZlZCIsIk1JTkVEX1RSQU5TQUNUSU9OUyIsIl9nZXRGaWx0ZXIiLCJCaWdOdW1iZXIiLCJmcm9tIiwidG9OdW1iZXIiLCJfZW1pdHRlZCIsImJsb2NrIiwiZm9ybWF0dGVyIiwiZmlsdGVyTG9nIiwiZm91bmQiLCJpc05vZGVFbnZpcm9ubWVudCIsInczY3dlYnNvY2tldCIsIldlYlNvY2tldCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJjYW5jZWxsZWQiLCJNSU5fUkVUUllfREVMQVkiLCJSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiIsIk1BWF9SRVRSWV9ERUxBWSIsImYiLCJyZXRyeUNvdW50Iiwic2hvdWxkUmV0cnkiLCJuZXh0V2FpdFRpbWUiLCJkZWxheSIsIm1pbiIsIm1zIiwicmVzb2x2ZSIsInByb21pc2UiLCJyYWNlIiwiXyIsInJlamVjdCIsImlzUmVzcG9uc2UiLCJBcnJheSIsImlzQXJyYXkiLCJwYXN0RXZlbnRzIiwiY3VycmVudEJsb2NrTnVtYmVyIiwiZmlyc3RHb29kSW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-44df3739.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js":
/*!*********************************************************!*\
  !*** ../node_modules/alchemy-sdk/dist/cjs/api/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar hash = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../node_modules/@ethersproject/hash/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar units = __webpack_require__(/*! @ethersproject/units */ \"(ssr)/../node_modules/@ethersproject/units/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar abi = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/../node_modules/@ethersproject/abi/lib.esm/index.js\");\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\nconst version = \"strings/5.7.0\";\nconst logger = new Logger(version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function(UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\nvar Utf8ErrorReason;\n(function(Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes$1, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes$1 = bytes.arrayify(bytes$1);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes$1.length){\n        const c = bytes$1[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes$1, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes$1, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes$1.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes$1, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes$1[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes$1, result);\n                res = null;\n                break;\n            }\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return bytes.arrayify(result);\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction bytes2(data) {\n    if (data.length % 4 !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for(let i = 0; i < data.length; i += 4){\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function(value) {\n            return [\n                parseInt(value, 16)\n            ];\n        };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair)=>{\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v)=>{\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return {\n            l: lo,\n            h: hi\n        };\n    });\n}\ncreateRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\n\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v)=>parseInt(v, 16));\ncreateTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\ncreateTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\ncreateTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\ncreateRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nObject.defineProperty(exports, \"dnsEncode\", ({\n    enumerable: true,\n    get: function() {\n        return hash.dnsEncode;\n    }\n}));\nObject.defineProperty(exports, \"hashMessage\", ({\n    enumerable: true,\n    get: function() {\n        return hash.hashMessage;\n    }\n}));\nObject.defineProperty(exports, \"id\", ({\n    enumerable: true,\n    get: function() {\n        return hash.id;\n    }\n}));\nObject.defineProperty(exports, \"isValidName\", ({\n    enumerable: true,\n    get: function() {\n        return hash.isValidName;\n    }\n}));\nObject.defineProperty(exports, \"namehash\", ({\n    enumerable: true,\n    get: function() {\n        return hash.namehash;\n    }\n}));\nObject.defineProperty(exports, \"arrayify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.arrayify;\n    }\n}));\nObject.defineProperty(exports, \"concat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.concat;\n    }\n}));\nObject.defineProperty(exports, \"hexConcat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexConcat;\n    }\n}));\nObject.defineProperty(exports, \"hexDataLength\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataLength;\n    }\n}));\nObject.defineProperty(exports, \"hexDataSlice\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataSlice;\n    }\n}));\nObject.defineProperty(exports, \"hexStripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexStripZeros;\n    }\n}));\nObject.defineProperty(exports, \"hexValue\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexValue;\n    }\n}));\nObject.defineProperty(exports, \"hexZeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexZeroPad;\n    }\n}));\nObject.defineProperty(exports, \"hexlify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexlify;\n    }\n}));\nObject.defineProperty(exports, \"isBytes\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytes;\n    }\n}));\nObject.defineProperty(exports, \"isBytesLike\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytesLike;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"joinSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.joinSignature;\n    }\n}));\nObject.defineProperty(exports, \"splitSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.splitSignature;\n    }\n}));\nObject.defineProperty(exports, \"stripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.stripZeros;\n    }\n}));\nObject.defineProperty(exports, \"zeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.zeroPad;\n    }\n}));\nObject.defineProperty(exports, \"formatEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatEther;\n    }\n}));\nObject.defineProperty(exports, \"formatUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatUnits;\n    }\n}));\nObject.defineProperty(exports, \"parseEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseEther;\n    }\n}));\nObject.defineProperty(exports, \"parseUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseUnits;\n    }\n}));\nObject.defineProperty(exports, \"Interface\", ({\n    enumerable: true,\n    get: function() {\n        return abi.Interface;\n    }\n}));\nexports.toUtf8Bytes = toUtf8Bytes;\nexports.toUtf8String = toUtf8String; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FwaS91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQkEsbUJBQU9BLENBQUM7QUFDUixJQUFJRyxNQUFNSCxtQkFBT0EsQ0FBQztBQUVsQixNQUFNSSxZQUFZO0FBRWxCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyxnQkFBZ0I7QUFDcEIsTUFBTUMsWUFBWTtJQUFFQyxPQUFPO0lBQUcsV0FBVztJQUFHQyxNQUFNO0lBQUdDLFNBQVM7SUFBR0MsT0FBTztJQUFHQyxLQUFLO0FBQUU7QUFDbEYsSUFBSUMsWUFBWU4sU0FBUyxDQUFDLFVBQVU7QUFDcEMsSUFBSU8sZ0JBQWdCO0FBQ3BCLFNBQVNDO0lBQ0wsSUFBSTtRQUNBLE1BQU1DLFVBQVUsRUFBRTtRQUNsQixxREFBcUQ7UUFDckQ7WUFBQztZQUFPO1lBQU87WUFBUTtTQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDQztZQUNwQyxJQUFJO2dCQUNBLElBQUksT0FBT0MsU0FBUyxDQUFDRCxVQUFVLFFBQVE7b0JBQ25DLE1BQU0sSUFBSUUsTUFBTTtnQkFDcEI7O1lBRUosRUFDQSxPQUFPVCxPQUFPO2dCQUNWSyxRQUFRSyxJQUFJLENBQUNIO1lBQ2pCO1FBQ0o7UUFDQSxJQUFJRixRQUFRTSxNQUFNLEVBQUU7WUFDaEIsTUFBTSxJQUFJRixNQUFNLGFBQWFKLFFBQVFPLElBQUksQ0FBQztRQUM5QztRQUNBLElBQUlDLE9BQU9DLFlBQVksQ0FBQyxNQUFNTixTQUFTLENBQUMsV0FBV0ssT0FBT0MsWUFBWSxDQUFDLE1BQU0sU0FBUztZQUNsRixNQUFNLElBQUlMLE1BQU07UUFDcEI7SUFDSixFQUNB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Q1o0SCxLQUFLO1FBQWMsT0FBTzdKLE1BQU1pTCxPQUFPO0lBQUU7QUFDN0MsQ0FBQyxFQUFDO0FBQ0Z2TCwrQ0FBOEM7SUFDMUN1QyxZQUFZO0lBQ1o0SCxLQUFLO1FBQWMsT0FBTzVKLE1BQU1pTCxXQUFXO0lBQUU7QUFDakQsQ0FBQyxFQUFDO0FBQ0Z4TCwrQ0FBOEM7SUFDMUN1QyxZQUFZO0lBQ1o0SCxLQUFLO1FBQWMsT0FBTzVKLE1BQU1rTCxXQUFXO0lBQUU7QUFDakQsQ0FBQyxFQUFDO0FBQ0Z6TCw4Q0FBNkM7SUFDekN1QyxZQUFZO0lBQ1o0SCxLQUFLO1FBQWMsT0FBTzVKLE1BQU1tTCxVQUFVO0lBQUU7QUFDaEQsQ0FBQyxFQUFDO0FBQ0YxTCw4Q0FBNkM7SUFDekN1QyxZQUFZO0lBQ1o0SCxLQUFLO1FBQWMsT0FBTzVKLE1BQU1vTCxVQUFVO0lBQUU7QUFDaEQsQ0FBQyxFQUFDO0FBQ0YzTCw2Q0FBNEM7SUFDeEN1QyxZQUFZO0lBQ1o0SCxLQUFLO1FBQWMsT0FBTzNKLElBQUlvTCxTQUFTO0lBQUU7QUFDN0MsQ0FBQyxFQUFDO0FBQ0YxTCxtQkFBbUIsR0FBR3dJO0FBQ3RCeEksb0JBQW9CLEdBQUdrSixjQUN2QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FwaS91dGlscy5qcz81ZjBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGhhc2ggPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9oYXNoJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9ieXRlcycpO1xudmFyIHVuaXRzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvdW5pdHMnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcicpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpO1xuXG5jb25zdCB2ZXJzaW9uJDEgPSBcImxvZ2dlci81LjcuMFwiO1xuXG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmxldCBfZ2xvYmFsTG9nZ2VyID0gbnVsbDtcbmZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG4gICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goKGZvcm0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFwiICsgbWlzc2luZy5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IF9ub3JtYWxpemVFcnJvciA9IF9jaGVja05vcm1hbGl6ZSgpO1xudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gSW50ZXJhY3Rpb24gRXJyb3JzXG4gICAgLy8gVGhlIHVzZXIgcmVqZWN0ZWQgdGhlIGFjdGlvbiwgc3VjaCBhcyBzaWduaW5nIGEgbWVzc2FnZSBvciBzZW5kaW5nXG4gICAgLy8gYSB0cmFuc2FjdGlvblxuICAgIEVycm9yQ29kZVtcIkFDVElPTl9SRUpFQ1RFRFwiXSA9IFwiQUNUSU9OX1JFSkVDVEVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5jb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLkRFQlVHLCBhcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLklORk8sIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldICYgMHgwZl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGxldCB1cmwgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5VTUVSSUNfRkFVTFQ6IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBmYXVsdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3ZlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGl2aXNpb24tYnktemVyb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLVwiICsgZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXBvd2VyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS13aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuQ0FMTF9FWENFUFRJT046XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfRlVORFM6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5NSVNTSU5HX05FVzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5PTkNFX0VYUElSRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlRSQU5TQUNUSU9OX1JFUExBQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQ6XG4gICAgICAgICAgICAgICAgdXJsID0gY29kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIFsgU2VlOiBodHRwczovXFwvbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyB1cmwgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VEZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogQW55Pz9cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIHRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIHRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNoZWNrTm9ybWFsaXplKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbiQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICB9XG59XG5Mb2dnZXIuZXJyb3JzID0gRXJyb3JDb2RlO1xuTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuXG5jb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNy4wXCI7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuKGZ1bmN0aW9uIChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pIHtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJjdXJyZW50XCJdID0gXCJcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkNcIl0gPSBcIk5GQ1wiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXSA9IFwiTkZEXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLQ1wiXSA9IFwiTkZLQ1wiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0RcIl0gPSBcIk5GS0RcIjtcbn0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSB8fCAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0ge30pKTtcbnZhciBVdGY4RXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKFV0ZjhFcnJvclJlYXNvbikge1xuICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXSA9IFwidW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIkJBRF9QUkVGSVhcIl0gPSBcImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJSVU5cIl0gPSBcInN0cmluZyBvdmVycnVuXCI7XG4gICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBhdFxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk1JU1NJTkdfQ09OVElOVUVcIl0gPSBcIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtcbiAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBvdXRzaWRlIHRoZSBVVEYtOCByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG4gICAgLy8gVVRGLTggc3RyaW5ncyBtYXkgbm90IGNvbnRhaW4gVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyc1xuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIlVURjE2X1NVUlJPR0FURVwiXSA9IFwiVVRGLTE2IHN1cnJvZ2F0ZVwiO1xuICAgIC8vIFRoZSBzdHJpbmcgaXMgYW4gb3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUkxPTkdcIl0gPSBcIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCI7XG59KShVdGY4RXJyb3JSZWFzb24gfHwgKFV0ZjhFcnJvclJlYXNvbiA9IHt9KSk7XG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCB8fCByZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJMT05HKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzJDEsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgYnl0ZXMkMSA9IGJ5dGVzLmFycmF5aWZ5KGJ5dGVzJDEpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG4gICAgd2hpbGUgKGkgPCBieXRlcyQxLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXMkMVtpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzJDEsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsIGkgLSAxLCBieXRlcyQxLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzJDEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcyQxLCByZXN1bHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcbiAgICAgICAgbGV0IHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGJ5dGVzJDFbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uTUlTU0lOR19DT05USU5VRSwgaSwgYnl0ZXMkMSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcyQxLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VVEYxNl9TVVJST0dBVEUsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzJDEsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJMT05HLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcyQxLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5mdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgIGlmIChmb3JtICE9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGkgPj0gc3RyLmxlbmd0aCB8fCAoYzIgJiAweGZjMDApICE9PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKGMgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5hcnJheWlmeShyZXN1bHQpO1xufVxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuXG5mdW5jdGlvbiBieXRlczIoZGF0YSkge1xuICAgIGlmICgoZGF0YS5sZW5ndGggJSA0KSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgZGF0YVwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChkYXRhLnN1YnN0cmluZyhpLCBpICsgNCksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZShkYXRhLCBmdW5jKSB7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFtwYXJzZUludCh2YWx1ZSwgMTYpXTsgfTtcbiAgICB9XG4gICAgbGV0IGxvID0gMDtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZGF0YS5zcGxpdChcIixcIikuZm9yRWFjaCgocGFpcikgPT4ge1xuICAgICAgICBsZXQgY29tcHMgPSBwYWlyLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgbG8gKz0gcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcbiAgICAgICAgcmVzdWx0W2xvXSA9IGZ1bmMoY29tcHNbMV0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZVRhYmxlKGRhdGEpIHtcbiAgICBsZXQgaGkgPSAwO1xuICAgIHJldHVybiBkYXRhLnNwbGl0KFwiLFwiKS5tYXAoKHYpID0+IHtcbiAgICAgICAgbGV0IGNvbXBzID0gdi5zcGxpdChcIi1cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzWzFdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcHNbMV0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBzWzFdID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvID0gaGkgKyBwYXJzZUludChjb21wc1swXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KGNvbXBzWzFdLCAxNik7XG4gICAgICAgIHJldHVybiB7IGw6IGxvLCBoOiBoaSB9O1xuICAgIH0pO1xufVxuY3JlYXRlUmFuZ2VUYWJsZShcIjIyMSwxMy0xYiw1Zi0sNDAtMTAsNTEtZiwxMS0zLDMtMywyLTIsMi00LDgsMiwxNSwyZCwyOC04LDg4LDQ4LDI3LSwzLTUsMTEtMjAsMjctLDgsMjgsMy01LDEyLDE4LGItYSwxYy00LDYtMTYsMi1kLDItMiwyLDFiLTQsMTctOSw4Zi0sMTAsZiwxZi0yLDFjLTM0LDMzLTE0ZSw0LDM2LSwxMy0sNi0yLDFhLWYsNCw5LSwzLSwxNyw4LDItMiw1LSwyLDgtLDMtLDQtOCwyLTMsMyw2LSwxNi02LDItLDctMywzLSwxNyw4LDMsMywzLSwyLDYtMywzLSw0LWEsNSwyLTYsMTAtYiw0LDgsMiw0LDE3LDgsMyw2LSxiLDQsNC0sMi1lLDItNCxiLTEwLDQsOS0sMy0sMTcsOCwzLSw1LSw5LTIsMy0sNC03LDMtMywzLDQtMyxjLTEwLDMsNy0yLDQsNS0yLDMsMiwzLTIsMy0yLDQtMiw5LDQtMyw2LTIsNCw1LTgsMi1lLGQtZCw0LDksNCwxOCxiLDYtMyw4LDQsNS02LDMtOCwzLTMsYi0xMSwzLDksNCwxOCxiLDYtMyw4LDQsNS02LDMtNiwyLDMtMyxiLTExLDMsOSw0LDE4LDExLTMsNy0sNCw1LTgsMi03LDMtMyxiLTExLDMsMTMtMiwxOSxhLDItLDgtMiwyLTMsNywyLDktMTEsNC1iLDNiLTMsMWUtMjQsMywyLSwzLDItLDItNSw1LDgsNCwyLDItLDMsZSw0LSw2LDIsNy0sYi0sMy0yMSw0OSwyMy01LDFjLTMsOSwyNSwxMC0sMi0yZiwyMyw2LDMsOC0yLDUtNSwxYi00NSwyNy05LDJhLSwyLTMsNWItNCw0NS00LDUzLTUsOCw0MCwyLDUtLDgsMiw1LSwyOCwyLDUtLDIwLDIsNS0sOCwyLDUtLDgsOCwxOCwyMCwyLDUtLDgsMjgsMTQtNSwxZC0yMiw1Ni1iLDI3Ny04LDFlLTIsNTItZSxlLDgtYSwxOC04LDE1LWIsZSw0LDMtYiw1ZS0yLGItMTUsMTAsYi01LDU5LTcsMmItNTU1LDlkLTMsNWItNSwxNy0sNy0sMjctLDctLDksMiwyLDIsMjAtLDM2LDEwLGYtLDcsMTQtLDQsYSw1NC0zLDItNiw2LTUsOS0sMWMtMTAsMTMtMWQsMWMtMTQsM2MtLDEwLTYsMzItYiwyNDAtMzAsMjgtMTgsYy0xNCxhMCwxMTUtLDMsNjYtLGItNzYsNSw1LSwxZCwyNCwyLDUtMiwyLDgtLDM1LTIsMTksZi0xMCwxZC0zLDMxMS0zN2YsMWIsNWEtYixkNy0xOSxkLTMsNDEsNTctLDY4LTQsMjktMyw1ZiwyOS0zNywyZS0yLDI1LWMsMmMtMiw0ZS0zLDMwLDc4LTMsNjQtLDIwLDE5YjctNDksNTFhNy01OSw0OGUtMiwzOC03MzgsMmJhNS01YiwyMjJmLSwzYy05NCw4LWIsNi00LDFiLDYsMiwzLDMsNmQtMjAsMTZlLWYsNDEtLDM3LTcsMmUtMiwxMS1mLDUtYiwxOC0sYiwxNCw1LTMsNiw4OC0sMixiZi0yLDctLDctLDctLDQtMiw4LDgtOSw4LTJmZiwyMCw1LWIsMWMtYjQsMjctLDI3LWNiYjEsZjctOSwyOC0yLGI1LTIyMSw1Niw0OCwzLSwyLSwzLSw1LGQsMiw1LDMsNDIsNS0sOSw4LDFkLDUsNiwyLTIsOCwxNTMtMywxMjMtMywzMy0yN2ZkLGE2ZGEtNTEyOCwyMWYtNWRmLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMywyLTFkLDYxLWZmN2RcIik7XG4vLyBAVE9ETzogTWFrZSB0aGlzIHJlbGF0aXZlLi4uXG5cImFkLDM0ZiwxODA2LDE4MGIsMTgwYywxODBkLDIwMGIsMjAwYywyMDBkLDIwNjAsZmVmZlwiLnNwbGl0KFwiLFwiKS5tYXAoKHYpID0+IHBhcnNlSW50KHYsIDE2KSk7XG5jcmVhdGVUYWJsZShcImI1OjNiYyxjMzpmZiw3OjczLDI6MjUzLDU6MjU0LDM6MjU2LDE6MjU3LDU6MjU5LDE6MjViLDM6MjYwLDE6MjYzLDI6MjY5LDE6MjY4LDU6MjZmLDE6MjcyLDI6Mjc1LDc6MjgwLDM6MjgzLDU6Mjg4LDM6MjhhLDE6MjhiLDU6MjkyLDNmOjE5NSwxOjFiZiwyOToxOWUsMTI1OjNiOSw4YjozYjIsMTozYjgsMTozYzUsMzozYzYsMTozYzAsMWE6M2JhLDE6M2MxLDE6M2MzLDI6M2I4LDE6M2I1LDFiYzk6M2I5LDFjOjFmNzYsMToxZjc3LGY6MWY3YSwxOjFmN2IsZDoxZjc4LDE6MWY3OSwxOjFmN2MsMToxZjdkLDEwNzo2Myw1OjI1Yiw0OjY4LDE6NjgsMTo2OCwzOjY5LDE6NjksMTo2YywzOjZlLDQ6NzAsMTo3MSwxOjcyLDE6NzIsMTo3Miw3OjdhLDI6M2M5LDI6N2EsMjo2YiwxOmU1LDE6NjIsMTo2MywzOjY1LDE6NjYsMjo2ZCxiOjNiMywxOjNjMCw2OjY0LDFiNTc0OjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjM1wiKTtcbmNyZWF0ZVRhYmxlKFwiMTc5OjEsMjoxLDI6MSw1OjEsMjoxLGE6NGYsYToxLDg6MSwyOjEsMjoxLDM6MSw1OjEsMzoxLDQ6MSwyOjEsMzoxLDQ6MSw4OjIsMToxLDI6MiwxOjEsMjoyLDI3OjIsMTk1OjI2LDI6MjUsMToyNSwxOjI1LDI6NDAsMjozZiwxOjNmLDMzOjEsMTE6LTYsMTotOSwxYWM3Oi0zYSw2ZDotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGI6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYzotOCwyOi04LDI6LTgsMjotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsNDk6LTgsMTotOCwxOi00YSwxOi00YSxkOi01NiwxOi01NiwxOi01NiwxOi01NixkOi04LDE6LTgsZjotOCwxOi04LDM6LTdcIik7XG5jcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsIGJ5dGVzMik7XG5jcmVhdGVSYW5nZVRhYmxlKFwiODAtMjAsMmEwLSwzOWMsMzIsZjcxLDE4ZSw3ZjItZiwxOS03LDMwLTQsNy01LGY4MS1iLDUsYTgwMC0yMGZmLDRkMS0xZiwxMTAsZmEtNixkMTc0LTcsMmU4NC0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sMiwxZi01ZixmZjdmLTIwMDAxXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Ruc0VuY29kZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaC5kbnNFbmNvZGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoYXNoTWVzc2FnZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaC5oYXNoTWVzc2FnZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2lkJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLmlkOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaXNWYWxpZE5hbWUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2guaXNWYWxpZE5hbWU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICduYW1laGFzaCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaC5uYW1laGFzaDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2FycmF5aWZ5Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5hcnJheWlmeTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NvbmNhdCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuY29uY2F0OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4Q29uY2F0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhDb25jYXQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhEYXRhTGVuZ3RoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhEYXRhTGVuZ3RoOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4RGF0YVNsaWNlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhEYXRhU2xpY2U7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhTdHJpcFplcm9zJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhTdHJpcFplcm9zOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4VmFsdWUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleFZhbHVlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4WmVyb1BhZCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaGV4WmVyb1BhZDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hleGxpZnknLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleGxpZnk7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc0J5dGVzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5pc0J5dGVzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaXNCeXRlc0xpa2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmlzQnl0ZXNMaWtlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaXNIZXhTdHJpbmcnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmlzSGV4U3RyaW5nOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnam9pblNpZ25hdHVyZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuam9pblNpZ25hdHVyZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NwbGl0U2lnbmF0dXJlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5zcGxpdFNpZ25hdHVyZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3N0cmlwWmVyb3MnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLnN0cmlwWmVyb3M7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd6ZXJvUGFkJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy56ZXJvUGFkOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZm9ybWF0RXRoZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzLmZvcm1hdEV0aGVyOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZm9ybWF0VW5pdHMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzLmZvcm1hdFVuaXRzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VFdGhlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMucGFyc2VFdGhlcjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3BhcnNlVW5pdHMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzLnBhcnNlVW5pdHM7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdJbnRlcmZhY2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFiaS5JbnRlcmZhY2U7IH1cbn0pO1xuZXhwb3J0cy50b1V0ZjhCeXRlcyA9IHRvVXRmOEJ5dGVzO1xuZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB0b1V0ZjhTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhhc2giLCJyZXF1aXJlIiwiYnl0ZXMiLCJ1bml0cyIsImFiaSIsInZlcnNpb24kMSIsIl9wZXJtYW5lbnRDZW5zb3JFcnJvcnMiLCJfY2Vuc29yRXJyb3JzIiwiTG9nTGV2ZWxzIiwiZGVidWciLCJpbmZvIiwid2FybmluZyIsImVycm9yIiwib2ZmIiwiX2xvZ0xldmVsIiwiX2dsb2JhbExvZ2dlciIsIl9jaGVja05vcm1hbGl6ZSIsIm1pc3NpbmciLCJmb3JFYWNoIiwiZm9ybSIsIm5vcm1hbGl6ZSIsIkVycm9yIiwicHVzaCIsImxlbmd0aCIsImpvaW4iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtZXNzYWdlIiwiX25vcm1hbGl6ZUVycm9yIiwiTG9nTGV2ZWwiLCJFcnJvckNvZGUiLCJIRVgiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsInZlcnNpb24iLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJfbG9nIiwibG9nTGV2ZWwiLCJhcmdzIiwibGV2ZWwiLCJ0b0xvd2VyQ2FzZSIsInRocm93QXJndW1lbnRFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJhcHBseSIsImxldmVscyIsIkRFQlVHIiwiSU5GTyIsIndhcm4iLCJXQVJOSU5HIiwibWFrZUVycm9yIiwiY29kZSIsInBhcmFtcyIsImVycm9ycyIsIlVOS05PV05fRVJST1IiLCJtZXNzYWdlRGV0YWlscyIsImtleXMiLCJrZXkiLCJVaW50OEFycmF5IiwiaGV4IiwiaSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b1N0cmluZyIsInJlYXNvbiIsInVybCIsIk5VTUVSSUNfRkFVTFQiLCJmYXVsdCIsIkNBTExfRVhDRVBUSU9OIiwiSU5TVUZGSUNJRU5UX0ZVTkRTIiwiTUlTU0lOR19ORVciLCJOT05DRV9FWFBJUkVEIiwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQiLCJUUkFOU0FDVElPTl9SRVBMQUNFRCIsIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUIiwidGhyb3dFcnJvciIsIm5hbWUiLCJJTlZBTElEX0FSR1VNRU5UIiwiYXJndW1lbnQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJhc3NlcnRBcmd1bWVudCIsImNoZWNrTm9ybWFsaXplIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwiY2hlY2tTYWZlVWludDUzIiwiY2hlY2tBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiTUlTU0lOR19BUkdVTUVOVCIsIlVORVhQRUNURURfQVJHVU1FTlQiLCJjaGVja05ldyIsInRhcmdldCIsImtpbmQiLCJjaGVja0Fic3RyYWN0IiwiZ2xvYmFsTG9nZ2VyIiwic2V0Q2Vuc29yc2hpcCIsImNlbnNvcnNoaXAiLCJwZXJtYW5lbnQiLCJzZXRMb2dMZXZlbCIsImZyb20iLCJsb2dnZXIiLCJVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0iLCJVdGY4RXJyb3JSZWFzb24iLCJlcnJvckZ1bmMiLCJvZmZzZXQiLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJpZ25vcmVGdW5jIiwiQkFEX1BSRUZJWCIsIlVORVhQRUNURURfQ09OVElOVUUiLCJvIiwiT1ZFUlJVTiIsInJlcGxhY2VGdW5jIiwiT1ZFUkxPTkciLCJVdGY4RXJyb3JGdW5jcyIsImZyZWV6ZSIsImlnbm9yZSIsInJlcGxhY2UiLCJnZXRVdGY4Q29kZVBvaW50cyIsImJ5dGVzJDEiLCJvbkVycm9yIiwiYXJyYXlpZnkiLCJyZXN1bHQiLCJjIiwiZXh0cmFMZW5ndGgiLCJvdmVybG9uZ01hc2siLCJyZXMiLCJqIiwibmV4dENoYXIiLCJNSVNTSU5HX0NPTlRJTlVFIiwiT1VUX09GX1JBTkdFIiwiVVRGMTZfU1VSUk9HQVRFIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJjdXJyZW50IiwiY2hhckNvZGVBdCIsImMyIiwicGFpciIsIl90b1V0ZjhTdHJpbmciLCJjb2RlUG9pbnRzIiwibWFwIiwiY29kZVBvaW50IiwidG9VdGY4U3RyaW5nIiwiYnl0ZXMyIiwiZGF0YSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiY3JlYXRlVGFibGUiLCJmdW5jIiwibG8iLCJzcGxpdCIsImNvbXBzIiwiY3JlYXRlUmFuZ2VUYWJsZSIsImhpIiwidiIsImwiLCJoIiwiZ2V0IiwiZG5zRW5jb2RlIiwiaGFzaE1lc3NhZ2UiLCJpZCIsImlzVmFsaWROYW1lIiwibmFtZWhhc2giLCJjb25jYXQiLCJoZXhDb25jYXQiLCJoZXhEYXRhTGVuZ3RoIiwiaGV4RGF0YVNsaWNlIiwiaGV4U3RyaXBaZXJvcyIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImhleGxpZnkiLCJpc0J5dGVzIiwiaXNCeXRlc0xpa2UiLCJpc0hleFN0cmluZyIsImpvaW5TaWduYXR1cmUiLCJzcGxpdFNpZ25hdHVyZSIsInN0cmlwWmVyb3MiLCJ6ZXJvUGFkIiwiZm9ybWF0RXRoZXIiLCJmb3JtYXRVbml0cyIsInBhcnNlRXRoZXIiLCJwYXJzZVVuaXRzIiwiSW50ZXJmYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js":
/*!**************************************************************!*\
  !*** ../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar axios = __webpack_require__(/*! axios */ \"(ssr)/../node_modules/axios/dist/node/axios.cjs\");\nvar abstractProvider = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\nvar wallet = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/../node_modules/@ethersproject/wallet/lib.esm/index.js\");\nvar contracts = __webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar axios__default = /*#__PURE__*/ _interopDefaultLegacy(axios);\n/**\r\n * The supported networks by Alchemy. Note that some functions are not available\r\n * on all networks. Please refer to the Alchemy documentation for which APIs are\r\n * available on which networks\r\n * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}\r\n *\r\n * @public\r\n */ exports.Network = void 0;\n(function(Network) {\n    Network[\"ETH_MAINNET\"] = \"eth-mainnet\";\n    Network[\"ETH_GOERLI\"] = \"eth-goerli\";\n    Network[\"ETH_SEPOLIA\"] = \"eth-sepolia\";\n    Network[\"OPT_MAINNET\"] = \"opt-mainnet\";\n    Network[\"OPT_GOERLI\"] = \"opt-goerli\";\n    Network[\"OPT_SEPOLIA\"] = \"opt-sepolia\";\n    Network[\"ARB_MAINNET\"] = \"arb-mainnet\";\n    Network[\"ARB_GOERLI\"] = \"arb-goerli\";\n    Network[\"ARB_SEPOLIA\"] = \"arb-sepolia\";\n    Network[\"MATIC_MAINNET\"] = \"polygon-mainnet\";\n    Network[\"MATIC_MUMBAI\"] = \"polygon-mumbai\";\n    Network[\"MATIC_AMOY\"] = \"polygon-amoy\";\n    Network[\"ASTAR_MAINNET\"] = \"astar-mainnet\";\n    Network[\"POLYGONZKEVM_MAINNET\"] = \"polygonzkevm-mainnet\";\n    Network[\"POLYGONZKEVM_TESTNET\"] = \"polygonzkevm-testnet\";\n    Network[\"BASE_MAINNET\"] = \"base-mainnet\";\n    Network[\"BASE_GOERLI\"] = \"base-goerli\";\n    Network[\"BASE_SEPOLIA\"] = \"base-sepolia\";\n    Network[\"ZKSYNC_MAINNET\"] = \"zksync-mainnet\";\n    Network[\"ZKSYNC_SEPOLIA\"] = \"zksync-sepolia\";\n})(exports.Network || (exports.Network = {}));\n/** Token Types for the `getTokenBalances()` endpoint. */ exports.TokenBalanceType = void 0;\n(function(TokenBalanceType) {\n    /**\r\n     * Option to fetch the top 100 tokens by 24-hour volume. This option is only\r\n     * available on Mainnet in Ethereum, Polygon, and Arbitrum.\r\n     */ TokenBalanceType[\"DEFAULT_TOKENS\"] = \"DEFAULT_TOKENS\";\n    /**\r\n     * Option to fetch the set of ERC-20 tokens that the address as ever held. his\r\n     * list is produced by an address's historical transfer activity and includes\r\n     * all tokens that the address has ever received.\r\n     */ TokenBalanceType[\"ERC20\"] = \"erc20\";\n})(exports.TokenBalanceType || (exports.TokenBalanceType = {}));\n/**\r\n * Categories of transfers to use with the {@link AssetTransfersParams} request\r\n * object when using {@link CoreNamespace.getAssetTransfers}.\r\n *\r\n * @public\r\n */ exports.AssetTransfersCategory = void 0;\n(function(AssetTransfersCategory) {\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * external user-created address. External addresses have private keys and are\r\n     * accessed by users.\r\n     */ AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * internal, smart contract address. For example, a smart contract calling\r\n     * another smart contract or sending\r\n     */ AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n    /** ERC20 transfers. */ AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n    /** ERC721 transfers. */ AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n    /** ERC1155 transfers. */ AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n    /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */ AssetTransfersCategory[\"SPECIALNFT\"] = \"specialnft\";\n})(exports.AssetTransfersCategory || (exports.AssetTransfersCategory = {}));\n/**\r\n * The type of transfer for the request. Note that using `TO` will also include\r\n * NFTs that were minted by the owner.\r\n */ exports.GetTransfersForOwnerTransferType = void 0;\n(function(GetTransfersForOwnerTransferType) {\n    GetTransfersForOwnerTransferType[\"TO\"] = \"TO\";\n    GetTransfersForOwnerTransferType[\"FROM\"] = \"FROM\";\n})(exports.GetTransfersForOwnerTransferType || (exports.GetTransfersForOwnerTransferType = {}));\n/**\r\n * Enum for representing the supported sorting orders of the API.\r\n *\r\n * @public\r\n */ exports.SortingOrder = void 0;\n(function(SortingOrder) {\n    SortingOrder[\"ASCENDING\"] = \"asc\";\n    SortingOrder[\"DESCENDING\"] = \"desc\";\n})(exports.SortingOrder || (exports.SortingOrder = {}));\n/** An OpenSea collection's approval status. */ exports.OpenSeaSafelistRequestStatus = void 0;\n(function(OpenSeaSafelistRequestStatus) {\n    /** Verified collection. */ OpenSeaSafelistRequestStatus[\"VERIFIED\"] = \"verified\";\n    /** Collections that are approved on open sea and can be found in search results. */ OpenSeaSafelistRequestStatus[\"APPROVED\"] = \"approved\";\n    /** Collections that requested safelisting on OpenSea. */ OpenSeaSafelistRequestStatus[\"REQUESTED\"] = \"requested\";\n    /** Brand new collections. */ OpenSeaSafelistRequestStatus[\"NOT_REQUESTED\"] = \"not_requested\";\n})(exports.OpenSeaSafelistRequestStatus || (exports.OpenSeaSafelistRequestStatus = {}));\n/**\r\n * Method names for Alchemy's custom Subscription API endpoints.\r\n *\r\n * This value is provided in the `method` field when creating an event filter on\r\n * the Websocket Namespace.\r\n */ exports.AlchemySubscription = void 0;\n(function(AlchemySubscription) {\n    AlchemySubscription[\"PENDING_TRANSACTIONS\"] = \"alchemy_pendingTransactions\";\n    AlchemySubscription[\"MINED_TRANSACTIONS\"] = \"alchemy_minedTransactions\";\n})(exports.AlchemySubscription || (exports.AlchemySubscription = {}));\n/**\r\n * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n * Allows you to determine if the assets approved or / and transferred are\r\n * native, tokens or NFTs.\r\n */ exports.SimulateAssetType = void 0;\n(function(SimulateAssetType) {\n    /**\r\n     * Native transfers that involve the currency of the chain the simulation is\r\n     * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).\r\n     */ SimulateAssetType[\"NATIVE\"] = \"NATIVE\";\n    /** ERC20 approval or transfers. */ SimulateAssetType[\"ERC20\"] = \"ERC20\";\n    /** ERC721 approval or transfers. */ SimulateAssetType[\"ERC721\"] = \"ERC721\";\n    /** ERC1155 approval or transfers. */ SimulateAssetType[\"ERC1155\"] = \"ERC1155\";\n    /**\r\n     * Special contracts that don't follow ERC 721/1155.Currently limited to\r\n     * CryptoKitties and CryptoPunks.\r\n     */ SimulateAssetType[\"SPECIAL_NFT\"] = \"SPECIAL_NFT\";\n})(exports.SimulateAssetType || (exports.SimulateAssetType = {}));\n/**\r\n * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n */ exports.SimulateChangeType = void 0;\n(function(SimulateChangeType) {\n    /**\r\n     * Represents a transaction that approved or disapproved permissions for a\r\n     * contract.\r\n     *\r\n     * APPROVE without token ID → approve all tokens\r\n     * APPROVE without amount → approve all amount\r\n     * APPROVE with zero amount → approval being cleared\r\n     */ SimulateChangeType[\"APPROVE\"] = \"APPROVE\";\n    /**\r\n     * Represents a transaction that transferred tokens from one address to another.\r\n     */ SimulateChangeType[\"TRANSFER\"] = \"TRANSFER\";\n})(exports.SimulateChangeType || (exports.SimulateChangeType = {}));\n/**\r\n * Authority used to decode calls and logs when using the\r\n * {@link TransactNamespace.simulateExecution} method.\r\n */ exports.DecodingAuthority = void 0;\n(function(DecodingAuthority) {\n    DecodingAuthority[\"ETHERSCAN\"] = \"ETHERSCAN\";\n})(exports.DecodingAuthority || (exports.DecodingAuthority = {}));\n/** The type of call in a debug call trace. */ exports.DebugCallType = void 0;\n(function(DebugCallType) {\n    DebugCallType[\"CREATE\"] = \"CREATE\";\n    DebugCallType[\"CALL\"] = \"CALL\";\n    DebugCallType[\"STATICCALL\"] = \"STATICCALL\";\n    DebugCallType[\"DELEGATECALL\"] = \"DELEGATECALL\";\n})(exports.DebugCallType || (exports.DebugCallType = {}));\n/**\r\n * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}\r\n *\r\n * @internal\r\n */ // TODO(txjob): Remove internal tag once this feature is released.\nexports.GasOptimizedTransactionStatus = void 0;\n(function(GasOptimizedTransactionStatus) {\n    GasOptimizedTransactionStatus[\"UNSPECIFIED\"] = \"TRANSACTION_JOB_STATUS_UNSPECIFIED\";\n    GasOptimizedTransactionStatus[\"IN_PROGRESS\"] = \"IN_PROGRESS\";\n    GasOptimizedTransactionStatus[\"COMPLETE\"] = \"COMPLETE\";\n    GasOptimizedTransactionStatus[\"ABANDONED\"] = \"ABANDONED\";\n})(exports.GasOptimizedTransactionStatus || (exports.GasOptimizedTransactionStatus = {}));\n/** The version of the webhook. All newly created webhooks default to V2. */ exports.WebhookVersion = void 0;\n(function(WebhookVersion) {\n    WebhookVersion[\"V1\"] = \"V1\";\n    WebhookVersion[\"V2\"] = \"V2\";\n})(exports.WebhookVersion || (exports.WebhookVersion = {}));\n/** The type of {@link Webhook}. */ exports.WebhookType = void 0;\n(function(WebhookType) {\n    WebhookType[\"MINED_TRANSACTION\"] = \"MINED_TRANSACTION\";\n    WebhookType[\"DROPPED_TRANSACTION\"] = \"DROPPED_TRANSACTION\";\n    WebhookType[\"ADDRESS_ACTIVITY\"] = \"ADDRESS_ACTIVITY\";\n    WebhookType[\"NFT_ACTIVITY\"] = \"NFT_ACTIVITY\";\n    WebhookType[\"NFT_METADATA_UPDATE\"] = \"NFT_METADATA_UPDATE\";\n    WebhookType[\"GRAPHQL\"] = \"GRAPHQL\";\n})(exports.WebhookType || (exports.WebhookType = {}));\n/**\r\n * Commitment level of the target block with using methods in the\r\n * {@link DebugNamespace}\r\n */ exports.CommitmentLevel = void 0;\n(function(CommitmentLevel) {\n    /**\r\n     * Sample next block inferred by Alchemy built on top of the latest block.\r\n     * This contains the set of transactions taken from the local mempool and\r\n     * is a proxy for blocks that have not been mined yet.\r\n     */ CommitmentLevel[\"PENDING\"] = \"pending\";\n    /**\r\n     * The most recent block in the canonical chain observed by Alchemy. Note that\r\n     * this block may be re-orged out of the canonical chain.\r\n     */ CommitmentLevel[\"LATEST\"] = \"latest\";\n    /**\r\n     * The most recent crypto-economically secure block that cannot be re-orged\r\n     * outside of manual intervention driven by community coordination. This is\r\n     * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"SAFE\"] = \"safe\";\n    /**\r\n     * The most recent secure block that has been accepted by >2/3 of validators.\r\n     * This block is very unlikely to be re-orged. This is only available on\r\n     * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"FINALIZED\"] = \"finalized\";\n    /**\r\n     * The lowest numbered block available that is usually the first block created.\r\n     */ CommitmentLevel[\"EARLIEST\"] = \"earliest\";\n})(exports.CommitmentLevel || (exports.CommitmentLevel = {}));\n/**\r\n * The type of tracer to use when running debug methods in the\r\n * {@link DebugNamespace}.\r\n */ exports.DebugTracerType = void 0;\n(function(DebugTracerType) {\n    DebugTracerType[\"CALL_TRACER\"] = \"callTracer\";\n    DebugTracerType[\"PRESTATE_TRACER\"] = \"prestateTracer\";\n})(exports.DebugTracerType || (exports.DebugTracerType = {}));\n/**\r\n * An enum for specifying the token type on NFTs.\r\n *\r\n * @public\r\n */ exports.NftTokenType = void 0;\n(function(NftTokenType) {\n    NftTokenType[\"ERC721\"] = \"ERC721\";\n    NftTokenType[\"ERC1155\"] = \"ERC1155\";\n    NftTokenType[\"NO_SUPPORTED_NFT_STANDARD\"] = \"NO_SUPPORTED_NFT_STANDARD\";\n    NftTokenType[\"NOT_A_CONTRACT\"] = \"NOT_A_CONTRACT\";\n    NftTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(exports.NftTokenType || (exports.NftTokenType = {}));\n/** Potential reasons why an NFT contract was classified as spam. */ exports.NftSpamClassification = void 0;\n(function(NftSpamClassification) {\n    NftSpamClassification[\"Erc721TooManyOwners\"] = \"Erc721TooManyOwners\";\n    NftSpamClassification[\"Erc721TooManyTokens\"] = \"Erc721TooManyTokens\";\n    NftSpamClassification[\"Erc721DishonestTotalSupply\"] = \"Erc721DishonestTotalSupply\";\n    NftSpamClassification[\"MostlyHoneyPotOwners\"] = \"MostlyHoneyPotOwners\";\n    NftSpamClassification[\"OwnedByMostHoneyPots\"] = \"OwnedByMostHoneyPots\";\n    NftSpamClassification[\"LowDistinctOwnersPercent\"] = \"LowDistinctOwnersPercent\";\n    NftSpamClassification[\"HighHoneyPotOwnerPercent\"] = \"HighHoneyPotOwnerPercent\";\n    NftSpamClassification[\"HighHoneyPotPercent\"] = \"HighHoneyPotPercent\";\n    NftSpamClassification[\"HoneyPotsOwnMultipleTokens\"] = \"HoneyPotsOwnMultipleTokens\";\n    NftSpamClassification[\"NoSalesActivity\"] = \"NoSalesActivity\";\n    NftSpamClassification[\"HighAirdropPercent\"] = \"HighAirdropPercent\";\n    NftSpamClassification[\"Unknown\"] = \"Unknown\";\n})(exports.NftSpamClassification || (exports.NftSpamClassification = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} request.\r\n *\r\n * @beta\r\n */ exports.NftFilters = void 0;\n(function(NftFilters) {\n    /** NFTs that have been classified as spam. */ NftFilters[\"SPAM\"] = \"SPAM\";\n    /** NFTs that have been airdropped to a user. */ NftFilters[\"AIRDROPS\"] = \"AIRDROPS\";\n})(exports.NftFilters || (exports.NftFilters = {}));\n/**\r\n * Enum of ordering that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} response.\r\n *\r\n * @beta\r\n */ exports.NftOrdering = void 0;\n(function(NftOrdering) {\n    NftOrdering[\"TRANSFERTIME\"] = \"TRANSFERTIME\";\n})(exports.NftOrdering || (exports.NftOrdering = {}));\n/**\r\n * Enum representing the supported NFT marketplaces by the\r\n * {@link NftNamespace.getNftSales} method.\r\n *\r\n * @public\r\n */ exports.NftSaleMarketplace = void 0;\n(function(NftSaleMarketplace) {\n    NftSaleMarketplace[\"SEAPORT\"] = \"seaport\";\n    NftSaleMarketplace[\"LOOKSRARE\"] = \"looksrare\";\n    NftSaleMarketplace[\"X2Y2\"] = \"x2y2\";\n    NftSaleMarketplace[\"WYVERN\"] = \"wyvern\";\n    NftSaleMarketplace[\"CRYPTOPUNKS\"] = \"cryptopunks\";\n    NftSaleMarketplace[\"BLUR\"] = \"blur\";\n    NftSaleMarketplace[\"UNKNOWN\"] = \"unknown\";\n})(exports.NftSaleMarketplace || (exports.NftSaleMarketplace = {}));\n/**\r\n * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}\r\n * method.\r\n *\r\n * @public\r\n */ exports.NftSaleTakerType = void 0;\n(function(NftSaleTakerType) {\n    NftSaleTakerType[\"BUYER\"] = \"buyer\";\n    NftSaleTakerType[\"SELLER\"] = \"seller\";\n})(exports.NftSaleTakerType || (exports.NftSaleTakerType = {}));\n/** The current state of the NFT contract refresh process. */ exports.NftRefreshState = void 0;\n(function(NftRefreshState) {\n    /** The provided contract is not an NFT or does not contain metadata. */ NftRefreshState[\"DOES_NOT_EXIST\"] = \"does_not_exist\";\n    /** The contract has already been queued for refresh. */ NftRefreshState[\"ALREADY_QUEUED\"] = \"already_queued\";\n    /** The contract is currently being refreshed. */ NftRefreshState[\"IN_PROGRESS\"] = \"in_progress\";\n    /** The contract refresh is complete. */ NftRefreshState[\"FINISHED\"] = \"finished\";\n    /** The contract refresh has been queued and await execution. */ NftRefreshState[\"QUEUED\"] = \"queued\";\n    /** The contract was unable to be queued due to an internal error. */ NftRefreshState[\"QUEUE_FAILED\"] = \"queue_failed\";\n})(exports.NftRefreshState || (exports.NftRefreshState = {}));\n/**\r\n * Enum representing the supported NFT marketplaces on a\r\n * {@link NftCollectionFloorPrice} object.\r\n */ exports.NftCollectionMarketplace = void 0;\n(function(NftCollectionMarketplace) {\n    NftCollectionMarketplace[\"OPENSEA\"] = \"OpenSea\";\n})(exports.NftCollectionMarketplace || (exports.NftCollectionMarketplace = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter$1(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nconst DEFAULT_ALCHEMY_API_KEY = \"demo\";\nconst DEFAULT_NETWORK = exports.Network.ETH_MAINNET;\nconst DEFAULT_MAX_RETRIES = 5;\nconst DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout\n/**\r\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\r\n * endpoints only work with non eth json-rpc requests.\r\n *\r\n * @internal\r\n */ function getAlchemyHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyNftHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/nft/v3/${apiKey}`;\n}\nfunction getAlchemyWsUrl(network, apiKey) {\n    return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyWebhookHttpUrl() {\n    return \"https://dashboard.alchemy.com/api\";\n}\nvar AlchemyApiType;\n(function(AlchemyApiType) {\n    AlchemyApiType[AlchemyApiType[\"BASE\"] = 0] = \"BASE\";\n    AlchemyApiType[AlchemyApiType[\"NFT\"] = 1] = \"NFT\";\n    AlchemyApiType[AlchemyApiType[\"WEBHOOK\"] = 2] = \"WEBHOOK\";\n})(AlchemyApiType || (AlchemyApiType = {}));\n/**\r\n * Mapping of network names to their corresponding Network strings used to\r\n * create an Ethers.js Provider instance.\r\n */ const EthersNetwork = {\n    [exports.Network.ETH_MAINNET]: \"mainnet\",\n    [exports.Network.ETH_GOERLI]: \"goerli\",\n    [exports.Network.ETH_SEPOLIA]: \"sepolia\",\n    [exports.Network.OPT_MAINNET]: \"optimism\",\n    [exports.Network.OPT_GOERLI]: \"optimism-goerli\",\n    [exports.Network.OPT_SEPOLIA]: \"optimism-sepolia\",\n    [exports.Network.ARB_MAINNET]: \"arbitrum\",\n    [exports.Network.ARB_GOERLI]: \"arbitrum-goerli\",\n    [exports.Network.ARB_SEPOLIA]: \"arbitrum-sepolia\",\n    [exports.Network.MATIC_MAINNET]: \"matic\",\n    [exports.Network.MATIC_MUMBAI]: \"maticmum\",\n    [exports.Network.MATIC_AMOY]: \"maticamoy\",\n    [exports.Network.ASTAR_MAINNET]: \"astar-mainnet\",\n    [exports.Network.POLYGONZKEVM_MAINNET]: \"polygonzkevm-mainnet\",\n    [exports.Network.POLYGONZKEVM_TESTNET]: \"polygonzkevm-testnet\",\n    [exports.Network.BASE_MAINNET]: \"base-mainnet\",\n    [exports.Network.BASE_GOERLI]: \"base-goerli\",\n    [exports.Network.BASE_SEPOLIA]: \"base-sepolia\",\n    [exports.Network.ZKSYNC_MAINNET]: \"zksync-mainnet\",\n    [exports.Network.ZKSYNC_SEPOLIA]: \"zksync-sepolia\"\n};\n/**\r\n * Mapping of network names to their corresponding Ethers Network objects. These\r\n * networks are not yet supported by Ethers and are listed here to be overriden\r\n * in the provider.\r\n */ const CustomNetworks = {\n    \"arbitrum-goerli\": {\n        chainId: 421613,\n        name: \"arbitrum-goerli\"\n    },\n    \"arbitrum-sepolia\": {\n        chainId: 421614,\n        name: \"arbitrum-sepolia\"\n    },\n    \"astar-mainnet\": {\n        chainId: 592,\n        name: \"astar-mainnet\"\n    },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\"\n    },\n    \"optimism-sepolia\": {\n        chainId: 11155420,\n        name: \"optimism-sepolia\"\n    },\n    \"polygonzkevm-mainnet\": {\n        chainId: 1101,\n        name: \"polygonzkevm-mainnet\"\n    },\n    \"polygonzkevm-testnet\": {\n        chainId: 1442,\n        name: \"polygonzkevm-testnet\"\n    },\n    \"base-mainnet\": {\n        chainId: 8453,\n        name: \"base-mainnet\"\n    },\n    \"base-goerli\": {\n        chainId: 84531,\n        name: \"base-goerli\"\n    },\n    \"base-sepolia\": {\n        chainId: 84532,\n        name: \"base-sepolia\"\n    },\n    maticamoy: {\n        chainId: 80002,\n        name: \"maticamoy\"\n    },\n    \"zksync-mainnet\": {\n        chainId: 324,\n        name: \"zksync-mainnet\"\n    },\n    \"zksync-sepolia\": {\n        chainId: 300,\n        name: \"zksync-sepolia\"\n    }\n};\nfunction noop() {\n// It's a no-op\n}\nconst ETH_NULL_VALUE = \"0x\";\nconst ETH_NULL_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n/**\r\n * This class holds the config information for the SDK client instance and\r\n * exposes the underlying providers for more advanced use cases.\r\n *\r\n * @public\r\n */ class AlchemyConfig {\n    constructor(config){\n        this.apiKey = (config === null || config === void 0 ? void 0 : config.apiKey) || DEFAULT_ALCHEMY_API_KEY;\n        this.network = (config === null || config === void 0 ? void 0 : config.network) || DEFAULT_NETWORK;\n        this.maxRetries = (config === null || config === void 0 ? void 0 : config.maxRetries) || DEFAULT_MAX_RETRIES;\n        this.url = config === null || config === void 0 ? void 0 : config.url;\n        this.authToken = config === null || config === void 0 ? void 0 : config.authToken;\n        this.batchRequests = (config === null || config === void 0 ? void 0 : config.batchRequests) || false;\n        this.requestTimeout = (config === null || config === void 0 ? void 0 : config.requestTimeout) || DEFAULT_REQUEST_TIMEOUT;\n        this.connectionInfoOverrides = config === null || config === void 0 ? void 0 : config.connectionInfoOverrides;\n    }\n    /**\r\n     * Returns the URL endpoint to send the HTTP request to. If a custom URL was\r\n     * provided in the config, that URL is returned. Otherwise, the default URL is\r\n     * from the network and API key.\r\n     *\r\n     * @param apiType - The type of API to get the URL for.\r\n     * @internal\r\n     */ _getRequestUrl(apiType) {\n        if (this.url !== undefined) {\n            return this.url;\n        } else if (apiType === AlchemyApiType.NFT) {\n            return getAlchemyNftHttpUrl(this.network, this.apiKey);\n        } else if (apiType === AlchemyApiType.WEBHOOK) {\n            return getAlchemyWebhookHttpUrl();\n        } else {\n            return getAlchemyHttpUrl(this.network, this.apiKey);\n        }\n    }\n    /**\r\n     * Returns an AlchemyProvider instance. Only one provider is created per\r\n     * Alchemy instance.\r\n     *\r\n     * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and\r\n     * has been expanded to support Alchemy's Enhanced APIs.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     *\r\n     * @public\r\n     */ getProvider() {\n        if (!this._baseAlchemyProvider) {\n            this._baseAlchemyProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-provider-7ab90821.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-provider-7ab90821.js\");\n                    });\n                    return new AlchemyProvider(this);\n                }))();\n        }\n        return this._baseAlchemyProvider;\n    }\n    /**\r\n     * Returns an AlchemyWebsocketProvider instance. Only one provider is created\r\n     * per Alchemy instance.\r\n     *\r\n     * The AlchemyWebSocketProvider is a wrapper around ether's\r\n     * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's\r\n     * Subscription APIs, automatic backfilling, and other performance improvements.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     */ getWebSocketProvider() {\n        if (!this._baseAlchemyWssProvider) {\n            this._baseAlchemyWssProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyWebSocketProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-websocket-provider-44df3739.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-44df3739.js\");\n                    });\n                    return new AlchemyWebSocketProvider(this);\n                }))();\n        }\n        return this._baseAlchemyWssProvider;\n    }\n}\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel$1;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel$1 || (LogLevel$1 = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger$1 {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger$1.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger$1.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger$1.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger$1.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger$1.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger$1.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger$1.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger$1(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger$1.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger$1(version);\n    }\n}\nLogger$1.errors = ErrorCode;\nLogger$1.levels = LogLevel$1;\nconst version = \"properties/5.7.0\";\nvar __awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst logger = new Logger$1(version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false\n    });\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const promises = Object.keys(object).map((key)=>{\n            const value = object[key];\n            return Promise.resolve(value).then((v)=>({\n                    key: key,\n                    value: v\n                }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result)=>{\n            accum[result.key] = result.value;\n            return accum;\n        }, {});\n    });\n}\nconst opaque = {\n    bigint: true,\n    boolean: true,\n    \"function\": true,\n    number: true,\n    string: true\n};\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof object === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            let value = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item)=>deepCopy(item)));\n    }\n    if (typeof object === \"object\") {\n        const result = {};\n        for(const key in object){\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\n/**\r\n * Converts a hex string to a decimal number.\r\n *\r\n * @param hexString - The hex string to convert.\r\n * @public\r\n */ function fromHex(hexString) {\n    return bignumber.BigNumber.from(hexString).toNumber();\n}\n/**\r\n * Converts a number to a hex string.\r\n *\r\n * @param num - The number to convert to hex.\r\n * @public\r\n */ function toHex(num) {\n    return bignumber.BigNumber.from(num).toHexString();\n}\n/**\r\n * Checks if a value is a hex string.\r\n *\r\n * @param possibleHexString - The value to check.\r\n * @public\r\n */ function isHex(possibleHexString) {\n    return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\nfunction formatBlock(block) {\n    if (typeof block === \"string\") {\n        return block;\n    } else if (Number.isInteger(block)) {\n        return toHex(block);\n    }\n    return block.toString();\n}\nfunction stringToEnum(x, enumb) {\n    return Object.values(enumb).includes(x) ? x : null;\n}\nfunction getNftContractForNftFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        spamClassifications: rawNftContract.spamClassifications.map(parseNftSpamClassification)\n    }));\n}\nfunction getNftContractsForOwnerFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        displayNft: rawNftContract.displayNft,\n        image: rawNftContract.image,\n        totalBalance: rawNftContract.totalBalance,\n        numDistinctTokensOwned: rawNftContract.numDistinctTokensOwned,\n        isSpam: rawNftContract.isSpam\n    }));\n}\nfunction getNftContractFromRaw(rawNftContract) {\n    var _a;\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftContract), {\n        tokenType: parseNftTokenType(rawNftContract.tokenType),\n        openSeaMetadata: Object.assign(Object.assign({}, rawNftContract.openSeaMetadata), {\n            safelistRequestStatus: ((_a = rawNftContract.openSeaMetadata) === null || _a === void 0 ? void 0 : _a.safelistRequestStatus) !== null ? stringToEnum(rawNftContract.openSeaMetadata.safelistRequestStatus, exports.OpenSeaSafelistRequestStatus) : null\n        })\n    }));\n}\nfunction getNftCollectionFromRaw(rawNftCollection) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftCollection), {\n        floorPrice: Object.assign(Object.assign({}, rawNftCollection.floorPrice), {\n            marketplace: parseNftCollectionMarketplace(rawNftCollection.floorPrice.marketplace)\n        })\n    }));\n}\nfunction getBaseNftFromRaw(rawBaseNft, contractAddress) {\n    return {\n        contractAddress: contractAddress ? contractAddress : rawBaseNft.contractAddress,\n        tokenId: rawBaseNft.tokenId\n    };\n}\nfunction getNftFromRaw(rawNft) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNft), {\n        contract: getNftContractForNftFromRaw(rawNft.contract),\n        tokenType: parseNftTokenType(rawNft.tokenType),\n        acquiredAt: rawNft.acquiredAt,\n        collection: rawNft.collection,\n        mint: rawNft.mint\n    }));\n}\nfunction getNftSalesFromRaw(rawNftSales) {\n    return nullsToUndefined({\n        nftSales: rawNftSales.nftSales.map((rawNftSale)=>Object.assign(Object.assign({}, rawNftSale), {\n                marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),\n                taker: parseNftTaker(rawNftSale.taker)\n            })),\n        validAt: rawNftSales.validAt,\n        pageKey: rawNftSales.pageKey\n    });\n}\nfunction parseNftSaleMarketplace(marketplace) {\n    switch(marketplace){\n        case \"looksrare\":\n            return exports.NftSaleMarketplace.LOOKSRARE;\n        case \"seaport\":\n            return exports.NftSaleMarketplace.SEAPORT;\n        case \"x2y2\":\n            return exports.NftSaleMarketplace.X2Y2;\n        case \"wyvern\":\n            return exports.NftSaleMarketplace.WYVERN;\n        case \"cryptopunks\":\n            return exports.NftSaleMarketplace.CRYPTOPUNKS;\n        case \"blur\":\n            return exports.NftSaleMarketplace.BLUR;\n        default:\n            return exports.NftSaleMarketplace.UNKNOWN;\n    }\n}\nfunction parseNftCollectionMarketplace(marketplace) {\n    switch(marketplace){\n        case \"OpenSea\":\n            return exports.NftCollectionMarketplace.OPENSEA;\n        default:\n            return undefined;\n    }\n}\nfunction parseNftTaker(taker) {\n    // The `.toLowerCase()` call is needed because the API returns the capitalized values\n    switch(taker.toLowerCase()){\n        case \"buyer\":\n            return exports.NftSaleTakerType.BUYER;\n        case \"seller\":\n            return exports.NftSaleTakerType.SELLER;\n        default:\n            throw new Error(`Unsupported NftSaleTakerType ${taker}`);\n    }\n}\nfunction parseNftSpamClassification(s) {\n    const res = stringToEnum(s, exports.NftSpamClassification);\n    if (res == null) {\n        return exports.NftSpamClassification.Unknown;\n    }\n    return res;\n}\nfunction parseNftTokenType(tokenType) {\n    switch(tokenType){\n        case \"erc721\":\n        case \"ERC721\":\n            return exports.NftTokenType.ERC721;\n        case \"erc1155\":\n        case \"ERC1155\":\n            return exports.NftTokenType.ERC1155;\n        case \"no_supported_nft_standard\":\n        case \"NO_SUPPORTED_NFT_STANDARD\":\n            return exports.NftTokenType.NO_SUPPORTED_NFT_STANDARD;\n        case \"not_a_contract\":\n        case \"NOT_A_CONTRACT\":\n            return exports.NftTokenType.NOT_A_CONTRACT;\n        default:\n            return exports.NftTokenType.UNKNOWN;\n    }\n}\nconst IS_BROWSER =  false && 0;\nfunction nullsToUndefined(obj) {\n    if (obj === null || obj === undefined) {\n        return undefined;\n    }\n    if (obj.constructor.name === \"Object\" || Array.isArray(obj)) {\n        for(const key in obj){\n            obj[key] = nullsToUndefined(obj[key]);\n        }\n    }\n    return obj;\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link CoreNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * CoreNamespace, or override the `srcMethod` param used for logging.\r\n */ /**\r\n * Gets the asset transfers for the provided params.\r\n */ function getAssetTransfers(config, params, srcMethod = \"getAssetTransfers\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        if (params.fromAddress) {\n            params.fromAddress = yield provider._getAddress(params.fromAddress);\n        }\n        if (params.toAddress) {\n            params.toAddress = yield provider._getAddress(params.toAddress);\n        }\n        return provider._send(\"alchemy_getAssetTransfers\", [\n            Object.assign(Object.assign({}, params), {\n                fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n                toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n                maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n            })\n        ], srcMethod);\n    });\n}\nfunction getTransactionReceipts(config, params, srcMethod = \"getTransactionReceipts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        return provider._send(\"alchemy_getTransactionReceipts\", [\n            params\n        ], srcMethod);\n    });\n}\n/**\r\n * This method is based on the ethers implementation of getLogs, but is expanded\r\n * to support specifying an address array in the filter.\r\n *\r\n * The main modifications made to support an address array are:\r\n * - Custom `getFilter()` method that supports an address array\r\n * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.\r\n * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.\r\n */ function getLogs(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        yield provider.getNetwork();\n        const params = yield resolveProperties({\n            filter: getFilter(config, filter)\n        });\n        const logs = yield provider.send(\"eth_getLogs\", [\n            params.filter\n        ]);\n        logs.forEach((log)=>{\n            if (log.removed == null) {\n                log.removed = false;\n            }\n        });\n        return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);\n    });\n}\n/**\r\n * This method is based on and copied from the ethers implementation of\r\n * `JsonRpcProvider._getFilter()`, but is extended to support an address array.\r\n *\r\n * This implementation is a hacky way to get around the ethers formatter. The\r\n * formatter is used to check the types of the `filter` params, but ethers does\r\n * not allow an array in the `address` field. To preserve the ethers formatter\r\n * on the other fields, we use the formatter to check the types of those other\r\n * fields, and then manually check the `address` field last.\r\n */ function getFilter(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // START MODIFIED CODE\n        const provider = yield config.getProvider();\n        const resolvedFilter = yield filter;\n        let result = {};\n        // END MODIFIED CODE\n        [\n            \"blockHash\",\n            \"topics\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = resolvedFilter[key];\n        });\n        [\n            \"fromBlock\",\n            \"toBlock\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = provider._getBlockTag(resolvedFilter[key]);\n        });\n        // BEGIN MODIFIED CODE\n        // Format the `result` object using the ethers formatter without the `address`\n        // field.\n        result = provider.formatter.filter((yield resolveProperties(result)));\n        // After formatting the other fields, manually format the `address` field\n        // before adding it to the `result` object.\n        if (Array.isArray(resolvedFilter.address)) {\n            result.address = yield Promise.all(resolvedFilter.address.map((address)=>__awaiter$1(this, void 0, void 0, function*() {\n                    return provider._getAddress(address);\n                })));\n        } else if (resolvedFilter.address != null) {\n            result.address = yield provider._getAddress(resolvedFilter.address);\n        }\n        return result;\n    // END MODIFIED CODE\n    });\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * This function is directly copied over from ethers implementation of\r\n * `Formatter.arrayOf()`. It is copied here to avoid having to import the\r\n * `Formatter` class or `FormatterFunc` type from ethers, that are not part of\r\n * the default export.\r\n *\r\n * This function returns a function that applies the formatter to an array of\r\n * values, and is used to format the logs returned by `getLogs()`.\r\n */ function arrayOf(format) {\n    return function(array) {\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        const result = [];\n        array.forEach((value)=>{\n            result.push(format(value));\n        });\n        return result;\n    };\n}\n/**\r\n * The core namespace contains all commonly-used [Ethers.js\r\n * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)\r\n * methods. If you are already using Ethers.js, you should be simply able to\r\n * replace the Ethers.js Provider object with `alchemy.core` when accessing\r\n * provider methods and it should just work.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.core`.\r\n */ class CoreNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Returns the balance of a given address as of the provided block.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the balance for.\r\n     * @param blockTag The optional block number or hash to get the balance for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getBalance(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBalance(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Checks if the provided address is a smart contract.\r\n     *\r\n     * @param address The address to check type for.\r\n     * @public\r\n     */ isContractAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const code = yield provider.getCode(address);\n            return code !== \"0x\";\n        });\n    }\n    /**\r\n     * Returns the contract code of the provided address at the block. If there is\r\n     * no contract deployed, the result is `0x`.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getCode(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getCode(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Return the value of the provided position at the provided address, at the\r\n     * provided block in `Bytes32` format.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param position The position of the storage slot to get.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getStorageAt(addressOrName, position, blockTag);\n        });\n    }\n    /**\r\n     * Returns the number of transactions ever sent from the provided address, as\r\n     * of the provided block tag. This value is used as the nonce for the next\r\n     * transaction from the address sent to the network.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the nonce for.\r\n     * @param blockTag The optional block number or hash to get the nonce for.\r\n     * @public\r\n     */ getTransactionCount(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionCount(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of transaction\r\n     * hashes. To get the full transaction details on the block, use\r\n     * {@link getBlockWithTransactions} instead.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlock(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlock(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of\r\n     * {@link TransactionResponse} objects.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlockWithTransactions(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockWithTransactions(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the {@link EthersNetworkAlias} Alchemy is connected to.\r\n     *\r\n     * @public\r\n     */ getNetwork() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getNetwork();\n        });\n    }\n    /**\r\n     * Returns the block number of the most recently mined block.\r\n     *\r\n     * @public\r\n     */ getBlockNumber() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockNumber();\n        });\n    }\n    /**\r\n     * Returns the best guess of the current gas price to use in a transaction.\r\n     *\r\n     * @public\r\n     */ getGasPrice() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getGasPrice();\n        });\n    }\n    /**\r\n     * Returns the recommended fee data to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @public\r\n     */ getFeeData() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getFeeData();\n        });\n    }\n    /**\r\n     * Returns a Promise which will stall until the network has heen established,\r\n     * ignoring errors due to the target node not being active yet.\r\n     *\r\n     * This can be used for testing or attaching scripts to wait until the node is\r\n     * up and running smoothly.\r\n     *\r\n     * @public\r\n     */ ready() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.ready;\n        });\n    }\n    /**\r\n     * Returns the result of executing the transaction, using call. A call does\r\n     * not require any ether, but cannot change any state. This is useful for\r\n     * calling getters on Contracts.\r\n     *\r\n     * @param transaction The transaction to execute.\r\n     * @param blockTag The optional block number or hash to get the call for.\r\n     * @public\r\n     */ call(transaction, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.call(transaction, blockTag);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link TransactNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Returns the transaction receipt for hash or null if the transaction has not\r\n     * been mined.\r\n     *\r\n     * To stall until the transaction has been mined, consider the\r\n     * waitForTransaction method below.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransactionReceipt(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionReceipt(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    /**\r\n     * Returns an array of logs that match the provided filter.\r\n     *\r\n     * @param filter The filter object to use.\r\n     * @public\r\n     */ getLogs(filter) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getLogs(this.config, filter);\n        });\n    }\n    /**\r\n     * Allows sending a raw message to the Alchemy backend.\r\n     *\r\n     * @param method The method to call.\r\n     * @param params The parameters to pass to the method.\r\n     * @public\r\n     */ send(method, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.send(method, params);\n        });\n    }\n    /**\r\n     * Finds the address that deployed the provided contract and block number it\r\n     * was deployed in.\r\n     *\r\n     * NOTE: This method performs a binary search across all blocks since genesis\r\n     * and can take a long time to complete. This method is a convenience method\r\n     * that will eventually be replaced by a single call to an Alchemy endpoint\r\n     * with this information cached.\r\n     *\r\n     * @param contractAddress - The contract address to find the deployer for.\r\n     * @beta\r\n     */ findContractDeployer(contractAddress) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const currentBlockNum = yield provider.getBlockNumber();\n            if ((yield provider.getCode(contractAddress, currentBlockNum)) === ETH_NULL_VALUE) {\n                throw new Error(`Contract '${contractAddress}' does not exist`);\n            }\n            // Binary search for the block number that the contract was deployed in.\n            const firstBlock = yield binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, this.config);\n            // Find the first transaction in the block that matches the provided address.\n            const txReceipts = yield getTransactionReceipts(this.config, {\n                blockNumber: toHex(firstBlock)\n            }, \"findContractDeployer\");\n            const matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find((receipt)=>receipt.contractAddress === contractAddress.toLowerCase());\n            return {\n                deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,\n                blockNumber: firstBlock\n            };\n        });\n    }\n    getTokenBalances(addressOrName, contractAddressesOrOptions) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            if (Array.isArray(contractAddressesOrOptions)) {\n                if (contractAddressesOrOptions.length > 1500) {\n                    throw new Error(\"You cannot pass in more than 1500 contract addresses to getTokenBalances()\");\n                }\n                if (contractAddressesOrOptions.length === 0) {\n                    throw new Error(\"getTokenBalances() requires at least one contractAddress when using an array\");\n                }\n                return provider._send(\"alchemy_getTokenBalances\", [\n                    address,\n                    contractAddressesOrOptions\n                ], \"getTokenBalances\");\n            } else {\n                const tokenType = contractAddressesOrOptions === undefined ? exports.TokenBalanceType.ERC20 : contractAddressesOrOptions.type;\n                const params = [\n                    address,\n                    tokenType\n                ];\n                if ((contractAddressesOrOptions === null || contractAddressesOrOptions === void 0 ? void 0 : contractAddressesOrOptions.type) === exports.TokenBalanceType.ERC20 && contractAddressesOrOptions.pageKey) {\n                    params.push({\n                        pageKey: contractAddressesOrOptions.pageKey\n                    });\n                }\n                return provider._send(\"alchemy_getTokenBalances\", params, \"getTokenBalances\");\n            }\n        });\n    }\n    /**\r\n     * Returns the tokens that the specified address owns, along with the amount\r\n     * of each token and the relevant metadata.\r\n     *\r\n     * @param addressOrName The owner address to get the tokens with balances for.\r\n     * @param options Additional options to pass to the request.\r\n     * @public\r\n     */ getTokensForOwner(addressOrName, options) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            const params = [\n                address,\n                (_a = options === null || options === void 0 ? void 0 : options.contractAddresses) !== null && _a !== void 0 ? _a : exports.TokenBalanceType.ERC20\n            ];\n            if (options === null || options === void 0 ? void 0 : options.pageKey) {\n                params.push({\n                    pageKey: options.pageKey\n                });\n            }\n            const response = yield provider._send(\"alchemy_getTokenBalances\", params, \"getTokensForOwner\");\n            const formattedBalances = response.tokenBalances.map((balance)=>({\n                    contractAddress: balance.contractAddress,\n                    rawBalance: bignumber.BigNumber.from(balance.tokenBalance).toString()\n                }));\n            const metadataPromises = yield Promise.allSettled(response.tokenBalances.map((token)=>provider._send(\"alchemy_getTokenMetadata\", [\n                    token.contractAddress\n                ], \"getTokensForOwner\", /* forceBatch= */ true)));\n            const metadata = metadataPromises.map((p)=>p.status === \"fulfilled\" ? p.value : {\n                    name: null,\n                    symbol: null,\n                    decimals: null,\n                    logo: null\n                });\n            const ownedTokens = formattedBalances.map((balance, index)=>Object.assign(Object.assign(Object.assign({}, balance), metadata[index]), {\n                    balance: metadata[index].decimals !== null ? utils.formatUnits(balance.rawBalance, metadata[index].decimals) : undefined\n                }));\n            return {\n                tokens: ownedTokens.map((t)=>nullsToUndefined(t)),\n                pageKey: response.pageKey\n            };\n        });\n    }\n    /**\r\n     * Returns metadata for a given token contract address.\r\n     *\r\n     * @param address The contract address to get metadata for.\r\n     * @public\r\n     */ getTokenMetadata(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getTokenMetadata\", [\n                address\n            ], \"getTokenMetadata\");\n        });\n    }\n    getAssetTransfers(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getAssetTransfers(this.config, params);\n        });\n    }\n    /**\r\n     * Gets all transaction receipts for a given block by number or block hash.\r\n     *\r\n     * @param params An object containing fields for the transaction receipt query.\r\n     * @public\r\n     */ getTransactionReceipts(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getTransactionReceipts(this.config, params);\n        });\n    }\n    /**\r\n     * Returns the underlying owner address for the provided ENS address, or `null`\r\n     * if the ENS name does not have an underlying address.\r\n     *\r\n     * @param name The ENS address name to resolve.\r\n     */ resolveName(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.resolveName(name);\n        });\n    }\n    /**\r\n     * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.\r\n     *\r\n     * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.\r\n     *\r\n     * @param address The address to look up the ENS domain name for.\r\n     */ lookupAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.lookupAddress(address);\n        });\n    }\n}\n/**\r\n * Perform a binary search between an integer range of block numbers to find the\r\n * block number where the contract was deployed.\r\n *\r\n * @internal\r\n */ function binarySearchFirstBlock(start, end, address, config) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (start >= end) {\n            return end;\n        }\n        const mid = Math.floor((start + end) / 2);\n        const provider = yield config.getProvider();\n        const code = yield provider.getCode(address, mid);\n        if (code === ETH_NULL_VALUE) {\n            return binarySearchFirstBlock(mid + 1, end, address, config);\n        }\n        return binarySearchFirstBlock(start, mid, address, config);\n    });\n}\n/**\r\n * The Debug namespace contains methods to access the non-standard RPC methods\r\n * for inspecting and debugging transactions.\r\n *\r\n * For more information on the different methods and use cases please read our\r\n * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the debug namespace\r\n * via `alchemy.debug`.\r\n */ class DebugNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    traceCall(transaction, blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transaction,\n                blockIdentifier,\n                parseTracerParams(tracer)\n            ];\n            return provider._send(\"debug_traceCall\", params, \"traceCall\");\n        });\n    }\n    traceTransaction(transactionHash, tracer, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transactionHash,\n                parseTracerParams(tracer, timeout)\n            ];\n            return provider._send(\"debug_traceTransaction\", params, \"traceTransaction\");\n        });\n    }\n    traceBlock(blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            let method;\n            let params;\n            if (utils.isHexString(blockIdentifier, 32)) {\n                method = \"debug_traceBlockByHash\";\n                params = [\n                    blockIdentifier,\n                    parseTracerParams(tracer)\n                ];\n            } else {\n                method = \"debug_traceBlockByNumber\";\n                const block = typeof blockIdentifier === \"number\" ? utils.hexStripZeros(utils.hexValue(blockIdentifier)) : blockIdentifier;\n                params = [\n                    block,\n                    parseTracerParams(tracer)\n                ];\n            }\n            return provider._send(method, params, \"traceBlock\");\n        });\n    }\n}\nfunction parseTracerParams(tracer, timeout) {\n    return Object.assign({\n        tracer: tracer.type\n    }, tracer.onlyTopCall !== undefined && {\n        tracerConfig: {\n            onlyTopCall: tracer.onlyTopCall,\n            timeout\n        }\n    });\n}\nfunction sanitizeTokenType(tokenType) {\n    if (tokenType === exports.NftTokenType.ERC1155 || tokenType === exports.NftTokenType.ERC721) {\n        return tokenType;\n    }\n    return undefined;\n}\n/**\r\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\r\n * default, the log level is set to INFO.\r\n *\r\n * The order is a follows: DEBUG < INFO < WARN < ERROR\r\n *\r\n * All log types above the current log level will be outputted.\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 4] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst logLevelStringToEnum = {\n    debug: LogLevel.DEBUG,\n    info: LogLevel.INFO,\n    warn: LogLevel.WARN,\n    error: LogLevel.ERROR,\n    silent: LogLevel.SILENT\n};\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n/**\r\n * Configures the verbosity of logging. The default log level is `info`.\r\n *\r\n * @param logLevel - The verbosity of logging. Can be any of the following values:\r\n *\r\n *   - `debug`: The most verbose logging level.\r\n *   - `info`: The default logging level.\r\n *   - `warn`: A logging level for non-critical issues.\r\n *   - `error`: A logging level for critical issues.\r\n *   - `silent`: Turn off all logging.\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\nfunction logDebug(message, ...args) {\n    loggerClient.debug(message, args);\n}\nfunction logInfo(message, ...args) {\n    loggerClient.info(message, args);\n}\nfunction logWarn(message, ...args) {\n    loggerClient.warn(message, args);\n}\nclass Logger {\n    constructor(){\n        /** The log level of the given Logger instance. */ this._logLevel = DEFAULT_LOG_LEVEL;\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    debug(...args) {\n        this._log(LogLevel.DEBUG, ...args);\n    }\n    info(...args) {\n        this._log(LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._log(LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._log(LogLevel.ERROR, ...args);\n    }\n    /**\r\n     * Forwards log messages to their corresponding console counterparts if the\r\n     * log level allows it.\r\n     */ _log(logLevel, ...args) {\n        if (logLevel < this._logLevel) {\n            return;\n        }\n        const now = new Date().toISOString();\n        const method = logLevelToConsoleFn[logLevel];\n        if (method) {\n            console[method](`[${now}] Alchemy:`, ...args.map(stringify));\n        } else {\n            throw new Error(`Logger received an invalid logLevel (value: ${logLevel})`);\n        }\n    }\n}\nfunction stringify(obj) {\n    if (typeof obj === \"string\") {\n        return obj;\n    } else {\n        try {\n            return JSON.stringify(obj);\n        } catch (e) {\n            // Failed to convert to JSON, log the object directly.\n            return obj;\n        }\n    }\n}\n// Instantiate default logger for the SDK.\nconst loggerClient = new Logger();\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nconst VERSION = \"3.3.1\";\n/**\r\n * Given a REST endpoint, method, and params, sends the request with axios and\r\n * returns the response.\r\n */ /**\r\n * Helper function to send http requests using Axis.\r\n *\r\n * @private\r\n */ function sendAxiosRequest(baseUrl, restApiName, methodName, params, overrides) {\n    var _a;\n    const requestUrl = baseUrl + \"/\" + restApiName;\n    const config = Object.assign(Object.assign({}, overrides), {\n        headers: Object.assign(Object.assign(Object.assign({}, overrides === null || overrides === void 0 ? void 0 : overrides.headers), !IS_BROWSER && {\n            \"Accept-Encoding\": \"gzip\"\n        }), {\n            \"Alchemy-Ethers-Sdk-Version\": VERSION,\n            \"Alchemy-Ethers-Sdk-Method\": methodName\n        }),\n        method: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.method) !== null && _a !== void 0 ? _a : \"GET\",\n        url: requestUrl,\n        params\n    });\n    return axios__default[\"default\"](config);\n}\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nconst DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n/**\r\n * Helper class for implementing exponential backoff and max retry attempts.\r\n *\r\n * @private\r\n * @internal\r\n */ class ExponentialBackoff {\n    constructor(maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS){\n        this.maxAttempts = maxAttempts;\n        this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n        this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n        this.numAttempts = 0;\n        this.currentDelayMs = 0;\n        this.isInBackoff = false;\n    }\n    /**\r\n     * Returns a promise that resolves after the the backoff delay. The delay is\r\n     * increased for each attempt. The promise is rejected if the maximum number\r\n     * of attempts is exceeded.\r\n     */ // TODO: beautify this into an async iterator.\n    backoff() {\n        if (this.numAttempts >= this.maxAttempts) {\n            return Promise.reject(new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`));\n        }\n        if (this.isInBackoff) {\n            return Promise.reject(new Error(\"A backoff operation is already in progress\"));\n        }\n        const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n        if (backoffDelayWithJitterMs > 0) {\n            logDebug(\"ExponentialBackoff.backoff\", `Backing off for ${backoffDelayWithJitterMs}ms`);\n        }\n        // Calculate the next delay.\n        this.currentDelayMs *= this.backoffMultiplier;\n        this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n        this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n        this.numAttempts += 1;\n        return new Promise((resolve)=>{\n            this.isInBackoff = true;\n            setTimeout(()=>{\n                this.isInBackoff = false;\n                resolve();\n            }, backoffDelayWithJitterMs);\n        });\n    }\n    /**\r\n     * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\r\n     *\r\n     * @private\r\n     * @param delayMs\r\n     */ withJitterMs(delayMs) {\n        return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n    }\n}\n/**\r\n * A wrapper function to make http requests and retry if the request fails.\r\n *\r\n * @internal\r\n */ // TODO: Wrap Axios error in AlchemyError.\nfunction requestHttpWithBackoff(config, apiType, restApiName, methodName, params, overrides) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        let lastError = undefined;\n        const backoff = new ExponentialBackoff(config.maxRetries);\n        for(let attempt = 0; attempt < config.maxRetries + 1; attempt++){\n            try {\n                if (lastError !== undefined) {\n                    logInfo(\"requestHttp\", `Retrying after error: ${lastError.message}`);\n                }\n                try {\n                    yield backoff.backoff();\n                } catch (err) {\n                    break;\n                }\n                const response = yield sendAxiosRequest(config._getRequestUrl(apiType), restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n                    timeout: config.requestTimeout\n                }));\n                if (response.status === 200) {\n                    logDebug(restApiName, `Successful request: ${restApiName}`);\n                    return response.data;\n                } else {\n                    logInfo(restApiName, `Request failed: ${restApiName}, ${response.status}, ${response.data}`);\n                    lastError = new Error(response.status + \": \" + response.data);\n                }\n            } catch (err) {\n                if (!axios__default[\"default\"].isAxiosError(err) || err.response === undefined) {\n                    throw err;\n                }\n                // TODO: Standardize all errors into AlchemyError\n                lastError = new Error(err.response.status + \": \" + JSON.stringify(err.response.data));\n                if (!isRetryableHttpError(err, apiType)) {\n                    break;\n                }\n            }\n        }\n        return Promise.reject(lastError);\n    });\n}\nfunction isRetryableHttpError(err, apiType) {\n    // TODO: remove 500s after webhooks are more stable.\n    const retryableCodes = apiType === AlchemyApiType.WEBHOOK ? [\n        429,\n        500\n    ] : [\n        429\n    ];\n    return err.response !== undefined && retryableCodes.includes(err.response.status);\n}\n/**\r\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\r\n * represents the property name containing the next page token.\r\n *\r\n * @internal\r\n */ function paginateEndpoint(config, apiType, restApiName, methodName, reqPageKey, resPageKey, params) {\n    return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {\n        let hasNext = true;\n        const requestParams = Object.assign({}, params);\n        while(hasNext){\n            const response = yield __await(requestHttpWithBackoff(config, apiType, restApiName, methodName, requestParams));\n            yield yield __await(response);\n            if (response[resPageKey] !== null) {\n                requestParams[reqPageKey] = response[resPageKey];\n            } else {\n                hasNext = false;\n            }\n        }\n    });\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link NftNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * NftNamespace.\r\n */ /**\r\n * Get the NFT metadata for the provided contract address.\r\n */ function getNftMetadata(config, contractAddress, tokenId, options, srcMethod = \"getNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            tokenType: sanitizeTokenType(options === null || options === void 0 ? void 0 : options.tokenType),\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        });\n        return getNftFromRaw(response);\n    });\n}\nfunction getNftMetadataBatch(config, tokens, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            tokens,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadataBatch\", \"getNftMetadataBatch\", {}, {\n            method: \"POST\",\n            data\n        });\n        return {\n            nfts: response.nfts.map((nft)=>getNftFromRaw(nft))\n        };\n    });\n}\nfunction getContractMetadata(config, contractAddress, srcMethod = \"getContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadata\", srcMethod, {\n            contractAddress\n        });\n        return getNftContractFromRaw(response);\n    });\n}\nfunction getContractMetadataBatch(config, contractAddresses) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadataBatch\", \"getContractMetadataBatch\", {}, {\n            method: \"POST\",\n            data: {\n                contractAddresses\n            }\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction getCollectionMetadata(config, collectionSlug, srcMethod = \"getCollectionMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getCollectionMetadata\", srcMethod, {\n            collectionSlug\n        });\n        return getNftCollectionFromRaw(response);\n    });\n}\nfunction getNftsForOwnerIterator(config, owner, options, srcMethod = \"getNftsForOwnerIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {\n        var e_1, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n                includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n                owner,\n                withMetadata,\n                tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n                orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const ownedNft of response.ownedNfts){\n                    yield yield __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), {\n                        balance: ownedNft.balance\n                    }));\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n    });\n}\nfunction getNftsForOwner(config, owner, options, srcMethod = \"getNftsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, {\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            owner,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            withMetadata,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getNftFromRaw(res)), {\n                        balance: res.balance\n                    })),\n                pageKey: response.pageKey,\n                totalCount: response.totalCount,\n                validAt: response.validAt\n            });\n        }\n        return nullsToUndefined({\n            ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getBaseNftFromRaw(res)), {\n                    balance: res.balance\n                })),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount,\n            validAt: response.validAt\n        });\n    });\n}\nfunction getNftsForContract(config, contractAddress, options, srcMethod = \"getNftsForContract\") {\n    var _a;\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, {\n            contractAddress,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            withMetadata,\n            limit: (_a = options === null || options === void 0 ? void 0 : options.pageSize) !== null && _a !== void 0 ? _a : undefined,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                nfts: response.nfts.map((res)=>getNftFromRaw(res)),\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            nfts: response.nfts.map((res)=>getBaseNftFromRaw(res, contractAddress)),\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getNftsForContractIterator(config, contractAddress, options, srcMethod = \"getNftsForContractIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForContractIterator_1() {\n        var e_2, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddress,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                withMetadata\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const nft of response.nfts){\n                    yield yield __await(nftFromGetNftContractResponse(nft, contractAddress));\n                }\n            }\n        } catch (e_2_1) {\n            e_2 = {\n                error: e_2_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_2) throw e_2.error;\n            }\n        }\n    });\n}\nfunction getOwnersForContract(config, contractAddress, options, srcMethod = \"getOwnersForContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Cast to `any` to avoid more type wrangling.\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForContract\", srcMethod, Object.assign(Object.assign({}, options), {\n            contractAddress\n        }));\n        if (options === null || options === void 0 ? void 0 : options.withTokenBalances) {\n            return nullsToUndefined({\n                owners: response.owners,\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            owners: response.owners,\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getContractsForOwner(config, owner, options, srcMethod = \"getContractsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractsForOwner\", srcMethod, {\n            owner,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        return nullsToUndefined({\n            contracts: response.contracts.map(getNftContractsForOwnerFromRaw),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount\n        });\n    });\n}\nfunction getOwnersForNft(config, contractAddress, tokenId, options, srcMethod = \"getOwnersForNft\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForNFT\", srcMethod, Object.assign({\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        }, options));\n    });\n}\nfunction getMintedNfts(config, owner, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            fromAddress: ETH_NULL_ADDRESS,\n            toAddress: ownerAddress,\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const response = yield getAssetTransfers(config, params, \"getMintedNfts\");\n        return getNftsForTransfers(config, response);\n    });\n}\nfunction getTransfersForOwner(config, owner, transferType, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        if (transferType === exports.GetTransfersForOwnerTransferType.TO) {\n            params.toAddress = ownerAddress;\n        } else {\n            params.fromAddress = ownerAddress;\n        }\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForOwner\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction getTransfersForContract(config, contract, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const category = [\n            exports.AssetTransfersCategory.ERC721,\n            exports.AssetTransfersCategory.ERC1155,\n            exports.AssetTransfersCategory.SPECIALNFT\n        ];\n        const provider = yield config.getProvider();\n        const fromBlock = (options === null || options === void 0 ? void 0 : options.fromBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.fromBlock))) : \"0x0\";\n        const toBlock = (options === null || options === void 0 ? void 0 : options.toBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.toBlock))) : undefined;\n        const params = {\n            fromBlock,\n            toBlock,\n            excludeZeroValue: true,\n            contractAddresses: [\n                contract\n            ],\n            order: options === null || options === void 0 ? void 0 : options.order,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForContract\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction nftTokenTypeToCategory(tokenType) {\n    switch(tokenType){\n        case exports.NftTokenType.ERC721:\n            return [\n                exports.AssetTransfersCategory.ERC721\n            ];\n        case exports.NftTokenType.ERC1155:\n            return [\n                exports.AssetTransfersCategory.ERC1155\n            ];\n        default:\n            return [\n                exports.AssetTransfersCategory.ERC721,\n                exports.AssetTransfersCategory.ERC1155,\n                exports.AssetTransfersCategory.SPECIALNFT\n            ];\n    }\n}\nfunction parse1155Transfer(transfer) {\n    return transfer.erc1155Metadata.map((metadata)=>({\n            contractAddress: transfer.rawContract.address,\n            tokenId: metadata.tokenId,\n            tokenType: exports.NftTokenType.ERC1155\n        }));\n}\nfunction verifyNftOwnership(config, owner, contractAddresses, srcMethod = \"verifyNftOwnership\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (typeof contractAddresses === \"string\") {\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses: [\n                    contractAddresses\n                ],\n                omitMetadata: true\n            }, srcMethod);\n            return response.ownedNfts.length > 0;\n        } else {\n            if (contractAddresses.length === 0) {\n                throw new Error(\"Must provide at least one contract address\");\n            }\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses,\n                omitMetadata: true\n            }, srcMethod);\n            // Create map where all input contract addresses are set to false, then flip\n            // owned nfts to true.\n            const result = contractAddresses.reduce((acc, curr)=>{\n                acc[curr] = false;\n                return acc;\n            }, {});\n            for (const nft of response.ownedNfts){\n                result[nft.contractAddress] = true;\n            }\n            return result;\n        }\n    });\n}\nfunction isSpamContract(config, contractAddress, srcMethod = \"isSpamContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"isSpamContract\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction getSpamContracts(config, srcMethod = \"getSpamContracts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getSpamContracts\", srcMethod, undefined);\n    });\n}\nfunction reportSpam(config, contractAddress, srcMethod = \"reportSpam\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        void requestHttpWithBackoff(config, AlchemyApiType.NFT, \"reportSpam\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction isAirdropNft(config, contractAddress, tokenId, srcMethod = \"isAirdropNft\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"isAirdropNFT\", srcMethod, {\n            contractAddress,\n            tokenId\n        });\n    });\n}\nfunction getFloorPrice(config, contractAddress, srcMethod = \"getFloorPrice\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getFloorPrice\", srcMethod, {\n            contractAddress\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getNftSales(config, options = {}, srcMethod = \"getNftSales\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Avoid ts compiler complaining about the contractAddress field.\n        const params = Object.assign({}, options);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTSales\", srcMethod, {\n            fromBlock: params === null || params === void 0 ? void 0 : params.fromBlock,\n            toBlock: params === null || params === void 0 ? void 0 : params.toBlock,\n            order: params === null || params === void 0 ? void 0 : params.order,\n            marketplace: params === null || params === void 0 ? void 0 : params.marketplace,\n            contractAddress: params === null || params === void 0 ? void 0 : params.contractAddress,\n            tokenId: (params === null || params === void 0 ? void 0 : params.tokenId) ? bignumber.BigNumber.from(params === null || params === void 0 ? void 0 : params.tokenId).toString() : undefined,\n            sellerAddress: params === null || params === void 0 ? void 0 : params.sellerAddress,\n            buyerAddress: params === null || params === void 0 ? void 0 : params.buyerAddress,\n            taker: params === null || params === void 0 ? void 0 : params.taker,\n            limit: params === null || params === void 0 ? void 0 : params.limit,\n            pageKey: params === null || params === void 0 ? void 0 : params.pageKey\n        });\n        return getNftSalesFromRaw(response);\n    });\n}\nfunction computeRarity(config, contractAddress, tokenId, srcMethod = \"computeRarity\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"computeRarity\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction searchContractMetadata(config, query, srcMethod = \"searchContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"searchContractMetadata\", srcMethod, {\n            query\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction summarizeNftAttributes(config, contractAddress, srcMethod = \"summarizeNftAttributes\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"summarizeNFTAttributes\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction refreshNftMetadata(config, contractAddress, tokenId, srcMethod = \"refreshNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const tokenIdString = bignumber.BigNumber.from(tokenId).toString();\n        const first = yield getNftMetadata(config, contractAddress, tokenIdString, undefined, srcMethod);\n        const second = yield refresh(config, contractAddress, tokenIdString, srcMethod);\n        return first.timeLastUpdated !== second.timeLastUpdated;\n    });\n}\nfunction refreshContract(config, contractAddress, srcMethod = \"refreshContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"reingestContract\", srcMethod, {\n            contractAddress\n        });\n        return {\n            contractAddress: response.contractAddress,\n            refreshState: parseReingestionState(response.reingestionState),\n            progress: response.progress\n        };\n    });\n}\nfunction refresh(config, contractAddress, tokenId, srcMethod) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            refreshCache: true\n        });\n        return getNftFromRaw(response);\n    });\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftResponse(ownedNft) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft);\n    }\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftContractResponse(ownedNft, contractAddress) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft, contractAddress);\n    }\n}\n/** @internal */ // TODO: more comprehensive type check\nfunction isNftWithMetadata(response) {\n    return response.name !== undefined;\n}\n/**\r\n * Given an AssetTransfersResponse, fetches the NFTs associated with the\r\n * transfers and collates them with transfer metadata.\r\n *\r\n * VISIBLE FOR TESTING\r\n */ function getNftsForTransfers(config, response) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const metadataTransfers = response.transfers.filter((transfer)=>transfer.rawContract.address !== null)// Use flatMap to flatten 1155 transfers that contain multiple NFTs.\n        .flatMap((transfer)=>{\n            var _a;\n            const tokens = getTokensFromTransfer(transfer);\n            const metadata = {\n                from: transfer.from,\n                to: (_a = transfer.to) !== null && _a !== void 0 ? _a : undefined,\n                transactionHash: transfer.hash,\n                blockNumber: transfer.blockNum\n            };\n            return tokens.map((token)=>({\n                    metadata,\n                    token\n                }));\n        });\n        if (metadataTransfers.length === 0) {\n            return {\n                nfts: []\n            };\n        }\n        // If we have more than 100 elements after unrolling 1155 transfers, split\n        // transfers into batches of 100 to stay under endpoint batch size limit.\n        const batchSize = 100;\n        const requestBatches = [];\n        for(let i = 0; i < metadataTransfers.length; i += batchSize){\n            requestBatches.push(metadataTransfers.slice(i, i + batchSize));\n        }\n        const responseBatches = yield Promise.all(requestBatches.map((batch)=>getNftMetadataBatch(config, batch.map((transfer)=>transfer.token))));\n        const nfts = responseBatches.map((r)=>r.nfts).flat();\n        // The same NFT can be transferred multiple times in the same transfers response.\n        // We want to return one NFT for each transfer, so we create a mapping for\n        // each NFT to pair with the transfer metadata.\n        const nftsByTokenId = new Map();\n        nfts.forEach((nft)=>{\n            const key = `${nft.contract.address.toLowerCase()}-${bignumber.BigNumber.from(nft.tokenId).toString()}`;\n            nftsByTokenId.set(key, nft);\n        });\n        const transferredNfts = metadataTransfers.map((t)=>{\n            const key = `${t.token.contractAddress.toLowerCase()}-${bignumber.BigNumber.from(t.token.tokenId).toString()}`;\n            return Object.assign(Object.assign({}, nftsByTokenId.get(key)), t.metadata);\n        });\n        return {\n            nfts: transferredNfts,\n            pageKey: response.pageKey\n        };\n    });\n}\n/**\r\n * Returns the underlying NFT tokens from a transfer as the params for a\r\n * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be\r\n * transferred in a single transaction.\r\n */ function getTokensFromTransfer(transfer) {\n    // ERC1155 NFTs can contain multiple tokens in a single transfer, which\n    // requires special logic.\n    if (transfer.category === exports.AssetTransfersCategory.ERC1155) {\n        return parse1155Transfer(transfer);\n    } else {\n        return [\n            {\n                contractAddress: transfer.rawContract.address,\n                tokenId: transfer.tokenId,\n                tokenType: transfer.category === exports.AssetTransfersCategory.ERC721 ? exports.NftTokenType.ERC721 : undefined\n            }\n        ];\n    }\n}\n/**\r\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\r\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\r\n * to including metadata.\r\n *\r\n * @internal\r\n */ function omitMetadataToWithMetadata(omitMetadata) {\n    return omitMetadata === undefined ? true : !omitMetadata;\n}\nfunction parseReingestionState(reingestionState) {\n    switch(reingestionState){\n        case \"does_not_exist\":\n            return exports.NftRefreshState.DOES_NOT_EXIST;\n        case \"already_queued\":\n            return exports.NftRefreshState.ALREADY_QUEUED;\n        case \"in_progress\":\n            return exports.NftRefreshState.IN_PROGRESS;\n        case \"finished\":\n            return exports.NftRefreshState.FINISHED;\n        case \"queued\":\n            return exports.NftRefreshState.QUEUED;\n        case \"queue_failed\":\n            return exports.NftRefreshState.QUEUE_FAILED;\n        default:\n            throw new Error(\"Unknown reingestion state: \" + reingestionState);\n    }\n}\n/**\r\n * The NFT namespace contains all the functionality related to NFTs.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.nft`.\r\n */ class NftNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    getNftMetadata(contractAddress, tokenId, optionsOrTokenType, tokenUriTimeoutInMs) {\n        let options;\n        if (typeof optionsOrTokenType === \"object\") {\n            options = {\n                tokenType: optionsOrTokenType.tokenType,\n                tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,\n                refreshCache: optionsOrTokenType.refreshCache\n            };\n        } else {\n            options = {\n                tokenType: optionsOrTokenType,\n                tokenUriTimeoutInMs\n            };\n        }\n        return getNftMetadata(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets the NFT metadata for multiple NFT tokens.\r\n     *\r\n     * @param tokens An array of NFT tokens to fetch metadata for.\r\n     * @param options Configuration options for making the request.\r\n     */ getNftMetadataBatch(tokens, options) {\n        return getNftMetadataBatch(this.config, tokens, options);\n    }\n    /**\r\n     * Get the NFT contract metadata associated with the provided parameters.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @public\r\n     */ getContractMetadata(contractAddress) {\n        return getContractMetadata(this.config, contractAddress);\n    }\n    /**\r\n     * Get the NFT contract metadata for multiple NFT contracts in a single request.\r\n     *\r\n     * @param contractAddresses - An array of contract addresses to fetch metadata for.\r\n     */ getContractMetadataBatch(contractAddresses) {\n        return getContractMetadataBatch(this.config, contractAddresses);\n    }\n    /**\r\n     * Get the NFT collection metadata associated with the provided parameters.\r\n     *\r\n     * @param collectionSlug - The OpenSea collection slug of the NFT.\r\n     * @beta\r\n     */ getCollectionMetadata(collectionSlug) {\n        return getCollectionMetadata(this.config, collectionSlug);\n    }\n    getNftsForOwnerIterator(owner, options) {\n        return getNftsForOwnerIterator(this.config, owner, options);\n    }\n    getNftsForOwner(owner, options) {\n        return getNftsForOwner(this.config, owner, options);\n    }\n    getNftsForContract(contractAddress, options) {\n        return getNftsForContract(this.config, contractAddress, options);\n    }\n    getNftsForContractIterator(contractAddress, options) {\n        return getNftsForContractIterator(this.config, contractAddress, options);\n    }\n    getOwnersForContract(contractAddress, options) {\n        return getOwnersForContract(this.config, contractAddress, options);\n    }\n    /**\r\n     * Gets all the owners for a given NFT contract address and token ID.\r\n     *\r\n     * @param contractAddress - The NFT contract address.\r\n     * @param tokenId - Token id of the NFT.\r\n     * @param options - Optional parameters to use for the request.\r\n     * @beta\r\n     */ getOwnersForNft(contractAddress, tokenId, options) {\n        return getOwnersForNft(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets all NFT contracts held by the specified owner address.\r\n     *\r\n     * @param owner - Address for NFT owner (can be in ENS format!).\r\n     * @param options - The optional parameters to use for the request.\r\n     * @public\r\n     */ // TODO(v3): Add overload for withMetadata=false\n    getContractsForOwner(owner, options) {\n        return getContractsForOwner(this.config, owner, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given owner's address.\r\n     *\r\n     * @param owner The owner to get transfers for.\r\n     * @param category Whether to get transfers to or from the owner address.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForOwner(owner, category, options) {\n        return getTransfersForOwner(this.config, owner, category, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given NFT contract address.\r\n     *\r\n     * Defaults to all transfers for the contract. To get transfers for a specific\r\n     * block range, use {@link GetTransfersForContractOptions}.\r\n     *\r\n     * @param contract The NFT contract to get transfers for.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForContract(contract, options) {\n        return getTransfersForContract(this.config, contract, options);\n    }\n    /**\r\n     * Get all the NFTs minted by a specified owner address.\r\n     *\r\n     * @param owner - Address for the NFT owner (can be in ENS format).\r\n     * @param options - The optional parameters to use for the request.\r\n     */ getMintedNfts(owner, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getMintedNfts(this.config, owner, options);\n        });\n    }\n    verifyNftOwnership(owner, contractAddress) {\n        return verifyNftOwnership(this.config, owner, contractAddress);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     */ isSpamContract(contractAddress) {\n        return isSpamContract(this.config, contractAddress);\n    }\n    /**\r\n     * Returns a list of all spam contracts marked by Alchemy. For details on how\r\n     * Alchemy marks spam contracts, go to\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     */ getSpamContracts() {\n        return getSpamContracts(this.config);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     */ reportSpam(contractAddress) {\n        return reportSpam(this.config, contractAddress);\n    }\n    /**\r\n     * Returns whether a token is marked as an airdrop or not.\r\n     * Airdrops are defined as NFTs that were minted to a user address in a transaction\r\n     * sent by a different address.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     * @param tokenId - Token id of the NFT.\r\n     */ isAirdropNft(contractAddress, tokenId) {\n        return isAirdropNft(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Returns the floor prices of a NFT contract by marketplace.\r\n     *\r\n     * @param contractAddress - The contract address for the NFT collection.\r\n     * @beta\r\n     */ getFloorPrice(contractAddress) {\n        return getFloorPrice(this.config, contractAddress);\n    }\n    getNftSales(options) {\n        return getNftSales(this.config, options);\n    }\n    /**\r\n     * Get the rarity of each attribute of an NFT.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     * @param tokenId - Token id of the NFT.\r\n     */ computeRarity(contractAddress, tokenId) {\n        return computeRarity(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.\r\n     *\r\n     * @param query - The search string that you want to search for in contract metadata.\r\n     */ searchContractMetadata(query) {\n        return searchContractMetadata(this.config, query);\n    }\n    /**\r\n     * Get a summary of attribute prevalence for an NFT collection.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     */ summarizeNftAttributes(contractAddress) {\n        return summarizeNftAttributes(this.config, contractAddress);\n    }\n    /**\r\n     * Refreshes the cached metadata for a provided NFT contract address and token\r\n     * id. Returns a boolean value indicating whether the metadata was refreshed.\r\n     *\r\n     * This method is useful when you want to refresh the metadata for a NFT that\r\n     * has been updated since the last time it was fetched. Note that the backend\r\n     * only allows one refresh per token every 15 minutes, globally for all users.\r\n     * The last refresh time for an NFT can be accessed on the\r\n     * {@link Nft.timeLastUpdated} field.\r\n     *\r\n     * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @param tokenId - The token id of the NFT.\r\n     */ refreshNftMetadata(contractAddress, tokenId) {\n        return refreshNftMetadata(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Triggers a metadata refresh all NFTs in the provided contract address. This\r\n     * method is useful after an NFT collection is revealed.\r\n     *\r\n     * Refreshes are queued on the Alchemy backend and may take time to fully\r\n     * process. To refresh the metadata for a specific token, use the\r\n     * {@link refreshNftMetadata} method instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT collection.\r\n     * @beta\r\n     */ refreshContract(contractAddress) {\n        return refreshContract(this.config, contractAddress);\n    }\n}\n/**\r\n * The Notify namespace contains methods used for creating, reading, updating,\r\n * and deleting webhooks in the Notify API.\r\n *\r\n * To use the methods in the API, you must provide your team's auth token in the\r\n * {@link AlchemySettings.authToken} field when configuring\r\n * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard\r\n * on the Notify tab.\r\n *\r\n * Note that not all networks are supported in the Notify API. Please consult\r\n * the documentation for which networks are supported.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the notify\r\n * namespace via `alchemy.notify`.\r\n */ class NotifyNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Get all webhooks on your team.\r\n     *\r\n     * The team is determined by the `authToken` provided into the {@link AlchemySettings}\r\n     * object when creating a new {@link Alchemy} instance.\r\n     *\r\n     * This method returns a response object containing all the webhooks\r\n     */ getAllWebhooks() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const response = yield this.sendWebhookRequest(\"team-webhooks\", \"getAllWebhooks\", {});\n            return {\n                webhooks: parseRawWebhookResponse(response),\n                totalCount: response.data.length\n            };\n        });\n    }\n    getAddresses(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-addresses\", \"getAddresses\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawAddressActivityResponse(response);\n        });\n    }\n    getGraphqlQuery(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"dashboard-webhook-graphql-query\", \"getGraphqlQuery\", {\n                webhook_id: webhookId\n            });\n            return parseRawCustomGraphqlWebhookResponse(response);\n        });\n    }\n    getNftFilters(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-nft-filters\", \"getNftFilters\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawNftFiltersResponse(response);\n        });\n    }\n    updateWebhook(webhookOrId, update) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            let restApiName;\n            let methodName;\n            let method;\n            let data;\n            if (\"isActive\" in update) {\n                restApiName = \"update-webhook\";\n                methodName = \"updateWebhook\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    is_active: update.isActive\n                };\n            } else if (\"addFilters\" in update || \"removeFilters\" in update) {\n                restApiName = \"update-webhook-nft-filters\";\n                methodName = \"updateWebhookNftFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_filters_to_add: update.addFilters ? update.addFilters.map(nftFilterToParam) : [],\n                    nft_filters_to_remove: update.removeFilters ? update.removeFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addMetadataFilters\" in update || \"removeMetadataFilters\" in update) {\n                restApiName = \"update-webhook-nft-metadata-filters\";\n                methodName = \"updateWebhookNftMetadataFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_metadata_filters_to_add: update.addMetadataFilters ? update.addMetadataFilters.map(nftFilterToParam) : [],\n                    nft_metadata_filters_to_remove: update.removeMetadataFilters ? update.removeMetadataFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addAddresses\" in update || \"removeAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddresses\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses_to_add: yield this.resolveAddresses(update.addAddresses),\n                    addresses_to_remove: yield this.resolveAddresses(update.removeAddresses)\n                };\n            } else if (\"newAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddress\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses: yield this.resolveAddresses(update.newAddresses)\n                };\n            } else {\n                throw new Error(\"Invalid `update` param passed into `updateWebhook`\");\n            }\n            yield this.sendWebhookRequest(restApiName, methodName, {}, {\n                method,\n                data\n            });\n        });\n    }\n    createWebhook(url, type, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            let appId;\n            if (type === exports.WebhookType.MINED_TRANSACTION || type === exports.WebhookType.DROPPED_TRANSACTION) {\n                if (!(\"appId\" in params)) {\n                    throw new Error(\"Transaction Webhooks require an app id.\");\n                }\n                appId = params.appId;\n            }\n            let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);\n            let nftFilterObj;\n            let addresses;\n            let graphqlQuery;\n            if (type === exports.WebhookType.NFT_ACTIVITY || type === exports.WebhookType.NFT_METADATA_UPDATE) {\n                if (!(\"filters\" in params) || params.filters.length === 0) {\n                    throw new Error(\"Nft Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                const filters = params.filters.map((filter)=>filter.tokenId ? {\n                        contract_address: filter.contractAddress,\n                        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n                    } : {\n                        contract_address: filter.contractAddress\n                    });\n                nftFilterObj = type === exports.WebhookType.NFT_ACTIVITY ? {\n                    nft_filters: filters\n                } : {\n                    nft_metadata_filters: filters\n                };\n            } else if (type === exports.WebhookType.ADDRESS_ACTIVITY) {\n                if (params === undefined || !(\"addresses\" in params) || params.addresses.length === 0) {\n                    throw new Error(\"Address Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                addresses = yield this.resolveAddresses(params.addresses);\n            } else if (type == exports.WebhookType.GRAPHQL) {\n                if (params === undefined || !(\"graphqlQuery\" in params) || params.graphqlQuery.length === 0) {\n                    throw new Error(\"Custom Webhooks require a non-empty graphql query.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                graphqlQuery = params.graphqlQuery;\n            }\n            const data = Object.assign(Object.assign(Object.assign(Object.assign({\n                network,\n                webhook_type: type,\n                webhook_url: url\n            }, appId && {\n                app_id: appId\n            }), nftFilterObj), addresses && {\n                addresses\n            }), graphqlQuery && {\n                graphql_query: graphqlQuery\n            });\n            const response = yield this.sendWebhookRequest(\"create-webhook\", \"createWebhook\", {}, {\n                method: \"POST\",\n                data\n            });\n            return parseRawWebhook(response.data);\n        });\n    }\n    deleteWebhook(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"delete-webhook\", \"deleteWebhook\", {\n                webhook_id: webhookId\n            }, {\n                method: \"DELETE\"\n            });\n            if (\"message\" in response) {\n                throw new Error(`Webhook not found. Failed to delete webhook: ${webhookId}`);\n            }\n        });\n    }\n    verifyConfig() {\n        if (this.config.authToken === undefined) {\n            throw new Error(\"Using the Notify API requires setting the Alchemy Auth Token in \" + \"the settings object when initializing Alchemy.\");\n        }\n    }\n    sendWebhookRequest(restApiName, methodName, params, overrides) {\n        return requestHttpWithBackoff(this.config, AlchemyApiType.WEBHOOK, restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n            headers: Object.assign({\n                \"X-Alchemy-Token\": this.config.authToken\n            }, overrides === null || overrides === void 0 ? void 0 : overrides.headers)\n        }));\n    }\n    /** Resolves ENS addresses to the raw address.\r\n     * @internal */ resolveAddresses(addresses) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (addresses === undefined) {\n                return [];\n            }\n            const resolvedAddresses = [];\n            const provider = yield this.config.getProvider();\n            for (const address of addresses){\n                const rawAddress = yield provider.resolveName(address);\n                if (rawAddress === null) {\n                    throw new Error(`Unable to resolve the ENS address: ${address}`);\n                }\n                resolvedAddresses.push(rawAddress);\n            }\n            return resolvedAddresses;\n        });\n    }\n}\n/**\r\n * Mapping of webhook network representations to the SDK's network representation.\r\n *\r\n * @internal\r\n */ const WEBHOOK_NETWORK_TO_NETWORK = {\n    ETH_MAINNET: exports.Network.ETH_MAINNET,\n    ETH_GOERLI: exports.Network.ETH_GOERLI,\n    ETH_SEPOLIA: exports.Network.ETH_SEPOLIA,\n    MATIC_MAINNET: exports.Network.MATIC_MAINNET,\n    MATIC_MUMBAI: exports.Network.MATIC_MUMBAI,\n    MATIC_AMOY: exports.Network.MATIC_AMOY,\n    ARB_MAINNET: exports.Network.ARB_MAINNET,\n    ARB_GOERLI: exports.Network.ARB_GOERLI,\n    ARB_SEPOLIA: exports.Network.ARB_SEPOLIA,\n    OPT_MAINNET: exports.Network.OPT_MAINNET,\n    OPT_GOERLI: exports.Network.OPT_GOERLI,\n    OPT_SEPOLIA: exports.Network.OPT_SEPOLIA,\n    BASE_MAINNET: exports.Network.BASE_MAINNET,\n    BASE_GOERLI: exports.Network.BASE_GOERLI,\n    BASE_SEPOLIA: exports.Network.BASE_SEPOLIA,\n    ZKSYNC_MAINNET: exports.Network.ZKSYNC_MAINNET,\n    ZKSYNC_SEPOLIA: exports.Network.ZKSYNC_SEPOLIA\n};\n/** Mapping of the SDK's network representation the webhook API's network representation. */ const NETWORK_TO_WEBHOOK_NETWORK = Object.keys(exports.Network).reduce((map, key)=>{\n    if (key in WEBHOOK_NETWORK_TO_NETWORK) {\n        map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);\n    }\n    return map;\n}, new Map());\nfunction parseRawWebhookResponse(response) {\n    return response.data.map(parseRawWebhook);\n}\nfunction parseRawWebhook(rawWebhook) {\n    return Object.assign({\n        id: rawWebhook.id,\n        network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],\n        type: rawWebhook.webhook_type,\n        url: rawWebhook.webhook_url,\n        isActive: rawWebhook.is_active,\n        timeCreated: new Date(rawWebhook.time_created).toISOString(),\n        signingKey: rawWebhook.signing_key,\n        version: rawWebhook.version\n    }, rawWebhook.app_id !== undefined && {\n        appId: rawWebhook.app_id\n    });\n}\nfunction parseRawAddressActivityResponse(response) {\n    return {\n        addresses: response.data,\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction parseRawCustomGraphqlWebhookResponse(response) {\n    return {\n        graphqlQuery: response.data.graphql_query\n    };\n}\nfunction parseRawNftFiltersResponse(response) {\n    return {\n        filters: response.data.map((f)=>f.token_id ? {\n                contractAddress: f.contract_address,\n                tokenId: bignumber.BigNumber.from(f.token_id).toString()\n            } : {\n                contractAddress: f.contract_address\n            }),\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction nftFilterToParam(filter) {\n    return filter.tokenId ? {\n        contract_address: filter.contractAddress,\n        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n    } : {\n        contract_address: filter.contractAddress\n    };\n}\n/**\r\n * Multiples to increment fee per gas when using\r\n * {@link TransactNamespace.sendGasOptimizedTransaction}.\r\n *\r\n * @internal\r\n */ const GAS_OPTIMIZED_TX_FEE_MULTIPLES = [\n    0.9,\n    1,\n    1.1,\n    1.2,\n    1.3\n];\n/**\r\n * The Transact namespace contains methods used for sending transactions and\r\n * checking on the state of submitted transactions.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the transact\r\n * namespace via `alchemy.transact`.\r\n */ class TransactNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Used to send a single transaction to Flashbots. Flashbots will attempt to\r\n     * send the transaction to miners for the next 25 blocks.\r\n     *\r\n     * Returns the transaction hash of the submitted transaction.\r\n     *\r\n     * @param signedTransaction The raw, signed transaction as a hash.\r\n     * @param maxBlockNumber Optional highest block number in which the\r\n     *   transaction should be included.\r\n     * @param options Options to configure the request.\r\n     */ sendPrivateTransaction(signedTransaction, maxBlockNumber, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;\n            return provider._send(\"eth_sendPrivateTransaction\", [\n                {\n                    tx: signedTransaction,\n                    maxBlockNumber: hexBlockNumber,\n                    preferences: options\n                }\n            ], \"sendPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Stops the provided private transaction from being submitted for future\r\n     * blocks. A transaction can only be cancelled if the request is signed by the\r\n     * same key as the {@link sendPrivateTransaction} call submitting the\r\n     * transaction in first place.\r\n     *\r\n     * Please note that fast mode transactions cannot be cancelled using this method.\r\n     *\r\n     * Returns a boolean indicating whether the cancellation was successful.\r\n     *\r\n     * @param transactionHash Transaction hash of private tx to be cancelled\r\n     */ cancelPrivateTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"eth_cancelPrivateTransaction\", [\n                {\n                    txHash: transactionHash\n                }\n            ], \"cancelPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a list of transactions simulated\r\n     * in sequence.\r\n     *\r\n     * Returns a list of asset changes for each transaction during simulation.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChangesBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChangesBundle\", params, \"simulateAssetChangesBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a single transaction.\r\n     *\r\n     * Returns list of asset changes that occurred during the transaction\r\n     * simulation. Note that this method does not run the transaction on the\r\n     * blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChanges(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChanges\", params, \"simulateAssetChanges\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a list of transactions in sequence and returns list of decoded\r\n     * traces and logs that occurred for each transaction during simulation.\r\n     *\r\n     * Note that this method does not run any transactions on the blockchain.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecutionBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = provider._send(\"alchemy_simulateExecutionBundle\", params, \"simulateExecutionBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a single transaction and the resulting and returns list of\r\n     * decoded traces and logs that occurred during the transaction simulation.\r\n     *\r\n     * Note that this method does not run the transaction on the blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecution(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = provider._send(\"alchemy_simulateExecution\", params, \"simulateExecution\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link CoreNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns a fee per gas (in wei) that is an estimate of how much you can pay\r\n     * as a priority fee, or \"tip\", to get a transaction included in the current block.\r\n     *\r\n     * This number is generally used to set the `maxPriorityFeePerGas` field in a\r\n     * transaction request.\r\n     *\r\n     * @public\r\n     */ getMaxPriorityFeePerGas() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const feeHex = yield provider._send(\"eth_maxPriorityFeePerGas\", [], \"getMaxPriorityFeePerGas\");\n            return fromHex(feeHex);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    sendGasOptimizedTransaction(transactionOrSignedTxs, wallet) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (Array.isArray(transactionOrSignedTxs)) {\n                return this._sendGasOptimizedTransaction(transactionOrSignedTxs, \"sendGasOptimizedTransactionPreSigned\");\n            }\n            let gasLimit;\n            let priorityFee;\n            let baseFee;\n            const provider = yield this.config.getProvider();\n            try {\n                gasLimit = yield this.estimateGas(transactionOrSignedTxs);\n                priorityFee = yield this.getMaxPriorityFeePerGas();\n                const currentBlock = yield provider.getBlock(\"latest\");\n                baseFee = currentBlock.baseFeePerGas.toNumber();\n            } catch (e) {\n                throw new Error(`Failed to estimate gas for transaction: ${e}`);\n            }\n            const gasSpreadTransactions = generateGasSpreadTransactions(transactionOrSignedTxs, gasLimit.toNumber(), baseFee, priorityFee);\n            const signedTransactions = yield Promise.all(gasSpreadTransactions.map((tx)=>wallet.signTransaction(tx)));\n            return this._sendGasOptimizedTransaction(signedTransactions, \"sendGasOptimizedTransactionGenerated\");\n        });\n    }\n    /**\r\n     * Returns the state of the transaction job returned by the\r\n     * {@link sendGasOptimizedTransaction}.\r\n     *\r\n     * @param trackingId The tracking id from the response of the sent gas optimized transaction.\r\n     * @internal\r\n     */ // TODO(txjob): Remove internal tag once this feature is released.\n    getGasOptimizedTransactionStatus(trackingId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getGasOptimizedTransactionStatus\", [\n                trackingId\n            ], \"getGasOptimizedTransactionStatus\");\n        });\n    }\n    /** @internal */ _sendGasOptimizedTransaction(signedTransactions, methodName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_sendGasOptimizedTransaction\", [\n                {\n                    rawTransactions: signedTransactions\n                }\n            ], methodName);\n        });\n    }\n}\n/**\r\n * Helper method to generate the raw transaction with the given gas limit and\r\n * priority fee across a spread of different gas prices.\r\n *\r\n * @internal\r\n */ // Visible for testing\nfunction generateGasSpreadTransactions(transaction, gasLimit, baseFee, priorityFee) {\n    return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map((feeMultiplier)=>{\n        return Object.assign(Object.assign({}, transaction), {\n            gasLimit,\n            maxFeePerGas: Math.round(baseFee * feeMultiplier + priorityFee * feeMultiplier),\n            maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)\n        });\n    });\n}\n/** This file contains internal types used by the SDK and are not exposed to the end user. */ /**\r\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\r\n * ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = \"alchemy-pending-transactions\";\n/**\r\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = \"alchemy-mined-transactions\";\n/**\r\n * Array containing all the custom event tags used internally by ethers to track\r\n * event filters.\r\n */ const ALCHEMY_EVENT_TYPES = [\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE\n];\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Event class copied directly over from ethers.js's `BaseProvider` class.\r\n *\r\n * This class is used to represent events and their corresponding listeners. The\r\n * SDK needs to extend this class in order to support Alchemy's custom\r\n * Subscription API types. The original class is not exported by ethers. Minimal\r\n * changes have been made in order to get TS to compile.\r\n */ class Event {\n    constructor(tag, listener, once){\n        this.listener = listener;\n        this.tag = tag;\n        this.once = once;\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n            default:\n                return this.tag;\n        }\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        const PollableEvents = [\n            \"block\",\n            \"network\",\n            \"pending\",\n            \"poll\"\n        ];\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n/**\r\n * Wrapper class around the ethers `Event` class in order to add support for\r\n * Alchemy's custom subscriptions types.\r\n *\r\n * The serialization and deserialization mechanism requires the order of the\r\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\r\n * using a getter on a new event filter, make sure that the position of the\r\n * field in serialization is correct.\r\n *\r\n * The getters on this class deserialize the event tag generated by\r\n * {@link getAlchemyEventTag} into the original fields passed into the event.\r\n */ class EthersEvent extends Event {\n    /**\r\n     * Converts the event tag into the original `fromAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get fromAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `toAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get toAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return deserializeAddressField(comps[2]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `hashesOnly` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\r\n     */ get hashesOnly() {\n        const comps = this.tag.split(\":\");\n        if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n            return undefined;\n        }\n        if (comps[3] && comps[3] !== \"*\") {\n            return comps[3] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get includeRemoved() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return comps[2] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get addresses() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressesField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n}\nfunction isAlchemyEvent(event) {\n    return typeof event === \"object\" && \"method\" in event;\n}\n/**\r\n * Creates a string representation of an `alchemy_pendingTransaction`\r\n * subscription filter that is compatible with the ethers implementation of\r\n * `getEventTag()`. The method is not an exported function in ethers, which is\r\n * why the SDK has its own implementation.\r\n *\r\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\r\n *\r\n * @example\r\n *   ```js\r\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\r\n *   const eventTag =  getAlchemyEventTag(\r\n *   {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   });\r\n *   ```;\r\n *\r\n * @param event\r\n * @internal\r\n */ function getAlchemyEventTag(event) {\n    if (!isAlchemyEvent(event)) {\n        throw new Error(\"Event tag requires AlchemyEventType\");\n    }\n    if (event.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n        return serializePendingTransactionsEvent(event);\n    } else if (event.method === exports.AlchemySubscription.MINED_TRANSACTIONS) {\n        return serializeMinedTransactionsEvent(event);\n    } else {\n        throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);\n    }\n}\nfunction verifyAlchemyEventName(eventName) {\n    if (!Object.values(exports.AlchemySubscription).includes(eventName.method)) {\n        throw new Error(`Invalid method name ${eventName.method}. Accepted method names: ${Object.values(exports.AlchemySubscription)}`);\n    }\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n */ function serializePendingTransactionsEvent(event) {\n    const fromAddress = serializeAddressField(event.fromAddress);\n    const toAddress = serializeAddressField(event.toAddress);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE + \":\" + fromAddress + \":\" + toAddress + \":\" + hashesOnly;\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_minedTransactions\",\r\n *     \"addresses\": [\r\n *       {\r\n *         from: \"0xABC\"\r\n *       },\r\n *       {\r\n *         to: \"0xDEF\",\r\n *         from: \"0x123\"\r\n *       }\r\n *     ]\r\n *     \"includeRemoved\": false\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n *\r\n * The `addresses` array is split by the '|' character, and each to/from address\r\n * pair is separated by a ',' character.\r\n *\r\n */ function serializeMinedTransactionsEvent(event) {\n    const addresses = serializeAddressesField(event.addresses);\n    const includeRemoved = serializeBooleanField(event.includeRemoved);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE + \":\" + addresses + \":\" + includeRemoved + \":\" + hashesOnly;\n}\nfunction serializeAddressesField(addresses) {\n    if (addresses === undefined) {\n        return \"*\";\n    }\n    return addresses.map((filter)=>serializeAddressField(filter.to) + \",\" + serializeAddressField(filter.from)).join(\"|\");\n}\nfunction serializeAddressField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else if (Array.isArray(field)) {\n        return field.join(\"|\");\n    } else {\n        return field;\n    }\n}\nfunction serializeBooleanField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else {\n        return field.toString();\n    }\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction deserializeAddressField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    const addresses = data.split(\"|\");\n    return addresses.length === 1 ? addresses[0] : addresses;\n}\nfunction deserializeAddressesField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n    // array from deserializing.\n    return data.split(\"|\").map((addressStr)=>addressStr.split(\",\")).map((addressPair)=>Object.assign(Object.assign({}, addressPair[0] !== \"*\" && {\n            to: addressPair[0]\n        }), addressPair[1] !== \"*\" && {\n            from: addressPair[1]\n        }));\n}\n/**\r\n * The Websocket namespace contains all subscription related functions that\r\n * allow you to subscribe to events and receive updates as they occur. The\r\n * underlying WebSocket provider has additional logic to handle reconnections\r\n * and automatically backfills missed events.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.ws`.\r\n */ class WebSocketNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Adds a listener to be triggered for each {@link eventName} event. Also\r\n     * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for\r\n     * how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ on(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.on(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Adds a listener to be triggered for only the next {@link eventName} event,\r\n     * after which it will be removed. Also includes Alchemy's Subscription API\r\n     * events. See {@link AlchemyEventType} for how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ once(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.once(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName The event to unlisten to.\r\n     * @param listener The listener to remove.\r\n     * @public\r\n     */ off(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                return provider.off(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n                provider.removeAllListeners(processedEvent);\n            }))();\n        return this;\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     */ listenerCount(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listenerCount(processedEvent);\n        });\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     */ listeners(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listeners(processedEvent);\n        });\n    }\n    /**\r\n     * Converts ENS addresses in an Alchemy Event to the underlying resolved\r\n     * address.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveEnsAlchemyEvent(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!isAlchemyEvent(eventName)) {\n                return eventName;\n            }\n            if (eventName.method === exports.AlchemySubscription.MINED_TRANSACTIONS && eventName.addresses) {\n                const processedAddresses = [];\n                for (const address of eventName.addresses){\n                    if (address.to) {\n                        address.to = yield this._resolveNameOrError(address.to);\n                    }\n                    if (address.from) {\n                        address.from = yield this._resolveNameOrError(address.from);\n                    }\n                    processedAddresses.push(address);\n                }\n                eventName.addresses = processedAddresses;\n            } else if (eventName.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n                if (eventName.fromAddress) {\n                    if (typeof eventName.fromAddress === \"string\") {\n                        eventName.fromAddress = yield this._resolveNameOrError(eventName.fromAddress);\n                    } else {\n                        eventName.fromAddress = yield Promise.all(eventName.fromAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n                if (eventName.toAddress) {\n                    if (typeof eventName.toAddress === \"string\") {\n                        eventName.toAddress = yield this._resolveNameOrError(eventName.toAddress);\n                    } else {\n                        eventName.toAddress = yield Promise.all(eventName.toAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n            }\n            return eventName;\n        });\n    }\n    /**\r\n     * Converts the provided ENS address or throws an error. This improves code\r\n     * readability and type safety in other methods.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveNameOrError(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const resolved = yield provider.resolveName(name);\n            if (resolved === null) {\n                throw new Error(`Unable to resolve the ENS address: ${name}`);\n            }\n            return resolved;\n        });\n    }\n}\n/**\r\n * The Alchemy SDK client. This class is the main entry point into Alchemy's\r\n * APIs and separates functionality into different namespaces.\r\n *\r\n * Each SDK instance is associated with a specific network and API key. To use a\r\n * different network or API key, create a new instance of {@link Alchemy}.\r\n *\r\n * @public\r\n */ class Alchemy {\n    /**\r\n     * @param {string} [settings.apiKey] - The API key to use for Alchemy\r\n     * @param {Network} [settings.network] - The network to use for Alchemy\r\n     * @param {number} [settings.maxRetries] - The maximum number of retries to attempt\r\n     * @param {number} [settings.requestTimeout] - The timeout after which request should fail\r\n     * @public\r\n     */ constructor(settings){\n        this.config = new AlchemyConfig(settings);\n        this.core = new CoreNamespace(this.config);\n        this.nft = new NftNamespace(this.config);\n        this.ws = new WebSocketNamespace(this.config);\n        this.transact = new TransactNamespace(this.config);\n        this.notify = new NotifyNamespace(this.config);\n        this.debug = new DebugNamespace(this.config);\n    }\n}\n/**\r\n * The Wallet class inherits Signer and can sign transactions and messages using\r\n * a private key as a standard Externally Owned Account (EOA).\r\n *\r\n * SDK's custom implementation of Ethers.js's 'Wallet'.\r\n *\r\n * Primary difference from Ethers.js 'Wallet' is that you can pass in either a\r\n * Provider or an Alchemy object. This implementation will intelligently detect\r\n * the format and set the provider accordingly.\r\n *\r\n * @public\r\n * @override\r\n */ class Wallet extends wallet.Wallet {\n    /**\r\n     * Overload permits users to pass in either a standard Provider or an Alchemy\r\n     * object. The constructor will detect the object type and handle appropriately.\r\n     *\r\n     * @override\r\n     */ constructor(privateKey, alchemyOrProvider){\n        // If object passed in is a provider, send to super\n        let superProvider;\n        if (alchemyOrProvider && abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            superProvider = alchemyOrProvider;\n        }\n        super(privateKey, superProvider);\n        // If object passed in is an Alchemy object, just set Alchemy\n        if (alchemyOrProvider && !abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();\n        }\n    }\n    //////////////////////////////////////////////////////////////////\n    // Set of overrides from Signer to handle async provider retrieval.\n    //////////////////////////////////////////////////////////////////\n    /**\r\n     * Returns the balance of this wallet at blockTag.\r\n     *\r\n     * @param blockTag The block to check the balance of\r\n     * @override\r\n     */ getBalance(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getBalance(blockTag));\n    }\n    /**\r\n     * Returns the number of transactions this account has ever sent. This is the\r\n     * value required to be included in transactions as the nonce.\r\n     *\r\n     * @param blockTag The block to check the transaction count on\r\n     * @override\r\n     */ getTransactionCount(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getTransactionCount(blockTag));\n    }\n    /**\r\n     * Returns the result of estimating the cost to send the transactionRequest,\r\n     * with this account address being used as the from field.\r\n     *\r\n     * @param transaction Transaction to estimate the gas on\r\n     * @override\r\n     */ estimateGas(transaction) {\n        return this.getWallet().then((wallet)=>wallet.estimateGas(transaction));\n    }\n    /**\r\n     * Returns the result of calling using the transactionRequest, with this\r\n     * account address being used as the from field.\r\n     *\r\n     * @param transaction To make a call on\r\n     * @param blockTag The block to make the call on\r\n     * @override\r\n     */ call(transaction, blockTag) {\n        return this.getWallet().then((wallet)=>wallet.call(transaction, blockTag));\n    }\n    /**\r\n     * Populates ALL keys for a transaction and checks that `from` matches this\r\n     * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,\r\n     * `nonce`, and `chainId` if they are not provided.\r\n     *\r\n     * @param transaction The transaction to populate.\r\n     * @override\r\n     */ populateTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.populateTransaction(transaction));\n    }\n    /**\r\n     * Populates all fields in a transaction, signs it and sends it to the network\r\n     *\r\n     * @param transaction The transaction to send.\r\n     * @override\r\n     */ sendTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.sendTransaction(transaction));\n    }\n    /**\r\n     * Returns the chain ID this wallet is connected to.\r\n     *\r\n     * @override\r\n     */ getChainId() {\n        return this.getWallet().then((wallet)=>wallet.getChainId());\n    }\n    /**\r\n     * Returns the current gas price.\r\n     *\r\n     * @override\r\n     */ getGasPrice() {\n        return this.getWallet().then((wallet)=>wallet.getGasPrice());\n    }\n    /**\r\n     * Returns the current recommended FeeData to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @override\r\n     */ getFeeData() {\n        return this.getWallet().then((wallet)=>wallet.getFeeData());\n    }\n    /**\r\n     * Looks up the address of name. If the name is not owned, or does not have a\r\n     * Resolver configured, or the Resolver does not have an address configured,\r\n     * null is returned.\r\n     *\r\n     * @param name Name of the ENS address\r\n     * @override\r\n     */ resolveName(name) {\n        return this.getWallet().then((wallet)=>wallet.resolveName(name));\n    }\n    getWallet() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!this.alchemyProviderPromise) {\n                return this.connect(this.provider);\n            }\n            return this.connect((yield this.alchemyProviderPromise));\n        });\n    }\n}\n/**\r\n * The Contract class is a wrapper around the Contract class from ethers.js and\r\n * is exported here for convenience.\r\n *\r\n * @public\r\n */ // TODO: support passing in Alchemy instance into the contract.\nclass Contract extends contracts.Contract {\n}\n/**\r\n * The ContractFactory class is a wrapper around the ContractFactory class from\r\n * ethers.js and is exported here for convenience.\r\n *\r\n * @public\r\n */ class ContractFactory extends contracts.ContractFactory {\n}\nexports.ALCHEMY_EVENT_TYPES = ALCHEMY_EVENT_TYPES;\nexports.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE;\nexports.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE;\nexports.Alchemy = Alchemy;\nexports.Contract = Contract;\nexports.ContractFactory = ContractFactory;\nexports.CustomNetworks = CustomNetworks;\nexports.DEFAULT_ALCHEMY_API_KEY = DEFAULT_ALCHEMY_API_KEY;\nexports.DEFAULT_NETWORK = DEFAULT_NETWORK;\nexports.EthersEvent = EthersEvent;\nexports.EthersNetwork = EthersNetwork;\nexports.IS_BROWSER = IS_BROWSER;\nexports.VERSION = VERSION;\nexports.Wallet = Wallet;\nexports.__awaiter = __awaiter$1;\nexports.deepCopy = deepCopy;\nexports.fromHex = fromHex;\nexports.getAlchemyEventTag = getAlchemyEventTag;\nexports.getAlchemyHttpUrl = getAlchemyHttpUrl;\nexports.getAlchemyWsUrl = getAlchemyWsUrl;\nexports.isAlchemyEvent = isAlchemyEvent;\nexports.isHex = isHex;\nexports.logWarn = logWarn;\nexports.noop = noop;\nexports.setLogLevel = setLogLevel;\nexports.toHex = toHex;\nexports.verifyAlchemyEventName = verifyAlchemyEventName; //# sourceMappingURL=index-769e52b6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2luZGV4LTc2OWU1MmI2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsbUJBQW1CSCxtQkFBT0EsQ0FBQztBQUMvQixJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQztBQUNyQixJQUFJSyxZQUFZTCxtQkFBT0EsQ0FBQztBQUV4QixTQUFTTSxzQkFBdUJDLENBQUM7SUFBSSxPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUUsV0FBV0E7SUFBRTtBQUFHO0FBRWpILElBQUlDLGlCQUFpQixXQUFXLEdBQUVGLHNCQUFzQko7QUFFeEQ7Ozs7Ozs7Q0FPQyxHQUNETyxlQUFlLEdBQUcsS0FBSztBQUN0QixVQUFVQyxPQUFPO0lBQ2RBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxhQUFhLEdBQUc7SUFDeEJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxhQUFhLEdBQUc7SUFDeEJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxhQUFhLEdBQUc7SUFDeEJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztJQUMzQkEsT0FBTyxDQUFDLGVBQWUsR0FBRztJQUMxQkEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4QkEsT0FBTyxDQUFDLGdCQUFnQixHQUFHO0lBQzNCQSxPQUFPLENBQUMsdUJBQXVCLEdBQUc7SUFDbENBLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRztJQUNsQ0EsT0FBTyxDQUFDLGVB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QUNuQjl3Qix1QkFBdUIsR0FBRyt3QjtBQUMxQi93QixzQkFBc0IsR0FBR3dHO0FBQ3pCeEcsK0JBQStCLEdBQUd3RTtBQUNsQ3hFLHVCQUF1QixHQUFHeUU7QUFDMUJ6RSxtQkFBbUIsR0FBRyt0QjtBQUN0Qi90QixxQkFBcUIsR0FBR29GO0FBQ3hCcEYsa0JBQWtCLEdBQUdzVTtBQUNyQnRVLGVBQWUsR0FBRzBjO0FBQ2xCMWMsY0FBYyxHQUFHbXdCO0FBQ2pCbndCLGlCQUFpQixHQUFHeUI7QUFDcEJ6QixnQkFBZ0IsR0FBR3dQO0FBQ25CeFAsZUFBZSxHQUFHeVA7QUFDbEJ6UCwwQkFBMEIsR0FBR3F1QjtBQUM3QnJ1Qix5QkFBeUIsR0FBRzZFO0FBQzVCN0UsdUJBQXVCLEdBQUdpRjtBQUMxQmpGLHNCQUFzQixHQUFHb3VCO0FBQ3pCcHVCLGFBQWEsR0FBR2dRO0FBQ2hCaFEsZUFBZSxHQUFHb2M7QUFDbEJwYyxZQUFZLEdBQUc2RztBQUNmN0csbUJBQW1CLEdBQUcrTjtBQUN0Qi9OLGFBQWEsR0FBRzZQO0FBQ2hCN1AsOEJBQThCLEdBQUcwdUIsd0JBQ2pDLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lwdC13My8uLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvaW5kZXgtNzY5ZTUyYjYuanM/Mjg5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vYXBpL3V0aWxzJyk7XG52YXIgYmlnbnVtYmVyID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG52YXIgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xudmFyIGFic3RyYWN0UHJvdmlkZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcicpO1xudmFyIHdhbGxldCA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xudmFyIGNvbnRyYWN0cyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGF4aW9zX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShheGlvcyk7XG5cbi8qKlxyXG4gKiBUaGUgc3VwcG9ydGVkIG5ldHdvcmtzIGJ5IEFsY2hlbXkuIE5vdGUgdGhhdCBzb21lIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZVxyXG4gKiBvbiBhbGwgbmV0d29ya3MuIFBsZWFzZSByZWZlciB0byB0aGUgQWxjaGVteSBkb2N1bWVudGF0aW9uIGZvciB3aGljaCBBUElzIGFyZVxyXG4gKiBhdmFpbGFibGUgb24gd2hpY2ggbmV0d29ya3NcclxuICoge0BsaW5rIGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2FwaXMvZmVhdHVyZS1zdXBwb3J0LWJ5LWNoYWlufVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5ldHdvcmsgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmV0d29yaykge1xyXG4gICAgTmV0d29ya1tcIkVUSF9NQUlOTkVUXCJdID0gXCJldGgtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkVUSF9HT0VSTElcIl0gPSBcImV0aC1nb2VybGlcIjtcclxuICAgIE5ldHdvcmtbXCJFVEhfU0VQT0xJQVwiXSA9IFwiZXRoLXNlcG9saWFcIjtcclxuICAgIE5ldHdvcmtbXCJPUFRfTUFJTk5FVFwiXSA9IFwib3B0LW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJPUFRfR09FUkxJXCJdID0gXCJvcHQtZ29lcmxpXCI7XHJcbiAgICBOZXR3b3JrW1wiT1BUX1NFUE9MSUFcIl0gPSBcIm9wdC1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCX01BSU5ORVRcIl0gPSBcImFyYi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCX0dPRVJMSVwiXSA9IFwiYXJiLWdvZXJsaVwiO1xyXG4gICAgTmV0d29ya1tcIkFSQl9TRVBPTElBXCJdID0gXCJhcmItc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIk1BVElDX01BSU5ORVRcIl0gPSBcInBvbHlnb24tbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIk1BVElDX01VTUJBSVwiXSA9IFwicG9seWdvbi1tdW1iYWlcIjtcclxuICAgIE5ldHdvcmtbXCJNQVRJQ19BTU9ZXCJdID0gXCJwb2x5Z29uLWFtb3lcIjtcclxuICAgIE5ldHdvcmtbXCJBU1RBUl9NQUlOTkVUXCJdID0gXCJhc3Rhci1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiUE9MWUdPTlpLRVZNX01BSU5ORVRcIl0gPSBcInBvbHlnb256a2V2bS1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiUE9MWUdPTlpLRVZNX1RFU1RORVRcIl0gPSBcInBvbHlnb256a2V2bS10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQkFTRV9NQUlOTkVUXCJdID0gXCJiYXNlLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJCQVNFX0dPRVJMSVwiXSA9IFwiYmFzZS1nb2VybGlcIjtcclxuICAgIE5ldHdvcmtbXCJCQVNFX1NFUE9MSUFcIl0gPSBcImJhc2Utc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIlpLU1lOQ19NQUlOTkVUXCJdID0gXCJ6a3N5bmMtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlpLU1lOQ19TRVBPTElBXCJdID0gXCJ6a3N5bmMtc2Vwb2xpYVwiO1xyXG59KShleHBvcnRzLk5ldHdvcmsgfHwgKGV4cG9ydHMuTmV0d29yayA9IHt9KSk7XHJcbi8qKiBUb2tlbiBUeXBlcyBmb3IgdGhlIGBnZXRUb2tlbkJhbGFuY2VzKClgIGVuZHBvaW50LiAqL1xyXG5leHBvcnRzLlRva2VuQmFsYW5jZVR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoVG9rZW5CYWxhbmNlVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb24gdG8gZmV0Y2ggdGhlIHRvcCAxMDAgdG9rZW5zIGJ5IDI0LWhvdXIgdm9sdW1lLiBUaGlzIG9wdGlvbiBpcyBvbmx5XHJcbiAgICAgKiBhdmFpbGFibGUgb24gTWFpbm5ldCBpbiBFdGhlcmV1bSwgUG9seWdvbiwgYW5kIEFyYml0cnVtLlxyXG4gICAgICovXHJcbiAgICBUb2tlbkJhbGFuY2VUeXBlW1wiREVGQVVMVF9UT0tFTlNcIl0gPSBcIkRFRkFVTFRfVE9LRU5TXCI7XHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbiB0byBmZXRjaCB0aGUgc2V0IG9mIEVSQy0yMCB0b2tlbnMgdGhhdCB0aGUgYWRkcmVzcyBhcyBldmVyIGhlbGQuIGhpc1xyXG4gICAgICogbGlzdCBpcyBwcm9kdWNlZCBieSBhbiBhZGRyZXNzJ3MgaGlzdG9yaWNhbCB0cmFuc2ZlciBhY3Rpdml0eSBhbmQgaW5jbHVkZXNcclxuICAgICAqIGFsbCB0b2tlbnMgdGhhdCB0aGUgYWRkcmVzcyBoYXMgZXZlciByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgVG9rZW5CYWxhbmNlVHlwZVtcIkVSQzIwXCJdID0gXCJlcmMyMFwiO1xyXG59KShleHBvcnRzLlRva2VuQmFsYW5jZVR5cGUgfHwgKGV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDYXRlZ29yaWVzIG9mIHRyYW5zZmVycyB0byB1c2Ugd2l0aCB0aGUge0BsaW5rIEFzc2V0VHJhbnNmZXJzUGFyYW1zfSByZXF1ZXN0XHJcbiAqIG9iamVjdCB3aGVuIHVzaW5nIHtAbGluayBDb3JlTmFtZXNwYWNlLmdldEFzc2V0VHJhbnNmZXJzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5ID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkpIHtcclxuICAgIC8qKlxyXG4gICAgICogVG9wIGxldmVsIEVUSCB0cmFuc2FjdGlvbnMgdGhhdCBvY2N1ciB3aGVyZSB0aGUgYGZyb21BZGRyZXNzYCBpcyBhblxyXG4gICAgICogZXh0ZXJuYWwgdXNlci1jcmVhdGVkIGFkZHJlc3MuIEV4dGVybmFsIGFkZHJlc3NlcyBoYXZlIHByaXZhdGUga2V5cyBhbmQgYXJlXHJcbiAgICAgKiBhY2Nlc3NlZCBieSB1c2Vycy5cclxuICAgICAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVYVEVSTkFMXCJdID0gXCJleHRlcm5hbFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb3AgbGV2ZWwgRVRIIHRyYW5zYWN0aW9ucyB0aGF0IG9jY3VyIHdoZXJlIHRoZSBgZnJvbUFkZHJlc3NgIGlzIGFuXHJcbiAgICAgKiBpbnRlcm5hbCwgc21hcnQgY29udHJhY3QgYWRkcmVzcy4gRm9yIGV4YW1wbGUsIGEgc21hcnQgY29udHJhY3QgY2FsbGluZ1xyXG4gICAgICogYW5vdGhlciBzbWFydCBjb250cmFjdCBvciBzZW5kaW5nXHJcbiAgICAgKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJJTlRFUk5BTFwiXSA9IFwiaW50ZXJuYWxcIjtcclxuICAgIC8qKiBFUkMyMCB0cmFuc2ZlcnMuICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVJDMjBcIl0gPSBcImVyYzIwXCI7XHJcbiAgICAvKiogRVJDNzIxIHRyYW5zZmVycy4gKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJFUkM3MjFcIl0gPSBcImVyYzcyMVwiO1xyXG4gICAgLyoqIEVSQzExNTUgdHJhbnNmZXJzLiAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVSQzExNTVcIl0gPSBcImVyYzExNTVcIjtcclxuICAgIC8qKiBTcGVjaWFsIGNvbnRyYWN0cyB0aGF0IGRvbid0IGZvbGxvdyBFUkMgNzIxLzExNTUsIChleDogQ3J5cHRvS2l0dGllcykuICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiU1BFQ0lBTE5GVFwiXSA9IFwic3BlY2lhbG5mdFwiO1xyXG59KShleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkgfHwgKGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgdHlwZSBvZiB0cmFuc2ZlciBmb3IgdGhlIHJlcXVlc3QuIE5vdGUgdGhhdCB1c2luZyBgVE9gIHdpbGwgYWxzbyBpbmNsdWRlXHJcbiAqIE5GVHMgdGhhdCB3ZXJlIG1pbnRlZCBieSB0aGUgb3duZXIuXHJcbiAqL1xyXG5leHBvcnRzLkdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlKSB7XHJcbiAgICBHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZVtcIlRPXCJdID0gXCJUT1wiO1xyXG4gICAgR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGVbXCJGUk9NXCJdID0gXCJGUk9NXCI7XHJcbn0pKGV4cG9ydHMuR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUgfHwgKGV4cG9ydHMuR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0ZWQgc29ydGluZyBvcmRlcnMgb2YgdGhlIEFQSS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5Tb3J0aW5nT3JkZXIgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoU29ydGluZ09yZGVyKSB7XHJcbiAgICBTb3J0aW5nT3JkZXJbXCJBU0NFTkRJTkdcIl0gPSBcImFzY1wiO1xyXG4gICAgU29ydGluZ09yZGVyW1wiREVTQ0VORElOR1wiXSA9IFwiZGVzY1wiO1xyXG59KShleHBvcnRzLlNvcnRpbmdPcmRlciB8fCAoZXhwb3J0cy5Tb3J0aW5nT3JkZXIgPSB7fSkpO1xyXG4vKiogQW4gT3BlblNlYSBjb2xsZWN0aW9uJ3MgYXBwcm92YWwgc3RhdHVzLiAqL1xyXG5leHBvcnRzLk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cykge1xyXG4gICAgLyoqIFZlcmlmaWVkIGNvbGxlY3Rpb24uICovXHJcbiAgICBPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzW1wiVkVSSUZJRURcIl0gPSBcInZlcmlmaWVkXCI7XHJcbiAgICAvKiogQ29sbGVjdGlvbnMgdGhhdCBhcmUgYXBwcm92ZWQgb24gb3BlbiBzZWEgYW5kIGNhbiBiZSBmb3VuZCBpbiBzZWFyY2ggcmVzdWx0cy4gKi9cclxuICAgIE9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXNbXCJBUFBST1ZFRFwiXSA9IFwiYXBwcm92ZWRcIjtcclxuICAgIC8qKiBDb2xsZWN0aW9ucyB0aGF0IHJlcXVlc3RlZCBzYWZlbGlzdGluZyBvbiBPcGVuU2VhLiAqL1xyXG4gICAgT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1c1tcIlJFUVVFU1RFRFwiXSA9IFwicmVxdWVzdGVkXCI7XHJcbiAgICAvKiogQnJhbmQgbmV3IGNvbGxlY3Rpb25zLiAqL1xyXG4gICAgT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1c1tcIk5PVF9SRVFVRVNURURcIl0gPSBcIm5vdF9yZXF1ZXN0ZWRcIjtcclxufSkoZXhwb3J0cy5PcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzIHx8IChleHBvcnRzLk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMgPSB7fSkpO1xyXG4vKipcclxuICogTWV0aG9kIG5hbWVzIGZvciBBbGNoZW15J3MgY3VzdG9tIFN1YnNjcmlwdGlvbiBBUEkgZW5kcG9pbnRzLlxyXG4gKlxyXG4gKiBUaGlzIHZhbHVlIGlzIHByb3ZpZGVkIGluIHRoZSBgbWV0aG9kYCBmaWVsZCB3aGVuIGNyZWF0aW5nIGFuIGV2ZW50IGZpbHRlciBvblxyXG4gKiB0aGUgV2Vic29ja2V0IE5hbWVzcGFjZS5cclxuICovXHJcbmV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbiA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChBbGNoZW15U3Vic2NyaXB0aW9uKSB7XHJcbiAgICBBbGNoZW15U3Vic2NyaXB0aW9uW1wiUEVORElOR19UUkFOU0FDVElPTlNcIl0gPSBcImFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uc1wiO1xyXG4gICAgQWxjaGVteVN1YnNjcmlwdGlvbltcIk1JTkVEX1RSQU5TQUNUSU9OU1wiXSA9IFwiYWxjaGVteV9taW5lZFRyYW5zYWN0aW9uc1wiO1xyXG59KShleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24gfHwgKGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBc3NldCB0eXBlIHJldHVybmVkIHdoZW4gY2FsbGluZyB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2ltdWxhdGVBc3NldENoYW5nZXN9LlxyXG4gKiBBbGxvd3MgeW91IHRvIGRldGVybWluZSBpZiB0aGUgYXNzZXRzIGFwcHJvdmVkIG9yIC8gYW5kIHRyYW5zZmVycmVkIGFyZVxyXG4gKiBuYXRpdmUsIHRva2VucyBvciBORlRzLlxyXG4gKi9cclxuZXhwb3J0cy5TaW11bGF0ZUFzc2V0VHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChTaW11bGF0ZUFzc2V0VHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXRpdmUgdHJhbnNmZXJzIHRoYXQgaW52b2x2ZSB0aGUgY3VycmVuY3kgb2YgdGhlIGNoYWluIHRoZSBzaW11bGF0aW9uIGlzXHJcbiAgICAgKiBydW4gb24gKGV4OiBFVEggZm9yIEV0aGVyZXVtLCBNQVRJQyBmb3IgUG9seWdvbiwgRVRIIGZvciBBcmJpdHJ1bSkuXHJcbiAgICAgKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiTkFUSVZFXCJdID0gXCJOQVRJVkVcIjtcclxuICAgIC8qKiBFUkMyMCBhcHByb3ZhbCBvciB0cmFuc2ZlcnMuICovXHJcbiAgICBTaW11bGF0ZUFzc2V0VHlwZVtcIkVSQzIwXCJdID0gXCJFUkMyMFwiO1xyXG4gICAgLyoqIEVSQzcyMSBhcHByb3ZhbCBvciB0cmFuc2ZlcnMuICovXHJcbiAgICBTaW11bGF0ZUFzc2V0VHlwZVtcIkVSQzcyMVwiXSA9IFwiRVJDNzIxXCI7XHJcbiAgICAvKiogRVJDMTE1NSBhcHByb3ZhbCBvciB0cmFuc2ZlcnMuICovXHJcbiAgICBTaW11bGF0ZUFzc2V0VHlwZVtcIkVSQzExNTVcIl0gPSBcIkVSQzExNTVcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lhbCBjb250cmFjdHMgdGhhdCBkb24ndCBmb2xsb3cgRVJDIDcyMS8xMTU1LkN1cnJlbnRseSBsaW1pdGVkIHRvXHJcbiAgICAgKiBDcnlwdG9LaXR0aWVzIGFuZCBDcnlwdG9QdW5rcy5cclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVBc3NldFR5cGVbXCJTUEVDSUFMX05GVFwiXSA9IFwiU1BFQ0lBTF9ORlRcIjtcclxufSkoZXhwb3J0cy5TaW11bGF0ZUFzc2V0VHlwZSB8fCAoZXhwb3J0cy5TaW11bGF0ZUFzc2V0VHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDaGFuZ2UgdHlwZSByZXR1cm5lZCB3aGVuIGNhbGxpbmcge0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLnNpbXVsYXRlQXNzZXRDaGFuZ2VzfS5cclxuICovXHJcbmV4cG9ydHMuU2ltdWxhdGVDaGFuZ2VUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKFNpbXVsYXRlQ2hhbmdlVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gdGhhdCBhcHByb3ZlZCBvciBkaXNhcHByb3ZlZCBwZXJtaXNzaW9ucyBmb3IgYVxyXG4gICAgICogY29udHJhY3QuXHJcbiAgICAgKlxyXG4gICAgICogQVBQUk9WRSB3aXRob3V0IHRva2VuIElEIOKGkiBhcHByb3ZlIGFsbCB0b2tlbnNcclxuICAgICAqIEFQUFJPVkUgd2l0aG91dCBhbW91bnQg4oaSIGFwcHJvdmUgYWxsIGFtb3VudFxyXG4gICAgICogQVBQUk9WRSB3aXRoIHplcm8gYW1vdW50IOKGkiBhcHByb3ZhbCBiZWluZyBjbGVhcmVkXHJcbiAgICAgKi9cclxuICAgIFNpbXVsYXRlQ2hhbmdlVHlwZVtcIkFQUFJPVkVcIl0gPSBcIkFQUFJPVkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBhIHRyYW5zYWN0aW9uIHRoYXQgdHJhbnNmZXJyZWQgdG9rZW5zIGZyb20gb25lIGFkZHJlc3MgdG8gYW5vdGhlci5cclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVDaGFuZ2VUeXBlW1wiVFJBTlNGRVJcIl0gPSBcIlRSQU5TRkVSXCI7XHJcbn0pKGV4cG9ydHMuU2ltdWxhdGVDaGFuZ2VUeXBlIHx8IChleHBvcnRzLlNpbXVsYXRlQ2hhbmdlVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBdXRob3JpdHkgdXNlZCB0byBkZWNvZGUgY2FsbHMgYW5kIGxvZ3Mgd2hlbiB1c2luZyB0aGVcclxuICoge0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLnNpbXVsYXRlRXhlY3V0aW9ufSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnRzLkRlY29kaW5nQXV0aG9yaXR5ID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKERlY29kaW5nQXV0aG9yaXR5KSB7XHJcbiAgICBEZWNvZGluZ0F1dGhvcml0eVtcIkVUSEVSU0NBTlwiXSA9IFwiRVRIRVJTQ0FOXCI7XHJcbn0pKGV4cG9ydHMuRGVjb2RpbmdBdXRob3JpdHkgfHwgKGV4cG9ydHMuRGVjb2RpbmdBdXRob3JpdHkgPSB7fSkpO1xyXG4vKiogVGhlIHR5cGUgb2YgY2FsbCBpbiBhIGRlYnVnIGNhbGwgdHJhY2UuICovXHJcbmV4cG9ydHMuRGVidWdDYWxsVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChEZWJ1Z0NhbGxUeXBlKSB7XHJcbiAgICBEZWJ1Z0NhbGxUeXBlW1wiQ1JFQVRFXCJdID0gXCJDUkVBVEVcIjtcclxuICAgIERlYnVnQ2FsbFR5cGVbXCJDQUxMXCJdID0gXCJDQUxMXCI7XHJcbiAgICBEZWJ1Z0NhbGxUeXBlW1wiU1RBVElDQ0FMTFwiXSA9IFwiU1RBVElDQ0FMTFwiO1xyXG4gICAgRGVidWdDYWxsVHlwZVtcIkRFTEVHQVRFQ0FMTFwiXSA9IFwiREVMRUdBVEVDQUxMXCI7XHJcbn0pKGV4cG9ydHMuRGVidWdDYWxsVHlwZSB8fCAoZXhwb3J0cy5EZWJ1Z0NhbGxUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIFBvdGVudGlhbCB0cmFuc2FjdGlvbiBqb2Igc3RhdHVzZXMgZm9yIGEge0BsaW5rIEdhc09wdGltaXplZFRyYW5zYWN0aW9uUmVzcG9uc2V9XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gVE9ETyh0eGpvYik6IFJlbW92ZSBpbnRlcm5hbCB0YWcgb25jZSB0aGlzIGZlYXR1cmUgaXMgcmVsZWFzZWQuXHJcbmV4cG9ydHMuR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMpIHtcclxuICAgIEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzW1wiVU5TUEVDSUZJRURcIl0gPSBcIlRSQU5TQUNUSU9OX0pPQl9TVEFUVVNfVU5TUEVDSUZJRURcIjtcclxuICAgIEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzW1wiSU5fUFJPR1JFU1NcIl0gPSBcIklOX1BST0dSRVNTXCI7XHJcbiAgICBHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1c1tcIkNPTVBMRVRFXCJdID0gXCJDT01QTEVURVwiO1xyXG4gICAgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXNbXCJBQkFORE9ORURcIl0gPSBcIkFCQU5ET05FRFwiO1xyXG59KShleHBvcnRzLkdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzIHx8IChleHBvcnRzLkdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzID0ge30pKTtcclxuLyoqIFRoZSB2ZXJzaW9uIG9mIHRoZSB3ZWJob29rLiBBbGwgbmV3bHkgY3JlYXRlZCB3ZWJob29rcyBkZWZhdWx0IHRvIFYyLiAqL1xyXG5leHBvcnRzLldlYmhvb2tWZXJzaW9uID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKFdlYmhvb2tWZXJzaW9uKSB7XHJcbiAgICBXZWJob29rVmVyc2lvbltcIlYxXCJdID0gXCJWMVwiO1xyXG4gICAgV2ViaG9va1ZlcnNpb25bXCJWMlwiXSA9IFwiVjJcIjtcclxufSkoZXhwb3J0cy5XZWJob29rVmVyc2lvbiB8fCAoZXhwb3J0cy5XZWJob29rVmVyc2lvbiA9IHt9KSk7XHJcbi8qKiBUaGUgdHlwZSBvZiB7QGxpbmsgV2ViaG9va30uICovXHJcbmV4cG9ydHMuV2ViaG9va1R5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoV2ViaG9va1R5cGUpIHtcclxuICAgIFdlYmhvb2tUeXBlW1wiTUlORURfVFJBTlNBQ1RJT05cIl0gPSBcIk1JTkVEX1RSQU5TQUNUSU9OXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIkRST1BQRURfVFJBTlNBQ1RJT05cIl0gPSBcIkRST1BQRURfVFJBTlNBQ1RJT05cIjtcclxuICAgIFdlYmhvb2tUeXBlW1wiQUREUkVTU19BQ1RJVklUWVwiXSA9IFwiQUREUkVTU19BQ1RJVklUWVwiO1xyXG4gICAgV2ViaG9va1R5cGVbXCJORlRfQUNUSVZJVFlcIl0gPSBcIk5GVF9BQ1RJVklUWVwiO1xyXG4gICAgV2ViaG9va1R5cGVbXCJORlRfTUVUQURBVEFfVVBEQVRFXCJdID0gXCJORlRfTUVUQURBVEFfVVBEQVRFXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIkdSQVBIUUxcIl0gPSBcIkdSQVBIUUxcIjtcclxufSkoZXhwb3J0cy5XZWJob29rVHlwZSB8fCAoZXhwb3J0cy5XZWJob29rVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDb21taXRtZW50IGxldmVsIG9mIHRoZSB0YXJnZXQgYmxvY2sgd2l0aCB1c2luZyBtZXRob2RzIGluIHRoZVxyXG4gKiB7QGxpbmsgRGVidWdOYW1lc3BhY2V9XHJcbiAqL1xyXG5leHBvcnRzLkNvbW1pdG1lbnRMZXZlbCA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChDb21taXRtZW50TGV2ZWwpIHtcclxuICAgIC8qKlxyXG4gICAgICogU2FtcGxlIG5leHQgYmxvY2sgaW5mZXJyZWQgYnkgQWxjaGVteSBidWlsdCBvbiB0b3Agb2YgdGhlIGxhdGVzdCBibG9jay5cclxuICAgICAqIFRoaXMgY29udGFpbnMgdGhlIHNldCBvZiB0cmFuc2FjdGlvbnMgdGFrZW4gZnJvbSB0aGUgbG9jYWwgbWVtcG9vbCBhbmRcclxuICAgICAqIGlzIGEgcHJveHkgZm9yIGJsb2NrcyB0aGF0IGhhdmUgbm90IGJlZW4gbWluZWQgeWV0LlxyXG4gICAgICovXHJcbiAgICBDb21taXRtZW50TGV2ZWxbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBibG9jayBpbiB0aGUgY2Fub25pY2FsIGNoYWluIG9ic2VydmVkIGJ5IEFsY2hlbXkuIE5vdGUgdGhhdFxyXG4gICAgICogdGhpcyBibG9jayBtYXkgYmUgcmUtb3JnZWQgb3V0IG9mIHRoZSBjYW5vbmljYWwgY2hhaW4uXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIkxBVEVTVFwiXSA9IFwibGF0ZXN0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBjcnlwdG8tZWNvbm9taWNhbGx5IHNlY3VyZSBibG9jayB0aGF0IGNhbm5vdCBiZSByZS1vcmdlZFxyXG4gICAgICogb3V0c2lkZSBvZiBtYW51YWwgaW50ZXJ2ZW50aW9uIGRyaXZlbiBieSBjb21tdW5pdHkgY29vcmRpbmF0aW9uLiBUaGlzIGlzXHJcbiAgICAgKiBvbmx5IGF2YWlsYWJsZSBvbiB7QGxpbmsgTmV0d29yay5FVEhfR09FUkxJfSBhbmQge0BsaW5rIE5ldHdvcmsuRVRIX1NFUE9MSUF9LlxyXG4gICAgICovXHJcbiAgICBDb21taXRtZW50TGV2ZWxbXCJTQUZFXCJdID0gXCJzYWZlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBzZWN1cmUgYmxvY2sgdGhhdCBoYXMgYmVlbiBhY2NlcHRlZCBieSA+Mi8zIG9mIHZhbGlkYXRvcnMuXHJcbiAgICAgKiBUaGlzIGJsb2NrIGlzIHZlcnkgdW5saWtlbHkgdG8gYmUgcmUtb3JnZWQuIFRoaXMgaXMgb25seSBhdmFpbGFibGUgb25cclxuICAgICAqIHtAbGluayBOZXR3b3JrLkVUSF9HT0VSTEl9IGFuZCB7QGxpbmsgTmV0d29yay5FVEhfU0VQT0xJQX0uXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIkZJTkFMSVpFRFwiXSA9IFwiZmluYWxpemVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3dlc3QgbnVtYmVyZWQgYmxvY2sgYXZhaWxhYmxlIHRoYXQgaXMgdXN1YWxseSB0aGUgZmlyc3QgYmxvY2sgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgQ29tbWl0bWVudExldmVsW1wiRUFSTElFU1RcIl0gPSBcImVhcmxpZXN0XCI7XHJcbn0pKGV4cG9ydHMuQ29tbWl0bWVudExldmVsIHx8IChleHBvcnRzLkNvbW1pdG1lbnRMZXZlbCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgdHlwZSBvZiB0cmFjZXIgdG8gdXNlIHdoZW4gcnVubmluZyBkZWJ1ZyBtZXRob2RzIGluIHRoZVxyXG4gKiB7QGxpbmsgRGVidWdOYW1lc3BhY2V9LlxyXG4gKi9cclxuZXhwb3J0cy5EZWJ1Z1RyYWNlclR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoRGVidWdUcmFjZXJUeXBlKSB7XHJcbiAgICBEZWJ1Z1RyYWNlclR5cGVbXCJDQUxMX1RSQUNFUlwiXSA9IFwiY2FsbFRyYWNlclwiO1xyXG4gICAgRGVidWdUcmFjZXJUeXBlW1wiUFJFU1RBVEVfVFJBQ0VSXCJdID0gXCJwcmVzdGF0ZVRyYWNlclwiO1xyXG59KShleHBvcnRzLkRlYnVnVHJhY2VyVHlwZSB8fCAoZXhwb3J0cy5EZWJ1Z1RyYWNlclR5cGUgPSB7fSkpO1xuXG4vKipcclxuICogQW4gZW51bSBmb3Igc3BlY2lmeWluZyB0aGUgdG9rZW4gdHlwZSBvbiBORlRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5mdFRva2VuVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRUb2tlblR5cGUpIHtcclxuICAgIE5mdFRva2VuVHlwZVtcIkVSQzcyMVwiXSA9IFwiRVJDNzIxXCI7XHJcbiAgICBOZnRUb2tlblR5cGVbXCJFUkMxMTU1XCJdID0gXCJFUkMxMTU1XCI7XHJcbiAgICBOZnRUb2tlblR5cGVbXCJOT19TVVBQT1JURURfTkZUX1NUQU5EQVJEXCJdID0gXCJOT19TVVBQT1JURURfTkZUX1NUQU5EQVJEXCI7XHJcbiAgICBOZnRUb2tlblR5cGVbXCJOT1RfQV9DT05UUkFDVFwiXSA9IFwiTk9UX0FfQ09OVFJBQ1RcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIlVOS05PV05cIl0gPSBcIlVOS05PV05cIjtcclxufSkoZXhwb3J0cy5OZnRUb2tlblR5cGUgfHwgKGV4cG9ydHMuTmZ0VG9rZW5UeXBlID0ge30pKTtcclxuLyoqIFBvdGVudGlhbCByZWFzb25zIHdoeSBhbiBORlQgY29udHJhY3Qgd2FzIGNsYXNzaWZpZWQgYXMgc3BhbS4gKi9cclxuZXhwb3J0cy5OZnRTcGFtQ2xhc3NpZmljYXRpb24gPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0U3BhbUNsYXNzaWZpY2F0aW9uKSB7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJFcmM3MjFUb29NYW55T3duZXJzXCJdID0gXCJFcmM3MjFUb29NYW55T3duZXJzXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJFcmM3MjFUb29NYW55VG9rZW5zXCJdID0gXCJFcmM3MjFUb29NYW55VG9rZW5zXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJFcmM3MjFEaXNob25lc3RUb3RhbFN1cHBseVwiXSA9IFwiRXJjNzIxRGlzaG9uZXN0VG90YWxTdXBwbHlcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIk1vc3RseUhvbmV5UG90T3duZXJzXCJdID0gXCJNb3N0bHlIb25leVBvdE93bmVyc1wiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiT3duZWRCeU1vc3RIb25leVBvdHNcIl0gPSBcIk93bmVkQnlNb3N0SG9uZXlQb3RzXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJMb3dEaXN0aW5jdE93bmVyc1BlcmNlbnRcIl0gPSBcIkxvd0Rpc3RpbmN0T3duZXJzUGVyY2VudFwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSGlnaEhvbmV5UG90T3duZXJQZXJjZW50XCJdID0gXCJIaWdoSG9uZXlQb3RPd25lclBlcmNlbnRcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkhpZ2hIb25leVBvdFBlcmNlbnRcIl0gPSBcIkhpZ2hIb25leVBvdFBlcmNlbnRcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkhvbmV5UG90c093bk11bHRpcGxlVG9rZW5zXCJdID0gXCJIb25leVBvdHNPd25NdWx0aXBsZVRva2Vuc1wiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiTm9TYWxlc0FjdGl2aXR5XCJdID0gXCJOb1NhbGVzQWN0aXZpdHlcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkhpZ2hBaXJkcm9wUGVyY2VudFwiXSA9IFwiSGlnaEFpcmRyb3BQZXJjZW50XCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJVbmtub3duXCJdID0gXCJVbmtub3duXCI7XHJcbn0pKGV4cG9ydHMuTmZ0U3BhbUNsYXNzaWZpY2F0aW9uIHx8IChleHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIG9mIE5GVCBmaWx0ZXJzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSB7QGxpbmsgZ2V0TmZ0c0Zvck93bmVyfSBvciBhXHJcbiAqIHtAbGluayBnZXRDb250cmFjdHNGb3JPd25lcn0gcmVxdWVzdC5cclxuICpcclxuICogQGJldGFcclxuICovXHJcbmV4cG9ydHMuTmZ0RmlsdGVycyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRGaWx0ZXJzKSB7XHJcbiAgICAvKiogTkZUcyB0aGF0IGhhdmUgYmVlbiBjbGFzc2lmaWVkIGFzIHNwYW0uICovXHJcbiAgICBOZnRGaWx0ZXJzW1wiU1BBTVwiXSA9IFwiU1BBTVwiO1xyXG4gICAgLyoqIE5GVHMgdGhhdCBoYXZlIGJlZW4gYWlyZHJvcHBlZCB0byBhIHVzZXIuICovXHJcbiAgICBOZnRGaWx0ZXJzW1wiQUlSRFJPUFNcIl0gPSBcIkFJUkRST1BTXCI7XHJcbn0pKGV4cG9ydHMuTmZ0RmlsdGVycyB8fCAoZXhwb3J0cy5OZnRGaWx0ZXJzID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gb2Ygb3JkZXJpbmcgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIHtAbGluayBnZXROZnRzRm9yT3duZXJ9IG9yIGFcclxuICoge0BsaW5rIGdldENvbnRyYWN0c0Zvck93bmVyfSByZXNwb25zZS5cclxuICpcclxuICogQGJldGFcclxuICovXHJcbmV4cG9ydHMuTmZ0T3JkZXJpbmcgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0T3JkZXJpbmcpIHtcclxuICAgIE5mdE9yZGVyaW5nW1wiVFJBTlNGRVJUSU1FXCJdID0gXCJUUkFOU0ZFUlRJTUVcIjtcclxufSkoZXhwb3J0cy5OZnRPcmRlcmluZyB8fCAoZXhwb3J0cy5OZnRPcmRlcmluZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgc3VwcG9ydGVkIE5GVCBtYXJrZXRwbGFjZXMgYnkgdGhlXHJcbiAqIHtAbGluayBOZnROYW1lc3BhY2UuZ2V0TmZ0U2FsZXN9IG1ldGhvZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0U2FsZU1hcmtldHBsYWNlKSB7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJTRUFQT1JUXCJdID0gXCJzZWFwb3J0XCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJMT09LU1JBUkVcIl0gPSBcImxvb2tzcmFyZVwiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiWDJZMlwiXSA9IFwieDJ5MlwiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiV1lWRVJOXCJdID0gXCJ3eXZlcm5cIjtcclxuICAgIE5mdFNhbGVNYXJrZXRwbGFjZVtcIkNSWVBUT1BVTktTXCJdID0gXCJjcnlwdG9wdW5rc1wiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiQkxVUlwiXSA9IFwiYmx1clwiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xyXG59KShleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZSB8fCAoZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSBmb3Igc3BlY2lmeWluZyB0aGUgdGFrZXIgdHlwZSBmb3IgdGhlIHtAbGluayBOZnROYW1lc3BhY2UuZ2V0TmZ0U2FsZXN9XHJcbiAqIG1ldGhvZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5OZnRTYWxlVGFrZXJUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdFNhbGVUYWtlclR5cGUpIHtcclxuICAgIE5mdFNhbGVUYWtlclR5cGVbXCJCVVlFUlwiXSA9IFwiYnV5ZXJcIjtcclxuICAgIE5mdFNhbGVUYWtlclR5cGVbXCJTRUxMRVJcIl0gPSBcInNlbGxlclwiO1xyXG59KShleHBvcnRzLk5mdFNhbGVUYWtlclR5cGUgfHwgKGV4cG9ydHMuTmZ0U2FsZVRha2VyVHlwZSA9IHt9KSk7XHJcbi8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgTkZUIGNvbnRyYWN0IHJlZnJlc2ggcHJvY2Vzcy4gKi9cclxuZXhwb3J0cy5OZnRSZWZyZXNoU3RhdGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0UmVmcmVzaFN0YXRlKSB7XHJcbiAgICAvKiogVGhlIHByb3ZpZGVkIGNvbnRyYWN0IGlzIG5vdCBhbiBORlQgb3IgZG9lcyBub3QgY29udGFpbiBtZXRhZGF0YS4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIkRPRVNfTk9UX0VYSVNUXCJdID0gXCJkb2VzX25vdF9leGlzdFwiO1xyXG4gICAgLyoqIFRoZSBjb250cmFjdCBoYXMgYWxyZWFkeSBiZWVuIHF1ZXVlZCBmb3IgcmVmcmVzaC4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIkFMUkVBRFlfUVVFVUVEXCJdID0gXCJhbHJlYWR5X3F1ZXVlZFwiO1xyXG4gICAgLyoqIFRoZSBjb250cmFjdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVmcmVzaGVkLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiSU5fUFJPR1JFU1NcIl0gPSBcImluX3Byb2dyZXNzXCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IHJlZnJlc2ggaXMgY29tcGxldGUuICovXHJcbiAgICBOZnRSZWZyZXNoU3RhdGVbXCJGSU5JU0hFRFwiXSA9IFwiZmluaXNoZWRcIjtcclxuICAgIC8qKiBUaGUgY29udHJhY3QgcmVmcmVzaCBoYXMgYmVlbiBxdWV1ZWQgYW5kIGF3YWl0IGV4ZWN1dGlvbi4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIlFVRVVFRFwiXSA9IFwicXVldWVkXCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IHdhcyB1bmFibGUgdG8gYmUgcXVldWVkIGR1ZSB0byBhbiBpbnRlcm5hbCBlcnJvci4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIlFVRVVFX0ZBSUxFRFwiXSA9IFwicXVldWVfZmFpbGVkXCI7XHJcbn0pKGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlIHx8IChleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgc3VwcG9ydGVkIE5GVCBtYXJrZXRwbGFjZXMgb24gYVxyXG4gKiB7QGxpbmsgTmZ0Q29sbGVjdGlvbkZsb29yUHJpY2V9IG9iamVjdC5cclxuICovXHJcbmV4cG9ydHMuTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSkge1xyXG4gICAgTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlW1wiT1BFTlNFQVwiXSA9IFwiT3BlblNlYVwiO1xyXG59KShleHBvcnRzLk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSB8fCAoZXhwb3J0cy5OZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UgPSB7fSkpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyJDEodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxuXG5jb25zdCBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSA9ICdkZW1vJztcclxuY29uc3QgREVGQVVMVF9ORVRXT1JLID0gZXhwb3J0cy5OZXR3b3JrLkVUSF9NQUlOTkVUO1xyXG5jb25zdCBERUZBVUxUX01BWF9SRVRSSUVTID0gNTtcclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQgPSAwOyAvLyAwID0gbm8gdGltZW91dFxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYmFzZSBVUkwgZm9yIG1ha2luZyBBbGNoZW15IEFQSSByZXF1ZXN0cy4gVGhlIGBhbGNoZW15LmNvbWBcclxuICogZW5kcG9pbnRzIG9ubHkgd29yayB3aXRoIG5vbiBldGgganNvbi1ycGMgcmVxdWVzdHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL3YyLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxjaGVteU5mdEh0dHBVcmwobmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL25mdC92My8ke2FwaUtleX1gO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgIHJldHVybiBgd3NzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL3YyLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxjaGVteVdlYmhvb2tIdHRwVXJsKCkge1xyXG4gICAgcmV0dXJuICdodHRwczovL2Rhc2hib2FyZC5hbGNoZW15LmNvbS9hcGknO1xyXG59XHJcbnZhciBBbGNoZW15QXBpVHlwZTtcclxuKGZ1bmN0aW9uIChBbGNoZW15QXBpVHlwZSkge1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJCQVNFXCJdID0gMF0gPSBcIkJBU0VcIjtcclxuICAgIEFsY2hlbXlBcGlUeXBlW0FsY2hlbXlBcGlUeXBlW1wiTkZUXCJdID0gMV0gPSBcIk5GVFwiO1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJXRUJIT09LXCJdID0gMl0gPSBcIldFQkhPT0tcIjtcclxufSkoQWxjaGVteUFwaVR5cGUgfHwgKEFsY2hlbXlBcGlUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIE1hcHBpbmcgb2YgbmV0d29yayBuYW1lcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIE5ldHdvcmsgc3RyaW5ncyB1c2VkIHRvXHJcbiAqIGNyZWF0ZSBhbiBFdGhlcnMuanMgUHJvdmlkZXIgaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBFdGhlcnNOZXR3b3JrID0ge1xyXG4gICAgW2V4cG9ydHMuTmV0d29yay5FVEhfTUFJTk5FVF06ICdtYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuRVRIX0dPRVJMSV06ICdnb2VybGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5FVEhfU0VQT0xJQV06ICdzZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuT1BUX01BSU5ORVRdOiAnb3B0aW1pc20nLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5PUFRfR09FUkxJXTogJ29wdGltaXNtLWdvZXJsaScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk9QVF9TRVBPTElBXTogJ29wdGltaXNtLXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5BUkJfTUFJTk5FVF06ICdhcmJpdHJ1bScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFSQl9HT0VSTEldOiAnYXJiaXRydW0tZ29lcmxpJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVJCX1NFUE9MSUFdOiAnYXJiaXRydW0tc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1BVElDX01BSU5ORVRdOiAnbWF0aWMnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5NQVRJQ19NVU1CQUldOiAnbWF0aWNtdW0nLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5NQVRJQ19BTU9ZXTogJ21hdGljYW1veScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFTVEFSX01BSU5ORVRdOiAnYXN0YXItbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlBPTFlHT05aS0VWTV9NQUlOTkVUXTogJ3BvbHlnb256a2V2bS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuUE9MWUdPTlpLRVZNX1RFU1RORVRdOiAncG9seWdvbnprZXZtLXRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CQVNFX01BSU5ORVRdOiAnYmFzZS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQkFTRV9HT0VSTEldOiAnYmFzZS1nb2VybGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CQVNFX1NFUE9MSUFdOiAnYmFzZS1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuWktTWU5DX01BSU5ORVRdOiAnemtzeW5jLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5aS1NZTkNfU0VQT0xJQV06ICd6a3N5bmMtc2Vwb2xpYSdcclxufTtcclxuLyoqXHJcbiAqIE1hcHBpbmcgb2YgbmV0d29yayBuYW1lcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIEV0aGVycyBOZXR3b3JrIG9iamVjdHMuIFRoZXNlXHJcbiAqIG5ldHdvcmtzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBieSBFdGhlcnMgYW5kIGFyZSBsaXN0ZWQgaGVyZSB0byBiZSBvdmVycmlkZW5cclxuICogaW4gdGhlIHByb3ZpZGVyLlxyXG4gKi9cclxuY29uc3QgQ3VzdG9tTmV0d29ya3MgPSB7XHJcbiAgICAnYXJiaXRydW0tZ29lcmxpJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDQyMTYxMyxcclxuICAgICAgICBuYW1lOiAnYXJiaXRydW0tZ29lcmxpJ1xyXG4gICAgfSxcclxuICAgICdhcmJpdHJ1bS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDQyMTYxNCxcclxuICAgICAgICBuYW1lOiAnYXJiaXRydW0tc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnYXN0YXItbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA1OTIsXHJcbiAgICAgICAgbmFtZTogJ2FzdGFyLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgc2Vwb2xpYToge1xyXG4gICAgICAgIGNoYWluSWQ6IDExMTU1MTExLFxyXG4gICAgICAgIG5hbWU6ICdzZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdvcHRpbWlzbS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDExMTU1NDIwLFxyXG4gICAgICAgIG5hbWU6ICdvcHRpbWlzbS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdwb2x5Z29uemtldm0tbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAxMTAxLFxyXG4gICAgICAgIG5hbWU6ICdwb2x5Z29uemtldm0tbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAncG9seWdvbnprZXZtLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTQ0MixcclxuICAgICAgICBuYW1lOiAncG9seWdvbnprZXZtLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2Jhc2UtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA4NDUzLFxyXG4gICAgICAgIG5hbWU6ICdiYXNlLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2Jhc2UtZ29lcmxpJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDg0NTMxLFxyXG4gICAgICAgIG5hbWU6ICdiYXNlLWdvZXJsaSdcclxuICAgIH0sXHJcbiAgICAnYmFzZS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDg0NTMyLFxyXG4gICAgICAgIG5hbWU6ICdiYXNlLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgbWF0aWNhbW95OiB7XHJcbiAgICAgICAgY2hhaW5JZDogODAwMDIsXHJcbiAgICAgICAgbmFtZTogJ21hdGljYW1veSdcclxuICAgIH0sXHJcbiAgICAnemtzeW5jLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMzI0LFxyXG4gICAgICAgIG5hbWU6ICd6a3N5bmMtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnemtzeW5jLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMzAwLFxyXG4gICAgICAgIG5hbWU6ICd6a3N5bmMtc2Vwb2xpYSdcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gbm9vcCgpIHtcclxuICAgIC8vIEl0J3MgYSBuby1vcFxyXG59XHJcbmNvbnN0IEVUSF9OVUxMX1ZBTFVFID0gJzB4JztcclxuY29uc3QgRVRIX05VTExfQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyBob2xkcyB0aGUgY29uZmlnIGluZm9ybWF0aW9uIGZvciB0aGUgU0RLIGNsaWVudCBpbnN0YW5jZSBhbmRcclxuICogZXhwb3NlcyB0aGUgdW5kZXJseWluZyBwcm92aWRlcnMgZm9yIG1vcmUgYWR2YW5jZWQgdXNlIGNhc2VzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15Q29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hcGlLZXkpIHx8IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgICAgIHRoaXMubmV0d29yayA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubmV0d29yaykgfHwgREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWF4UmV0cmllcykgfHwgREVGQVVMVF9NQVhfUkVUUklFUztcclxuICAgICAgICB0aGlzLnVybCA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0aFRva2VuO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYmF0Y2hSZXF1ZXN0cykgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucmVxdWVzdFRpbWVvdXQpIHx8IERFRkFVTFRfUkVRVUVTVF9USU1FT1VUO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkluZm9PdmVycmlkZXMgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuY29ubmVjdGlvbkluZm9PdmVycmlkZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFVSTCBlbmRwb2ludCB0byBzZW5kIHRoZSBIVFRQIHJlcXVlc3QgdG8uIElmIGEgY3VzdG9tIFVSTCB3YXNcclxuICAgICAqIHByb3ZpZGVkIGluIHRoZSBjb25maWcsIHRoYXQgVVJMIGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBkZWZhdWx0IFVSTCBpc1xyXG4gICAgICogZnJvbSB0aGUgbmV0d29yayBhbmQgQVBJIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXBpVHlwZSAtIFRoZSB0eXBlIG9mIEFQSSB0byBnZXQgdGhlIFVSTCBmb3IuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2dldFJlcXVlc3RVcmwoYXBpVHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnVybCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXBpVHlwZSA9PT0gQWxjaGVteUFwaVR5cGUuTkZUKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBbGNoZW15TmZ0SHR0cFVybCh0aGlzLm5ldHdvcmssIHRoaXMuYXBpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXBpVHlwZSA9PT0gQWxjaGVteUFwaVR5cGUuV0VCSE9PSykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxjaGVteVdlYmhvb2tIdHRwVXJsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxjaGVteUh0dHBVcmwodGhpcy5uZXR3b3JrLCB0aGlzLmFwaUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIEFsY2hlbXlQcm92aWRlciBpbnN0YW5jZS4gT25seSBvbmUgcHJvdmlkZXIgaXMgY3JlYXRlZCBwZXJcclxuICAgICAqIEFsY2hlbXkgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIEFsY2hlbXlQcm92aWRlciBpcyBhIHdyYXBwZXIgYXJvdW5kIGV0aGVyJ3MgYEFsY2hlbXlQcm92aWRlcmAgY2xhc3MgYW5kXHJcbiAgICAgKiBoYXMgYmVlbiBleHBhbmRlZCB0byBzdXBwb3J0IEFsY2hlbXkncyBFbmhhbmNlZCBBUElzLlxyXG4gICAgICpcclxuICAgICAqIE1vc3QgY29tbW9uIG1ldGhvZHMgb24gdGhlIHByb3ZpZGVyIGFyZSBhdmFpbGFibGUgYXMgdG9wLWxldmVsIG1ldGhvZHMgb25cclxuICAgICAqIHRoZSB7QGxpbmsgQWxjaGVteX0gaW5zdGFuY2UsIGJ1dCB0aGUgcHJvdmlkZXIgaXMgZXhwb3NlZCBoZXJlIHRvIGFjY2Vzc1xyXG4gICAgICogb3RoZXIgbGVzcy1jb21tb24gbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYmFzZUFsY2hlbXlQcm92aWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlQWxjaGVteVByb3ZpZGVyID0gKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBBbGNoZW15UHJvdmlkZXIgfSA9IHlpZWxkIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9hbGNoZW15LXByb3ZpZGVyLTdhYjkwODIxLmpzJyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15UHJvdmlkZXIodGhpcyk7XHJcbiAgICAgICAgICAgIH0pKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUFsY2hlbXlQcm92aWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBbGNoZW15V2Vic29ja2V0UHJvdmlkZXIgaW5zdGFuY2UuIE9ubHkgb25lIHByb3ZpZGVyIGlzIGNyZWF0ZWRcclxuICAgICAqIHBlciBBbGNoZW15IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCBldGhlcidzXHJcbiAgICAgKiBgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyYCBjbGFzcyBhbmQgaGFzIGJlZW4gZXhwYW5kZWQgdG8gc3VwcG9ydCBBbGNoZW15J3NcclxuICAgICAqIFN1YnNjcmlwdGlvbiBBUElzLCBhdXRvbWF0aWMgYmFja2ZpbGxpbmcsIGFuZCBvdGhlciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogTW9zdCBjb21tb24gbWV0aG9kcyBvbiB0aGUgcHJvdmlkZXIgYXJlIGF2YWlsYWJsZSBhcyB0b3AtbGV2ZWwgbWV0aG9kcyBvblxyXG4gICAgICogdGhlIHtAbGluayBBbGNoZW15fSBpbnN0YW5jZSwgYnV0IHRoZSBwcm92aWRlciBpcyBleHBvc2VkIGhlcmUgdG8gYWNjZXNzXHJcbiAgICAgKiBvdGhlciBsZXNzLWNvbW1vbiBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBnZXRXZWJTb2NrZXRQcm92aWRlcigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Jhc2VBbGNoZW15V3NzUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFzZUFsY2hlbXlXc3NQcm92aWRlciA9ICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH0gPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItNDRkZjM3MzkuanMnKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcih0aGlzKTtcclxuICAgICAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9iYXNlQWxjaGVteVdzc1Byb3ZpZGVyO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHZlcnNpb24kMSA9IFwibG9nZ2VyLzUuNy4wXCI7XG5cbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG52YXIgTG9nTGV2ZWwkMTtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuICAgIExvZ0xldmVsW1wiV0FSTklOR1wiXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ0xldmVsW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoTG9nTGV2ZWwkMSB8fCAoTG9nTGV2ZWwkMSA9IHt9KSk7XG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gR2VuZXJpYyBFcnJvcnNcbiAgICAvLyBVbmtub3duIEVycm9yXG4gICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuICAgIEVycm9yQ29kZVtcIk5PVF9JTVBMRU1FTlRFRFwiXSA9IFwiTk9UX0lNUExFTUVOVEVEXCI7XG4gICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG4gICAgLy8gICAtIG9wZXJhdGlvblxuICAgIEVycm9yQ29kZVtcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXSA9IFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCI7XG4gICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG4gICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG4gICAgRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICAgIC8vIFNvbWUgc29ydCBvZiBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcbiAgICAvLyBUaW1lb3V0XG4gICAgRXJyb3JDb2RlW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBPcGVyYXRpb25hbCAgRXJyb3JzXG4gICAgLy8gQnVmZmVyIE92ZXJydW5cbiAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcbiAgICAvLyBOdW1lcmljIEZhdWx0XG4gICAgLy8gICAtIG9wZXJhdGlvbjogdGhlIG9wZXJhdGlvbiBiZWluZyBleGVjdXRlZFxuICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcbiAgICBFcnJvckNvZGVbXCJOVU1FUklDX0ZBVUxUXCJdID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuICAgIC8vIE1pc3NpbmcgbmV3IG9wZXJhdG9yIHRvIGFuIG9iamVjdFxuICAgIC8vICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuICAgIC8vIEludmFsaWQgYXJndW1lbnQgKGUuZy4gdmFsdWUgaXMgaW5jb21wYXRpYmxlIHdpdGggdHlwZSkgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gYXJndW1lbnQ6IFRoZSBhcmd1bWVudCBuYW1lIHRoYXQgd2FzIGludmFsaWRcbiAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAgICBFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgLy8gTWlzc2luZyBhcmd1bWVudCB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdID0gXCJNSVNTSU5HX0FSR1VNRU5UXCI7XG4gICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQmxvY2tjaGFpbiBFcnJvcnNcbiAgICAvLyBDYWxsIGV4Y2VwdGlvblxuICAgIC8vICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBhZGRyZXNzPzogdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICAvLyAgLSBtZXRob2Q/OiBUaGUgU29saWRpdHkgbWV0aG9kIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yU2lnbmF0dXJlPzogVGhlIEVJUDg0OCBlcnJvciBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcbiAgICAvLyAgLSByZWFzb246IFRoZSByZWFzb24gKG9ubHkgZm9yIEVJUDg0OCBcIkVycm9yKHN0cmluZylcIilcbiAgICBFcnJvckNvZGVbXCJDQUxMX0VYQ0VQVElPTlwiXSA9IFwiQ0FMTF9FWENFUFRJT05cIjtcbiAgICAvLyBJbnN1ZmZpY2llbnQgZnVuZHMgKDwgdmFsdWUgKyBnYXNMaW1pdCAqIGdhc1ByaWNlKVxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG4gICAgLy8gTm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuICAgIC8vIFRoZSByZXBsYWNlbWVudCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpcyB0b28gbG93XG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG4gICAgLy8gVGhlIGdhcyBsaW1pdCBjb3VsZCBub3QgYmUgZXN0aW1hdGVkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gcGFzc2VkIHRvIGVzdGltYXRlR2FzXG4gICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZCBieSBvbmUgd2l0aCBhIGhpZ2hlciBnYXMgcHJpY2VcbiAgICAvLyAgIC0gcmVhc29uOiBcImNhbmNlbGxlZFwiLCBcInJlcGxhY2VkXCIgb3IgXCJyZXByaWNlZFwiXG4gICAgLy8gICAtIGNhbmNlbGxlZDogdHJ1ZSBpZiByZWFzb24gPT0gXCJjYW5jZWxsZWRcIiBvciByZWFzb24gPT0gXCJyZXBsYWNlZFwiKVxuICAgIC8vICAgLSBoYXNoOiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBoYXNoXG4gICAgLy8gICAtIHJlcGxhY2VtZW50OiB0aGUgZnVsbCBUcmFuc2FjdGlvbnNSZXNwb25zZSBmb3IgdGhlIHJlcGxhY2VtZW50XG4gICAgLy8gICAtIHJlY2VpcHQ6IHRoZSByZWNlaXB0IG9mIHRoZSByZXBsYWNlbWVudFxuICAgIEVycm9yQ29kZVtcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCJdID0gXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBJbnRlcmFjdGlvbiBFcnJvcnNcbiAgICAvLyBUaGUgdXNlciByZWplY3RlZCB0aGUgYWN0aW9uLCBzdWNoIGFzIHNpZ25pbmcgYSBtZXNzYWdlIG9yIHNlbmRpbmdcbiAgICAvLyBhIHRyYW5zYWN0aW9uXG4gICAgRXJyb3JDb2RlW1wiQUNUSU9OX1JFSkVDVEVEXCJdID0gXCJBQ1RJT05fUkVKRUNURURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuY2xhc3MgTG9nZ2VyJDEge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZlcnNpb24sXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9sb2cobG9nTGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBsb2dMZXZlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoTG9nTGV2ZWxzW2xldmVsXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9sb2dMZXZlbCA+IExvZ0xldmVsc1tsZXZlbF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyJDEubGV2ZWxzLkRFQlVHLCBhcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIkMS5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyJDEubGV2ZWxzLldBUk5JTkcsIGFyZ3MpO1xuICAgIH1cbiAgICBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEVycm9ycyBhcmUgYmVpbmcgY2Vuc29yZWRcbiAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VFcnJvcihcImNlbnNvcmVkIGVycm9yXCIsIGNvZGUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSBMb2dnZXIkMS5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldICYgMHgwZl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGxldCB1cmwgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5VTUVSSUNfRkFVTFQ6IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBmYXVsdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3ZlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGl2aXNpb24tYnktemVyb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLVwiICsgZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXBvd2VyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS13aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuQ0FMTF9FWENFUFRJT046XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfRlVORFM6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5NSVNTSU5HX05FVzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5PTkNFX0VYUElSRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlRSQU5TQUNUSU9OX1JFUExBQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQ6XG4gICAgICAgICAgICAgICAgdXJsID0gY29kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIFsgU2VlOiBodHRwczovXFwvbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyB1cmwgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VEZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogQW55Pz9cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIHRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIHRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlciQxLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlciQxLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NhZmVVaW50NTModmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIkMS5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIkMS5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIkMS5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIExvZ2dlciQxLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlciQxLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyJDEuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIkMS5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIkMSh2ZXJzaW9uJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcbiAgICAgICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIkMS5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlciQxLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlciQxLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyJDEodmVyc2lvbik7XG4gICAgfVxufVxuTG9nZ2VyJDEuZXJyb3JzID0gRXJyb3JDb2RlO1xuTG9nZ2VyJDEubGV2ZWxzID0gTG9nTGV2ZWwkMTtcblxuY29uc3QgdmVyc2lvbiA9IFwicHJvcGVydGllcy81LjcuMFwiO1xuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyJDEodmVyc2lvbik7XG5mdW5jdGlvbiBkZWZpbmVSZWFkT25seShvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oKHYpID0+ICh7IGtleToga2V5LCB2YWx1ZTogdiB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFjY3VtWyhyZXN1bHQua2V5KV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9KTtcbn1cbmNvbnN0IG9wYXF1ZSA9IHsgYmlnaW50OiB0cnVlLCBib29sZWFuOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIG51bWJlcjogdHJ1ZSwgc3RyaW5nOiB0cnVlIH07XG5mdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgLy8gT3BhcXVlIG9iamVjdHMgYXJlIG5vdCBtdXRhYmxlLCBzbyBzYWZlIHRvIGNvcHkgYnkgYXNzaWdubWVudFxuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwgfHwgb3BhcXVlW3R5cGVvZiAob2JqZWN0KV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgdHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFjY2Vzc2luZyBhIHZhbHVlIHRyaWdnZXJzIGFuIGVycm9yLCBpdCBpcyBhIGdldHRlclxuICAgICAgICAgICAgICAgIC8vIGRlc2lnbmVkIHRvIGRvIHNvIChlLmcuIFJlc3VsdCkgYW5kIGlzIHRoZXJlZm9yZSBcImZyb3plblwiXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV9pc0Zyb3plbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbi8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cbi8vIE5ldyBwcm9wZXJ0aWVzIG1heSBiZSBhZGRlZCBvbmx5IHRvIG9iamVjdHMuXG5mdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG4gICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKChpdGVtKSA9PiBkZWVwQ29weShpdGVtKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9kZWVwQ29weShvYmplY3QpO1xufVxuXG4vKipcclxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgZGVjaW1hbCBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSGV4KGhleFN0cmluZykge1xyXG4gICAgcmV0dXJuIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShoZXhTdHJpbmcpLnRvTnVtYmVyKCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGEgaGV4IHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIG51bSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBoZXguXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHRvSGV4KG51bSkge1xyXG4gICAgcmV0dXJuIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShudW0pLnRvSGV4U3RyaW5nKCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgaGV4IHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHBvc3NpYmxlSGV4U3RyaW5nIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hleChwb3NzaWJsZUhleFN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXSskLy50ZXN0KHBvc3NpYmxlSGV4U3RyaW5nKTtcclxufVxuXG5mdW5jdGlvbiBmb3JtYXRCbG9jayhibG9jaykge1xyXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYmxvY2s7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGJsb2NrKSkge1xyXG4gICAgICAgIHJldHVybiB0b0hleChibG9jayk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmxvY2sudG9TdHJpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdUb0VudW0oeCwgZW51bWIpIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGVudW1iKS5pbmNsdWRlcyh4KSA/IHggOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdENvbnRyYWN0Rm9yTmZ0RnJvbVJhdyhyYXdOZnRDb250cmFjdCkge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXROZnRDb250cmFjdEZyb21SYXcocmF3TmZ0Q29udHJhY3QpKSwgeyBzcGFtQ2xhc3NpZmljYXRpb25zOiByYXdOZnRDb250cmFjdC5zcGFtQ2xhc3NpZmljYXRpb25zLm1hcChwYXJzZU5mdFNwYW1DbGFzc2lmaWNhdGlvbikgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdENvbnRyYWN0c0Zvck93bmVyRnJvbVJhdyhyYXdOZnRDb250cmFjdCkge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXROZnRDb250cmFjdEZyb21SYXcocmF3TmZ0Q29udHJhY3QpKSwgeyBkaXNwbGF5TmZ0OiByYXdOZnRDb250cmFjdC5kaXNwbGF5TmZ0LCBpbWFnZTogcmF3TmZ0Q29udHJhY3QuaW1hZ2UsIHRvdGFsQmFsYW5jZTogcmF3TmZ0Q29udHJhY3QudG90YWxCYWxhbmNlLCBudW1EaXN0aW5jdFRva2Vuc093bmVkOiByYXdOZnRDb250cmFjdC5udW1EaXN0aW5jdFRva2Vuc093bmVkLCBpc1NwYW06IHJhd05mdENvbnRyYWN0LmlzU3BhbSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KHJhd05mdENvbnRyYWN0KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdENvbnRyYWN0KSwgeyB0b2tlblR5cGU6IHBhcnNlTmZ0VG9rZW5UeXBlKHJhd05mdENvbnRyYWN0LnRva2VuVHlwZSksIG9wZW5TZWFNZXRhZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnRDb250cmFjdC5vcGVuU2VhTWV0YWRhdGEpLCB7IHNhZmVsaXN0UmVxdWVzdFN0YXR1czogKChfYSA9IHJhd05mdENvbnRyYWN0Lm9wZW5TZWFNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNhZmVsaXN0UmVxdWVzdFN0YXR1cykgIT09IG51bGxcclxuICAgICAgICAgICAgICAgID8gc3RyaW5nVG9FbnVtKHJhd05mdENvbnRyYWN0Lm9wZW5TZWFNZXRhZGF0YS5zYWZlbGlzdFJlcXVlc3RTdGF0dXMsIGV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cylcclxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0Q29sbGVjdGlvbkZyb21SYXcocmF3TmZ0Q29sbGVjdGlvbikge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnRDb2xsZWN0aW9uKSwgeyBmbG9vclByaWNlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdENvbGxlY3Rpb24uZmxvb3JQcmljZSksIHsgbWFya2V0cGxhY2U6IHBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKHJhd05mdENvbGxlY3Rpb24uZmxvb3JQcmljZS5tYXJrZXRwbGFjZSkgfSkgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEJhc2VOZnRGcm9tUmF3KHJhd0Jhc2VOZnQsIGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgICAgICA/IGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgICAgICA6IHJhd0Jhc2VOZnQuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgIHRva2VuSWQ6IHJhd0Jhc2VOZnQudG9rZW5JZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRGcm9tUmF3KHJhd05mdCkge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnQpLCB7IGNvbnRyYWN0OiBnZXROZnRDb250cmFjdEZvck5mdEZyb21SYXcocmF3TmZ0LmNvbnRyYWN0KSwgdG9rZW5UeXBlOiBwYXJzZU5mdFRva2VuVHlwZShyYXdOZnQudG9rZW5UeXBlKSwgYWNxdWlyZWRBdDogcmF3TmZ0LmFjcXVpcmVkQXQsIGNvbGxlY3Rpb246IHJhd05mdC5jb2xsZWN0aW9uLCBtaW50OiByYXdOZnQubWludCB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0U2FsZXNGcm9tUmF3KHJhd05mdFNhbGVzKSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgbmZ0U2FsZXM6IHJhd05mdFNhbGVzLm5mdFNhbGVzLm1hcChyYXdOZnRTYWxlID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdFNhbGUpLCB7IG1hcmtldHBsYWNlOiBwYXJzZU5mdFNhbGVNYXJrZXRwbGFjZShyYXdOZnRTYWxlLm1hcmtldHBsYWNlKSwgdGFrZXI6IHBhcnNlTmZ0VGFrZXIocmF3TmZ0U2FsZS50YWtlcikgfSkpKSxcclxuICAgICAgICB2YWxpZEF0OiByYXdOZnRTYWxlcy52YWxpZEF0LFxyXG4gICAgICAgIHBhZ2VLZXk6IHJhd05mdFNhbGVzLnBhZ2VLZXlcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0U2FsZU1hcmtldHBsYWNlKG1hcmtldHBsYWNlKSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldHBsYWNlKSB7XHJcbiAgICAgICAgY2FzZSAnbG9va3NyYXJlJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLkxPT0tTUkFSRTtcclxuICAgICAgICBjYXNlICdzZWFwb3J0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLlNFQVBPUlQ7XHJcbiAgICAgICAgY2FzZSAneDJ5Mic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5YMlkyO1xyXG4gICAgICAgIGNhc2UgJ3d5dmVybic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5XWVZFUk47XHJcbiAgICAgICAgY2FzZSAnY3J5cHRvcHVua3MnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UuQ1JZUFRPUFVOS1M7XHJcbiAgICAgICAgY2FzZSAnYmx1cic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5CTFVSO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5VTktOT1dOO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKG1hcmtldHBsYWNlKSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldHBsYWNlKSB7XHJcbiAgICAgICAgY2FzZSAnT3BlblNlYSc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZS5PUEVOU0VBO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRUYWtlcih0YWtlcikge1xyXG4gICAgLy8gVGhlIGAudG9Mb3dlckNhc2UoKWAgY2FsbCBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgQVBJIHJldHVybnMgdGhlIGNhcGl0YWxpemVkIHZhbHVlc1xyXG4gICAgc3dpdGNoICh0YWtlci50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSAnYnV5ZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlVGFrZXJUeXBlLkJVWUVSO1xyXG4gICAgICAgIGNhc2UgJ3NlbGxlcic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVUYWtlclR5cGUuU0VMTEVSO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTmZ0U2FsZVRha2VyVHlwZSAke3Rha2VyfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0U3BhbUNsYXNzaWZpY2F0aW9uKHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IHN0cmluZ1RvRW51bShzLCBleHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbik7XHJcbiAgICBpZiAocmVzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTcGFtQ2xhc3NpZmljYXRpb24uVW5rbm93bjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRUb2tlblR5cGUodG9rZW5UeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHRva2VuVHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2VyYzcyMSc6XHJcbiAgICAgICAgY2FzZSAnRVJDNzIxJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMTtcclxuICAgICAgICBjYXNlICdlcmMxMTU1JzpcclxuICAgICAgICBjYXNlICdFUkMxMTU1JzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzExNTU7XHJcbiAgICAgICAgY2FzZSAnbm9fc3VwcG9ydGVkX25mdF9zdGFuZGFyZCc6XHJcbiAgICAgICAgY2FzZSAnTk9fU1VQUE9SVEVEX05GVF9TVEFOREFSRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFRva2VuVHlwZS5OT19TVVBQT1JURURfTkZUX1NUQU5EQVJEO1xyXG4gICAgICAgIGNhc2UgJ25vdF9hX2NvbnRyYWN0JzpcclxuICAgICAgICBjYXNlICdOT1RfQV9DT05UUkFDVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFRva2VuVHlwZS5OT1RfQV9DT05UUkFDVDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRUb2tlblR5cGUuVU5LTk9XTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICE9PSBudWxsO1xyXG5mdW5jdGlvbiBudWxsc1RvVW5kZWZpbmVkKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IG51bGxzVG9VbmRlZmluZWQob2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbnMgZm9yIGV4cG9zZWQgQVBJIHN1cmZhY2UgaW5cclxuICogdGhlIHtAbGluayBDb3JlTmFtZXNwYWNlfS4gQnkgbW92aW5nIHRoZSBtZXRob2RzIG91dCBpbnRvIGEgc2VwYXJhdGUgZmlsZSxcclxuICogb3RoZXIgbmFtZXNwYWNlcyBjYW4gYWNjZXNzIHRoZXNlIG1ldGhvZHMgd2l0aG91dCBkZXBlbmRpbmcgb24gdGhlIGVudGlyZVxyXG4gKiBDb3JlTmFtZXNwYWNlLCBvciBvdmVycmlkZSB0aGUgYHNyY01ldGhvZGAgcGFyYW0gdXNlZCBmb3IgbG9nZ2luZy5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBhc3NldCB0cmFuc2ZlcnMgZm9yIHRoZSBwcm92aWRlZCBwYXJhbXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBc3NldFRyYW5zZmVycyhjb25maWcsIHBhcmFtcywgc3JjTWV0aG9kID0gJ2dldEFzc2V0VHJhbnNmZXJzJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5mcm9tQWRkcmVzcykge1xyXG4gICAgICAgICAgICBwYXJhbXMuZnJvbUFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhwYXJhbXMuZnJvbUFkZHJlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zLnRvQWRkcmVzcykge1xyXG4gICAgICAgICAgICBwYXJhbXMudG9BZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MocGFyYW1zLnRvQWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRBc3NldFRyYW5zZmVycycsIFtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGZyb21CbG9jazogcGFyYW1zLmZyb21CbG9jayAhPSBudWxsID8gZm9ybWF0QmxvY2socGFyYW1zLmZyb21CbG9jaykgOiB1bmRlZmluZWQsIHRvQmxvY2s6IHBhcmFtcy50b0Jsb2NrICE9IG51bGwgPyBmb3JtYXRCbG9jayhwYXJhbXMudG9CbG9jaykgOiB1bmRlZmluZWQsIG1heENvdW50OiBwYXJhbXMubWF4Q291bnQgIT0gbnVsbCA/IHRvSGV4KHBhcmFtcy5tYXhDb3VudCkgOiB1bmRlZmluZWQgfSlcclxuICAgICAgICBdLCBzcmNNZXRob2QpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyhjb25maWcsIHBhcmFtcywgc3JjTWV0aG9kID0gJ2dldFRyYW5zYWN0aW9uUmVjZWlwdHMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cycsIFtwYXJhbXNdLCBzcmNNZXRob2QpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2YgZ2V0TG9ncywgYnV0IGlzIGV4cGFuZGVkXHJcbiAqIHRvIHN1cHBvcnQgc3BlY2lmeWluZyBhbiBhZGRyZXNzIGFycmF5IGluIHRoZSBmaWx0ZXIuXHJcbiAqXHJcbiAqIFRoZSBtYWluIG1vZGlmaWNhdGlvbnMgbWFkZSB0byBzdXBwb3J0IGFuIGFkZHJlc3MgYXJyYXkgYXJlOlxyXG4gKiAtIEN1c3RvbSBgZ2V0RmlsdGVyKClgIG1ldGhvZCB0aGF0IHN1cHBvcnRzIGFuIGFkZHJlc3MgYXJyYXlcclxuICogLSBVc2Ugb2YgYGFycmF5T2YoKWAgZm9ybWF0dGVyIHRvIGZvcm1hdCB0aGUgbG9ncyB0byBhdm9pZCB0aGUgYEZvcm1hdHRlcmAgaW1wb3J0LlxyXG4gKiAtIFVzZSBvZiBgcHJvdmlkZXIuc2VuZCgpYCB0byBhdm9pZCBmb3JtYXR0aW5nIGxvZ2ljIGluIGBwcm92aWRlci5wZXJmb3JtKClgLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TG9ncyhjb25maWcsIGZpbHRlcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgeWllbGQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgZmlsdGVyOiBnZXRGaWx0ZXIoY29uZmlnLCBmaWx0ZXIpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRMb2dzJywgW3BhcmFtcy5maWx0ZXJdKTtcclxuICAgICAgICBsb2dzLmZvckVhY2gobG9nID0+IHtcclxuICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXJyYXlPZihwcm92aWRlci5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQocHJvdmlkZXIuZm9ybWF0dGVyKSkobG9ncyk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gYW5kIGNvcGllZCBmcm9tIHRoZSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2ZcclxuICogYEpzb25ScGNQcm92aWRlci5fZ2V0RmlsdGVyKClgLCBidXQgaXMgZXh0ZW5kZWQgdG8gc3VwcG9ydCBhbiBhZGRyZXNzIGFycmF5LlxyXG4gKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGEgaGFja3kgd2F5IHRvIGdldCBhcm91bmQgdGhlIGV0aGVycyBmb3JtYXR0ZXIuIFRoZVxyXG4gKiBmb3JtYXR0ZXIgaXMgdXNlZCB0byBjaGVjayB0aGUgdHlwZXMgb2YgdGhlIGBmaWx0ZXJgIHBhcmFtcywgYnV0IGV0aGVycyBkb2VzXHJcbiAqIG5vdCBhbGxvdyBhbiBhcnJheSBpbiB0aGUgYGFkZHJlc3NgIGZpZWxkLiBUbyBwcmVzZXJ2ZSB0aGUgZXRoZXJzIGZvcm1hdHRlclxyXG4gKiBvbiB0aGUgb3RoZXIgZmllbGRzLCB3ZSB1c2UgdGhlIGZvcm1hdHRlciB0byBjaGVjayB0aGUgdHlwZXMgb2YgdGhvc2Ugb3RoZXJcclxuICogZmllbGRzLCBhbmQgdGhlbiBtYW51YWxseSBjaGVjayB0aGUgYGFkZHJlc3NgIGZpZWxkIGxhc3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaWx0ZXIoY29uZmlnLCBmaWx0ZXIpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCByZXNvbHZlZEZpbHRlciA9IHlpZWxkIGZpbHRlcjtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge307XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICBbJ2Jsb2NrSGFzaCcsICd0b3BpY3MnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZEZpbHRlcltrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVkRmlsdGVyW2tleV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgWydmcm9tQmxvY2snLCAndG9CbG9jayddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkRmlsdGVyW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJvdmlkZXIuX2dldEJsb2NrVGFnKHJlc29sdmVkRmlsdGVyW2tleV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAvLyBGb3JtYXQgdGhlIGByZXN1bHRgIG9iamVjdCB1c2luZyB0aGUgZXRoZXJzIGZvcm1hdHRlciB3aXRob3V0IHRoZSBgYWRkcmVzc2BcclxuICAgICAgICAvLyBmaWVsZC5cclxuICAgICAgICByZXN1bHQgPSBwcm92aWRlci5mb3JtYXR0ZXIuZmlsdGVyKHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHJlc3VsdCkpO1xyXG4gICAgICAgIC8vIEFmdGVyIGZvcm1hdHRpbmcgdGhlIG90aGVyIGZpZWxkcywgbWFudWFsbHkgZm9ybWF0IHRoZSBgYWRkcmVzc2AgZmllbGRcclxuICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBgcmVzdWx0YCBvYmplY3QuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcykpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB5aWVsZCBQcm9taXNlLmFsbChyZXNvbHZlZEZpbHRlci5hZGRyZXNzLm1hcCgoYWRkcmVzcykgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBwcm92aWRlci5fZ2V0QWRkcmVzcyhhZGRyZXNzKTsgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGRpcmVjdGx5IGNvcGllZCBvdmVyIGZyb20gZXRoZXJzIGltcGxlbWVudGF0aW9uIG9mXHJcbiAqIGBGb3JtYXR0ZXIuYXJyYXlPZigpYC4gSXQgaXMgY29waWVkIGhlcmUgdG8gYXZvaWQgaGF2aW5nIHRvIGltcG9ydCB0aGVcclxuICogYEZvcm1hdHRlcmAgY2xhc3Mgb3IgYEZvcm1hdHRlckZ1bmNgIHR5cGUgZnJvbSBldGhlcnMsIHRoYXQgYXJlIG5vdCBwYXJ0IG9mXHJcbiAqIHRoZSBkZWZhdWx0IGV4cG9ydC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHRoZSBmb3JtYXR0ZXIgdG8gYW4gYXJyYXkgb2ZcclxuICogdmFsdWVzLCBhbmQgaXMgdXNlZCB0byBmb3JtYXQgdGhlIGxvZ3MgcmV0dXJuZWQgYnkgYGdldExvZ3MoKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheU9mKGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYW4gYXJyYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgYXJyYXkuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgY29yZSBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGNvbW1vbmx5LXVzZWQgW0V0aGVycy5qc1xyXG4gKiBQcm92aWRlcl0oaHR0cHM6Ly9kb2NzLmV0aGVycy5pby92NS9hcGkvcHJvdmlkZXJzL2FwaS1wcm92aWRlcnMvI0FsY2hlbXlQcm92aWRlcilcclxuICogbWV0aG9kcy4gSWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIEV0aGVycy5qcywgeW91IHNob3VsZCBiZSBzaW1wbHkgYWJsZSB0b1xyXG4gKiByZXBsYWNlIHRoZSBFdGhlcnMuanMgUHJvdmlkZXIgb2JqZWN0IHdpdGggYGFsY2hlbXkuY29yZWAgd2hlbiBhY2Nlc3NpbmdcclxuICogcHJvdmlkZXIgbWV0aG9kcyBhbmQgaXQgc2hvdWxkIGp1c3Qgd29yay5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgY29yZSBuYW1lc3BhY2VcclxuICogdmlhIGBhbGNoZW15LmNvcmVgLlxyXG4gKi9cclxuY2xhc3MgQ29yZU5hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiBhIGdpdmVuIGFkZHJlc3MgYXMgb2YgdGhlIHByb3ZpZGVkIGJsb2NrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBiYWxhbmNlIGZvci5cclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgb3B0aW9uYWwgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBiYWxhbmNlIGZvci5cclxuICAgICAqICAgRGVmYXVsdHMgdG8gJ2xhdGVzdCcgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFkZHJlc3MgaXMgYSBzbWFydCBjb250cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBjaGVjayB0eXBlIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgaXNDb250cmFjdEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0geWllbGQgcHJvdmlkZXIuZ2V0Q29kZShhZGRyZXNzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgIT09ICcweCc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IGNvZGUgb2YgdGhlIHByb3ZpZGVkIGFkZHJlc3MgYXQgdGhlIGJsb2NrLiBJZiB0aGVyZSBpc1xyXG4gICAgICogbm8gY29udHJhY3QgZGVwbG95ZWQsIHRoZSByZXN1bHQgaXMgYDB4YC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgYWRkcmVzcyBvciBuYW1lIG9mIHRoZSBhY2NvdW50IHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiAgIERlZmF1bHRzIHRvICdsYXRlc3QnIGlmIHVuc3BlY2lmaWVkLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgcG9zaXRpb24gYXQgdGhlIHByb3ZpZGVkIGFkZHJlc3MsIGF0IHRoZVxyXG4gICAgICogcHJvdmlkZWQgYmxvY2sgaW4gYEJ5dGVzMzJgIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgYWRkcmVzcyBvciBuYW1lIG9mIHRoZSBhY2NvdW50IHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBzdG9yYWdlIHNsb3QgdG8gZ2V0LlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBvcHRpb25hbCBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGNvZGUgZm9yLlxyXG4gICAgICogICBEZWZhdWx0cyB0byAnbGF0ZXN0JyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGZyb20gdGhlIHByb3ZpZGVkIGFkZHJlc3MsIGFzXHJcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYmxvY2sgdGFnLiBUaGlzIHZhbHVlIGlzIHVzZWQgYXMgdGhlIG5vbmNlIGZvciB0aGUgbmV4dFxyXG4gICAgICogdHJhbnNhY3Rpb24gZnJvbSB0aGUgYWRkcmVzcyBzZW50IHRvIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBub25jZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgbm9uY2UgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgZnJvbSB0aGUgbmV0d29yayBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmxvY2sgbnVtYmVyIG9yXHJcbiAgICAgKiBoYXNoLiBUcmFuc2FjdGlvbnMgb24gdGhlIGJsb2NrIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiB0cmFuc2FjdGlvblxyXG4gICAgICogaGFzaGVzLiBUbyBnZXQgdGhlIGZ1bGwgdHJhbnNhY3Rpb24gZGV0YWlscyBvbiB0aGUgYmxvY2ssIHVzZVxyXG4gICAgICoge0BsaW5rIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tIYXNoT3JCbG9ja1RhZyBUaGUgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBibG9jayBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBmcm9tIHRoZSBuZXR3b3JrIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIgb3JcclxuICAgICAqIGhhc2guIFRyYW5zYWN0aW9ucyBvbiB0aGUgYmxvY2sgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mXHJcbiAgICAgKiB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0gb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tIYXNoT3JCbG9ja1RhZyBUaGUgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBibG9jayBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBFdGhlcnNOZXR3b3JrQWxpYXN9IEFsY2hlbXkgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0TmV0d29yaygpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBtb3N0IHJlY2VudGx5IG1pbmVkIGJsb2NrLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGd1ZXNzIG9mIHRoZSBjdXJyZW50IGdhcyBwcmljZSB0byB1c2UgaW4gYSB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEdhc1ByaWNlKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0R2FzUHJpY2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVjb21tZW5kZWQgZmVlIGRhdGEgdG8gdXNlIGluIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGFuIEVJUC0xNTU5IHRyYW5zYWN0aW9uLCB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc1xyXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgYW5kIG5ldHdvcmtzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5LCB0aGVcclxuICAgICAqIGdhc1ByaWNlIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0RmVlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEZlZURhdGEoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFByb21pc2Ugd2hpY2ggd2lsbCBzdGFsbCB1bnRpbCB0aGUgbmV0d29yayBoYXMgaGVlbiBlc3RhYmxpc2hlZCxcclxuICAgICAqIGlnbm9yaW5nIGVycm9ycyBkdWUgdG8gdGhlIHRhcmdldCBub2RlIG5vdCBiZWluZyBhY3RpdmUgeWV0LlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHRlc3Rpbmcgb3IgYXR0YWNoaW5nIHNjcmlwdHMgdG8gd2FpdCB1bnRpbCB0aGUgbm9kZSBpc1xyXG4gICAgICogdXAgYW5kIHJ1bm5pbmcgc21vb3RobHkuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlYWR5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSB0cmFuc2FjdGlvbiwgdXNpbmcgY2FsbC4gQSBjYWxsIGRvZXNcclxuICAgICAqIG5vdCByZXF1aXJlIGFueSBldGhlciwgYnV0IGNhbm5vdCBjaGFuZ2UgYW55IHN0YXRlLiBUaGlzIGlzIHVzZWZ1bCBmb3JcclxuICAgICAqIGNhbGxpbmcgZ2V0dGVycyBvbiBDb250cmFjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBleGVjdXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBvcHRpb25hbCBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGNhbGwgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd291bGQgYmUgcmVxdWlyZWQgdG8gc3VibWl0XHJcbiAgICAgKiB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cclxuICAgICAqXHJcbiAgICAgKiBBbiBlc3RpbWF0ZSBtYXkgbm90IGJlIGFjY3VyYXRlIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGFub3RoZXIgdHJhbnNhY3Rpb24gb25cclxuICAgICAqIHRoZSBuZXR3b3JrIHRoYXQgd2FzIG5vdCBhY2NvdW50ZWQgZm9yLCBidXQgYWZ0ZXIgYmVpbmcgbWluZWQgYWZmZWN0cyB0aGVcclxuICAgICAqIHJlbGV2YW50IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5lc3RpbWF0ZUdhc30uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBnYXMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5rbm93bi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgdGhpcyBtZXRob2Qgd2lsbCBzZWFyY2ggdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBwb29sLiBWYXJpb3VzIGJhY2tlbmRzIG1heSBoYXZlIG1vcmUgcmVzdHJpY3RpdmUgdHJhbnNhY3Rpb25cclxuICAgICAqIHBvb2wgYWNjZXNzIChlLmcuIGlmIHRoZSBnYXMgcHJpY2UgaXMgdG9vIGxvdyBvciB0aGUgdHJhbnNhY3Rpb24gd2FzIG9ubHlcclxuICAgICAqIHJlY2VudGx5IHNlbnQgYW5kIG5vdCB5ZXQgaW5kZXhlZCkgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCBtYXkgYWxzbyByZXR1cm4gbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2UuZ2V0VHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGdldC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvciBoYXNoIG9yIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3RcclxuICAgICAqIGJlZW4gbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogVG8gc3RhbGwgdW50aWwgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkLCBjb25zaWRlciB0aGVcclxuICAgICAqIHdhaXRGb3JUcmFuc2FjdGlvbiBtZXRob2QgYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VibWl0cyB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yayB0byBiZSBtaW5lZC4gVGhlIHRyYW5zYWN0aW9uIG11c3QgYmVcclxuICAgICAqIHNpZ25lZCwgYW5kIGJlIHZhbGlkIChpLmUuIHRoZSBub25jZSBpcyBjb3JyZWN0IGFuZCB0aGUgYWNjb3VudCBoYXNcclxuICAgICAqIHN1ZmZpY2llbnQgYmFsYW5jZSB0byBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLmdldFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb24gVGhlIHNpZ25lZCB0cmFuc2FjdGlvbiB0byBzZW5kLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgbm90IHJlc29sdmUgdW50aWwgc3BlY2lmaWVkIHRyYW5zYWN0aW9uIGhhc2ggaXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogSWYge0BsaW5rIGNvbmZpcm1hdGlvbnN9IGlzIDAsIHRoaXMgbWV0aG9kIGlzIG5vbi1ibG9ja2luZyBhbmQgaWYgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGxcclxuICAgICAqIGJsb2NrIHVudGlsIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29uZmlybWVkIGJsb2NrcyBtaW5lZCBvbiB0b3Agb2YgdGhlIGJsb2NrXHJcbiAgICAgKiBpbiB3aGljaCBpdCB3YXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLmdldFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byB3YWl0IGZvci5cclxuICAgICAqIEBwYXJhbSBjb25maXJtYXRpb25zIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRvIHdhaXQgZm9yLlxyXG4gICAgICogQHBhcmFtIHRpbWVvdXQgVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29uZmlybS5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbG9ncyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbHRlciBUaGUgZmlsdGVyIG9iamVjdCB0byB1c2UuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3MoZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TG9ncyh0aGlzLmNvbmZpZywgZmlsdGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIHNlbmRpbmcgYSByYXcgbWVzc2FnZSB0byB0aGUgQWxjaGVteSBiYWNrZW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCB0byBjYWxsLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgYWRkcmVzcyB0aGF0IGRlcGxveWVkIHRoZSBwcm92aWRlZCBjb250cmFjdCBhbmQgYmxvY2sgbnVtYmVyIGl0XHJcbiAgICAgKiB3YXMgZGVwbG95ZWQgaW4uXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFjcm9zcyBhbGwgYmxvY2tzIHNpbmNlIGdlbmVzaXNcclxuICAgICAqIGFuZCBjYW4gdGFrZSBhIGxvbmcgdGltZSB0byBjb21wbGV0ZS4gVGhpcyBtZXRob2QgaXMgYSBjb252ZW5pZW5jZSBtZXRob2RcclxuICAgICAqIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIHJlcGxhY2VkIGJ5IGEgc2luZ2xlIGNhbGwgdG8gYW4gQWxjaGVteSBlbmRwb2ludFxyXG4gICAgICogd2l0aCB0aGlzIGluZm9ybWF0aW9uIGNhY2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gZmluZCB0aGUgZGVwbG95ZXIgZm9yLlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgZmluZENvbnRyYWN0RGVwbG95ZXIoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW0gPSB5aWVsZCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoKHlpZWxkIHByb3ZpZGVyLmdldENvZGUoY29udHJhY3RBZGRyZXNzLCBjdXJyZW50QmxvY2tOdW0pKSA9PT1cclxuICAgICAgICAgICAgICAgIEVUSF9OVUxMX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0ICcke2NvbnRyYWN0QWRkcmVzc30nIGRvZXMgbm90IGV4aXN0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgdGhlIGJsb2NrIG51bWJlciB0aGF0IHRoZSBjb250cmFjdCB3YXMgZGVwbG95ZWQgaW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QmxvY2sgPSB5aWVsZCBiaW5hcnlTZWFyY2hGaXJzdEJsb2NrKDAsIGN1cnJlbnRCbG9ja051bSArIDEsIGNvbnRyYWN0QWRkcmVzcywgdGhpcy5jb25maWcpO1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiBpbiB0aGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBhZGRyZXNzLlxyXG4gICAgICAgICAgICBjb25zdCB0eFJlY2VpcHRzID0geWllbGQgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyh0aGlzLmNvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRvSGV4KGZpcnN0QmxvY2spXHJcbiAgICAgICAgICAgIH0sICdmaW5kQ29udHJhY3REZXBsb3llcicpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1JlY2VpcHQgPSAoX2EgPSB0eFJlY2VpcHRzLnJlY2VpcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChyZWNlaXB0ID0+IHJlY2VpcHQuY29udHJhY3RBZGRyZXNzID09PSBjb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkZXBsb3llckFkZHJlc3M6IG1hdGNoaW5nUmVjZWlwdCA9PT0gbnVsbCB8fCBtYXRjaGluZ1JlY2VpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoaW5nUmVjZWlwdC5mcm9tLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGZpcnN0QmxvY2tcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRva2VuQmFsYW5jZXMoYWRkcmVzc09yTmFtZSwgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy5sZW5ndGggPiAxNTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBhc3MgaW4gbW9yZSB0aGFuIDE1MDAgY29udHJhY3QgYWRkcmVzc2VzIHRvIGdldFRva2VuQmFsYW5jZXMoKScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0VG9rZW5CYWxhbmNlcygpIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBjb250cmFjdEFkZHJlc3Mgd2hlbiB1c2luZyBhbiBhcnJheScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuQmFsYW5jZXMnLCBbYWRkcmVzcywgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnNdLCAnZ2V0VG9rZW5CYWxhbmNlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlLkVSQzIwXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW2FkZHJlc3MsIHRva2VuVHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoKGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zID09PSBudWxsIHx8IGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy50eXBlKSA9PT0gZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlLkVSQzIwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMucGFnZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHsgcGFnZUtleTogY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMucGFnZUtleSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRUb2tlbkJhbGFuY2VzJywgcGFyYW1zLCAnZ2V0VG9rZW5CYWxhbmNlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRva2VucyB0aGF0IHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBvd25zLCBhbG9uZyB3aXRoIHRoZSBhbW91bnRcclxuICAgICAqIG9mIGVhY2ggdG9rZW4gYW5kIHRoZSByZWxldmFudCBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgb3duZXIgYWRkcmVzcyB0byBnZXQgdGhlIHRva2VucyB3aXRoIGJhbGFuY2VzIGZvci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlbnNGb3JPd25lcihhZGRyZXNzT3JOYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZS5FUkMyMFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXkpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHsgcGFnZUtleTogb3B0aW9ucy5wYWdlS2V5IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHlpZWxkIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuQmFsYW5jZXMnLCBwYXJhbXMsICdnZXRUb2tlbnNGb3JPd25lcicpKTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkQmFsYW5jZXMgPSByZXNwb25zZS50b2tlbkJhbGFuY2VzLm1hcChiYWxhbmNlID0+ICh7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGJhbGFuY2UuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgcmF3QmFsYW5jZTogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGJhbGFuY2UudG9rZW5CYWxhbmNlKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFQcm9taXNlcyA9IHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZChyZXNwb25zZS50b2tlbkJhbGFuY2VzLm1hcCh0b2tlbiA9PiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRUb2tlbk1ldGFkYXRhJywgW3Rva2VuLmNvbnRyYWN0QWRkcmVzc10sICdnZXRUb2tlbnNGb3JPd25lcicsIFxyXG4gICAgICAgICAgICAvKiBmb3JjZUJhdGNoPSAqLyB0cnVlKSkpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvbWlzZXMubWFwKHAgPT4gcC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnXHJcbiAgICAgICAgICAgICAgICA/IHAudmFsdWVcclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IG51bGxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBvd25lZFRva2VucyA9IGZvcm1hdHRlZEJhbGFuY2VzLm1hcCgoYmFsYW5jZSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFsYW5jZSksIG1ldGFkYXRhW2luZGV4XSksIHsgYmFsYW5jZTogbWV0YWRhdGFbaW5kZXhdLmRlY2ltYWxzICE9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1dGlscy5mb3JtYXRVbml0cyhiYWxhbmNlLnJhd0JhbGFuY2UsIG1ldGFkYXRhW2luZGV4XS5kZWNpbWFscylcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBvd25lZFRva2Vucy5tYXAodCA9PiBudWxsc1RvVW5kZWZpbmVkKHQpKSxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBtZXRhZGF0YSBmb3IgYSBnaXZlbiB0b2tlbiBjb250cmFjdCBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGdldCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRva2VuTWV0YWRhdGEoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VG9rZW5NZXRhZGF0YScsIFthZGRyZXNzXSwgJ2dldFRva2VuTWV0YWRhdGEnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEFzc2V0VHJhbnNmZXJzKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEFzc2V0VHJhbnNmZXJzKHRoaXMuY29uZmlnLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCB0cmFuc2FjdGlvbiByZWNlaXB0cyBmb3IgYSBnaXZlbiBibG9jayBieSBudW1iZXIgb3IgYmxvY2sgaGFzaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyBmb3IgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgcXVlcnkuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdHMocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyh0aGlzLmNvbmZpZywgcGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBvd25lciBhZGRyZXNzIGZvciB0aGUgcHJvdmlkZWQgRU5TIGFkZHJlc3MsIG9yIGBudWxsYFxyXG4gICAgICogaWYgdGhlIEVOUyBuYW1lIGRvZXMgbm90IGhhdmUgYW4gdW5kZXJseWluZyBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBFTlMgYWRkcmVzcyBuYW1lIHRvIHJlc29sdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHJldmVyc2UgbG9va3VwIG9mIHRoZSBhZGRyZXNzIGluIEVOUyB1c2luZyB0aGUgUmV2ZXJzZSBSZWdpc3RyYXIuIElmIHRoZSBuYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgZm9yd2FyZCBsb29rdXAgZG9lcyBub3QgbWF0Y2gsIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQW4gRU5TIG5hbWUgcmVxdWlyZXMgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNldHVwIGEgcmV2ZXJzZSByZWNvcmQsIHNvIG5vdCBhbGwgRU5TIGFkZHJlc3NlcyB3aWxsIG1hcCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBFTlMgZG9tYWluLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGxvb2sgdXAgdGhlIEVOUyBkb21haW4gbmFtZSBmb3IuXHJcbiAgICAgKi9cclxuICAgIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIubG9va3VwQWRkcmVzcyhhZGRyZXNzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggYmV0d2VlbiBhbiBpbnRlZ2VyIHJhbmdlIG9mIGJsb2NrIG51bWJlcnMgdG8gZmluZCB0aGVcclxuICogYmxvY2sgbnVtYmVyIHdoZXJlIHRoZSBjb250cmFjdCB3YXMgZGVwbG95ZWQuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoRmlyc3RCbG9jayhzdGFydCwgZW5kLCBhZGRyZXNzLCBjb25maWcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHlpZWxkIHByb3ZpZGVyLmdldENvZGUoYWRkcmVzcywgbWlkKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gRVRIX05VTExfVkFMVUUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaEZpcnN0QmxvY2sobWlkICsgMSwgZW5kLCBhZGRyZXNzLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmluYXJ5U2VhcmNoRmlyc3RCbG9jayhzdGFydCwgbWlkLCBhZGRyZXNzLCBjb25maWcpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBEZWJ1ZyBuYW1lc3BhY2UgY29udGFpbnMgbWV0aG9kcyB0byBhY2Nlc3MgdGhlIG5vbi1zdGFuZGFyZCBSUEMgbWV0aG9kc1xyXG4gKiBmb3IgaW5zcGVjdGluZyBhbmQgZGVidWdnaW5nIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGRpZmZlcmVudCBtZXRob2RzIGFuZCB1c2UgY2FzZXMgcGxlYXNlIHJlYWQgb3VyXHJcbiAqIFtkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuYWxjaGVteS5jb20vcmVmZXJlbmNlL2RlYnVnLWFwaS1xdWlja3N0YXJ0KS5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgZGVidWcgbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS5kZWJ1Z2AuXHJcbiAqL1xyXG5jbGFzcyBEZWJ1Z05hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIHRyYWNlQ2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyLCB0cmFjZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW3RyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXIsIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2RlYnVnX3RyYWNlQ2FsbCcsIHBhcmFtcywgJ3RyYWNlQ2FsbCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJhY2VUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIHRyYWNlciwgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbdHJhbnNhY3Rpb25IYXNoLCBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIsIHRpbWVvdXQpXTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdkZWJ1Z190cmFjZVRyYW5zYWN0aW9uJywgcGFyYW1zLCAndHJhY2VUcmFuc2FjdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJhY2VCbG9jayhibG9ja0lkZW50aWZpZXIsIHRyYWNlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNIZXhTdHJpbmcoYmxvY2tJZGVudGlmaWVyLCAzMikpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdkZWJ1Z190cmFjZUJsb2NrQnlIYXNoJztcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtibG9ja0lkZW50aWZpZXIsIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ2RlYnVnX3RyYWNlQmxvY2tCeU51bWJlcic7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHR5cGVvZiBibG9ja0lkZW50aWZpZXIgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1dGlscy5oZXhTdHJpcFplcm9zKHV0aWxzLmhleFZhbHVlKGJsb2NrSWRlbnRpZmllcikpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBibG9ja0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbYmxvY2ssIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3RyYWNlQmxvY2snKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIsIHRpbWVvdXQpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHJhY2VyOiB0cmFjZXIudHlwZSB9LCAodHJhY2VyLm9ubHlUb3BDYWxsICE9PSB1bmRlZmluZWQgJiYge1xyXG4gICAgICAgIHRyYWNlckNvbmZpZzoge1xyXG4gICAgICAgICAgICBvbmx5VG9wQ2FsbDogdHJhY2VyLm9ubHlUb3BDYWxsLFxyXG4gICAgICAgICAgICB0aW1lb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSkpO1xyXG59XG5cbmZ1bmN0aW9uIHNhbml0aXplVG9rZW5UeXBlKHRva2VuVHlwZSkge1xyXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDMTE1NSB8fCB0b2tlblR5cGUgPT09IGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMSkge1xyXG4gICAgICAgIHJldHVybiB0b2tlblR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgU0RLIGhhcyA0IGxvZyBsZXZlbHMgYW5kIGEgNXRoIG9wdGlvbiBmb3IgZGlzYWJsaW5nIGFsbCBsb2dnaW5nLiBCeVxyXG4gKiBkZWZhdWx0LCB0aGUgbG9nIGxldmVsIGlzIHNldCB0byBJTkZPLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOiBERUJVRyA8IElORk8gPCBXQVJOIDwgRVJST1JcclxuICpcclxuICogQWxsIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBvdXRwdXR0ZWQuXHJcbiAqL1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAyXSA9IFwiV0FSTlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDNdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA0XSA9IFwiU0lMRU5UXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0ge1xyXG4gICAgZGVidWc6IExvZ0xldmVsLkRFQlVHLFxyXG4gICAgaW5mbzogTG9nTGV2ZWwuSU5GTyxcclxuICAgIHdhcm46IExvZ0xldmVsLldBUk4sXHJcbiAgICBlcnJvcjogTG9nTGV2ZWwuRVJST1IsXHJcbiAgICBzaWxlbnQ6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vLyBIQUNLWTogVXNlIHRoZSBjb25zb2xlIG1ldGhvZCBhcyBhIHN0cmluZyByYXRoZXIgdGhhbiB0aGUgZnVuY3Rpb24gaXRzZWxmXHJcbi8vIGluIG9yZGVyIHRvIGFsbG93IGZvciBtb2NraW5nIGluIHRlc3RzLlxyXG5jb25zdCBsb2dMZXZlbFRvQ29uc29sZUZuID0ge1xyXG4gICAgW0xvZ0xldmVsLkRFQlVHXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcclxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxyXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xyXG59O1xyXG5jb25zdCBERUZBVUxUX0xPR19MRVZFTCA9IExvZ0xldmVsLklORk87XHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIHRoZSB2ZXJib3NpdHkgb2YgbG9nZ2luZy4gVGhlIGRlZmF1bHQgbG9nIGxldmVsIGlzIGBpbmZvYC5cclxuICpcclxuICogQHBhcmFtIGxvZ0xldmVsIC0gVGhlIHZlcmJvc2l0eSBvZiBsb2dnaW5nLiBDYW4gYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAgIC0gYGRlYnVnYDogVGhlIG1vc3QgdmVyYm9zZSBsb2dnaW5nIGxldmVsLlxyXG4gKiAgIC0gYGluZm9gOiBUaGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLlxyXG4gKiAgIC0gYHdhcm5gOiBBIGxvZ2dpbmcgbGV2ZWwgZm9yIG5vbi1jcml0aWNhbCBpc3N1ZXMuXHJcbiAqICAgLSBgZXJyb3JgOiBBIGxvZ2dpbmcgbGV2ZWwgZm9yIGNyaXRpY2FsIGlzc3Vlcy5cclxuICogICAtIGBzaWxlbnRgOiBUdXJuIG9mZiBhbGwgbG9nZ2luZy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcclxuICAgIGxvZ2dlckNsaWVudC5sb2dMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtW2xvZ0xldmVsXTtcclxufVxyXG5mdW5jdGlvbiBsb2dEZWJ1ZyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBsb2dnZXJDbGllbnQuZGVidWcobWVzc2FnZSwgYXJncyk7XHJcbn1cclxuZnVuY3Rpb24gbG9nSW5mbyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBsb2dnZXJDbGllbnQuaW5mbyhtZXNzYWdlLCBhcmdzKTtcclxufVxyXG5mdW5jdGlvbiBsb2dXYXJuKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIGxvZ2dlckNsaWVudC53YXJuKG1lc3NhZ2UsIGFyZ3MpO1xyXG59XHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKiogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gREVGQVVMVF9MT0dfTEVWRUw7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbmZvKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlcnJvciguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yd2FyZHMgbG9nIG1lc3NhZ2VzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgaWYgdGhlXHJcbiAgICAgKiBsb2cgbGV2ZWwgYWxsb3dzIGl0LlxyXG4gICAgICovXHJcbiAgICBfbG9nKGxvZ0xldmVsLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGxvZ0xldmVsIDwgdGhpcy5fbG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbG9nTGV2ZWxUb0NvbnNvbGVGbltsb2dMZXZlbF07XHJcbiAgICAgICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dIEFsY2hlbXk6YCwgLi4uYXJncy5tYXAoc3RyaW5naWZ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvZ2dlciByZWNlaXZlZCBhbiBpbnZhbGlkIGxvZ0xldmVsICh2YWx1ZTogJHtsb2dMZXZlbH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGNvbnZlcnQgdG8gSlNPTiwgbG9nIHRoZSBvYmplY3QgZGlyZWN0bHkuXHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIEluc3RhbnRpYXRlIGRlZmF1bHQgbG9nZ2VyIGZvciB0aGUgU0RLLlxyXG5jb25zdCBsb2dnZXJDbGllbnQgPSBuZXcgTG9nZ2VyKCk7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIGJ5IGluamVjdFZlcnNpb24uanMuIEFueSBjaGFuZ2VzIHdpbGwgYmVcclxuLy8gb3ZlcndyaXR0ZW4gb24gY29tbWl0IVxyXG5jb25zdCBWRVJTSU9OID0gJzMuMy4xJztcblxuLyoqXHJcbiAqIEdpdmVuIGEgUkVTVCBlbmRwb2ludCwgbWV0aG9kLCBhbmQgcGFyYW1zLCBzZW5kcyB0aGUgcmVxdWVzdCB3aXRoIGF4aW9zIGFuZFxyXG4gKiByZXR1cm5zIHRoZSByZXNwb25zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VuZCBodHRwIHJlcXVlc3RzIHVzaW5nIEF4aXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kQXhpb3NSZXF1ZXN0KGJhc2VVcmwsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcmVxdWVzdFVybCA9IGJhc2VVcmwgKyAnLycgKyByZXN0QXBpTmFtZTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLmhlYWRlcnMpLCAoIUlTX0JST1dTRVIgJiYgeyAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnIH0pKSwgeyAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OLCAnQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCc6IG1ldGhvZE5hbWUgfSksIG1ldGhvZDogKF9hID0gb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0dFVCcsIHVybDogcmVxdWVzdFVybCwgcGFyYW1zIH0pO1xyXG4gICAgcmV0dXJuIGF4aW9zX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjb25maWcpO1xyXG59XG5cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX01VTFRJUExJRVIgPSAxLjU7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMgPSAzMCAqIDEwMDA7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMgPSA1O1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgZXhwb25lbnRpYWwgYmFja29mZiBhbmQgbWF4IHJldHJ5IGF0dGVtcHRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhBdHRlbXB0cyA9IERFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMpIHtcclxuICAgICAgICB0aGlzLm1heEF0dGVtcHRzID0gbWF4QXR0ZW1wdHM7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TO1xyXG4gICAgICAgIHRoaXMuYmFja29mZk11bHRpcGxpZXIgPSBERUZBVUxUX0JBQ0tPRkZfTVVMVElQTElFUjtcclxuICAgICAgICB0aGlzLm1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TO1xyXG4gICAgICAgIHRoaXMubnVtQXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlbGF5TXMgPSAwO1xyXG4gICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgdGhlIGJhY2tvZmYgZGVsYXkuIFRoZSBkZWxheSBpc1xyXG4gICAgICogaW5jcmVhc2VkIGZvciBlYWNoIGF0dGVtcHQuIFRoZSBwcm9taXNlIGlzIHJlamVjdGVkIGlmIHRoZSBtYXhpbXVtIG51bWJlclxyXG4gICAgICogb2YgYXR0ZW1wdHMgaXMgZXhjZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IGJlYXV0aWZ5IHRoaXMgaW50byBhbiBhc3luYyBpdGVyYXRvci5cclxuICAgIGJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubnVtQXR0ZW1wdHMgPj0gdGhpcy5tYXhBdHRlbXB0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBFeGNlZWRlZCBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0czogJHt0aGlzLm1heEF0dGVtcHRzfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbkJhY2tvZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQSBiYWNrb2ZmIG9wZXJhdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiYWNrb2ZmRGVsYXlXaXRoSml0dGVyTXMgPSB0aGlzLndpdGhKaXR0ZXJNcyh0aGlzLmN1cnJlbnREZWxheU1zKTtcclxuICAgICAgICBpZiAoYmFja29mZkRlbGF5V2l0aEppdHRlck1zID4gMCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnRXhwb25lbnRpYWxCYWNrb2ZmLmJhY2tvZmYnLCBgQmFja2luZyBvZmYgZm9yICR7YmFja29mZkRlbGF5V2l0aEppdHRlck1zfW1zYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV4dCBkZWxheS5cclxuICAgICAgICB0aGlzLmN1cnJlbnREZWxheU1zICo9IHRoaXMuYmFja29mZk11bHRpcGxpZXI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGVsYXlNcyA9IE1hdGgubWF4KHRoaXMuY3VycmVudERlbGF5TXMsIHRoaXMuaW5pdGlhbERlbGF5TXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlbGF5TXMgPSBNYXRoLm1pbih0aGlzLmN1cnJlbnREZWxheU1zLCB0aGlzLm1heERlbGF5TXMpO1xyXG4gICAgICAgIHRoaXMubnVtQXR0ZW1wdHMgKz0gMTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgYmFja29mZkRlbGF5V2l0aEppdHRlck1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyArLy0gNTAlIGppdHRlciB0byB0aGUgYmFja29mZiBkZWxheSwgdXAgdG8gdGhlIG1heCBkZWxheSBjYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkZWxheU1zXHJcbiAgICAgKi9cclxuICAgIHdpdGhKaXR0ZXJNcyhkZWxheU1zKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGRlbGF5TXMgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBkZWxheU1zLCB0aGlzLm1heERlbGF5TXMpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBBIHdyYXBwZXIgZnVuY3Rpb24gdG8gbWFrZSBodHRwIHJlcXVlc3RzIGFuZCByZXRyeSBpZiB0aGUgcmVxdWVzdCBmYWlscy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBUT0RPOiBXcmFwIEF4aW9zIGVycm9yIGluIEFsY2hlbXlFcnJvci5cclxuZnVuY3Rpb24gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIGFwaVR5cGUsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBsYXN0RXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYoY29uZmlnLm1heFJldHJpZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgY29uZmlnLm1heFJldHJpZXMgKyAxOyBhdHRlbXB0KyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0luZm8oJ3JlcXVlc3RIdHRwJywgYFJldHJ5aW5nIGFmdGVyIGVycm9yOiAke2xhc3RFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBiYWNrb2ZmLmJhY2tvZmYoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrb2ZmIGVycm9ycyB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyBpcyByZWFjaGVkLiBCcmVha1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dCBvZiB0aGUgbG9vcCB0byBwcmVzZXJ2ZSB0aGUgbGFzdCBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgc2VuZEF4aW9zUmVxdWVzdChjb25maWcuX2dldFJlcXVlc3RVcmwoYXBpVHlwZSksIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyB0aW1lb3V0OiBjb25maWcucmVxdWVzdFRpbWVvdXQgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcocmVzdEFwaU5hbWUsIGBTdWNjZXNzZnVsIHJlcXVlc3Q6ICR7cmVzdEFwaU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dJbmZvKHJlc3RBcGlOYW1lLCBgUmVxdWVzdCBmYWlsZWQ6ICR7cmVzdEFwaU5hbWV9LCAke3Jlc3BvbnNlLnN0YXR1c30sICR7cmVzcG9uc2UuZGF0YX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgJzogJyArIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXhpb3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmlzQXhpb3NFcnJvcihlcnIpIHx8IGVyci5yZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU3RhbmRhcmRpemUgYWxsIGVycm9ycyBpbnRvIEFsY2hlbXlFcnJvclxyXG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbmV3IEVycm9yKGVyci5yZXNwb25zZS5zdGF0dXMgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyLnJlc3BvbnNlLmRhdGEpKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGVIdHRwRXJyb3IoZXJyLCBhcGlUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsYXN0RXJyb3IpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZXRyeWFibGVIdHRwRXJyb3IoZXJyLCBhcGlUeXBlKSB7XHJcbiAgICAvLyBUT0RPOiByZW1vdmUgNTAwcyBhZnRlciB3ZWJob29rcyBhcmUgbW9yZSBzdGFibGUuXHJcbiAgICBjb25zdCByZXRyeWFibGVDb2RlcyA9IGFwaVR5cGUgPT09IEFsY2hlbXlBcGlUeXBlLldFQkhPT0sgPyBbNDI5LCA1MDBdIDogWzQyOV07XHJcbiAgICByZXR1cm4gKGVyci5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIHJldHJ5YWJsZUNvZGVzLmluY2x1ZGVzKGVyci5yZXNwb25zZS5zdGF0dXMpKTtcclxufVxyXG4vKipcclxuICogRmV0Y2hlcyBhbGwgcGFnZXMgaW4gYSBwYWdpbmF0ZWQgZW5kcG9pbnQsIGdpdmVuIGEgYHBhZ2VLZXlgIGZpZWxkIHRoYXRcclxuICogcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgbmFtZSBjb250YWluaW5nIHRoZSBuZXh0IHBhZ2UgdG9rZW4uXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcGFnaW5hdGVFbmRwb2ludChjb25maWcsIGFwaVR5cGUsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCByZXFQYWdlS2V5LCByZXNQYWdlS2V5LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHBhZ2luYXRlRW5kcG9pbnRfMSgpIHtcclxuICAgICAgICBsZXQgaGFzTmV4dCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XHJcbiAgICAgICAgd2hpbGUgKGhhc05leHQpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfX2F3YWl0KHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBhcGlUeXBlLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcmVxdWVzdFBhcmFtcykpO1xyXG4gICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlW3Jlc1BhZ2VLZXldICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zW3JlcVBhZ2VLZXldID0gcmVzcG9uc2VbcmVzUGFnZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYXNOZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9ucyBmb3IgZXhwb3NlZCBBUEkgc3VyZmFjZSBpblxyXG4gKiB0aGUge0BsaW5rIE5mdE5hbWVzcGFjZX0uIEJ5IG1vdmluZyB0aGUgbWV0aG9kcyBvdXQgaW50byBhIHNlcGFyYXRlIGZpbGUsXHJcbiAqIG90aGVyIG5hbWVzcGFjZXMgY2FuIGFjY2VzcyB0aGVzZSBtZXRob2RzIHdpdGhvdXQgZGVwZW5kaW5nIG9uIHRoZSBlbnRpcmVcclxuICogTmZ0TmFtZXNwYWNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdldCB0aGUgTkZUIG1ldGFkYXRhIGZvciB0aGUgcHJvdmlkZWQgY29udHJhY3QgYWRkcmVzcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5mdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0TmZ0TWV0YWRhdGEnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUTWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICB0b2tlbklkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgdG9rZW5UeXBlOiBzYW5pdGl6ZVRva2VuVHlwZShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5UeXBlKSxcclxuICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVXJpVGltZW91dEluTXMsXHJcbiAgICAgICAgICAgIHJlZnJlc2hDYWNoZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZnJlc2hDYWNoZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRGcm9tUmF3KHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdE1ldGFkYXRhQmF0Y2goY29uZmlnLCB0b2tlbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICByZWZyZXNoQ2FjaGU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWZyZXNoQ2FjaGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVE1ldGFkYXRhQmF0Y2gnLCAnZ2V0TmZ0TWV0YWRhdGFCYXRjaCcsIHt9LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBkYXRhXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmZ0czogcmVzcG9uc2UubmZ0cy5tYXAobmZ0ID0+IGdldE5mdEZyb21SYXcobmZ0KSlcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udHJhY3RNZXRhZGF0YShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ2dldENvbnRyYWN0TWV0YWRhdGEnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0Q29udHJhY3RNZXRhZGF0YScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRyYWN0TWV0YWRhdGFCYXRjaChjb25maWcsIGNvbnRyYWN0QWRkcmVzc2VzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoJywgJ2dldENvbnRyYWN0TWV0YWRhdGFCYXRjaCcsIHt9LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBkYXRhOiB7IGNvbnRyYWN0QWRkcmVzc2VzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250cmFjdHM6IHJlc3BvbnNlLmNvbnRyYWN0cy5tYXAoZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uTWV0YWRhdGEoY29uZmlnLCBjb2xsZWN0aW9uU2x1Zywgc3JjTWV0aG9kID0gJ2dldENvbGxlY3Rpb25NZXRhZGF0YScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRDb2xsZWN0aW9uTWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvblNsdWdcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0Q29sbGVjdGlvbkZyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0c0Zvck93bmVySXRlcmF0b3IoY29uZmlnLCBvd25lciwgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE5mdHNGb3JPd25lckl0ZXJhdG9yJykge1xyXG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogZ2V0TmZ0c0Zvck93bmVySXRlcmF0b3JfMSgpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICBjb25zdCB3aXRoTWV0YWRhdGEgPSBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub21pdE1ldGFkYXRhKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fYXN5bmNWYWx1ZXMocGFnaW5hdGVFbmRwb2ludChjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVHNGb3JPd25lcicsIHNyY01ldGhvZCwgJ3BhZ2VLZXknLCAncGFnZUtleScsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSxcclxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICBpbmNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgICAgICB3aXRoTWV0YWRhdGEsXHJcbiAgICAgICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5VcmlUaW1lb3V0SW5NcyxcclxuICAgICAgICAgICAgICAgIG9yZGVyQnk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcmRlckJ5XHJcbiAgICAgICAgICAgIH0pKSwgX2M7IF9jID0geWllbGQgX19hd2FpdChfYi5uZXh0KCkpLCAhX2MuZG9uZTspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG93bmVkTmZ0IG9mIHJlc3BvbnNlLm93bmVkTmZ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZnRGcm9tR2V0TmZ0UmVzcG9uc2Uob3duZWROZnQpKSwgeyBiYWxhbmNlOiBvd25lZE5mdC5iYWxhbmNlIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2EuY2FsbChfYikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRzRm9yT3duZXIoY29uZmlnLCBvd25lciwgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE5mdHNGb3JPd25lcicpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCB3aXRoTWV0YWRhdGEgPSBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub21pdE1ldGFkYXRhKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRzRm9yT3duZXInLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXksXHJcbiAgICAgICAgICAgIGV4Y2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgIGluY2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VTaXplLFxyXG4gICAgICAgICAgICB3aXRoTWV0YWRhdGEsXHJcbiAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3JkZXJCeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh3aXRoTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICAgICAgb3duZWROZnRzOiByZXNwb25zZS5vd25lZE5mdHMubWFwKHJlcyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXROZnRGcm9tUmF3KHJlcykpLCB7IGJhbGFuY2U6IHJlcy5iYWxhbmNlIH0pKSksXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5LFxyXG4gICAgICAgICAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UudG90YWxDb3VudCxcclxuICAgICAgICAgICAgICAgIHZhbGlkQXQ6IHJlc3BvbnNlLnZhbGlkQXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgb3duZWROZnRzOiByZXNwb25zZS5vd25lZE5mdHMubWFwKHJlcyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRCYXNlTmZ0RnJvbVJhdyhyZXMpKSwgeyBiYWxhbmNlOiByZXMuYmFsYW5jZSB9KSkpLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5LFxyXG4gICAgICAgICAgICB0b3RhbENvdW50OiByZXNwb25zZS50b3RhbENvdW50LFxyXG4gICAgICAgICAgICB2YWxpZEF0OiByZXNwb25zZS52YWxpZEF0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRzRm9yQ29udHJhY3QoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXROZnRzRm9yQ29udHJhY3QnKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aE1ldGFkYXRhID0gb21pdE1ldGFkYXRhVG9XaXRoTWV0YWRhdGEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9taXRNZXRhZGF0YSk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUc0ZvckNvbnRyYWN0Jywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXksXHJcbiAgICAgICAgICAgIHdpdGhNZXRhZGF0YSxcclxuICAgICAgICAgICAgbGltaXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5VcmlUaW1lb3V0SW5Nc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh3aXRoTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICAgICAgbmZ0czogcmVzcG9uc2UubmZ0cy5tYXAocmVzID0+IGdldE5mdEZyb21SYXcocmVzKSksXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgIG5mdHM6IHJlc3BvbnNlLm5mdHMubWFwKHJlcyA9PiBnZXRCYXNlTmZ0RnJvbVJhdyhyZXMsIGNvbnRyYWN0QWRkcmVzcykpLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcihjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE5mdHNGb3JDb250cmFjdEl0ZXJhdG9yJykge1xyXG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3JfMSgpIHtcclxuICAgICAgICB2YXIgZV8yLCBfYTtcclxuICAgICAgICBjb25zdCB3aXRoTWV0YWRhdGEgPSBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub21pdE1ldGFkYXRhKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fYXN5bmNWYWx1ZXMocGFnaW5hdGVFbmRwb2ludChjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVHNGb3JDb250cmFjdCcsIHNyY01ldGhvZCwgJ3BhZ2VLZXknLCAncGFnZUtleScsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5LFxyXG4gICAgICAgICAgICAgICAgd2l0aE1ldGFkYXRhXHJcbiAgICAgICAgICAgIH0pKSwgX2M7IF9jID0geWllbGQgX19hd2FpdChfYi5uZXh0KCkpLCAhX2MuZG9uZTspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5mdCBvZiByZXNwb25zZS5uZnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZnRGcm9tR2V0TmZ0Q29udHJhY3RSZXNwb25zZShuZnQsIGNvbnRyYWN0QWRkcmVzcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYS5jYWxsKF9iKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE93bmVyc0ZvckNvbnRyYWN0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0T3duZXJzRm9yQ29udHJhY3QnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgLy8gQ2FzdCB0byBgYW55YCB0byBhdm9pZCBtb3JlIHR5cGUgd3JhbmdsaW5nLlxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE93bmVyc0ZvckNvbnRyYWN0Jywgc3JjTWV0aG9kLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGNvbnRyYWN0QWRkcmVzcyB9KSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aXRoVG9rZW5CYWxhbmNlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgICAgICBvd25lcnM6IHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgLm93bmVycyxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgb3duZXJzOiByZXNwb25zZS5vd25lcnMsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRyYWN0c0Zvck93bmVyKGNvbmZpZywgb3duZXIsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXRDb250cmFjdHNGb3JPd25lcicpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRDb250cmFjdHNGb3JPd25lcicsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgZXhjbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5leGNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgaW5jbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXksXHJcbiAgICAgICAgICAgIHBhZ2VTaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZVNpemUsXHJcbiAgICAgICAgICAgIG9yZGVyQnk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcmRlckJ5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICBjb250cmFjdHM6IHJlc3BvbnNlLmNvbnRyYWN0cy5tYXAoZ2V0TmZ0Q29udHJhY3RzRm9yT3duZXJGcm9tUmF3KSxcclxuICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleSxcclxuICAgICAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UudG90YWxDb3VudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3duZXJzRm9yTmZ0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0T3duZXJzRm9yTmZ0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0T3duZXJzRm9yTkZUJywgc3JjTWV0aG9kLCBPYmplY3QuYXNzaWduKHsgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKSB9LCBvcHRpb25zKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRNaW50ZWROZnRzKGNvbmZpZywgb3duZXIsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLl9nZXRBZGRyZXNzKG93bmVyKTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IG5mdFRva2VuVHlwZVRvQ2F0ZWdvcnkob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVHlwZSk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBmcm9tQmxvY2s6ICcweDAnLFxyXG4gICAgICAgICAgICBmcm9tQWRkcmVzczogRVRIX05VTExfQUREUkVTUyxcclxuICAgICAgICAgICAgdG9BZGRyZXNzOiBvd25lckFkZHJlc3MsXHJcbiAgICAgICAgICAgIGV4Y2x1ZGVaZXJvVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIGNhdGVnb3J5LFxyXG4gICAgICAgICAgICBtYXhDb3VudDogMTAwLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBnZXRBc3NldFRyYW5zZmVycyhjb25maWcsIHBhcmFtcywgJ2dldE1pbnRlZE5mdHMnKTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0ZvclRyYW5zZmVycyhjb25maWcsIHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zZmVyc0Zvck93bmVyKGNvbmZpZywgb3duZXIsIHRyYW5zZmVyVHlwZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29uc3Qgb3duZXJBZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3Mob3duZXIpO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gbmZ0VG9rZW5UeXBlVG9DYXRlZ29yeShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5UeXBlKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jazogJzB4MCcsXHJcbiAgICAgICAgICAgIGV4Y2x1ZGVaZXJvVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIGNhdGVnb3J5LFxyXG4gICAgICAgICAgICBtYXhDb3VudDogMTAwLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRyYW5zZmVyVHlwZSA9PT0gZXhwb3J0cy5HZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZS5UTykge1xyXG4gICAgICAgICAgICBwYXJhbXMudG9BZGRyZXNzID0gb3duZXJBZGRyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLmZyb21BZGRyZXNzID0gb3duZXJBZGRyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFuc2ZlcnNSZXNwb25zZSA9IHlpZWxkIGdldEFzc2V0VHJhbnNmZXJzKGNvbmZpZywgcGFyYW1zLCAnZ2V0VHJhbnNmZXJzRm9yT3duZXInKTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0ZvclRyYW5zZmVycyhjb25maWcsIHRyYW5zZmVyc1Jlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zZmVyc0ZvckNvbnRyYWN0KGNvbmZpZywgY29udHJhY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IFtcclxuICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzcyMSxcclxuICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzExNTUsXHJcbiAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5TUEVDSUFMTkZUXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGZyb21CbG9jayA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZnJvbUJsb2NrKVxyXG4gICAgICAgICAgICA/IHByb3ZpZGVyLmZvcm1hdHRlci5ibG9ja1RhZyh5aWVsZCBwcm92aWRlci5fZ2V0QmxvY2tUYWcob3B0aW9ucy5mcm9tQmxvY2spKVxyXG4gICAgICAgICAgICA6ICcweDAnO1xyXG4gICAgICAgIGNvbnN0IHRvQmxvY2sgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvQmxvY2spXHJcbiAgICAgICAgICAgID8gcHJvdmlkZXIuZm9ybWF0dGVyLmJsb2NrVGFnKHlpZWxkIHByb3ZpZGVyLl9nZXRCbG9ja1RhZyhvcHRpb25zLnRvQmxvY2spKVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jayxcclxuICAgICAgICAgICAgdG9CbG9jayxcclxuICAgICAgICAgICAgZXhjbHVkZVplcm9WYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IFtjb250cmFjdF0sXHJcbiAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3JkZXIsXHJcbiAgICAgICAgICAgIGNhdGVnb3J5LFxyXG4gICAgICAgICAgICBtYXhDb3VudDogMTAwLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJzUmVzcG9uc2UgPSB5aWVsZCBnZXRBc3NldFRyYW5zZmVycyhjb25maWcsIHBhcmFtcywgJ2dldFRyYW5zZmVyc0ZvckNvbnRyYWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JUcmFuc2ZlcnMoY29uZmlnLCB0cmFuc2ZlcnNSZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBuZnRUb2tlblR5cGVUb0NhdGVnb3J5KHRva2VuVHlwZSkge1xyXG4gICAgc3dpdGNoICh0b2tlblR5cGUpIHtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMTpcclxuICAgICAgICAgICAgcmV0dXJuIFtleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDNzIxXTtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzExNTU6XHJcbiAgICAgICAgICAgIHJldHVybiBbZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzExNTVdO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDNzIxLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzExNTUsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuU1BFQ0lBTE5GVFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlMTE1NVRyYW5zZmVyKHRyYW5zZmVyKSB7XHJcbiAgICByZXR1cm4gdHJhbnNmZXIuZXJjMTE1NU1ldGFkYXRhLm1hcChtZXRhZGF0YSA9PiAoe1xyXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHJhbnNmZXIucmF3Q29udHJhY3QuYWRkcmVzcyxcclxuICAgICAgICB0b2tlbklkOiBtZXRhZGF0YS50b2tlbklkLFxyXG4gICAgICAgIHRva2VuVHlwZTogZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDMTE1NVxyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeU5mdE93bmVyc2hpcChjb25maWcsIG93bmVyLCBjb250cmFjdEFkZHJlc3Nlcywgc3JjTWV0aG9kID0gJ3ZlcmlmeU5mdE93bmVyc2hpcCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRyYWN0QWRkcmVzc2VzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGdldE5mdHNGb3JPd25lcihjb25maWcsIG93bmVyLCB7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3NlczogW2NvbnRyYWN0QWRkcmVzc2VzXSxcclxuICAgICAgICAgICAgICAgIG9taXRNZXRhZGF0YTogdHJ1ZVxyXG4gICAgICAgICAgICB9LCBzcmNNZXRob2QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub3duZWROZnRzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY29udHJhY3RBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgY29udHJhY3QgYWRkcmVzcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZ2V0TmZ0c0Zvck93bmVyKGNvbmZpZywgb3duZXIsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgICAgICAgICAgb21pdE1ldGFkYXRhOiB0cnVlXHJcbiAgICAgICAgICAgIH0sIHNyY01ldGhvZCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBtYXAgd2hlcmUgYWxsIGlucHV0IGNvbnRyYWN0IGFkZHJlc3NlcyBhcmUgc2V0IHRvIGZhbHNlLCB0aGVuIGZsaXBcclxuICAgICAgICAgICAgLy8gb3duZWQgbmZ0cyB0byB0cnVlLlxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb250cmFjdEFkZHJlc3Nlcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWNjW2N1cnJdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmZ0IG9mIHJlc3BvbnNlLm93bmVkTmZ0cykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W25mdC5jb250cmFjdEFkZHJlc3NdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3BhbUNvbnRyYWN0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAnaXNTcGFtQ29udHJhY3QnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdpc1NwYW1Db250cmFjdCcsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNwYW1Db250cmFjdHMoY29uZmlnLCBzcmNNZXRob2QgPSAnZ2V0U3BhbUNvbnRyYWN0cycpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldFNwYW1Db250cmFjdHMnLCBzcmNNZXRob2QsIHVuZGVmaW5lZCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvcnRTcGFtKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAncmVwb3J0U3BhbScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2b2lkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdyZXBvcnRTcGFtJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNBaXJkcm9wTmZ0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBzcmNNZXRob2QgPSAnaXNBaXJkcm9wTmZ0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnaXNBaXJkcm9wTkZUJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5JZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rmxvb3JQcmljZShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ2dldEZsb29yUHJpY2UnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0Rmxvb3JQcmljZScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRTYWxlcyhjb25maWcsIG9wdGlvbnMgPSB7fSwgc3JjTWV0aG9kID0gJ2dldE5mdFNhbGVzJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIEF2b2lkIHRzIGNvbXBpbGVyIGNvbXBsYWluaW5nIGFib3V0IHRoZSBjb250cmFjdEFkZHJlc3MgZmllbGQuXHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUU2FsZXMnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgZnJvbUJsb2NrOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZnJvbUJsb2NrLFxyXG4gICAgICAgICAgICB0b0Jsb2NrOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMudG9CbG9jayxcclxuICAgICAgICAgICAgb3JkZXI6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5vcmRlcixcclxuICAgICAgICAgICAgbWFya2V0cGxhY2U6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5tYXJrZXRwbGFjZSxcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICB0b2tlbklkOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRva2VuSWQpXHJcbiAgICAgICAgICAgICAgICA/IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMudG9rZW5JZCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNlbGxlckFkZHJlc3M6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5zZWxsZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBidXllckFkZHJlc3M6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5idXllckFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRha2VyOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMudGFrZXIsXHJcbiAgICAgICAgICAgIGxpbWl0OiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubGltaXQsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYWdlS2V5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdFNhbGVzRnJvbVJhdyhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlUmFyaXR5KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBzcmNNZXRob2QgPSAnY29tcHV0ZVJhcml0eScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdjb21wdXRlUmFyaXR5Jywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5JZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRva2VuSWQpLnRvU3RyaW5nKClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZWFyY2hDb250cmFjdE1ldGFkYXRhKGNvbmZpZywgcXVlcnksIHNyY01ldGhvZCA9ICdzZWFyY2hDb250cmFjdE1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ3NlYXJjaENvbnRyYWN0TWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250cmFjdHM6IHJlc3BvbnNlLmNvbnRyYWN0cy5tYXAoZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzdW1tYXJpemVOZnRBdHRyaWJ1dGVzKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAnc3VtbWFyaXplTmZ0QXR0cmlidXRlcycpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ3N1bW1hcml6ZU5GVEF0dHJpYnV0ZXMnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWZyZXNoTmZ0TWV0YWRhdGEoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIHNyY01ldGhvZCA9ICdyZWZyZXNoTmZ0TWV0YWRhdGEnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW5JZFN0cmluZyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0geWllbGQgZ2V0TmZ0TWV0YWRhdGEoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWRTdHJpbmcsIHVuZGVmaW5lZCwgc3JjTWV0aG9kKTtcclxuICAgICAgICBjb25zdCBzZWNvbmQgPSB5aWVsZCByZWZyZXNoKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkU3RyaW5nLCBzcmNNZXRob2QpO1xyXG4gICAgICAgIHJldHVybiBmaXJzdC50aW1lTGFzdFVwZGF0ZWQgIT09IHNlY29uZC50aW1lTGFzdFVwZGF0ZWQ7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWZyZXNoQ29udHJhY3QoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHNyY01ldGhvZCA9ICdyZWZyZXNoQ29udHJhY3QnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAncmVpbmdlc3RDb250cmFjdCcsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHJlc3BvbnNlLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgcmVmcmVzaFN0YXRlOiBwYXJzZVJlaW5nZXN0aW9uU3RhdGUocmVzcG9uc2UucmVpbmdlc3Rpb25TdGF0ZSksXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiByZXNwb25zZS5wcm9ncmVzc1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWZyZXNoKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBzcmNNZXRob2QpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRNZXRhZGF0YScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRva2VuSWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICByZWZyZXNoQ2FjaGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0RnJvbVJhdyhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0byBjb252ZXJ0IGEgTkZUIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gQWxjaGVteSBiYWNrZW5kIHRvIGFuXHJcbiAqIFNESyBORlQgdHlwZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBuZnRGcm9tR2V0TmZ0UmVzcG9uc2Uob3duZWROZnQpIHtcclxuICAgIGlmIChpc05mdFdpdGhNZXRhZGF0YShvd25lZE5mdCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0RnJvbVJhdyhvd25lZE5mdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0QmFzZU5mdEZyb21SYXcob3duZWROZnQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGNvbnZlcnQgYSBORlQgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBBbGNoZW15IGJhY2tlbmQgdG8gYW5cclxuICogU0RLIE5GVCB0eXBlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIG5mdEZyb21HZXROZnRDb250cmFjdFJlc3BvbnNlKG93bmVkTmZ0LCBjb250cmFjdEFkZHJlc3MpIHtcclxuICAgIGlmIChpc05mdFdpdGhNZXRhZGF0YShvd25lZE5mdCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0RnJvbVJhdyhvd25lZE5mdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0QmFzZU5mdEZyb21SYXcob3duZWROZnQsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG4vLyBUT0RPOiBtb3JlIGNvbXByZWhlbnNpdmUgdHlwZSBjaGVja1xyXG5mdW5jdGlvbiBpc05mdFdpdGhNZXRhZGF0YShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLm5hbWUgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogR2l2ZW4gYW4gQXNzZXRUcmFuc2ZlcnNSZXNwb25zZSwgZmV0Y2hlcyB0aGUgTkZUcyBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAqIHRyYW5zZmVycyBhbmQgY29sbGF0ZXMgdGhlbSB3aXRoIHRyYW5zZmVyIG1ldGFkYXRhLlxyXG4gKlxyXG4gKiBWSVNJQkxFIEZPUiBURVNUSU5HXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROZnRzRm9yVHJhbnNmZXJzKGNvbmZpZywgcmVzcG9uc2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YVRyYW5zZmVycyA9IHJlc3BvbnNlLnRyYW5zZmVyc1xyXG4gICAgICAgICAgICAuZmlsdGVyKHRyYW5zZmVyID0+IHRyYW5zZmVyLnJhd0NvbnRyYWN0LmFkZHJlc3MgIT09IG51bGwpXHJcbiAgICAgICAgICAgIC8vIFVzZSBmbGF0TWFwIHRvIGZsYXR0ZW4gMTE1NSB0cmFuc2ZlcnMgdGhhdCBjb250YWluIG11bHRpcGxlIE5GVHMuXHJcbiAgICAgICAgICAgIC5mbGF0TWFwKHRyYW5zZmVyID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlbnNGcm9tVHJhbnNmZXIodHJhbnNmZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGZyb206IHRyYW5zZmVyLmZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogKF9hID0gdHJhbnNmZXIudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHJhbnNmZXIuaGFzaCxcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0cmFuc2Zlci5ibG9ja051bVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCh0b2tlbiA9PiAoeyBtZXRhZGF0YSwgdG9rZW4gfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YVRyYW5zZmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbmZ0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gMTAwIGVsZW1lbnRzIGFmdGVyIHVucm9sbGluZyAxMTU1IHRyYW5zZmVycywgc3BsaXRcclxuICAgICAgICAvLyB0cmFuc2ZlcnMgaW50byBiYXRjaGVzIG9mIDEwMCB0byBzdGF5IHVuZGVyIGVuZHBvaW50IGJhdGNoIHNpemUgbGltaXQuXHJcbiAgICAgICAgY29uc3QgYmF0Y2hTaXplID0gMTAwO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCYXRjaGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhZGF0YVRyYW5zZmVycy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RCYXRjaGVzLnB1c2gobWV0YWRhdGFUcmFuc2ZlcnMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNwb25zZUJhdGNoZXMgPSB5aWVsZCBQcm9taXNlLmFsbChyZXF1ZXN0QmF0Y2hlcy5tYXAoYmF0Y2ggPT4gZ2V0TmZ0TWV0YWRhdGFCYXRjaChjb25maWcsIGJhdGNoLm1hcCh0cmFuc2ZlciA9PiB0cmFuc2Zlci50b2tlbikpKSk7XHJcbiAgICAgICAgY29uc3QgbmZ0cyA9IHJlc3BvbnNlQmF0Y2hlcy5tYXAociA9PiByLm5mdHMpLmZsYXQoKTtcclxuICAgICAgICAvLyBUaGUgc2FtZSBORlQgY2FuIGJlIHRyYW5zZmVycmVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRyYW5zZmVycyByZXNwb25zZS5cclxuICAgICAgICAvLyBXZSB3YW50IHRvIHJldHVybiBvbmUgTkZUIGZvciBlYWNoIHRyYW5zZmVyLCBzbyB3ZSBjcmVhdGUgYSBtYXBwaW5nIGZvclxyXG4gICAgICAgIC8vIGVhY2ggTkZUIHRvIHBhaXIgd2l0aCB0aGUgdHJhbnNmZXIgbWV0YWRhdGEuXHJcbiAgICAgICAgY29uc3QgbmZ0c0J5VG9rZW5JZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBuZnRzLmZvckVhY2gobmZ0ID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7bmZ0LmNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKX0tJHtiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20obmZ0LnRva2VuSWQpLnRvU3RyaW5nKCl9YDtcclxuICAgICAgICAgICAgbmZ0c0J5VG9rZW5JZC5zZXQoa2V5LCBuZnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVycmVkTmZ0cyA9IG1ldGFkYXRhVHJhbnNmZXJzLm1hcCh0ID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7dC50b2tlbi5jb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKX0tJHtiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odC50b2tlbi50b2tlbklkKS50b1N0cmluZygpfWA7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5mdHNCeVRva2VuSWQuZ2V0KGtleSkpLCB0Lm1ldGFkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZnRzOiB0cmFuc2ZlcnJlZE5mdHMsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgTkZUIHRva2VucyBmcm9tIGEgdHJhbnNmZXIgYXMgdGhlIHBhcmFtcyBmb3IgYVxyXG4gKiBgZ2V0TmZ0TWV0YWRhdGFCYXRjaGAgY2FsbC4gSGFuZGxlcyB0aGUgMTE1NSBjYXNlIHdoZXJlIG11bHRpcGxlIE5GVHMgY2FuIGJlXHJcbiAqIHRyYW5zZmVycmVkIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VG9rZW5zRnJvbVRyYW5zZmVyKHRyYW5zZmVyKSB7XHJcbiAgICAvLyBFUkMxMTU1IE5GVHMgY2FuIGNvbnRhaW4gbXVsdGlwbGUgdG9rZW5zIGluIGEgc2luZ2xlIHRyYW5zZmVyLCB3aGljaFxyXG4gICAgLy8gcmVxdWlyZXMgc3BlY2lhbCBsb2dpYy5cclxuICAgIGlmICh0cmFuc2Zlci5jYXRlZ29yeSA9PT0gZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzExNTUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2UxMTU1VHJhbnNmZXIodHJhbnNmZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0cmFuc2Zlci5yYXdDb250cmFjdC5hZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5JZDogdHJhbnNmZXIudG9rZW5JZCxcclxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogdHJhbnNmZXIuY2F0ZWdvcnkgPT09IGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkM3MjFcclxuICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBGbGlwcyB0aGUgYG9taXRNZXRhZGF0YWAgU0RLIHBhcmFtZXRlciB0eXBlIHRvIHRoZSBgd2l0aE1ldGFkYXRhYCBwYXJhbWV0ZXJcclxuICogcmVxdWlyZWQgYnkgdGhlIEFsY2hlbXkgQVBJLiBJZiBgb21pdE1ldGFkYXRhYCBpcyB1bmRlZmluZWQsIHRoZSBTREsgZGVmYXVsdHNcclxuICogdG8gaW5jbHVkaW5nIG1ldGFkYXRhLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIG9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhKG9taXRNZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIG9taXRNZXRhZGF0YSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICFvbWl0TWV0YWRhdGE7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSZWluZ2VzdGlvblN0YXRlKHJlaW5nZXN0aW9uU3RhdGUpIHtcclxuICAgIHN3aXRjaCAocmVpbmdlc3Rpb25TdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgJ2RvZXNfbm90X2V4aXN0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlLkRPRVNfTk9UX0VYSVNUO1xyXG4gICAgICAgIGNhc2UgJ2FscmVhZHlfcXVldWVkJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlLkFMUkVBRFlfUVVFVUVEO1xyXG4gICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlLklOX1BST0dSRVNTO1xyXG4gICAgICAgIGNhc2UgJ2ZpbmlzaGVkJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlLkZJTklTSEVEO1xyXG4gICAgICAgIGNhc2UgJ3F1ZXVlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5RVUVVRUQ7XHJcbiAgICAgICAgY2FzZSAncXVldWVfZmFpbGVkJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlLlFVRVVFX0ZBSUxFRDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcmVpbmdlc3Rpb24gc3RhdGU6ICcgKyByZWluZ2VzdGlvblN0YXRlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogVGhlIE5GVCBuYW1lc3BhY2UgY29udGFpbnMgYWxsIHRoZSBmdW5jdGlvbmFsaXR5IHJlbGF0ZWQgdG8gTkZUcy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgY29yZSBuYW1lc3BhY2VcclxuICogdmlhIGBhbGNoZW15Lm5mdGAuXHJcbiAqL1xyXG5jbGFzcyBOZnROYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICBnZXROZnRNZXRhZGF0YShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnNPclRva2VuVHlwZSwgdG9rZW5VcmlUaW1lb3V0SW5Ncykge1xyXG4gICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yVG9rZW5UeXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBvcHRpb25zT3JUb2tlblR5cGUudG9rZW5UeXBlLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9uc09yVG9rZW5UeXBlLnRva2VuVXJpVGltZW91dEluTXMsXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoQ2FjaGU6IG9wdGlvbnNPclRva2VuVHlwZS5yZWZyZXNoQ2FjaGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IG9wdGlvbnNPclRva2VuVHlwZSxcclxuICAgICAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdE1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBORlQgbWV0YWRhdGEgZm9yIG11bHRpcGxlIE5GVCB0b2tlbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRva2VucyBBbiBhcnJheSBvZiBORlQgdG9rZW5zIHRvIGZldGNoIG1ldGFkYXRhIGZvci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgbWFraW5nIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXROZnRNZXRhZGF0YUJhdGNoKHRva2Vucywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRNZXRhZGF0YUJhdGNoKHRoaXMuY29uZmlnLCB0b2tlbnMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIE5GVCBjb250cmFjdCBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBORlQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldENvbnRyYWN0TWV0YWRhdGEoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgTkZUIGNvbnRyYWN0IG1ldGFkYXRhIGZvciBtdWx0aXBsZSBORlQgY29udHJhY3RzIGluIGEgc2luZ2xlIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzc2VzIC0gQW4gYXJyYXkgb2YgY29udHJhY3QgYWRkcmVzc2VzIHRvIGZldGNoIG1ldGFkYXRhIGZvci5cclxuICAgICAqL1xyXG4gICAgZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoKGNvbnRyYWN0QWRkcmVzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0TWV0YWRhdGFCYXRjaCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIE5GVCBjb2xsZWN0aW9uIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblNsdWcgLSBUaGUgT3BlblNlYSBjb2xsZWN0aW9uIHNsdWcgb2YgdGhlIE5GVC5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIGdldENvbGxlY3Rpb25NZXRhZGF0YShjb2xsZWN0aW9uU2x1Zykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb2xsZWN0aW9uTWV0YWRhdGEodGhpcy5jb25maWcsIGNvbGxlY3Rpb25TbHVnKTtcclxuICAgIH1cclxuICAgIGdldE5mdHNGb3JPd25lckl0ZXJhdG9yKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JPd25lckl0ZXJhdG9yKHRoaXMuY29uZmlnLCBvd25lciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yT3duZXIob3duZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0Zvck93bmVyKHRoaXMuY29uZmlnLCBvd25lciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JDb250cmFjdCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGdldE5mdHNGb3JDb250cmFjdEl0ZXJhdG9yKGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcih0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGdldE93bmVyc0ZvckNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXRPd25lcnNGb3JDb250cmFjdCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgdGhlIG93bmVycyBmb3IgYSBnaXZlbiBORlQgY29udHJhY3QgYWRkcmVzcyBhbmQgdG9rZW4gSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBORlQgY29udHJhY3QgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgZ2V0T3duZXJzRm9yTmZ0KGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXRPd25lcnNGb3JOZnQodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIE5GVCBjb250cmFjdHMgaGVsZCBieSB0aGUgc3BlY2lmaWVkIG93bmVyIGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG93bmVyIC0gQWRkcmVzcyBmb3IgTkZUIG93bmVyIChjYW4gYmUgaW4gRU5TIGZvcm1hdCEpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPKHYzKTogQWRkIG92ZXJsb2FkIGZvciB3aXRoTWV0YWRhdGE9ZmFsc2VcclxuICAgIGdldENvbnRyYWN0c0Zvck93bmVyKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0c0Zvck93bmVyKHRoaXMuY29uZmlnLCBvd25lciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIE5GVCB0cmFuc2ZlcnMgZm9yIGEgZ2l2ZW4gb3duZXIncyBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgdG8gZ2V0IHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcnkgV2hldGhlciB0byBnZXQgdHJhbnNmZXJzIHRvIG9yIGZyb20gdGhlIG93bmVyIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2ZlcnNGb3JPd25lcihvd25lciwgY2F0ZWdvcnksIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0VHJhbnNmZXJzRm9yT3duZXIodGhpcy5jb25maWcsIG93bmVyLCBjYXRlZ29yeSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIE5GVCB0cmFuc2ZlcnMgZm9yIGEgZ2l2ZW4gTkZUIGNvbnRyYWN0IGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdHMgdG8gYWxsIHRyYW5zZmVycyBmb3IgdGhlIGNvbnRyYWN0LiBUbyBnZXQgdHJhbnNmZXJzIGZvciBhIHNwZWNpZmljXHJcbiAgICAgKiBibG9jayByYW5nZSwgdXNlIHtAbGluayBHZXRUcmFuc2ZlcnNGb3JDb250cmFjdE9wdGlvbnN9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdCBUaGUgTkZUIGNvbnRyYWN0IHRvIGdldCB0cmFuc2ZlcnMgZm9yLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNmZXJzRm9yQ29udHJhY3QoY29udHJhY3QsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0VHJhbnNmZXJzRm9yQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0LCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCB0aGUgTkZUcyBtaW50ZWQgYnkgYSBzcGVjaWZpZWQgb3duZXIgYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3duZXIgLSBBZGRyZXNzIGZvciB0aGUgTkZUIG93bmVyIChjYW4gYmUgaW4gRU5TIGZvcm1hdCkuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGdldE1pbnRlZE5mdHMob3duZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRNaW50ZWROZnRzKHRoaXMuY29uZmlnLCBvd25lciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlOZnRPd25lcnNoaXAob3duZXIsIGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiB2ZXJpZnlOZnRPd25lcnNoaXAodGhpcy5jb25maWcsIG93bmVyLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjb250cmFjdCBpcyBtYXJrZWQgYXMgc3BhbSBvciBub3QgYnkgQWxjaGVteS4gRm9yIG1vcmVcclxuICAgICAqIGluZm9ybWF0aW9uIG9uIGhvdyB3ZSBjbGFzc2lmeSBzcGFtLCBnbyB0byBvdXIgTkZUIEFQSSBGQVEgYXRcclxuICAgICAqIGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2VuaGFuY2VkLWFwaXMvbmZ0LWFwaS9uZnQtYXBpLWZhcSNuZnQtc3BhbS1jbGFzc2lmaWNhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gY2hlY2suXHJcbiAgICAgKi9cclxuICAgIGlzU3BhbUNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBpc1NwYW1Db250cmFjdCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHNwYW0gY29udHJhY3RzIG1hcmtlZCBieSBBbGNoZW15LiBGb3IgZGV0YWlscyBvbiBob3dcclxuICAgICAqIEFsY2hlbXkgbWFya3Mgc3BhbSBjb250cmFjdHMsIGdvIHRvXHJcbiAgICAgKiBodHRwczovL2RvY3MuYWxjaGVteS5jb20vYWxjaGVteS9lbmhhbmNlZC1hcGlzL25mdC1hcGkvbmZ0LWFwaS1mYXEjbmZ0LXNwYW0tY2xhc3NpZmljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldFNwYW1Db250cmFjdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNwYW1Db250cmFjdHModGhpcy5jb25maWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjb250cmFjdCBpcyBtYXJrZWQgYXMgc3BhbSBvciBub3QgYnkgQWxjaGVteS4gRm9yIG1vcmVcclxuICAgICAqIGluZm9ybWF0aW9uIG9uIGhvdyB3ZSBjbGFzc2lmeSBzcGFtLCBnbyB0byBvdXIgTkZUIEFQSSBGQVEgYXRcclxuICAgICAqIGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2VuaGFuY2VkLWFwaXMvbmZ0LWFwaS9uZnQtYXBpLWZhcSNuZnQtc3BhbS1jbGFzc2lmaWNhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gY2hlY2suXHJcbiAgICAgKi9cclxuICAgIHJlcG9ydFNwYW0oY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcG9ydFNwYW0odGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhIHRva2VuIGlzIG1hcmtlZCBhcyBhbiBhaXJkcm9wIG9yIG5vdC5cclxuICAgICAqIEFpcmRyb3BzIGFyZSBkZWZpbmVkIGFzIE5GVHMgdGhhdCB3ZXJlIG1pbnRlZCB0byBhIHVzZXIgYWRkcmVzcyBpbiBhIHRyYW5zYWN0aW9uXHJcbiAgICAgKiBzZW50IGJ5IGEgZGlmZmVyZW50IGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZCBvZiB0aGUgTkZULlxyXG4gICAgICovXHJcbiAgICBpc0FpcmRyb3BOZnQoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQWlyZHJvcE5mdCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmxvb3IgcHJpY2VzIG9mIGEgTkZUIGNvbnRyYWN0IGJ5IG1hcmtldHBsYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIE5GVCBjb2xsZWN0aW9uLlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgZ2V0Rmxvb3JQcmljZShjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Rmxvb3JQcmljZSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIGdldE5mdFNhbGVzKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0U2FsZXModGhpcy5jb25maWcsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHJhcml0eSBvZiBlYWNoIGF0dHJpYnV0ZSBvZiBhbiBORlQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqL1xyXG4gICAgY29tcHV0ZVJhcml0eShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVJhcml0eSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoIGZvciBhIGtleXdvcmQgYWNyb3NzIG1ldGFkYXRhIG9mIGFsbCBFUkMtNzIxIGFuZCBFUkMtMTE1NSBzbWFydCBjb250cmFjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHNlYXJjaCBzdHJpbmcgdGhhdCB5b3Ugd2FudCB0byBzZWFyY2ggZm9yIGluIGNvbnRyYWN0IG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICBzZWFyY2hDb250cmFjdE1ldGFkYXRhKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb25maWcsIHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgc3VtbWFyeSBvZiBhdHRyaWJ1dGUgcHJldmFsZW5jZSBmb3IgYW4gTkZUIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3VtbWFyaXplTmZ0QXR0cmlidXRlcyhjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gc3VtbWFyaXplTmZ0QXR0cmlidXRlcyh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBjYWNoZWQgbWV0YWRhdGEgZm9yIGEgcHJvdmlkZWQgTkZUIGNvbnRyYWN0IGFkZHJlc3MgYW5kIHRva2VuXHJcbiAgICAgKiBpZC4gUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBtZXRhZGF0YSB3YXMgcmVmcmVzaGVkLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHJlZnJlc2ggdGhlIG1ldGFkYXRhIGZvciBhIE5GVCB0aGF0XHJcbiAgICAgKiBoYXMgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGZldGNoZWQuIE5vdGUgdGhhdCB0aGUgYmFja2VuZFxyXG4gICAgICogb25seSBhbGxvd3Mgb25lIHJlZnJlc2ggcGVyIHRva2VuIGV2ZXJ5IDE1IG1pbnV0ZXMsIGdsb2JhbGx5IGZvciBhbGwgdXNlcnMuXHJcbiAgICAgKiBUaGUgbGFzdCByZWZyZXNoIHRpbWUgZm9yIGFuIE5GVCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlXHJcbiAgICAgKiB7QGxpbmsgTmZ0LnRpbWVMYXN0VXBkYXRlZH0gZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogVG8gdHJpZ2dlciBhIHJlZnJlc2ggZm9yIGFsbCBORlRzIGluIGEgY29udHJhY3QsIHVzZSB7QGxpbmsgcmVmcmVzaENvbnRyYWN0fSBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZULlxyXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaE5mdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xyXG4gICAgICAgIHJldHVybiByZWZyZXNoTmZ0TWV0YWRhdGEodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGEgbWV0YWRhdGEgcmVmcmVzaCBhbGwgTkZUcyBpbiB0aGUgcHJvdmlkZWQgY29udHJhY3QgYWRkcmVzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIHVzZWZ1bCBhZnRlciBhbiBORlQgY29sbGVjdGlvbiBpcyByZXZlYWxlZC5cclxuICAgICAqXHJcbiAgICAgKiBSZWZyZXNoZXMgYXJlIHF1ZXVlZCBvbiB0aGUgQWxjaGVteSBiYWNrZW5kIGFuZCBtYXkgdGFrZSB0aW1lIHRvIGZ1bGx5XHJcbiAgICAgKiBwcm9jZXNzLiBUbyByZWZyZXNoIHRoZSBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB0b2tlbiwgdXNlIHRoZVxyXG4gICAgICoge0BsaW5rIHJlZnJlc2hOZnRNZXRhZGF0YX0gbWV0aG9kIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hDb250cmFjdChjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gcmVmcmVzaENvbnRyYWN0KHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgTm90aWZ5IG5hbWVzcGFjZSBjb250YWlucyBtZXRob2RzIHVzZWQgZm9yIGNyZWF0aW5nLCByZWFkaW5nLCB1cGRhdGluZyxcclxuICogYW5kIGRlbGV0aW5nIHdlYmhvb2tzIGluIHRoZSBOb3RpZnkgQVBJLlxyXG4gKlxyXG4gKiBUbyB1c2UgdGhlIG1ldGhvZHMgaW4gdGhlIEFQSSwgeW91IG11c3QgcHJvdmlkZSB5b3VyIHRlYW0ncyBhdXRoIHRva2VuIGluIHRoZVxyXG4gKiB7QGxpbmsgQWxjaGVteVNldHRpbmdzLmF1dGhUb2tlbn0gZmllbGQgd2hlbiBjb25maWd1cmluZ1xyXG4gKiB7QGxpbmsgQWxjaGVteVNldHRpbmdzfS4gVGhlIGF1dGggdG9rZW4gY2FuIGJlIGZvdW5kIGluIHRoZSBBbGNoZW15IERhc2hib2FyZFxyXG4gKiBvbiB0aGUgTm90aWZ5IHRhYi5cclxuICpcclxuICogTm90ZSB0aGF0IG5vdCBhbGwgbmV0d29ya3MgYXJlIHN1cHBvcnRlZCBpbiB0aGUgTm90aWZ5IEFQSS4gUGxlYXNlIGNvbnN1bHRcclxuICogdGhlIGRvY3VtZW50YXRpb24gZm9yIHdoaWNoIG5ldHdvcmtzIGFyZSBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIG5vdGlmeVxyXG4gKiBuYW1lc3BhY2UgdmlhIGBhbGNoZW15Lm5vdGlmeWAuXHJcbiAqL1xyXG5jbGFzcyBOb3RpZnlOYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgd2ViaG9va3Mgb24geW91ciB0ZWFtLlxyXG4gICAgICpcclxuICAgICAqIFRoZSB0ZWFtIGlzIGRldGVybWluZWQgYnkgdGhlIGBhdXRoVG9rZW5gIHByb3ZpZGVkIGludG8gdGhlIHtAbGluayBBbGNoZW15U2V0dGluZ3N9XHJcbiAgICAgKiBvYmplY3Qgd2hlbiBjcmVhdGluZyBhIG5ldyB7QGxpbmsgQWxjaGVteX0gaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHJlc3BvbnNlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViaG9va3NcclxuICAgICAqL1xyXG4gICAgZ2V0QWxsV2ViaG9va3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCd0ZWFtLXdlYmhvb2tzJywgJ2dldEFsbFdlYmhvb2tzJywge30pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2ViaG9va3M6IHBhcnNlUmF3V2ViaG9va1Jlc3BvbnNlKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLmRhdGEubGVuZ3RoXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBZGRyZXNzZXMod2ViaG9va09ySWQsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Q29uZmlnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlYmhvb2tJZCA9IHR5cGVvZiB3ZWJob29rT3JJZCA9PT0gJ3N0cmluZycgPyB3ZWJob29rT3JJZCA6IHdlYmhvb2tPcklkLmlkO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCd3ZWJob29rLWFkZHJlc3NlcycsICdnZXRBZGRyZXNzZXMnLCB7XHJcbiAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICBsaW1pdDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxpbWl0LFxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSYXdBZGRyZXNzQWN0aXZpdHlSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHcmFwaHFsUXVlcnkod2ViaG9va09ySWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Q29uZmlnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlYmhvb2tJZCA9IHR5cGVvZiB3ZWJob29rT3JJZCA9PT0gJ3N0cmluZycgPyB3ZWJob29rT3JJZCA6IHdlYmhvb2tPcklkLmlkO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCdkYXNoYm9hcmQtd2ViaG9vay1ncmFwaHFsLXF1ZXJ5JywgJ2dldEdyYXBocWxRdWVyeScsIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmF3Q3VzdG9tR3JhcGhxbFdlYmhvb2tSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRGaWx0ZXJzKHdlYmhvb2tPcklkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnd2ViaG9vay1uZnQtZmlsdGVycycsICdnZXROZnRGaWx0ZXJzJywge1xyXG4gICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVdlYmhvb2sod2ViaG9va09ySWQsIHVwZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2ViaG9va0lkID0gdHlwZW9mIHdlYmhvb2tPcklkID09PSAnc3RyaW5nJyA/IHdlYmhvb2tPcklkIDogd2ViaG9va09ySWQuaWQ7XHJcbiAgICAgICAgICAgIGxldCByZXN0QXBpTmFtZTtcclxuICAgICAgICAgICAgbGV0IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XHJcbiAgICAgICAgICAgIGxldCBkYXRhO1xyXG4gICAgICAgICAgICBpZiAoJ2lzQWN0aXZlJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAndXBkYXRlV2ViaG9vayc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzX2FjdGl2ZTogdXBkYXRlLmlzQWN0aXZlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdhZGRGaWx0ZXJzJyBpbiB1cGRhdGUgfHwgJ3JlbW92ZUZpbHRlcnMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stbmZ0LWZpbHRlcnMnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICd1cGRhdGVXZWJob29rTmZ0RmlsdGVycyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUEFUQ0gnO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmZ0X2ZpbHRlcnNfdG9fYWRkOiB1cGRhdGUuYWRkRmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZS5hZGRGaWx0ZXJzLm1hcChuZnRGaWx0ZXJUb1BhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG5mdF9maWx0ZXJzX3RvX3JlbW92ZTogdXBkYXRlLnJlbW92ZUZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUucmVtb3ZlRmlsdGVycy5tYXAobmZ0RmlsdGVyVG9QYXJhbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnYWRkTWV0YWRhdGFGaWx0ZXJzJyBpbiB1cGRhdGUgfHxcclxuICAgICAgICAgICAgICAgICdyZW1vdmVNZXRhZGF0YUZpbHRlcnMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stbmZ0LW1ldGFkYXRhLWZpbHRlcnMnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICd1cGRhdGVXZWJob29rTmZ0TWV0YWRhdGFGaWx0ZXJzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdQQVRDSCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBuZnRfbWV0YWRhdGFfZmlsdGVyc190b19hZGQ6IHVwZGF0ZS5hZGRNZXRhZGF0YUZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUuYWRkTWV0YWRhdGFGaWx0ZXJzLm1hcChuZnRGaWx0ZXJUb1BhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG5mdF9tZXRhZGF0YV9maWx0ZXJzX3RvX3JlbW92ZTogdXBkYXRlLnJlbW92ZU1ldGFkYXRhRmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZS5yZW1vdmVNZXRhZGF0YUZpbHRlcnMubWFwKG5mdEZpbHRlclRvUGFyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2FkZEFkZHJlc3NlcycgaW4gdXBkYXRlIHx8ICdyZW1vdmVBZGRyZXNzZXMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stYWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnd2ViaG9vazp1cGRhdGVXZWJob29rQWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdQQVRDSCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXNfdG9fYWRkOiB5aWVsZCB0aGlzLnJlc29sdmVBZGRyZXNzZXModXBkYXRlLmFkZEFkZHJlc3NlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzX3RvX3JlbW92ZTogeWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHVwZGF0ZS5yZW1vdmVBZGRyZXNzZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCduZXdBZGRyZXNzZXMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stYWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnd2ViaG9vazp1cGRhdGVXZWJob29rQWRkcmVzcyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogeWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHVwZGF0ZS5uZXdBZGRyZXNzZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGB1cGRhdGVgIHBhcmFtIHBhc3NlZCBpbnRvIGB1cGRhdGVXZWJob29rYCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCB7fSwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVdlYmhvb2sodXJsLCB0eXBlLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBhcHBJZDtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuTUlORURfVFJBTlNBQ1RJT04gfHxcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuRFJPUFBFRF9UUkFOU0FDVElPTikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2FwcElkJyBpbiBwYXJhbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBXZWJob29rcyByZXF1aXJlIGFuIGFwcCBpZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcElkID0gcGFyYW1zLmFwcElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHRoaXMuY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgICAgICBsZXQgbmZ0RmlsdGVyT2JqO1xyXG4gICAgICAgICAgICBsZXQgYWRkcmVzc2VzO1xyXG4gICAgICAgICAgICBsZXQgZ3JhcGhxbFF1ZXJ5O1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5ORlRfQUNUSVZJVFkgfHxcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuTkZUX01FVEFEQVRBX1VQREFURSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2ZpbHRlcnMnIGluIHBhcmFtcykgfHwgcGFyYW1zLmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZnQgQWN0aXZpdHkgV2ViaG9va3MgcmVxdWlyZSBhIG5vbi1lbXB0eSBhcnJheSBpbnB1dC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBwYXJhbXMubmV0d29ya1xyXG4gICAgICAgICAgICAgICAgICAgID8gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHBhcmFtcy5uZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV0d29yaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcnMgPSBwYXJhbXMuZmlsdGVycy5tYXAoZmlsdGVyID0+IGZpbHRlci50b2tlbklkXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGZpbHRlci5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2lkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZmlsdGVyLnRva2VuSWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGZpbHRlci5jb250cmFjdEFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG5mdEZpbHRlck9iaiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5ORlRfQUNUSVZJVFlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IG5mdF9maWx0ZXJzOiBmaWx0ZXJzIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IG5mdF9tZXRhZGF0YV9maWx0ZXJzOiBmaWx0ZXJzIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5BRERSRVNTX0FDVElWSVRZKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhKCdhZGRyZXNzZXMnIGluIHBhcmFtcykgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkcmVzcyBBY3Rpdml0eSBXZWJob29rcyByZXF1aXJlIGEgbm9uLWVtcHR5IGFycmF5IGlucHV0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHBhcmFtcy5uZXR3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgPyBORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSy5nZXQocGFyYW1zLm5ldHdvcmspXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0geWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHBhcmFtcy5hZGRyZXNzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gZXhwb3J0cy5XZWJob29rVHlwZS5HUkFQSFFMKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhKCdncmFwaHFsUXVlcnknIGluIHBhcmFtcykgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZ3JhcGhxbFF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIFdlYmhvb2tzIHJlcXVpcmUgYSBub24tZW1wdHkgZ3JhcGhxbCBxdWVyeS4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBwYXJhbXMubmV0d29ya1xyXG4gICAgICAgICAgICAgICAgICAgID8gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHBhcmFtcy5uZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV0d29yaztcclxuICAgICAgICAgICAgICAgIGdyYXBocWxRdWVyeSA9IHBhcmFtcy5ncmFwaHFsUXVlcnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuZXR3b3JrLCB3ZWJob29rX3R5cGU6IHR5cGUsIHdlYmhvb2tfdXJsOiB1cmwgfSwgKGFwcElkICYmIHsgYXBwX2lkOiBhcHBJZCB9KSksIG5mdEZpbHRlck9iaiksIChhZGRyZXNzZXMgJiYgeyBhZGRyZXNzZXMgfSkpLCAoZ3JhcGhxbFF1ZXJ5ICYmIHsgZ3JhcGhxbF9xdWVyeTogZ3JhcGhxbFF1ZXJ5IH0pKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnY3JlYXRlLXdlYmhvb2snLCAnY3JlYXRlV2ViaG9vaycsIHt9LCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJhd1dlYmhvb2socmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVXZWJob29rKHdlYmhvb2tPcklkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnZGVsZXRlLXdlYmhvb2snLCAnZGVsZXRlV2ViaG9vaycsIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYmhvb2sgbm90IGZvdW5kLiBGYWlsZWQgdG8gZGVsZXRlIHdlYmhvb2s6ICR7d2ViaG9va0lkfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGhUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgdGhlIE5vdGlmeSBBUEkgcmVxdWlyZXMgc2V0dGluZyB0aGUgQWxjaGVteSBBdXRoIFRva2VuIGluICcgK1xyXG4gICAgICAgICAgICAgICAgJ3RoZSBzZXR0aW5ncyBvYmplY3Qgd2hlbiBpbml0aWFsaXppbmcgQWxjaGVteS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kV2ViaG9va1JlcXVlc3QocmVzdEFwaU5hbWUsIG1ldGhvZE5hbWUsIHBhcmFtcywgb3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYodGhpcy5jb25maWcsIEFsY2hlbXlBcGlUeXBlLldFQkhPT0ssIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ1gtQWxjaGVteS1Ub2tlbic6IHRoaXMuY29uZmlnLmF1dGhUb2tlbiB9LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMuaGVhZGVycykgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlc29sdmVzIEVOUyBhZGRyZXNzZXMgdG8gdGhlIHJhdyBhZGRyZXNzLlxyXG4gICAgICogQGludGVybmFsICovXHJcbiAgICByZXNvbHZlQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3NlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBZGRyZXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWRkcmVzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXdBZGRyZXNzID0geWllbGQgcHJvdmlkZXIucmVzb2x2ZU5hbWUoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3QWRkcmVzcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgdGhlIEVOUyBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFkZHJlc3Nlcy5wdXNoKHJhd0FkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFkZHJlc3NlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFwcGluZyBvZiB3ZWJob29rIG5ldHdvcmsgcmVwcmVzZW50YXRpb25zIHRvIHRoZSBTREsncyBuZXR3b3JrIHJlcHJlc2VudGF0aW9uLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IFdFQkhPT0tfTkVUV09SS19UT19ORVRXT1JLID0ge1xyXG4gICAgRVRIX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5FVEhfTUFJTk5FVCxcclxuICAgIEVUSF9HT0VSTEk6IGV4cG9ydHMuTmV0d29yay5FVEhfR09FUkxJLFxyXG4gICAgRVRIX1NFUE9MSUE6IGV4cG9ydHMuTmV0d29yay5FVEhfU0VQT0xJQSxcclxuICAgIE1BVElDX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5NQVRJQ19NQUlOTkVULFxyXG4gICAgTUFUSUNfTVVNQkFJOiBleHBvcnRzLk5ldHdvcmsuTUFUSUNfTVVNQkFJLFxyXG4gICAgTUFUSUNfQU1PWTogZXhwb3J0cy5OZXR3b3JrLk1BVElDX0FNT1ksXHJcbiAgICBBUkJfTUFJTk5FVDogZXhwb3J0cy5OZXR3b3JrLkFSQl9NQUlOTkVULFxyXG4gICAgQVJCX0dPRVJMSTogZXhwb3J0cy5OZXR3b3JrLkFSQl9HT0VSTEksXHJcbiAgICBBUkJfU0VQT0xJQTogZXhwb3J0cy5OZXR3b3JrLkFSQl9TRVBPTElBLFxyXG4gICAgT1BUX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5PUFRfTUFJTk5FVCxcclxuICAgIE9QVF9HT0VSTEk6IGV4cG9ydHMuTmV0d29yay5PUFRfR09FUkxJLFxyXG4gICAgT1BUX1NFUE9MSUE6IGV4cG9ydHMuTmV0d29yay5PUFRfU0VQT0xJQSxcclxuICAgIEJBU0VfTUFJTk5FVDogZXhwb3J0cy5OZXR3b3JrLkJBU0VfTUFJTk5FVCxcclxuICAgIEJBU0VfR09FUkxJOiBleHBvcnRzLk5ldHdvcmsuQkFTRV9HT0VSTEksXHJcbiAgICBCQVNFX1NFUE9MSUE6IGV4cG9ydHMuTmV0d29yay5CQVNFX1NFUE9MSUEsXHJcbiAgICBaS1NZTkNfTUFJTk5FVDogZXhwb3J0cy5OZXR3b3JrLlpLU1lOQ19NQUlOTkVULFxyXG4gICAgWktTWU5DX1NFUE9MSUE6IGV4cG9ydHMuTmV0d29yay5aS1NZTkNfU0VQT0xJQVxyXG59O1xyXG4vKiogTWFwcGluZyBvZiB0aGUgU0RLJ3MgbmV0d29yayByZXByZXNlbnRhdGlvbiB0aGUgd2ViaG9vayBBUEkncyBuZXR3b3JrIHJlcHJlc2VudGF0aW9uLiAqL1xyXG5jb25zdCBORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuTmV0d29yaykucmVkdWNlKChtYXAsIGtleSkgPT4ge1xyXG4gICAgaWYgKGtleSBpbiBXRUJIT09LX05FVFdPUktfVE9fTkVUV09SSykge1xyXG4gICAgICAgIG1hcC5zZXQoV0VCSE9PS19ORVRXT1JLX1RPX05FVFdPUktba2V5XSwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXA7XHJcbn0sIG5ldyBNYXAoKSk7XHJcbmZ1bmN0aW9uIHBhcnNlUmF3V2ViaG9va1Jlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tYXAocGFyc2VSYXdXZWJob29rKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVJhd1dlYmhvb2socmF3V2ViaG9vaykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBpZDogcmF3V2ViaG9vay5pZCwgbmV0d29yazogV0VCSE9PS19ORVRXT1JLX1RPX05FVFdPUktbcmF3V2ViaG9vay5uZXR3b3JrXSwgdHlwZTogcmF3V2ViaG9vay53ZWJob29rX3R5cGUsIHVybDogcmF3V2ViaG9vay53ZWJob29rX3VybCwgaXNBY3RpdmU6IHJhd1dlYmhvb2suaXNfYWN0aXZlLCB0aW1lQ3JlYXRlZDogbmV3IERhdGUocmF3V2ViaG9vay50aW1lX2NyZWF0ZWQpLnRvSVNPU3RyaW5nKCksIHNpZ25pbmdLZXk6IHJhd1dlYmhvb2suc2lnbmluZ19rZXksIHZlcnNpb246IHJhd1dlYmhvb2sudmVyc2lvbiB9LCAocmF3V2ViaG9vay5hcHBfaWQgIT09IHVuZGVmaW5lZCAmJiB7IGFwcElkOiByYXdXZWJob29rLmFwcF9pZCB9KSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdBZGRyZXNzQWN0aXZpdHlSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRyZXNzZXM6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UucGFnaW5hdGlvbi50b3RhbF9jb3VudCxcclxuICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdpbmF0aW9uLmN1cnNvcnMuYWZ0ZXJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdDdXN0b21HcmFwaHFsV2ViaG9va1Jlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdyYXBocWxRdWVyeTogcmVzcG9uc2UuZGF0YS5ncmFwaHFsX3F1ZXJ5XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpbHRlcnM6IHJlc3BvbnNlLmRhdGEubWFwKGYgPT4gZi50b2tlbl9pZFxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZi5jb250cmFjdF9hZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5JZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGYudG9rZW5faWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZi5jb250cmFjdF9hZGRyZXNzXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLnBhZ2luYXRpb24udG90YWxfY291bnQsXHJcbiAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnaW5hdGlvbi5jdXJzb3JzLmFmdGVyXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5mdEZpbHRlclRvUGFyYW0oZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gZmlsdGVyLnRva2VuSWRcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5faWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShmaWx0ZXIudG9rZW5JZCkudG9TdHJpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIE11bHRpcGxlcyB0byBpbmNyZW1lbnQgZmVlIHBlciBnYXMgd2hlbiB1c2luZ1xyXG4gKiB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9ufS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBHQVNfT1BUSU1JWkVEX1RYX0ZFRV9NVUxUSVBMRVMgPSBbMC45LCAxLCAxLjEsIDEuMiwgMS4zXTtcclxuLyoqXHJcbiAqIFRoZSBUcmFuc2FjdCBuYW1lc3BhY2UgY29udGFpbnMgbWV0aG9kcyB1c2VkIGZvciBzZW5kaW5nIHRyYW5zYWN0aW9ucyBhbmRcclxuICogY2hlY2tpbmcgb24gdGhlIHN0YXRlIG9mIHN1Ym1pdHRlZCB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIHRyYW5zYWN0XHJcbiAqIG5hbWVzcGFjZSB2aWEgYGFsY2hlbXkudHJhbnNhY3RgLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3ROYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gc2VuZCBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0byBGbGFzaGJvdHMuIEZsYXNoYm90cyB3aWxsIGF0dGVtcHQgdG9cclxuICAgICAqIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvIG1pbmVycyBmb3IgdGhlIG5leHQgMjUgYmxvY2tzLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHN1Ym1pdHRlZCB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb24gVGhlIHJhdywgc2lnbmVkIHRyYW5zYWN0aW9uIGFzIGEgaGFzaC5cclxuICAgICAqIEBwYXJhbSBtYXhCbG9ja051bWJlciBPcHRpb25hbCBoaWdoZXN0IGJsb2NrIG51bWJlciBpbiB3aGljaCB0aGVcclxuICAgICAqICAgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGluY2x1ZGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHNlbmRQcml2YXRlVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24sIG1heEJsb2NrTnVtYmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhleEJsb2NrTnVtYmVyID0gbWF4QmxvY2tOdW1iZXIgPyB0b0hleChtYXhCbG9ja051bWJlcikgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnZXRoX3NlbmRQcml2YXRlVHJhbnNhY3Rpb24nLCBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHg6IHNpZ25lZFRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEJsb2NrTnVtYmVyOiBoZXhCbG9ja051bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlczogb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCAnc2VuZFByaXZhdGVUcmFuc2FjdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgcHJvdmlkZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbiBmcm9tIGJlaW5nIHN1Ym1pdHRlZCBmb3IgZnV0dXJlXHJcbiAgICAgKiBibG9ja3MuIEEgdHJhbnNhY3Rpb24gY2FuIG9ubHkgYmUgY2FuY2VsbGVkIGlmIHRoZSByZXF1ZXN0IGlzIHNpZ25lZCBieSB0aGVcclxuICAgICAqIHNhbWUga2V5IGFzIHRoZSB7QGxpbmsgc2VuZFByaXZhdGVUcmFuc2FjdGlvbn0gY2FsbCBzdWJtaXR0aW5nIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaW4gZmlyc3QgcGxhY2UuXHJcbiAgICAgKlxyXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBmYXN0IG1vZGUgdHJhbnNhY3Rpb25zIGNhbm5vdCBiZSBjYW5jZWxsZWQgdXNpbmcgdGhpcyBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjYW5jZWxsYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUcmFuc2FjdGlvbiBoYXNoIG9mIHByaXZhdGUgdHggdG8gYmUgY2FuY2VsbGVkXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbFByaXZhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdldGhfY2FuY2VsUHJpdmF0ZVRyYW5zYWN0aW9uJywgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25IYXNoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sICdjYW5jZWxQcml2YXRlVHJhbnNhY3Rpb24nKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltdWxhdGVzIHRoZSBhc3NldCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgc2ltdWxhdGVkXHJcbiAgICAgKiBpbiBzZXF1ZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhc3NldCBjaGFuZ2VzIGZvciBlYWNoIHRyYW5zYWN0aW9uIGR1cmluZyBzaW11bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIGxpc3Qgb2YgbWF4IDMgdHJhbnNhY3Rpb25zIHRvIHNpbXVsYXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBPcHRpb25hbCBibG9jayBpZGVudGlmaWVyIHRvIHNpbXVsYXRlIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaW4uXHJcbiAgICAgKi9cclxuICAgIHNpbXVsYXRlQXNzZXRDaGFuZ2VzQnVuZGxlKHRyYW5zYWN0aW9ucywgYmxvY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGJsb2NrSWRlbnRpZmllciAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IFt0cmFuc2FjdGlvbnMsIGJsb2NrSWRlbnRpZmllcl1cclxuICAgICAgICAgICAgICAgIDogW3RyYW5zYWN0aW9uc107XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X3NpbXVsYXRlQXNzZXRDaGFuZ2VzQnVuZGxlJywgcGFyYW1zLCAnc2ltdWxhdGVBc3NldENoYW5nZXNCdW5kbGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltdWxhdGVzIHRoZSBhc3NldCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGEgc2luZ2xlIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgbGlzdCBvZiBhc3NldCBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICogc2ltdWxhdGlvbi4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IHJ1biB0aGUgdHJhbnNhY3Rpb24gb24gdGhlXHJcbiAgICAgKiBibG9ja2NoYWluLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gdG8gc2ltdWxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIE9wdGlvbmFsIGJsb2NrIGlkZW50aWZpZXIgdG8gc2ltdWxhdGUgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBpbi5cclxuICAgICAqL1xyXG4gICAgc2ltdWxhdGVBc3NldENoYW5nZXModHJhbnNhY3Rpb24sIGJsb2NrSWRlbnRpZmllcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBibG9ja0lkZW50aWZpZXIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBbdHJhbnNhY3Rpb24sIGJsb2NrSWRlbnRpZmllcl1cclxuICAgICAgICAgICAgICAgIDogW3RyYW5zYWN0aW9uXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfc2ltdWxhdGVBc3NldENoYW5nZXMnLCBwYXJhbXMsICdzaW11bGF0ZUFzc2V0Q2hhbmdlcycpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgYSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyBsaXN0IG9mIGRlY29kZWRcclxuICAgICAqIHRyYWNlcyBhbmQgbG9ncyB0aGF0IG9jY3VycmVkIGZvciBlYWNoIHRyYW5zYWN0aW9uIGR1cmluZyBzaW11bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBydW4gYW55IHRyYW5zYWN0aW9ucyBvbiB0aGUgYmxvY2tjaGFpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyBsaXN0IG9mIG1heCAzIHRyYW5zYWN0aW9ucyB0byBzaW11bGF0ZS5cclxuICAgICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgT3B0aW9uYWwgYmxvY2sgaWRlbnRpZmllciB0byBzaW11bGF0ZSB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGluLlxyXG4gICAgICovXHJcbiAgICBzaW11bGF0ZUV4ZWN1dGlvbkJ1bmRsZSh0cmFuc2FjdGlvbnMsIGJsb2NrSWRlbnRpZmllcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBibG9ja0lkZW50aWZpZXIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBbdHJhbnNhY3Rpb25zLCBibG9ja0lkZW50aWZpZXJdXHJcbiAgICAgICAgICAgICAgICA6IFt0cmFuc2FjdGlvbnNdO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9zaW11bGF0ZUV4ZWN1dGlvbkJ1bmRsZScsIHBhcmFtcywgJ3NpbXVsYXRlRXhlY3V0aW9uQnVuZGxlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiBhbmQgdGhlIHJlc3VsdGluZyBhbmQgcmV0dXJucyBsaXN0IG9mXHJcbiAgICAgKiBkZWNvZGVkIHRyYWNlcyBhbmQgbG9ncyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24gc2ltdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgcnVuIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgYmxvY2tjaGFpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIHNpbXVsYXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBPcHRpb25hbCBibG9jayBpZGVudGlmaWVyIHRvIHNpbXVsYXRlIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaW4uXHJcbiAgICAgKi9cclxuICAgIHNpbXVsYXRlRXhlY3V0aW9uKHRyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYmxvY2tJZGVudGlmaWVyICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gW3RyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXJdXHJcbiAgICAgICAgICAgICAgICA6IFt0cmFuc2FjdGlvbl07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X3NpbXVsYXRlRXhlY3V0aW9uJywgcGFyYW1zLCAnc2ltdWxhdGVFeGVjdXRpb24nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gd2l0aCBoYXNoIG9yIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHVua25vd24uXHJcbiAgICAgKlxyXG4gICAgICogSWYgYSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIHRoaXMgbWV0aG9kIHdpbGwgc2VhcmNoIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gcG9vbC4gVmFyaW91cyBiYWNrZW5kcyBtYXkgaGF2ZSBtb3JlIHJlc3RyaWN0aXZlIHRyYW5zYWN0aW9uXHJcbiAgICAgKiBwb29sIGFjY2VzcyAoZS5nLiBpZiB0aGUgZ2FzIHByaWNlIGlzIHRvbyBsb3cgb3IgdGhlIHRyYW5zYWN0aW9uIHdhcyBvbmx5XHJcbiAgICAgKiByZWNlbnRseSBzZW50IGFuZCBub3QgeWV0IGluZGV4ZWQpIGluIHdoaWNoIGNhc2UgdGhpcyBtZXRob2QgbWF5IGFsc28gcmV0dXJuIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIENvcmVOYW1lc3BhY2UuZ2V0VHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGdldC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJtaXRzIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrIHRvIGJlIG1pbmVkLiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZVxyXG4gICAgICogc2lnbmVkLCBhbmQgYmUgdmFsaWQgKGkuZS4gdGhlIG5vbmNlIGlzIGNvcnJlY3QgYW5kIHRoZSBhY2NvdW50IGhhc1xyXG4gICAgICogc3VmZmljaWVudCBiYWxhbmNlIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgQ29yZU5hbWVzcGFjZS5zZW5kVHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaWduZWRUcmFuc2FjdGlvbiBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uIHRvIHNlbmQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBlc3RpbWF0ZSBvZiB0aGUgYW1vdW50IG9mIGdhcyB0aGF0IHdvdWxkIGJlIHJlcXVpcmVkIHRvIHN1Ym1pdFxyXG4gICAgICogdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsuXHJcbiAgICAgKlxyXG4gICAgICogQW4gZXN0aW1hdGUgbWF5IG5vdCBiZSBhY2N1cmF0ZSBzaW5jZSB0aGVyZSBjb3VsZCBiZSBhbm90aGVyIHRyYW5zYWN0aW9uIG9uXHJcbiAgICAgKiB0aGUgbmV0d29yayB0aGF0IHdhcyBub3QgYWNjb3VudGVkIGZvciwgYnV0IGFmdGVyIGJlaW5nIG1pbmVkIGFmZmVjdHMgdGhlXHJcbiAgICAgKiByZWxldmFudCBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgQ29yZU5hbWVzcGFjZS5lc3RpbWF0ZUdhc30uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBnYXMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZmVlIHBlciBnYXMgKGluIHdlaSkgdGhhdCBpcyBhbiBlc3RpbWF0ZSBvZiBob3cgbXVjaCB5b3UgY2FuIHBheVxyXG4gICAgICogYXMgYSBwcmlvcml0eSBmZWUsIG9yIFwidGlwXCIsIHRvIGdldCBhIHRyYW5zYWN0aW9uIGluY2x1ZGVkIGluIHRoZSBjdXJyZW50IGJsb2NrLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbnVtYmVyIGlzIGdlbmVyYWxseSB1c2VkIHRvIHNldCB0aGUgYG1heFByaW9yaXR5RmVlUGVyR2FzYCBmaWVsZCBpbiBhXHJcbiAgICAgKiB0cmFuc2FjdGlvbiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0TWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZlZUhleCA9IHlpZWxkIHByb3ZpZGVyLl9zZW5kKCdldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXMnLCBbXSwgJ2dldE1heFByaW9yaXR5RmVlUGVyR2FzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KGZlZUhleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgbm90IHJlc29sdmUgdW50aWwgc3BlY2lmaWVkIHRyYW5zYWN0aW9uIGhhc2ggaXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogSWYge0BsaW5rIGNvbmZpcm1hdGlvbnN9IGlzIDAsIHRoaXMgbWV0aG9kIGlzIG5vbi1ibG9ja2luZyBhbmQgaWYgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGxcclxuICAgICAqIGJsb2NrIHVudGlsIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29uZmlybWVkIGJsb2NrcyBtaW5lZCBvbiB0b3Agb2YgdGhlIGJsb2NrXHJcbiAgICAgKiBpbiB3aGljaCBpdCB3YXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIENvcmVOYW1lc3BhY2Uud2FpdEZvclRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byB3YWl0IGZvci5cclxuICAgICAqIEBwYXJhbSBjb25maXJtYXRpb25zIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRvIHdhaXQgZm9yLlxyXG4gICAgICogQHBhcmFtIHRpbWVvdXQgVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29uZmlybS5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25PclNpZ25lZFR4cywgd2FsbGV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbk9yU2lnbmVkVHhzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk9yU2lnbmVkVHhzLCAnc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uUHJlU2lnbmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGdhc0xpbWl0O1xyXG4gICAgICAgICAgICBsZXQgcHJpb3JpdHlGZWU7XHJcbiAgICAgICAgICAgIGxldCBiYXNlRmVlO1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBnYXNMaW1pdCA9IHlpZWxkIHRoaXMuZXN0aW1hdGVHYXModHJhbnNhY3Rpb25PclNpZ25lZFR4cyk7XHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eUZlZSA9IHlpZWxkIHRoaXMuZ2V0TWF4UHJpb3JpdHlGZWVQZXJHYXMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHlpZWxkIHByb3ZpZGVyLmdldEJsb2NrKCdsYXRlc3QnKTtcclxuICAgICAgICAgICAgICAgIGJhc2VGZWUgPSBjdXJyZW50QmxvY2suYmFzZUZlZVBlckdhcy50b051bWJlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlc3RpbWF0ZSBnYXMgZm9yIHRyYW5zYWN0aW9uOiAke2V9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZ2FzU3ByZWFkVHJhbnNhY3Rpb25zID0gZ2VuZXJhdGVHYXNTcHJlYWRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25PclNpZ25lZFR4cywgZ2FzTGltaXQudG9OdW1iZXIoKSwgYmFzZUZlZSwgcHJpb3JpdHlGZWUpO1xyXG4gICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSB5aWVsZCBQcm9taXNlLmFsbChnYXNTcHJlYWRUcmFuc2FjdGlvbnMubWFwKHR4ID0+IHdhbGxldC5zaWduVHJhbnNhY3Rpb24odHgpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb25zLCAnc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uR2VuZXJhdGVkJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBqb2IgcmV0dXJuZWQgYnkgdGhlXHJcbiAgICAgKiB7QGxpbmsgc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhY2tpbmdJZCBUaGUgdHJhY2tpbmcgaWQgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgdGhlIHNlbnQgZ2FzIG9wdGltaXplZCB0cmFuc2FjdGlvbi5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPKHR4am9iKTogUmVtb3ZlIGludGVybmFsIHRhZyBvbmNlIHRoaXMgZmVhdHVyZSBpcyByZWxlYXNlZC5cclxuICAgIGdldEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzKHRyYWNraW5nSWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzJywgW3RyYWNraW5nSWRdLCAnZ2V0R2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb25zLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24nLCBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3VHJhbnNhY3Rpb25zOiBzaWduZWRUcmFuc2FjdGlvbnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlIHJhdyB0cmFuc2FjdGlvbiB3aXRoIHRoZSBnaXZlbiBnYXMgbGltaXQgYW5kXHJcbiAqIHByaW9yaXR5IGZlZSBhY3Jvc3MgYSBzcHJlYWQgb2YgZGlmZmVyZW50IGdhcyBwcmljZXMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUdhc1NwcmVhZFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbiwgZ2FzTGltaXQsIGJhc2VGZWUsIHByaW9yaXR5RmVlKSB7XHJcbiAgICByZXR1cm4gR0FTX09QVElNSVpFRF9UWF9GRUVfTVVMVElQTEVTLm1hcChmZWVNdWx0aXBsaWVyID0+IHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQsIG1heEZlZVBlckdhczogTWF0aC5yb3VuZChiYXNlRmVlICogZmVlTXVsdGlwbGllciArIHByaW9yaXR5RmVlICogZmVlTXVsdGlwbGllciksIG1heFByaW9yaXR5RmVlUGVyR2FzOiBNYXRoLnJvdW5kKGZlZU11bHRpcGxpZXIgKiBwcmlvcml0eUZlZSkgfSk7XHJcbiAgICB9KTtcclxufVxuXG4vKiogVGhpcyBmaWxlIGNvbnRhaW5zIGludGVybmFsIHR5cGVzIHVzZWQgYnkgdGhlIFNESyBhbmQgYXJlIG5vdCBleHBvc2VkIHRvIHRoZSBlbmQgdXNlci4gKi9cclxuLyoqXHJcbiAqIFByZWZpeCBmb3IgYGFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uc2Agc3Vic2NyaXB0aW9ucyB3aGVuIHNlcmlhbGl6aW5nIHRvXHJcbiAqIGV0aGVycyBldmVudHMuXHJcbiAqXHJcbiAqIFRoaXMgdGFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBldGhlcnMgdG8gdHJhY2sgZGlmZmVyZW50IGV2ZW50IGZpbHRlcnMuXHJcbiAqL1xyXG5jb25zdCBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSAnYWxjaGVteS1wZW5kaW5nLXRyYW5zYWN0aW9ucyc7XHJcbi8qKlxyXG4gKiBQcmVmaXggZm9yIGBhbGNoZW15X21pbmVkVHJhbnNhY3Rpb25zYCBzdWJzY3JpcHRpb25zIHdoZW4gc2VyaWFsaXppbmcgdG8gZXRoZXJzIGV2ZW50cy5cclxuICpcclxuICogVGhpcyB0YWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGV0aGVycyB0byB0cmFjayBkaWZmZXJlbnQgZXZlbnQgZmlsdGVycy5cclxuICovXHJcbmNvbnN0IEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSAnYWxjaGVteS1taW5lZC10cmFuc2FjdGlvbnMnO1xyXG4vKipcclxuICogQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGN1c3RvbSBldmVudCB0YWdzIHVzZWQgaW50ZXJuYWxseSBieSBldGhlcnMgdG8gdHJhY2tcclxuICogZXZlbnQgZmlsdGVycy5cclxuICovXHJcbmNvbnN0IEFMQ0hFTVlfRVZFTlRfVFlQRVMgPSBbXHJcbiAgICBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUsXHJcbiAgICBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFXHJcbl07XG5cbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBFdmVudCBjbGFzcyBjb3BpZWQgZGlyZWN0bHkgb3ZlciBmcm9tIGV0aGVycy5qcydzIGBCYXNlUHJvdmlkZXJgIGNsYXNzLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gcmVwcmVzZW50IGV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBsaXN0ZW5lcnMuIFRoZVxyXG4gKiBTREsgbmVlZHMgdG8gZXh0ZW5kIHRoaXMgY2xhc3MgaW4gb3JkZXIgdG8gc3VwcG9ydCBBbGNoZW15J3MgY3VzdG9tXHJcbiAqIFN1YnNjcmlwdGlvbiBBUEkgdHlwZXMuIFRoZSBvcmlnaW5hbCBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgYnkgZXRoZXJzLiBNaW5pbWFsXHJcbiAqIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgaW4gb3JkZXIgdG8gZ2V0IFRTIHRvIGNvbXBpbGUuXHJcbiAqL1xyXG5jbGFzcyBFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG4gICAgICAgIHRoaXMub25jZSA9IG9uY2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XHJcbiAgICAgICAgdGhpcy5faW5mbGlnaHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBldmVudCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0eCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xyXG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB0eXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZy5zcGxpdCgnOicpWzBdO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc2goKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gJ3R4Jykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHRyYW5zYWN0aW9uIGV2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wc1sxXTtcclxuICAgIH1cclxuICAgIGdldCBmaWx0ZXIoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gJ2ZpbHRlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB0cmFuc2FjdGlvbiBldmVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHNbMV07XHJcbiAgICAgICAgY29uc3QgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xyXG4gICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSAnKicpIHtcclxuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfVxyXG4gICAgcG9sbGFibGUoKSB7XHJcbiAgICAgICAgY29uc3QgUG9sbGFibGVFdmVudHMgPSBbJ2Jsb2NrJywgJ25ldHdvcmsnLCAncGVuZGluZycsICdwb2xsJ107XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLmluZGV4T2YoJzonKSA+PSAwIHx8IFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpID49IDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBwZXIgY2xhc3MgYXJvdW5kIHRoZSBldGhlcnMgYEV2ZW50YCBjbGFzcyBpbiBvcmRlciB0byBhZGQgc3VwcG9ydCBmb3JcclxuICogQWxjaGVteSdzIGN1c3RvbSBzdWJzY3JpcHRpb25zIHR5cGVzLlxyXG4gKlxyXG4gKiBUaGUgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG1lY2hhbmlzbSByZXF1aXJlcyB0aGUgb3JkZXIgb2YgdGhlXHJcbiAqIGZpZWxkcyB0byBiZSB0aGUgc2FtZSBhY3Jvc3MgZGlmZmVyZW50IHtAbGluayBBTENIRU1ZX0VWRU5UX1RZUEVTfS4gQmVmb3JlXHJcbiAqIHVzaW5nIGEgZ2V0dGVyIG9uIGEgbmV3IGV2ZW50IGZpbHRlciwgbWFrZSBzdXJlIHRoYXQgdGhlIHBvc2l0aW9uIG9mIHRoZVxyXG4gKiBmaWVsZCBpbiBzZXJpYWxpemF0aW9uIGlzIGNvcnJlY3QuXHJcbiAqXHJcbiAqIFRoZSBnZXR0ZXJzIG9uIHRoaXMgY2xhc3MgZGVzZXJpYWxpemUgdGhlIGV2ZW50IHRhZyBnZW5lcmF0ZWQgYnlcclxuICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW50byB0aGUgb3JpZ2luYWwgZmllbGRzIHBhc3NlZCBpbnRvIHRoZSBldmVudC5cclxuICovXHJcbmNsYXNzIEV0aGVyc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZXZlbnQgdGFnIGludG8gdGhlIG9yaWdpbmFsIGBmcm9tQWRkcmVzc2AgZmllbGQgaW5cclxuICAgICAqIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGZyb21BZGRyZXNzKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbMV0gJiYgY29tcHNbMV0gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVBZGRyZXNzRmllbGQoY29tcHNbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBldmVudCB0YWcgaW50byB0aGUgb3JpZ2luYWwgYHRvQWRkcmVzc2AgZmllbGQgaW5cclxuICAgICAqIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHRvQWRkcmVzcygpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzJdICYmIGNvbXBzWzJdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGNvbXBzWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZXZlbnQgdGFnIGludG8gdGhlIG9yaWdpbmFsIGBoYXNoZXNPbmx5YCBmaWVsZCBpblxyXG4gICAgICoge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9IGFuZCB7QGxpbmsgQWxjaGVteU1pbmVkVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9LlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFzaGVzT25seSgpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKCFBTENIRU1ZX0VWRU5UX1RZUEVTLmluY2x1ZGVzKGNvbXBzWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbM10gJiYgY29tcHNbM10gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcHNbM10gPT09ICd0cnVlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGluY2x1ZGVSZW1vdmVkKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09IEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzJdICYmIGNvbXBzWzJdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBzWzJdID09PSAndHJ1ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBhZGRyZXNzZXMoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbMV0gJiYgY29tcHNbMV0gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVBZGRyZXNzZXNGaWVsZChjb21wc1sxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0FsY2hlbXlFdmVudChldmVudCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBldmVudCA9PT0gJ29iamVjdCcgJiYgJ21ldGhvZCcgaW4gZXZlbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYGFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uYFxyXG4gKiBzdWJzY3JpcHRpb24gZmlsdGVyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2ZcclxuICogYGdldEV2ZW50VGFnKClgLiBUaGUgbWV0aG9kIGlzIG5vdCBhbiBleHBvcnRlZCBmdW5jdGlvbiBpbiBldGhlcnMsIHdoaWNoIGlzXHJcbiAqIHdoeSB0aGUgU0RLIGhhcyBpdHMgb3duIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBUaGUgZXZlbnQgdGFnIGlzIHRoZW4gZGVzZXJpYWxpemVkIGJ5IHRoZSBTREsncyB7QGxpbmsgRXRoZXJzRXZlbnR9IGdldHRlcnMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgYGBganNcclxuICogICAvLyBSZXR1cm5zICdhbGNoZW15LXBlbmRpbmctdHJhbnNhY3Rpb25zOjB4QUJDOjB4REVGfDB4R0hJOnRydWUnXHJcbiAqICAgY29uc3QgZXZlbnRUYWcgPSAgZ2V0QWxjaGVteUV2ZW50VGFnKFxyXG4gKiAgIHtcclxuICogICAgIFwibWV0aG9kXCI6IFwiYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zXCIsXHJcbiAqICAgICBcImZyb21BZGRyZXNzXCI6IFwiMHhBQkNcIixcclxuICogICAgIFwidG9BZGRyZXNzXCI6IFtcIjB4REVGXCIsIFwiMHhHSElcIl0sXHJcbiAqICAgICBcImhhc2hlc09ubHk6IHRydWVcclxuICogICB9KTtcclxuICogICBgYGA7XHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGdldEFsY2hlbXlFdmVudFRhZyhldmVudCkge1xyXG4gICAgaWYgKCFpc0FsY2hlbXlFdmVudChldmVudCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHRhZyByZXF1aXJlcyBBbGNoZW15RXZlbnRUeXBlJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnQubWV0aG9kID09PSBleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMpIHtcclxuICAgICAgICByZXR1cm4gc2VyaWFsaXplUGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50Lm1ldGhvZCA9PT0gZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUykge1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVNaW5lZFRyYW5zYWN0aW9uc0V2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIEFsY2hlbXlGaWx0ZXJFdmVudDogJHtldmVudH1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2ZXJpZnlBbGNoZW15RXZlbnROYW1lKGV2ZW50TmFtZSkge1xyXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbikuaW5jbHVkZXMoZXZlbnROYW1lLm1ldGhvZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIG5hbWUgJHtldmVudE5hbWUubWV0aG9kfS4gQWNjZXB0ZWQgbWV0aG9kIG5hbWVzOiAke09iamVjdC52YWx1ZXMoZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uKX1gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2VyaWFsaXplcyB0aGUgcHJvdmlkZWQge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9IGludG8gYW4gZXRoZXJzXHJcbiAqIGNvbXBhdGlibGUgZXZlbnQgdGFnLlxyXG4gKlxyXG4gKiBGb3IgdGhlIGV4YW1wbGUgZXZlbnQ6XHJcbiAqIGBgYFxyXG4gKiAge1xyXG4gKiAgICAgXCJtZXRob2RcIjogXCJhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbnNcIixcclxuICogICAgIFwiZnJvbUFkZHJlc3NcIjogXCIweEFCQ1wiLFxyXG4gKiAgICAgXCJ0b0FkZHJlc3NcIjogW1wiMHhERUZcIiwgXCIweEdISVwiXSxcclxuICogICAgIFwiaGFzaGVzT25seTogdHJ1ZVxyXG4gKiAgIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvbiBpczpcclxuICogYGFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uczoweEFCQzoweERFRnwweEdISTp0cnVlYFxyXG4gKlxyXG4gKiBJZiBhIGZpZWxkIGlzIG9taXR0ZWQsIGl0IGlzIHJlcGxhY2VkIHdpdGggYSBgKmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJpYWxpemVQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnQoZXZlbnQpIHtcclxuICAgIGNvbnN0IGZyb21BZGRyZXNzID0gc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGV2ZW50LmZyb21BZGRyZXNzKTtcclxuICAgIGNvbnN0IHRvQWRkcmVzcyA9IHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChldmVudC50b0FkZHJlc3MpO1xyXG4gICAgY29uc3QgaGFzaGVzT25seSA9IHNlcmlhbGl6ZUJvb2xlYW5GaWVsZChldmVudC5oYXNoZXNPbmx5KTtcclxuICAgIHJldHVybiAoQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGZyb21BZGRyZXNzICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIHRvQWRkcmVzcyArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICBoYXNoZXNPbmx5KTtcclxufVxyXG4vKipcclxuICogU2VyaWFsaXplcyB0aGUgcHJvdmlkZWQge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9IGludG8gYW4gZXRoZXJzXHJcbiAqIGNvbXBhdGlibGUgZXZlbnQgdGFnLlxyXG4gKlxyXG4gKiBGb3IgdGhlIGV4YW1wbGUgZXZlbnQ6XHJcbiAqIGBgYFxyXG4gKiAge1xyXG4gKiAgICAgXCJtZXRob2RcIjogXCJhbGNoZW15X21pbmVkVHJhbnNhY3Rpb25zXCIsXHJcbiAqICAgICBcImFkZHJlc3Nlc1wiOiBbXHJcbiAqICAgICAgIHtcclxuICogICAgICAgICBmcm9tOiBcIjB4QUJDXCJcclxuICogICAgICAgfSxcclxuICogICAgICAge1xyXG4gKiAgICAgICAgIHRvOiBcIjB4REVGXCIsXHJcbiAqICAgICAgICAgZnJvbTogXCIweDEyM1wiXHJcbiAqICAgICAgIH1cclxuICogICAgIF1cclxuICogICAgIFwiaW5jbHVkZVJlbW92ZWRcIjogZmFsc2VcclxuICogICAgIFwiaGFzaGVzT25seTogdHJ1ZVxyXG4gKiAgIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvbiBpczpcclxuICogYGFsY2hlbXlfbWluZWRUcmFuc2FjdGlvbnM6KiwweEFCQ3wweERFRiwweDEyMzpmYWxzZTp0cnVlYFxyXG4gKlxyXG4gKiBJZiBhIGZpZWxkIGlzIG9taXR0ZWQsIGl0IGlzIHJlcGxhY2VkIHdpdGggYSBgKmAuXHJcbiAqXHJcbiAqIFRoZSBgYWRkcmVzc2VzYCBhcnJheSBpcyBzcGxpdCBieSB0aGUgJ3wnIGNoYXJhY3RlciwgYW5kIGVhY2ggdG8vZnJvbSBhZGRyZXNzXHJcbiAqIHBhaXIgaXMgc2VwYXJhdGVkIGJ5IGEgJywnIGNoYXJhY3Rlci5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZU1pbmVkVHJhbnNhY3Rpb25zRXZlbnQoZXZlbnQpIHtcclxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkKGV2ZW50LmFkZHJlc3Nlcyk7XHJcbiAgICBjb25zdCBpbmNsdWRlUmVtb3ZlZCA9IHNlcmlhbGl6ZUJvb2xlYW5GaWVsZChldmVudC5pbmNsdWRlUmVtb3ZlZCk7XHJcbiAgICBjb25zdCBoYXNoZXNPbmx5ID0gc2VyaWFsaXplQm9vbGVhbkZpZWxkKGV2ZW50Lmhhc2hlc09ubHkpO1xyXG4gICAgcmV0dXJuIChBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGFkZHJlc3NlcyArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICBpbmNsdWRlUmVtb3ZlZCArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICBoYXNoZXNPbmx5KTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVBZGRyZXNzZXNGaWVsZChhZGRyZXNzZXMpIHtcclxuICAgIGlmIChhZGRyZXNzZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAnKic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRkcmVzc2VzXHJcbiAgICAgICAgLm1hcChmaWx0ZXIgPT4gc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGZpbHRlci50bykgK1xyXG4gICAgICAgICcsJyArXHJcbiAgICAgICAgc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGZpbHRlci5mcm9tKSlcclxuICAgICAgICAuam9pbignfCcpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChmaWVsZCkge1xyXG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcclxuICAgICAgICByZXR1cm4gZmllbGQuam9pbignfCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJvb2xlYW5GaWVsZChmaWVsZCkge1xyXG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoLyYvZykubWFwKHRvcGljID0+IHtcclxuICAgICAgICBpZiAodG9waWMgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0b3BpYy5zcGxpdCgnfCcpLm1hcCh0b3BpYyA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b3BpYyA9PT0gJ251bGwnID8gbnVsbCA6IHRvcGljO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wcy5sZW5ndGggPT09IDEgPyBjb21wc1swXSA6IGNvbXBzO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVzZXJpYWxpemVBZGRyZXNzRmllbGQoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGRhdGEuc3BsaXQoJ3wnKTtcclxuICAgIHJldHVybiBhZGRyZXNzZXMubGVuZ3RoID09PSAxID8gYWRkcmVzc2VzWzBdIDogYWRkcmVzc2VzO1xyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplQWRkcmVzc2VzRmllbGQoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIFBlcmZvcm0gYSBjYXN0IGhlcmUgc2luY2UgVFMgZG9lc24ndCBrbm93IHdlJ3JlIGd1YXJhbnRlZWQgYSBub24tZW1wdHlcclxuICAgIC8vIGFycmF5IGZyb20gZGVzZXJpYWxpemluZy5cclxuICAgIHJldHVybiBkYXRhXHJcbiAgICAgICAgLnNwbGl0KCd8JylcclxuICAgICAgICAubWFwKGFkZHJlc3NTdHIgPT4gYWRkcmVzc1N0ci5zcGxpdCgnLCcpKVxyXG4gICAgICAgIC5tYXAoYWRkcmVzc1BhaXIgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGFkZHJlc3NQYWlyWzBdICE9PSAnKicgJiYgeyB0bzogYWRkcmVzc1BhaXJbMF0gfSkpLCAoYWRkcmVzc1BhaXJbMV0gIT09ICcqJyAmJiB7IGZyb206IGFkZHJlc3NQYWlyWzFdIH0pKSkpO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgV2Vic29ja2V0IG5hbWVzcGFjZSBjb250YWlucyBhbGwgc3Vic2NyaXB0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zIHRoYXRcclxuICogYWxsb3cgeW91IHRvIHN1YnNjcmliZSB0byBldmVudHMgYW5kIHJlY2VpdmUgdXBkYXRlcyBhcyB0aGV5IG9jY3VyLiBUaGVcclxuICogdW5kZXJseWluZyBXZWJTb2NrZXQgcHJvdmlkZXIgaGFzIGFkZGl0aW9uYWwgbG9naWMgdG8gaGFuZGxlIHJlY29ubmVjdGlvbnNcclxuICogYW5kIGF1dG9tYXRpY2FsbHkgYmFja2ZpbGxzIG1pc3NlZCBldmVudHMuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIGNvcmUgbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS53c2AuXHJcbiAqL1xyXG5jbGFzcyBXZWJTb2NrZXROYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgZm9yIGVhY2gge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIEFsc29cclxuICAgICAqIGluY2x1ZGVzIEFsY2hlbXkncyBTdWJzY3JpcHRpb24gQVBJIGV2ZW50cy4gU2VlIHtAbGluayBBbGNoZW15RXZlbnRUeXBlfSBmb3JcclxuICAgICAqIGhvdyB0byB1c2UgdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHZvaWQgKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5vbihwcm9jZXNzZWRFdmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYmUgdHJpZ2dlcmVkIGZvciBvbmx5IHRoZSBuZXh0IHtAbGluayBldmVudE5hbWV9IGV2ZW50LFxyXG4gICAgICogYWZ0ZXIgd2hpY2ggaXQgd2lsbCBiZSByZW1vdmVkLiBBbHNvIGluY2x1ZGVzIEFsY2hlbXkncyBTdWJzY3JpcHRpb24gQVBJXHJcbiAgICAgKiBldmVudHMuIFNlZSB7QGxpbmsgQWxjaGVteUV2ZW50VHlwZX0gZm9yIGhvdyB0byB1c2UgdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UocHJvY2Vzc2VkRXZlbnQsIGxpc3RlbmVyKTtcclxuICAgICAgICB9KSkoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQge0BsaW5rIGxpc3RlbmVyfSBmb3IgdGhlIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBub1xyXG4gICAgICogbGlzdGVuZXIgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gdW5saXN0ZW4gdG8uXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2b2lkICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLm9mZihwcm9jZXNzZWRFdmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBubyBldmVudFxyXG4gICAgICogaXMgcHJvdmlkZWQsIGFsbCBldmVudHMgYW5kIHRoZWlyIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICB2b2lkICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IGV2ZW50TmFtZVxyXG4gICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSlcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBwcm92aWRlci5yZW1vdmVBbGxMaXN0ZW5lcnMocHJvY2Vzc2VkRXZlbnQpO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgdGhlIHRvdGFsIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSBldmVudE5hbWVcclxuICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmxpc3RlbmVyQ291bnQocHJvY2Vzc2VkRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSBpbmNsdWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSBldmVudE5hbWVcclxuICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmxpc3RlbmVycyhwcm9jZXNzZWRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIEVOUyBhZGRyZXNzZXMgaW4gYW4gQWxjaGVteSBFdmVudCB0byB0aGUgdW5kZXJseWluZyByZXNvbHZlZFxyXG4gICAgICogYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBWSVNJQkxFIE9OTFkgRk9SIFRFU1RJTkcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUubWV0aG9kID09PSBleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TICYmXHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWUuYWRkcmVzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRBZGRyZXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBldmVudE5hbWUuYWRkcmVzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MudG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50byA9IHlpZWxkIHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihhZGRyZXNzLnRvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmZyb20gPSB5aWVsZCB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoYWRkcmVzcy5mcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWUuYWRkcmVzc2VzID1cclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBZGRyZXNzZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lLm1ldGhvZCA9PT0gZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLmZyb21BZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUuZnJvbUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5mcm9tQWRkcmVzcyA9IHlpZWxkIHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihldmVudE5hbWUuZnJvbUFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLmZyb21BZGRyZXNzID0geWllbGQgUHJvbWlzZS5hbGwoZXZlbnROYW1lLmZyb21BZGRyZXNzLm1hcChhZGRyZXNzID0+IHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihhZGRyZXNzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUudG9BZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUudG9BZGRyZXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUudG9BZGRyZXNzID0geWllbGQgdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGV2ZW50TmFtZS50b0FkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLnRvQWRkcmVzcyA9IHlpZWxkIFByb21pc2UuYWxsKGV2ZW50TmFtZS50b0FkZHJlc3MubWFwKGFkZHJlc3MgPT4gdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGFkZHJlc3MpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBFTlMgYWRkcmVzcyBvciB0aHJvd3MgYW4gZXJyb3IuIFRoaXMgaW1wcm92ZXMgY29kZVxyXG4gICAgICogcmVhZGFiaWxpdHkgYW5kIHR5cGUgc2FmZXR5IGluIG90aGVyIG1ldGhvZHMuXHJcbiAgICAgKlxyXG4gICAgICogVklTSUJMRSBPTkxZIEZPUiBURVNUSU5HLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcmVzb2x2ZU5hbWVPckVycm9yKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCBwcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHRoZSBFTlMgYWRkcmVzczogJHtuYW1lfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogVGhlIEFsY2hlbXkgU0RLIGNsaWVudC4gVGhpcyBjbGFzcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBpbnRvIEFsY2hlbXknc1xyXG4gKiBBUElzIGFuZCBzZXBhcmF0ZXMgZnVuY3Rpb25hbGl0eSBpbnRvIGRpZmZlcmVudCBuYW1lc3BhY2VzLlxyXG4gKlxyXG4gKiBFYWNoIFNESyBpbnN0YW5jZSBpcyBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBuZXR3b3JrIGFuZCBBUEkga2V5LiBUbyB1c2UgYVxyXG4gKiBkaWZmZXJlbnQgbmV0d29yayBvciBBUEkga2V5LCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIEFsY2hlbXl9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXR0aW5ncy5hcGlLZXldIC0gVGhlIEFQSSBrZXkgdG8gdXNlIGZvciBBbGNoZW15XHJcbiAgICAgKiBAcGFyYW0ge05ldHdvcmt9IFtzZXR0aW5ncy5uZXR3b3JrXSAtIFRoZSBuZXR3b3JrIHRvIHVzZSBmb3IgQWxjaGVteVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzZXR0aW5ncy5tYXhSZXRyaWVzXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIHRvIGF0dGVtcHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2V0dGluZ3MucmVxdWVzdFRpbWVvdXRdIC0gVGhlIHRpbWVvdXQgYWZ0ZXIgd2hpY2ggcmVxdWVzdCBzaG91bGQgZmFpbFxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gbmV3IEFsY2hlbXlDb25maWcoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMuY29yZSA9IG5ldyBDb3JlTmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLm5mdCA9IG5ldyBOZnROYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0TmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLnRyYW5zYWN0ID0gbmV3IFRyYW5zYWN0TmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLm5vdGlmeSA9IG5ldyBOb3RpZnlOYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBuZXcgRGVidWdOYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgV2FsbGV0IGNsYXNzIGluaGVyaXRzIFNpZ25lciBhbmQgY2FuIHNpZ24gdHJhbnNhY3Rpb25zIGFuZCBtZXNzYWdlcyB1c2luZ1xyXG4gKiBhIHByaXZhdGUga2V5IGFzIGEgc3RhbmRhcmQgRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLlxyXG4gKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgRXRoZXJzLmpzJ3MgJ1dhbGxldCcuXHJcbiAqXHJcbiAqIFByaW1hcnkgZGlmZmVyZW5jZSBmcm9tIEV0aGVycy5qcyAnV2FsbGV0JyBpcyB0aGF0IHlvdSBjYW4gcGFzcyBpbiBlaXRoZXIgYVxyXG4gKiBQcm92aWRlciBvciBhbiBBbGNoZW15IG9iamVjdC4gVGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIGludGVsbGlnZW50bHkgZGV0ZWN0XHJcbiAqIHRoZSBmb3JtYXQgYW5kIHNldCB0aGUgcHJvdmlkZXIgYWNjb3JkaW5nbHkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5jbGFzcyBXYWxsZXQgZXh0ZW5kcyB3YWxsZXQuV2FsbGV0IHtcclxuICAgIC8qKlxyXG4gICAgICogT3ZlcmxvYWQgcGVybWl0cyB1c2VycyB0byBwYXNzIGluIGVpdGhlciBhIHN0YW5kYXJkIFByb3ZpZGVyIG9yIGFuIEFsY2hlbXlcclxuICAgICAqIG9iamVjdC4gVGhlIGNvbnN0cnVjdG9yIHdpbGwgZGV0ZWN0IHRoZSBvYmplY3QgdHlwZSBhbmQgaGFuZGxlIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIGFsY2hlbXlPclByb3ZpZGVyKSB7XHJcbiAgICAgICAgLy8gSWYgb2JqZWN0IHBhc3NlZCBpbiBpcyBhIHByb3ZpZGVyLCBzZW5kIHRvIHN1cGVyXHJcbiAgICAgICAgbGV0IHN1cGVyUHJvdmlkZXI7XHJcbiAgICAgICAgaWYgKGFsY2hlbXlPclByb3ZpZGVyICYmIGFic3RyYWN0UHJvdmlkZXIuUHJvdmlkZXIuaXNQcm92aWRlcihhbGNoZW15T3JQcm92aWRlcikpIHtcclxuICAgICAgICAgICAgc3VwZXJQcm92aWRlciA9IGFsY2hlbXlPclByb3ZpZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihwcml2YXRlS2V5LCBzdXBlclByb3ZpZGVyKTtcclxuICAgICAgICAvLyBJZiBvYmplY3QgcGFzc2VkIGluIGlzIGFuIEFsY2hlbXkgb2JqZWN0LCBqdXN0IHNldCBBbGNoZW15XHJcbiAgICAgICAgaWYgKGFsY2hlbXlPclByb3ZpZGVyICYmICFhYnN0cmFjdFByb3ZpZGVyLlByb3ZpZGVyLmlzUHJvdmlkZXIoYWxjaGVteU9yUHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxjaGVteVByb3ZpZGVyUHJvbWlzZSA9IGFsY2hlbXlPclByb3ZpZGVyLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gU2V0IG9mIG92ZXJyaWRlcyBmcm9tIFNpZ25lciB0byBoYW5kbGUgYXN5bmMgcHJvdmlkZXIgcmV0cmlldmFsLlxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXQgYXQgYmxvY2tUYWcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBibG9jayB0byBjaGVjayB0aGUgYmFsYW5jZSBvZlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGdldEJhbGFuY2UoYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuZ2V0QmFsYW5jZShibG9ja1RhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRoaXMgYWNjb3VudCBoYXMgZXZlciBzZW50LiBUaGlzIGlzIHRoZVxyXG4gICAgICogdmFsdWUgcmVxdWlyZWQgdG8gYmUgaW5jbHVkZWQgaW4gdHJhbnNhY3Rpb25zIGFzIHRoZSBub25jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIGJsb2NrIHRvIGNoZWNrIHRoZSB0cmFuc2FjdGlvbiBjb3VudCBvblxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uQ291bnQoYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZXN0aW1hdGluZyB0aGUgY29zdCB0byBzZW5kIHRoZSB0cmFuc2FjdGlvblJlcXVlc3QsXHJcbiAgICAgKiB3aXRoIHRoaXMgYWNjb3VudCBhZGRyZXNzIGJlaW5nIHVzZWQgYXMgdGhlIGZyb20gZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIHRoZSBnYXMgb25cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY2FsbGluZyB1c2luZyB0aGUgdHJhbnNhY3Rpb25SZXF1ZXN0LCB3aXRoIHRoaXNcclxuICAgICAqIGFjY291bnQgYWRkcmVzcyBiZWluZyB1c2VkIGFzIHRoZSBmcm9tIGZpZWxkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUbyBtYWtlIGEgY2FsbCBvblxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBibG9jayB0byBtYWtlIHRoZSBjYWxsIG9uXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBgZnJvbWAgbWF0Y2hlcyB0aGlzXHJcbiAgICAgKiBgU2lnbmVyYC4gUmVzb2x2ZXMgRU5TIG5hbWVzIGFuZCBwb3B1bGF0ZXMgZmllbGRzIGxpa2UgYGdhc1ByaWNlYCwgYGdhc0xpbWl0YCxcclxuICAgICAqIGBub25jZWAsIGFuZCBgY2hhaW5JZGAgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gdG8gcG9wdWxhdGUuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgcG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBvcHVsYXRlcyBhbGwgZmllbGRzIGluIGEgdHJhbnNhY3Rpb24sIHNpZ25zIGl0IGFuZCBzZW5kcyBpdCB0byB0aGUgbmV0d29ya1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gdG8gc2VuZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNoYWluIElEIHRoaXMgd2FsbGV0IGlzIGNvbm5lY3RlZCB0by5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhaW5JZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuZ2V0Q2hhaW5JZCgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBnYXMgcHJpY2UuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGdldEdhc1ByaWNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRHYXNQcmljZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCByZWNvbW1lbmRlZCBGZWVEYXRhIHRvIHVzZSBpbiBhIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEZvciBhbiBFSVAtMTU1OSB0cmFuc2FjdGlvbiwgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXNcclxuICAgICAqIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIGFuZCBuZXR3b3JrcyB3aGljaCBkbyBub3Qgc3VwcG9ydCBFSVAtMTU1OSwgdGhlXHJcbiAgICAgKiBnYXNQcmljZSBzaG91bGQgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0RmVlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQuZ2V0RmVlRGF0YSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgdGhlIGFkZHJlc3Mgb2YgbmFtZS4gSWYgdGhlIG5hbWUgaXMgbm90IG93bmVkLCBvciBkb2VzIG5vdCBoYXZlIGFcclxuICAgICAqIFJlc29sdmVyIGNvbmZpZ3VyZWQsIG9yIHRoZSBSZXNvbHZlciBkb2VzIG5vdCBoYXZlIGFuIGFkZHJlc3MgY29uZmlndXJlZCxcclxuICAgICAqIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgRU5TIGFkZHJlc3NcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LnJlc29sdmVOYW1lKG5hbWUpKTtcclxuICAgIH1cclxuICAgIGdldFdhbGxldCgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGNoZW15UHJvdmlkZXJQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoeWllbGQgdGhpcy5hbGNoZW15UHJvdmlkZXJQcm9taXNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogVGhlIENvbnRyYWN0IGNsYXNzIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIENvbnRyYWN0IGNsYXNzIGZyb20gZXRoZXJzLmpzIGFuZFxyXG4gKiBpcyBleHBvcnRlZCBoZXJlIGZvciBjb252ZW5pZW5jZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuLy8gVE9ETzogc3VwcG9ydCBwYXNzaW5nIGluIEFsY2hlbXkgaW5zdGFuY2UgaW50byB0aGUgY29udHJhY3QuXHJcbmNsYXNzIENvbnRyYWN0IGV4dGVuZHMgY29udHJhY3RzLkNvbnRyYWN0IHtcclxufVxyXG4vKipcclxuICogVGhlIENvbnRyYWN0RmFjdG9yeSBjbGFzcyBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBDb250cmFjdEZhY3RvcnkgY2xhc3MgZnJvbVxyXG4gKiBldGhlcnMuanMgYW5kIGlzIGV4cG9ydGVkIGhlcmUgZm9yIGNvbnZlbmllbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBDb250cmFjdEZhY3RvcnkgZXh0ZW5kcyBjb250cmFjdHMuQ29udHJhY3RGYWN0b3J5IHtcclxufVxuXG5leHBvcnRzLkFMQ0hFTVlfRVZFTlRfVFlQRVMgPSBBTENIRU1ZX0VWRU5UX1RZUEVTO1xuZXhwb3J0cy5BTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFID0gQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRTtcbmV4cG9ydHMuQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFID0gQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFO1xuZXhwb3J0cy5BbGNoZW15ID0gQWxjaGVteTtcbmV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gQ29udHJhY3RGYWN0b3J5O1xuZXhwb3J0cy5DdXN0b21OZXR3b3JrcyA9IEN1c3RvbU5ldHdvcmtzO1xuZXhwb3J0cy5ERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSA9IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xuZXhwb3J0cy5ERUZBVUxUX05FVFdPUksgPSBERUZBVUxUX05FVFdPUks7XG5leHBvcnRzLkV0aGVyc0V2ZW50ID0gRXRoZXJzRXZlbnQ7XG5leHBvcnRzLkV0aGVyc05ldHdvcmsgPSBFdGhlcnNOZXR3b3JrO1xuZXhwb3J0cy5JU19CUk9XU0VSID0gSVNfQlJPV1NFUjtcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5leHBvcnRzLldhbGxldCA9IFdhbGxldDtcbmV4cG9ydHMuX19hd2FpdGVyID0gX19hd2FpdGVyJDE7XG5leHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG5leHBvcnRzLmZyb21IZXggPSBmcm9tSGV4O1xuZXhwb3J0cy5nZXRBbGNoZW15RXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWc7XG5leHBvcnRzLmdldEFsY2hlbXlIdHRwVXJsID0gZ2V0QWxjaGVteUh0dHBVcmw7XG5leHBvcnRzLmdldEFsY2hlbXlXc1VybCA9IGdldEFsY2hlbXlXc1VybDtcbmV4cG9ydHMuaXNBbGNoZW15RXZlbnQgPSBpc0FsY2hlbXlFdmVudDtcbmV4cG9ydHMuaXNIZXggPSBpc0hleDtcbmV4cG9ydHMubG9nV2FybiA9IGxvZ1dhcm47XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IHNldExvZ0xldmVsO1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy52ZXJpZnlBbGNoZW15RXZlbnROYW1lID0gdmVyaWZ5QWxjaGVteUV2ZW50TmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LTc2OWU1MmI2LmpzLm1hcFxuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImJpZ251bWJlciIsImF4aW9zIiwiYWJzdHJhY3RQcm92aWRlciIsIndhbGxldCIsImNvbnRyYWN0cyIsIl9pbnRlcm9wRGVmYXVsdExlZ2FjeSIsImUiLCJheGlvc19fZGVmYXVsdCIsImV4cG9ydHMiLCJOZXR3b3JrIiwiVG9rZW5CYWxhbmNlVHlwZSIsIkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkiLCJHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSIsIlNvcnRpbmdPcmRlciIsIk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMiLCJBbGNoZW15U3Vic2NyaXB0aW9uIiwiU2ltdWxhdGVBc3NldFR5cGUiLCJTaW11bGF0ZUNoYW5nZVR5cGUiLCJEZWNvZGluZ0F1dGhvcml0eSIsIkRlYnVnQ2FsbFR5cGUiLCJHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cyIsIldlYmhvb2tWZXJzaW9uIiwiV2ViaG9va1R5cGUiLCJDb21taXRtZW50TGV2ZWwiLCJEZWJ1Z1RyYWNlclR5cGUiLCJOZnRUb2tlblR5cGUiLCJOZnRTcGFtQ2xhc3NpZmljYXRpb24iLCJOZnRGaWx0ZXJzIiwiTmZ0T3JkZXJpbmciLCJOZnRTYWxlTWFya2V0cGxhY2UiLCJOZnRTYWxlVGFrZXJUeXBlIiwiTmZ0UmVmcmVzaFN0YXRlIiwiTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIiwiX19hd2FpdGVyJDEiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fdmFsdWVzIiwibyIsInMiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm0iLCJpIiwiY2FsbCIsImxlbmd0aCIsIlR5cGVFcnJvciIsIl9fYXdhaXQiLCJ2IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJnIiwicSIsInZlcmIiLCJuIiwiYSIsImIiLCJwdXNoIiwicmVzdW1lIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJmIiwic2hpZnQiLCJfX2FzeW5jVmFsdWVzIiwiZCIsIkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZIiwiREVGQVVMVF9ORVRXT1JLIiwiRVRIX01BSU5ORVQiLCJERUZBVUxUX01BWF9SRVRSSUVTIiwiREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQiLCJnZXRBbGNoZW15SHR0cFVybCIsIm5ldHdvcmsiLCJhcGlLZXkiLCJnZXRBbGNoZW15TmZ0SHR0cFVybCIsImdldEFsY2hlbXlXc1VybCIsImdldEFsY2hlbXlXZWJob29rSHR0cFVybCIsIkFsY2hlbXlBcGlUeXBlIiwiRXRoZXJzTmV0d29yayIsIkVUSF9HT0VSTEkiLCJFVEhfU0VQT0xJQSIsIk9QVF9NQUlOTkVUIiwiT1BUX0dPRVJMSSIsIk9QVF9TRVBPTElBIiwiQVJCX01BSU5ORVQiLCJBUkJfR09FUkxJIiwiQVJCX1NFUE9MSUEiLCJNQVRJQ19NQUlOTkVUIiwiTUFUSUNfTVVNQkFJIiwiTUFUSUNfQU1PWSIsIkFTVEFSX01BSU5ORVQiLCJQT0xZR09OWktFVk1fTUFJTk5FVCIsIlBPTFlHT05aS0VWTV9URVNUTkVUIiwiQkFTRV9NQUlOTkVUIiwiQkFTRV9HT0VSTEkiLCJCQVNFX1NFUE9MSUEiLCJaS1NZTkNfTUFJTk5FVCIsIlpLU1lOQ19TRVBPTElBIiwiQ3VzdG9tTmV0d29ya3MiLCJjaGFpbklkIiwibmFtZSIsInNlcG9saWEiLCJtYXRpY2Ftb3kiLCJub29wIiwiRVRIX05VTExfVkFMVUUiLCJFVEhfTlVMTF9BRERSRVNTIiwiQWxjaGVteUNvbmZpZyIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibWF4UmV0cmllcyIsInVybCIsImF1dGhUb2tlbiIsImJhdGNoUmVxdWVzdHMiLCJyZXF1ZXN0VGltZW91dCIsImNvbm5lY3Rpb25JbmZvT3ZlcnJpZGVzIiwiX2dldFJlcXVlc3RVcmwiLCJhcGlUeXBlIiwidW5kZWZpbmVkIiwiTkZUIiwiV0VCSE9PSyIsImdldFByb3ZpZGVyIiwiX2Jhc2VBbGNoZW15UHJvdmlkZXIiLCJBbGNoZW15UHJvdmlkZXIiLCJnZXRXZWJTb2NrZXRQcm92aWRlciIsIl9iYXNlQWxjaGVteVdzc1Byb3ZpZGVyIiwiQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIiwidmVyc2lvbiQxIiwiX3Blcm1hbmVudENlbnNvckVycm9ycyIsIl9jZW5zb3JFcnJvcnMiLCJMb2dMZXZlbHMiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuaW5nIiwiZXJyb3IiLCJvZmYiLCJfbG9nTGV2ZWwiLCJfZ2xvYmFsTG9nZ2VyIiwiX2NoZWNrTm9ybWFsaXplIiwibWlzc2luZyIsImZvckVhY2giLCJmb3JtIiwibm9ybWFsaXplIiwiRXJyb3IiLCJqb2luIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWVzc2FnZSIsIl9ub3JtYWxpemVFcnJvciIsIkxvZ0xldmVsJDEiLCJMb2dMZXZlbCIsIkVycm9yQ29kZSIsIkhFWCIsIkxvZ2dlciQxIiwidmVyc2lvbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiX2xvZyIsImxvZ0xldmVsIiwiYXJncyIsImxldmVsIiwidG9Mb3dlckNhc2UiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25zb2xlIiwibG9nIiwibGV2ZWxzIiwiREVCVUciLCJJTkZPIiwid2FybiIsIldBUk5JTkciLCJtYWtlRXJyb3IiLCJjb2RlIiwicGFyYW1zIiwiZXJyb3JzIiwiVU5LTk9XTl9FUlJPUiIsIm1lc3NhZ2VEZXRhaWxzIiwia2V5cyIsImtleSIsIlVpbnQ4QXJyYXkiLCJoZXgiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJyZWFzb24iLCJOVU1FUklDX0ZBVUxUIiwiZmF1bHQiLCJDQUxMX0VYQ0VQVElPTiIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk1JU1NJTkdfTkVXIiwiTk9OQ0VfRVhQSVJFRCIsIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInRocm93RXJyb3IiLCJJTlZBTElEX0FSR1VNRU5UIiwiYXJndW1lbnQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJhc3NlcnRBcmd1bWVudCIsImNoZWNrTm9ybWFsaXplIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwiY2hlY2tTYWZlVWludDUzIiwiY2hlY2tBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiTUlTU0lOR19BUkdVTUVOVCIsIlVORVhQRUNURURfQVJHVU1FTlQiLCJjaGVja05ldyIsInRhcmdldCIsImtpbmQiLCJjaGVja0Fic3RyYWN0IiwiZ2xvYmFsTG9nZ2VyIiwic2V0Q2Vuc29yc2hpcCIsImNlbnNvcnNoaXAiLCJwZXJtYW5lbnQiLCJzZXRMb2dMZXZlbCIsImZyb20iLCJfX2F3YWl0ZXIiLCJsb2dnZXIiLCJkZWZpbmVSZWFkT25seSIsIm9iamVjdCIsInJlc29sdmVQcm9wZXJ0aWVzIiwicHJvbWlzZXMiLCJtYXAiLCJyZXN1bHRzIiwiYWxsIiwicmVkdWNlIiwiYWNjdW0iLCJvcGFxdWUiLCJiaWdpbnQiLCJib29sZWFuIiwibnVtYmVyIiwic3RyaW5nIiwiX2lzRnJvemVuIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNGcm96ZW4iLCJfZGVlcENvcHkiLCJmcmVlemUiLCJpdGVtIiwiZGVlcENvcHkiLCJmcm9tSGV4IiwiaGV4U3RyaW5nIiwiQmlnTnVtYmVyIiwidG9OdW1iZXIiLCJ0b0hleCIsIm51bSIsInRvSGV4U3RyaW5nIiwiaXNIZXgiLCJwb3NzaWJsZUhleFN0cmluZyIsInRlc3QiLCJmb3JtYXRCbG9jayIsImJsb2NrIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic3RyaW5nVG9FbnVtIiwieCIsImVudW1iIiwidmFsdWVzIiwiaW5jbHVkZXMiLCJnZXROZnRDb250cmFjdEZvck5mdEZyb21SYXciLCJyYXdOZnRDb250cmFjdCIsIm51bGxzVG9VbmRlZmluZWQiLCJhc3NpZ24iLCJnZXROZnRDb250cmFjdEZyb21SYXciLCJzcGFtQ2xhc3NpZmljYXRpb25zIiwicGFyc2VOZnRTcGFtQ2xhc3NpZmljYXRpb24iLCJnZXROZnRDb250cmFjdHNGb3JPd25lckZyb21SYXciLCJkaXNwbGF5TmZ0IiwiaW1hZ2UiLCJ0b3RhbEJhbGFuY2UiLCJudW1EaXN0aW5jdFRva2Vuc093bmVkIiwiaXNTcGFtIiwiX2EiLCJ0b2tlblR5cGUiLCJwYXJzZU5mdFRva2VuVHlwZSIsIm9wZW5TZWFNZXRhZGF0YSIsInNhZmVsaXN0UmVxdWVzdFN0YXR1cyIsImdldE5mdENvbGxlY3Rpb25Gcm9tUmF3IiwicmF3TmZ0Q29sbGVjdGlvbiIsImZsb29yUHJpY2UiLCJtYXJrZXRwbGFjZSIsInBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIiwiZ2V0QmFzZU5mdEZyb21SYXciLCJyYXdCYXNlTmZ0IiwiY29udHJhY3RBZGRyZXNzIiwidG9rZW5JZCIsImdldE5mdEZyb21SYXciLCJyYXdOZnQiLCJjb250cmFjdCIsImFjcXVpcmVkQXQiLCJjb2xsZWN0aW9uIiwibWludCIsImdldE5mdFNhbGVzRnJvbVJhdyIsInJhd05mdFNhbGVzIiwibmZ0U2FsZXMiLCJyYXdOZnRTYWxlIiwicGFyc2VOZnRTYWxlTWFya2V0cGxhY2UiLCJ0YWtlciIsInBhcnNlTmZ0VGFrZXIiLCJ2YWxpZEF0IiwicGFnZUtleSIsIkxPT0tTUkFSRSIsIlNFQVBPUlQiLCJYMlkyIiwiV1lWRVJOIiwiQ1JZUFRPUFVOS1MiLCJCTFVSIiwiVU5LTk9XTiIsIk9QRU5TRUEiLCJCVVlFUiIsIlNFTExFUiIsInJlcyIsIlVua25vd24iLCJFUkM3MjEiLCJFUkMxMTU1IiwiTk9fU1VQUE9SVEVEX05GVF9TVEFOREFSRCIsIk5PVF9BX0NPTlRSQUNUIiwiSVNfQlJPV1NFUiIsIndpbmRvdyIsIm9iaiIsImdldEFzc2V0VHJhbnNmZXJzIiwic3JjTWV0aG9kIiwicHJvdmlkZXIiLCJmcm9tQWRkcmVzcyIsIl9nZXRBZGRyZXNzIiwidG9BZGRyZXNzIiwiX3NlbmQiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibWF4Q291bnQiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHRzIiwiZ2V0TG9ncyIsImZpbHRlciIsImdldE5ldHdvcmsiLCJnZXRGaWx0ZXIiLCJsb2dzIiwic2VuZCIsInJlbW92ZWQiLCJhcnJheU9mIiwiZm9ybWF0dGVyIiwiZmlsdGVyTG9nIiwiYmluZCIsInJlc29sdmVkRmlsdGVyIiwiX2dldEJsb2NrVGFnIiwiYWRkcmVzcyIsImZvcm1hdCIsImFycmF5IiwiQ29yZU5hbWVzcGFjZSIsImdldEJhbGFuY2UiLCJhZGRyZXNzT3JOYW1lIiwiYmxvY2tUYWciLCJpc0NvbnRyYWN0QWRkcmVzcyIsImdldENvZGUiLCJnZXRTdG9yYWdlQXQiLCJwb3NpdGlvbiIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRCbG9jayIsImJsb2NrSGFzaE9yQmxvY2tUYWciLCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMiLCJnZXRCbG9ja051bWJlciIsImdldEdhc1ByaWNlIiwiZ2V0RmVlRGF0YSIsInJlYWR5IiwidHJhbnNhY3Rpb24iLCJlc3RpbWF0ZUdhcyIsImdldFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25IYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Iiwic2VuZFRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25zIiwidGltZW91dCIsIm1ldGhvZCIsImZpbmRDb250cmFjdERlcGxveWVyIiwiY3VycmVudEJsb2NrTnVtIiwiZmlyc3RCbG9jayIsImJpbmFyeVNlYXJjaEZpcnN0QmxvY2siLCJ0eFJlY2VpcHRzIiwiYmxvY2tOdW1iZXIiLCJtYXRjaGluZ1JlY2VpcHQiLCJyZWNlaXB0cyIsImZpbmQiLCJyZWNlaXB0IiwiZGVwbG95ZXJBZGRyZXNzIiwiZ2V0VG9rZW5CYWxhbmNlcyIsImNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zIiwiRVJDMjAiLCJ0eXBlIiwiZ2V0VG9rZW5zRm9yT3duZXIiLCJvcHRpb25zIiwiY29udHJhY3RBZGRyZXNzZXMiLCJyZXNwb25zZSIsImZvcm1hdHRlZEJhbGFuY2VzIiwidG9rZW5CYWxhbmNlcyIsImJhbGFuY2UiLCJyYXdCYWxhbmNlIiwidG9rZW5CYWxhbmNlIiwibWV0YWRhdGFQcm9taXNlcyIsImFsbFNldHRsZWQiLCJ0b2tlbiIsIm1ldGFkYXRhIiwicCIsInN0YXR1cyIsInN5bWJvbCIsImRlY2ltYWxzIiwibG9nbyIsIm93bmVkVG9rZW5zIiwiaW5kZXgiLCJmb3JtYXRVbml0cyIsInRva2VucyIsInQiLCJnZXRUb2tlbk1ldGFkYXRhIiwicmVzb2x2ZU5hbWUiLCJsb29rdXBBZGRyZXNzIiwic3RhcnQiLCJlbmQiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJEZWJ1Z05hbWVzcGFjZSIsInRyYWNlQ2FsbCIsImJsb2NrSWRlbnRpZmllciIsInRyYWNlciIsInBhcnNlVHJhY2VyUGFyYW1zIiwidHJhY2VUcmFuc2FjdGlvbiIsInRyYWNlQmxvY2siLCJpc0hleFN0cmluZyIsImhleFN0cmlwWmVyb3MiLCJoZXhWYWx1ZSIsIm9ubHlUb3BDYWxsIiwidHJhY2VyQ29uZmlnIiwic2FuaXRpemVUb2tlblR5cGUiLCJsb2dMZXZlbFN0cmluZ1RvRW51bSIsIldBUk4iLCJFUlJPUiIsInNpbGVudCIsIlNJTEVOVCIsImxvZ0xldmVsVG9Db25zb2xlRm4iLCJERUZBVUxUX0xPR19MRVZFTCIsImxvZ2dlckNsaWVudCIsImxvZ0RlYnVnIiwibG9nSW5mbyIsImxvZ1dhcm4iLCJMb2dnZXIiLCJ2YWwiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJWRVJTSU9OIiwic2VuZEF4aW9zUmVxdWVzdCIsImJhc2VVcmwiLCJyZXN0QXBpTmFtZSIsIm1ldGhvZE5hbWUiLCJvdmVycmlkZXMiLCJyZXF1ZXN0VXJsIiwiaGVhZGVycyIsIkRFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TIiwiREVGQVVMVF9CQUNLT0ZGX01VTFRJUExJRVIiLCJERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TIiwiREVGQVVMVF9CQUNLT0ZGX01BWF9BVFRFTVBUUyIsIkV4cG9uZW50aWFsQmFja29mZiIsIm1heEF0dGVtcHRzIiwiaW5pdGlhbERlbGF5TXMiLCJiYWNrb2ZmTXVsdGlwbGllciIsIm1heERlbGF5TXMiLCJudW1BdHRlbXB0cyIsImN1cnJlbnREZWxheU1zIiwiaXNJbkJhY2tvZmYiLCJiYWNrb2ZmIiwiYmFja29mZkRlbGF5V2l0aEppdHRlck1zIiwid2l0aEppdHRlck1zIiwibWF4IiwibWluIiwic2V0VGltZW91dCIsImRlbGF5TXMiLCJyYW5kb20iLCJyZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImVyciIsImRhdGEiLCJpc0F4aW9zRXJyb3IiLCJpc1JldHJ5YWJsZUh0dHBFcnJvciIsInJldHJ5YWJsZUNvZGVzIiwicGFnaW5hdGVFbmRwb2ludCIsInJlcVBhZ2VLZXkiLCJyZXNQYWdlS2V5IiwiYXJndW1lbnRzIiwicGFnaW5hdGVFbmRwb2ludF8xIiwiaGFzTmV4dCIsInJlcXVlc3RQYXJhbXMiLCJnZXROZnRNZXRhZGF0YSIsInRva2VuVXJpVGltZW91dEluTXMiLCJyZWZyZXNoQ2FjaGUiLCJnZXROZnRNZXRhZGF0YUJhdGNoIiwibmZ0cyIsIm5mdCIsImdldENvbnRyYWN0TWV0YWRhdGEiLCJnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2giLCJnZXRDb2xsZWN0aW9uTWV0YWRhdGEiLCJjb2xsZWN0aW9uU2x1ZyIsImdldE5mdHNGb3JPd25lckl0ZXJhdG9yIiwib3duZXIiLCJnZXROZnRzRm9yT3duZXJJdGVyYXRvcl8xIiwiZV8xIiwid2l0aE1ldGFkYXRhIiwib21pdE1ldGFkYXRhVG9XaXRoTWV0YWRhdGEiLCJvbWl0TWV0YWRhdGEiLCJfYiIsImV4Y2x1ZGVGaWx0ZXJzIiwiaW5jbHVkZUZpbHRlcnMiLCJvcmRlckJ5IiwiX2MiLCJvd25lZE5mdCIsIm93bmVkTmZ0cyIsIm5mdEZyb21HZXROZnRSZXNwb25zZSIsImVfMV8xIiwicmV0dXJuIiwiZ2V0TmZ0c0Zvck93bmVyIiwicGFnZVNpemUiLCJ0b3RhbENvdW50IiwiZ2V0TmZ0c0ZvckNvbnRyYWN0IiwibGltaXQiLCJnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvciIsImdldE5mdHNGb3JDb250cmFjdEl0ZXJhdG9yXzEiLCJlXzIiLCJuZnRGcm9tR2V0TmZ0Q29udHJhY3RSZXNwb25zZSIsImVfMl8xIiwiZ2V0T3duZXJzRm9yQ29udHJhY3QiLCJ3aXRoVG9rZW5CYWxhbmNlcyIsIm93bmVycyIsImdldENvbnRyYWN0c0Zvck93bmVyIiwiZ2V0T3duZXJzRm9yTmZ0IiwiZ2V0TWludGVkTmZ0cyIsIm93bmVyQWRkcmVzcyIsImNhdGVnb3J5IiwibmZ0VG9rZW5UeXBlVG9DYXRlZ29yeSIsImV4Y2x1ZGVaZXJvVmFsdWUiLCJnZXROZnRzRm9yVHJhbnNmZXJzIiwiZ2V0VHJhbnNmZXJzRm9yT3duZXIiLCJ0cmFuc2ZlclR5cGUiLCJUTyIsInRyYW5zZmVyc1Jlc3BvbnNlIiwiZ2V0VHJhbnNmZXJzRm9yQ29udHJhY3QiLCJTUEVDSUFMTkZUIiwib3JkZXIiLCJwYXJzZTExNTVUcmFuc2ZlciIsInRyYW5zZmVyIiwiZXJjMTE1NU1ldGFkYXRhIiwicmF3Q29udHJhY3QiLCJ2ZXJpZnlOZnRPd25lcnNoaXAiLCJhY2MiLCJjdXJyIiwiaXNTcGFtQ29udHJhY3QiLCJnZXRTcGFtQ29udHJhY3RzIiwicmVwb3J0U3BhbSIsImlzQWlyZHJvcE5mdCIsImdldEZsb29yUHJpY2UiLCJnZXROZnRTYWxlcyIsInNlbGxlckFkZHJlc3MiLCJidXllckFkZHJlc3MiLCJjb21wdXRlUmFyaXR5Iiwic2VhcmNoQ29udHJhY3RNZXRhZGF0YSIsInF1ZXJ5Iiwic3VtbWFyaXplTmZ0QXR0cmlidXRlcyIsInJlZnJlc2hOZnRNZXRhZGF0YSIsInRva2VuSWRTdHJpbmciLCJmaXJzdCIsInNlY29uZCIsInJlZnJlc2giLCJ0aW1lTGFzdFVwZGF0ZWQiLCJyZWZyZXNoQ29udHJhY3QiLCJyZWZyZXNoU3RhdGUiLCJwYXJzZVJlaW5nZXN0aW9uU3RhdGUiLCJyZWluZ2VzdGlvblN0YXRlIiwicHJvZ3Jlc3MiLCJpc05mdFdpdGhNZXRhZGF0YSIsIm1ldGFkYXRhVHJhbnNmZXJzIiwidHJhbnNmZXJzIiwiZmxhdE1hcCIsImdldFRva2Vuc0Zyb21UcmFuc2ZlciIsInRvIiwiaGFzaCIsImJsb2NrTnVtIiwiYmF0Y2hTaXplIiwicmVxdWVzdEJhdGNoZXMiLCJzbGljZSIsInJlc3BvbnNlQmF0Y2hlcyIsImJhdGNoIiwiZmxhdCIsIm5mdHNCeVRva2VuSWQiLCJNYXAiLCJzZXQiLCJ0cmFuc2ZlcnJlZE5mdHMiLCJnZXQiLCJET0VTX05PVF9FWElTVCIsIkFMUkVBRFlfUVVFVUVEIiwiSU5fUFJPR1JFU1MiLCJGSU5JU0hFRCIsIlFVRVVFRCIsIlFVRVVFX0ZBSUxFRCIsIk5mdE5hbWVzcGFjZSIsIm9wdGlvbnNPclRva2VuVHlwZSIsIk5vdGlmeU5hbWVzcGFjZSIsImdldEFsbFdlYmhvb2tzIiwidmVyaWZ5Q29uZmlnIiwic2VuZFdlYmhvb2tSZXF1ZXN0Iiwid2ViaG9va3MiLCJwYXJzZVJhd1dlYmhvb2tSZXNwb25zZSIsImdldEFkZHJlc3NlcyIsIndlYmhvb2tPcklkIiwid2ViaG9va0lkIiwiaWQiLCJ3ZWJob29rX2lkIiwiYWZ0ZXIiLCJwYXJzZVJhd0FkZHJlc3NBY3Rpdml0eVJlc3BvbnNlIiwiZ2V0R3JhcGhxbFF1ZXJ5IiwicGFyc2VSYXdDdXN0b21HcmFwaHFsV2ViaG9va1Jlc3BvbnNlIiwiZ2V0TmZ0RmlsdGVycyIsInBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlIiwidXBkYXRlV2ViaG9vayIsInVwZGF0ZSIsImlzX2FjdGl2ZSIsImlzQWN0aXZlIiwibmZ0X2ZpbHRlcnNfdG9fYWRkIiwiYWRkRmlsdGVycyIsIm5mdEZpbHRlclRvUGFyYW0iLCJuZnRfZmlsdGVyc190b19yZW1vdmUiLCJyZW1vdmVGaWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnNfdG9fYWRkIiwiYWRkTWV0YWRhdGFGaWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnNfdG9fcmVtb3ZlIiwicmVtb3ZlTWV0YWRhdGFGaWx0ZXJzIiwiYWRkcmVzc2VzX3RvX2FkZCIsInJlc29sdmVBZGRyZXNzZXMiLCJhZGRBZGRyZXNzZXMiLCJhZGRyZXNzZXNfdG9fcmVtb3ZlIiwicmVtb3ZlQWRkcmVzc2VzIiwiYWRkcmVzc2VzIiwibmV3QWRkcmVzc2VzIiwiY3JlYXRlV2ViaG9vayIsImFwcElkIiwiTUlORURfVFJBTlNBQ1RJT04iLCJEUk9QUEVEX1RSQU5TQUNUSU9OIiwiTkVUV09SS19UT19XRUJIT09LX05FVFdPUksiLCJuZnRGaWx0ZXJPYmoiLCJncmFwaHFsUXVlcnkiLCJORlRfQUNUSVZJVFkiLCJORlRfTUVUQURBVEFfVVBEQVRFIiwiZmlsdGVycyIsImNvbnRyYWN0X2FkZHJlc3MiLCJ0b2tlbl9pZCIsIm5mdF9maWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnMiLCJBRERSRVNTX0FDVElWSVRZIiwiR1JBUEhRTCIsIndlYmhvb2tfdHlwZSIsIndlYmhvb2tfdXJsIiwiYXBwX2lkIiwiZ3JhcGhxbF9xdWVyeSIsInBhcnNlUmF3V2ViaG9vayIsImRlbGV0ZVdlYmhvb2siLCJyZXNvbHZlZEFkZHJlc3NlcyIsInJhd0FkZHJlc3MiLCJXRUJIT09LX05FVFdPUktfVE9fTkVUV09SSyIsInJhd1dlYmhvb2siLCJ0aW1lQ3JlYXRlZCIsInRpbWVfY3JlYXRlZCIsInNpZ25pbmdLZXkiLCJzaWduaW5nX2tleSIsInBhZ2luYXRpb24iLCJ0b3RhbF9jb3VudCIsImN1cnNvcnMiLCJHQVNfT1BUSU1JWkVEX1RYX0ZFRV9NVUxUSVBMRVMiLCJUcmFuc2FjdE5hbWVzcGFjZSIsInNlbmRQcml2YXRlVHJhbnNhY3Rpb24iLCJtYXhCbG9ja051bWJlciIsImhleEJsb2NrTnVtYmVyIiwidHgiLCJwcmVmZXJlbmNlcyIsImNhbmNlbFByaXZhdGVUcmFuc2FjdGlvbiIsInR4SGFzaCIsInNpbXVsYXRlQXNzZXRDaGFuZ2VzQnVuZGxlIiwidHJhbnNhY3Rpb25zIiwic2ltdWxhdGVBc3NldENoYW5nZXMiLCJzaW11bGF0ZUV4ZWN1dGlvbkJ1bmRsZSIsInNpbXVsYXRlRXhlY3V0aW9uIiwiZ2V0TWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJmZWVIZXgiLCJzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbk9yU2lnbmVkVHhzIiwiX3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbiIsImdhc0xpbWl0IiwicHJpb3JpdHlGZWUiLCJiYXNlRmVlIiwiY3VycmVudEJsb2NrIiwiYmFzZUZlZVBlckdhcyIsImdhc1NwcmVhZFRyYW5zYWN0aW9ucyIsImdlbmVyYXRlR2FzU3ByZWFkVHJhbnNhY3Rpb25zIiwic2lnbmVkVHJhbnNhY3Rpb25zIiwic2lnblRyYW5zYWN0aW9uIiwiZ2V0R2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMiLCJ0cmFja2luZ0lkIiwicmF3VHJhbnNhY3Rpb25zIiwiZmVlTXVsdGlwbGllciIsIm1heEZlZVBlckdhcyIsInJvdW5kIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUiLCJBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFIiwiQUxDSEVNWV9FVkVOVF9UWVBFUyIsIkV2ZW50IiwidGFnIiwibGlzdGVuZXIiLCJvbmNlIiwiX2xhc3RCbG9ja051bWJlciIsIl9pbmZsaWdodCIsImV2ZW50Iiwic3BsaXQiLCJjb21wcyIsInRvcGljcyIsImRlc2VyaWFsaXplVG9waWNzIiwicG9sbGFibGUiLCJQb2xsYWJsZUV2ZW50cyIsImluZGV4T2YiLCJFdGhlcnNFdmVudCIsImRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkIiwiaGFzaGVzT25seSIsImluY2x1ZGVSZW1vdmVkIiwiZGVzZXJpYWxpemVBZGRyZXNzZXNGaWVsZCIsImlzQWxjaGVteUV2ZW50IiwiZ2V0QWxjaGVteUV2ZW50VGFnIiwiUEVORElOR19UUkFOU0FDVElPTlMiLCJzZXJpYWxpemVQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnQiLCJNSU5FRF9UUkFOU0FDVElPTlMiLCJzZXJpYWxpemVNaW5lZFRyYW5zYWN0aW9uc0V2ZW50IiwidmVyaWZ5QWxjaGVteUV2ZW50TmFtZSIsImV2ZW50TmFtZSIsInNlcmlhbGl6ZUFkZHJlc3NGaWVsZCIsInNlcmlhbGl6ZUJvb2xlYW5GaWVsZCIsInNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkIiwiZmllbGQiLCJ0b3BpYyIsImFkZHJlc3NTdHIiLCJhZGRyZXNzUGFpciIsIldlYlNvY2tldE5hbWVzcGFjZSIsIm9uIiwicHJvY2Vzc2VkRXZlbnQiLCJfcmVzb2x2ZUVuc0FsY2hlbXlFdmVudCIsInJlbW92ZUFsbExpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJwcm9jZXNzZWRBZGRyZXNzZXMiLCJfcmVzb2x2ZU5hbWVPckVycm9yIiwicmVzb2x2ZWQiLCJBbGNoZW15Iiwic2V0dGluZ3MiLCJjb3JlIiwid3MiLCJ0cmFuc2FjdCIsIm5vdGlmeSIsIldhbGxldCIsInByaXZhdGVLZXkiLCJhbGNoZW15T3JQcm92aWRlciIsInN1cGVyUHJvdmlkZXIiLCJQcm92aWRlciIsImlzUHJvdmlkZXIiLCJhbGNoZW15UHJvdmlkZXJQcm9taXNlIiwiZ2V0V2FsbGV0IiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsImdldENoYWluSWQiLCJjb25uZWN0IiwiQ29udHJhY3QiLCJDb250cmFjdEZhY3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/alchemy-sdk/dist/cjs/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/alchemy-sdk/dist/cjs/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar index = __webpack_require__(/*! ./index-769e52b6.js */ \"(ssr)/../node_modules/alchemy-sdk/dist/cjs/index-769e52b6.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/../node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/../node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/../node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar utils__namespace = /*#__PURE__*/ _interopNamespace(utils);\nexports.Utils = utils__namespace;\nexports.Alchemy = index.Alchemy;\nObject.defineProperty(exports, \"AlchemySubscription\", ({\n    enumerable: true,\n    get: function() {\n        return index.AlchemySubscription;\n    }\n}));\nObject.defineProperty(exports, \"AssetTransfersCategory\", ({\n    enumerable: true,\n    get: function() {\n        return index.AssetTransfersCategory;\n    }\n}));\nObject.defineProperty(exports, \"CommitmentLevel\", ({\n    enumerable: true,\n    get: function() {\n        return index.CommitmentLevel;\n    }\n}));\nexports.Contract = index.Contract;\nexports.ContractFactory = index.ContractFactory;\nObject.defineProperty(exports, \"DebugCallType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugCallType;\n    }\n}));\nObject.defineProperty(exports, \"DebugTracerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugTracerType;\n    }\n}));\nObject.defineProperty(exports, \"DecodingAuthority\", ({\n    enumerable: true,\n    get: function() {\n        return index.DecodingAuthority;\n    }\n}));\nObject.defineProperty(exports, \"GasOptimizedTransactionStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.GasOptimizedTransactionStatus;\n    }\n}));\nObject.defineProperty(exports, \"GetTransfersForOwnerTransferType\", ({\n    enumerable: true,\n    get: function() {\n        return index.GetTransfersForOwnerTransferType;\n    }\n}));\nObject.defineProperty(exports, \"Network\", ({\n    enumerable: true,\n    get: function() {\n        return index.Network;\n    }\n}));\nObject.defineProperty(exports, \"NftCollectionMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftCollectionMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftFilters\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftFilters;\n    }\n}));\nObject.defineProperty(exports, \"NftOrdering\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftOrdering;\n    }\n}));\nObject.defineProperty(exports, \"NftRefreshState\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftRefreshState;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleTakerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleTakerType;\n    }\n}));\nObject.defineProperty(exports, \"NftSpamClassification\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSpamClassification;\n    }\n}));\nObject.defineProperty(exports, \"NftTokenType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftTokenType;\n    }\n}));\nObject.defineProperty(exports, \"OpenSeaSafelistRequestStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.OpenSeaSafelistRequestStatus;\n    }\n}));\nObject.defineProperty(exports, \"SimulateAssetType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateAssetType;\n    }\n}));\nObject.defineProperty(exports, \"SimulateChangeType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateChangeType;\n    }\n}));\nObject.defineProperty(exports, \"SortingOrder\", ({\n    enumerable: true,\n    get: function() {\n        return index.SortingOrder;\n    }\n}));\nObject.defineProperty(exports, \"TokenBalanceType\", ({\n    enumerable: true,\n    get: function() {\n        return index.TokenBalanceType;\n    }\n}));\nexports.Wallet = index.Wallet;\nObject.defineProperty(exports, \"WebhookType\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookType;\n    }\n}));\nObject.defineProperty(exports, \"WebhookVersion\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookVersion;\n    }\n}));\nexports.fromHex = index.fromHex;\nexports.isHex = index.isHex;\nexports.setLogLevel = index.setLogLevel;\nexports.toHex = index.toHex;\nObject.defineProperty(exports, \"BigNumber\", ({\n    enumerable: true,\n    get: function() {\n        return bignumber.BigNumber;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLFNBQVNHLGtCQUFrQkMsQ0FBQztJQUMzQixJQUFJQSxLQUFLQSxFQUFFQyxVQUFVLEVBQUUsT0FBT0Q7SUFDOUIsSUFBSUUsSUFBSVgsT0FBT1ksTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDTlQsT0FBT2EsSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNqQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ3BCLElBQUlDLElBQUloQixPQUFPaUIsd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ2YsT0FBT0MsY0FBYyxDQUFDVSxHQUFHSSxHQUFHQyxFQUFFRSxHQUFHLEdBQUdGLElBQUk7b0JBQ3ZDRyxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9ULENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDakM7WUFDRDtRQUNEO0lBQ0Q7SUFDQUosQ0FBQyxDQUFDLFVBQVUsR0FBR0Y7SUFDZixPQUFPVCxPQUFPb0IsTUFBTSxDQUFDVDtBQUN0QjtBQUVBLElBQUlVLG1CQUFtQixXQUFXLEdBQUViLGtCQUFrQko7QUFJdERGLGFBQWEsR0FBR21CO0FBQ2hCbkIsZUFBZSxHQUFHSSxNQUFNaUIsT0FBTztBQUMvQnZCLHVEQUFzRDtJQUNyRG1CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU1rQixtQkFBbUI7SUFBRTtBQUN0RCxDQUFDLEVBQUM7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RCxDQUFDLEVBQUM7QUFDRjdDLGNBQWMsR0FBR0ksTUFBTTBDLE1BQU07QUFDN0JoRCwrQ0FBOEM7SUFDN0NtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNMkMsV0FBVztJQUFFO0FBQzlDLENBQUMsRUFBQztBQUNGakQsa0RBQWlEO0lBQ2hEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTRDLGNBQWM7SUFBRTtBQUNqRCxDQUFDLEVBQUM7QUFDRmhELGVBQWUsR0FBR0ksTUFBTTZDLE9BQU87QUFDL0JqRCxhQUFhLEdBQUdJLE1BQU04QyxLQUFLO0FBQzNCbEQsbUJBQW1CLEdBQUdJLE1BQU0rQyxXQUFXO0FBQ3ZDbkQsYUFBYSxHQUFHSSxNQUFNZ0QsS0FBSztBQUMzQnRELDZDQUE0QztJQUMzQ21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9YLFVBQVVnRCxTQUFTO0lBQUU7QUFDaEQsQ0FBQyxFQUFDLEVBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2Nqcy9pbmRleC5qcz84YzUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9hcGkvdXRpbHMnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vaW5kZXgtNzY5ZTUyYjYuanMnKTtcbnZhciBiaWdudW1iZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnJlcXVpcmUoJ2F4aW9zJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcicpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2FsbGV0Jyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuXHRpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuXHR2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGlmIChlKSB7XG5cdFx0T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0bltcImRlZmF1bHRcIl0gPSBlO1xuXHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIHV0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UodXRpbHMpO1xuXG5cblxuZXhwb3J0cy5VdGlscyA9IHV0aWxzX19uYW1lc3BhY2U7XG5leHBvcnRzLkFsY2hlbXkgPSBpbmRleC5BbGNoZW15O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbGNoZW15U3Vic2NyaXB0aW9uJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb247IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBc3NldFRyYW5zZmVyc0NhdGVnb3J5Jywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnk7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb21taXRtZW50TGV2ZWwnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguQ29tbWl0bWVudExldmVsOyB9XG59KTtcbmV4cG9ydHMuQ29udHJhY3QgPSBpbmRleC5Db250cmFjdDtcbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gaW5kZXguQ29udHJhY3RGYWN0b3J5O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEZWJ1Z0NhbGxUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkRlYnVnQ2FsbFR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEZWJ1Z1RyYWNlclR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguRGVidWdUcmFjZXJUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRGVjb2RpbmdBdXRob3JpdHknLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguRGVjb2RpbmdBdXRob3JpdHk7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5HYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1czsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmV0d29yaycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZXR3b3JrOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdEZpbHRlcnMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0RmlsdGVyczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdE9yZGVyaW5nJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdE9yZGVyaW5nOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0UmVmcmVzaFN0YXRlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdFJlZnJlc2hTdGF0ZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdFNhbGVNYXJrZXRwbGFjZScsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZnRTYWxlTWFya2V0cGxhY2U7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRTYWxlVGFrZXJUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdFNhbGVUYWtlclR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRTcGFtQ2xhc3NpZmljYXRpb24nLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0U3BhbUNsYXNzaWZpY2F0aW9uOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0VG9rZW5UeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdFRva2VuVHlwZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ09wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1czsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NpbXVsYXRlQXNzZXRUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LlNpbXVsYXRlQXNzZXRUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2ltdWxhdGVDaGFuZ2VUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LlNpbXVsYXRlQ2hhbmdlVHlwZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NvcnRpbmdPcmRlcicsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5Tb3J0aW5nT3JkZXI7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUb2tlbkJhbGFuY2VUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LlRva2VuQmFsYW5jZVR5cGU7IH1cbn0pO1xuZXhwb3J0cy5XYWxsZXQgPSBpbmRleC5XYWxsZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1dlYmhvb2tUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LldlYmhvb2tUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnV2ViaG9va1ZlcnNpb24nLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguV2ViaG9va1ZlcnNpb247IH1cbn0pO1xuZXhwb3J0cy5mcm9tSGV4ID0gaW5kZXguZnJvbUhleDtcbmV4cG9ydHMuaXNIZXggPSBpbmRleC5pc0hleDtcbmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBpbmRleC5zZXRMb2dMZXZlbDtcbmV4cG9ydHMudG9IZXggPSBpbmRleC50b0hleDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQmlnTnVtYmVyJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlci5CaWdOdW1iZXI7IH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlscyIsInJlcXVpcmUiLCJpbmRleCIsImJpZ251bWJlciIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiZSIsIl9fZXNNb2R1bGUiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJ1dGlsc19fbmFtZXNwYWNlIiwiVXRpbHMiLCJBbGNoZW15IiwiQWxjaGVteVN1YnNjcmlwdGlvbiIsIkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkiLCJDb21taXRtZW50TGV2ZWwiLCJDb250cmFjdCIsIkNvbnRyYWN0RmFjdG9yeSIsIkRlYnVnQ2FsbFR5cGUiLCJEZWJ1Z1RyYWNlclR5cGUiLCJEZWNvZGluZ0F1dGhvcml0eSIsIkdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzIiwiR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUiLCJOZXR3b3JrIiwiTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIiwiTmZ0RmlsdGVycyIsIk5mdE9yZGVyaW5nIiwiTmZ0UmVmcmVzaFN0YXRlIiwiTmZ0U2FsZU1hcmtldHBsYWNlIiwiTmZ0U2FsZVRha2VyVHlwZSIsIk5mdFNwYW1DbGFzc2lmaWNhdGlvbiIsIk5mdFRva2VuVHlwZSIsIk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMiLCJTaW11bGF0ZUFzc2V0VHlwZSIsIlNpbXVsYXRlQ2hhbmdlVHlwZSIsIlNvcnRpbmdPcmRlciIsIlRva2VuQmFsYW5jZVR5cGUiLCJXYWxsZXQiLCJXZWJob29rVHlwZSIsIldlYmhvb2tWZXJzaW9uIiwiZnJvbUhleCIsImlzSGV4Iiwic2V0TG9nTGV2ZWwiLCJ0b0hleCIsIkJpZ051bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/alchemy-sdk/dist/cjs/index.js\n");

/***/ })

};
;