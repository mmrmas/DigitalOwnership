"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-mdx-jsx";
exports.ids = ["vendor-chunks/mdast-util-mdx-jsx"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-mdx-jsx/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mdast-util-mdx-jsx/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxJsxFromMarkdown: () => (/* binding */ mdxJsxFromMarkdown),\n/* harmony export */   mdxJsxToMarkdown: () => (/* binding */ mdxJsxToMarkdown)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ccount */ \"(ssr)/./node_modules/ccount/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var parse_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-entities */ \"(ssr)/./node_modules/parse-entities/lib/index.js\");\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stringify-entities */ \"(ssr)/./node_modules/stringify-entities/lib/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-stringify-position */ \"(ssr)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, OnEnterError, OnExitError, Token} from 'mdast-util-from-markdown'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State, Tracker} from 'mdast-util-to-markdown'\n * @import {Point} from 'unist'\n * @import {MdxJsxAttribute, MdxJsxAttributeValueExpression, MdxJsxExpressionAttribute, MdxJsxFlowElement, MdxJsxTextElement} from '../index.js'\n */ /**\n * @typedef Tag\n *   Single tag.\n * @property {string | undefined} name\n *   Name of tag, or `undefined` for fragment.\n *\n *   > ðŸ‘‰ **Note**: `null` is used in the AST for fragments, as it serializes in\n *   > JSON.\n * @property {Array<MdxJsxAttribute | MdxJsxExpressionAttribute>} attributes\n *   Attributes.\n * @property {boolean} close\n *   Whether the tag is closing (`</x>`).\n * @property {boolean} selfClosing\n *   Whether the tag is self-closing (`<x/>`).\n * @property {Token['start']} start\n *   Start point.\n * @property {Token['start']} end\n *   End point.\n *\n * @typedef ToMarkdownOptions\n *   Configuration.\n * @property {'\"' | \"'\" | null | undefined} [quote='\"']\n *   Preferred quote to use around attribute values (default: `'\"'`).\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n * @property {number | null | undefined} [printWidth=Infinity]\n *   Try and wrap syntax at this width (default: `Infinity`).\n *\n *   When set to a finite number (say, `80`), the formatter will print\n *   attributes on separate lines when a tag doesnâ€™t fit on one line.\n *   The normal behavior is to print attributes with spaces between them\n *   instead of line endings.\n */ \n\n\n\n\n\nconst indent = \"  \";\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n *   When using the syntax extension with `addResult`, nodes will have a\n *   `data.estree` field set to an ESTree `Program` node.\n */ function mdxJsxFromMarkdown() {\n    return {\n        canContainEols: [\n            \"mdxJsxTextElement\"\n        ],\n        enter: {\n            mdxJsxFlowTag: enterMdxJsxTag,\n            mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,\n            mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,\n            mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n            mdxJsxFlowTagAttributeValueLiteral: buffer,\n            mdxJsxFlowTagAttributeValueExpression: buffer,\n            mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,\n            mdxJsxTextTag: enterMdxJsxTag,\n            mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,\n            mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,\n            mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n            mdxJsxTextTagAttributeValueLiteral: buffer,\n            mdxJsxTextTagAttributeValueExpression: buffer,\n            mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker\n        },\n        exit: {\n            mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,\n            mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,\n            mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,\n            mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,\n            mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n            mdxJsxFlowTagExpressionAttributeValue: data,\n            mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n            mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n            mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n            mdxJsxFlowTagAttributeValueLiteralValue: data,\n            mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,\n            mdxJsxFlowTagAttributeValueExpressionValue: data,\n            mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n            mdxJsxFlowTag: exitMdxJsxTag,\n            mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,\n            mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,\n            mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,\n            mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,\n            mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n            mdxJsxTextTagExpressionAttributeValue: data,\n            mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n            mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n            mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n            mdxJsxTextTagAttributeValueLiteralValue: data,\n            mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,\n            mdxJsxTextTagAttributeValueExpressionValue: data,\n            mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n            mdxJsxTextTag: exitMdxJsxTag\n        }\n    };\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function buffer() {\n        this.buffer();\n    }\n    /**\n   * Copy a point-like value.\n   *\n   * @param {Point} d\n   *   Point-like value.\n   * @returns {Point}\n   *   unist point.\n   */ function point(d) {\n        return {\n            line: d.line,\n            column: d.column,\n            offset: d.offset\n        };\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function data(token) {\n        this.config.enter.data.call(this, token);\n        this.config.exit.data.call(this, token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTag(token) {\n        /** @type {Tag} */ const tag = {\n            name: undefined,\n            attributes: [],\n            close: false,\n            selfClosing: false,\n            start: token.start,\n            end: token.end\n        };\n        if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = [];\n        this.data.mdxJsxTag = tag;\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagClosingMarker(token) {\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        if (stack.length === 0) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected closing slash `/` in tag, expected an open tag first\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-closing-slash\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagAnyAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        if (tag.close) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected attribute in closing tag, expected the end of the tag\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-attribute\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagSelfClosingMarker(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        if (tag.close) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected self-closing slash `/` in closing tag, expected the end of the tag\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-self-closing-slash\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagClosingMarker() {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.close = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNamePrimary(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNameMember(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name += \".\" + this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNameLocal(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name += \":\" + this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        enterMdxJsxTagAnyAttribute.call(this, token);\n        tag.attributes.push({\n            type: \"mdxJsxAttribute\",\n            name: \"\",\n            value: null,\n            position: {\n                start: point(token.start),\n                // @ts-expect-error: `end` will be patched later.\n                end: undefined\n            }\n        });\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagExpressionAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        enterMdxJsxTagAnyAttribute.call(this, token);\n        tag.attributes.push({\n            type: \"mdxJsxExpressionAttribute\",\n            value: \"\"\n        });\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagExpressionAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const tail = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === \"mdxJsxExpressionAttribute\");\n        const estree = token.estree;\n        tail.value = this.resume();\n        if (estree) {\n            tail.data = {\n                estree\n            };\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeNamePrimary(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"mdxJsxAttribute\");\n        node.name = this.sliceSerialize(token);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeNameLocal(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"mdxJsxAttribute\");\n        node.name += \":\" + this.sliceSerialize(token);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeValueLiteral(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        node.value = (0,parse_entities__WEBPACK_IMPORTED_MODULE_2__.parseEntities)(this.resume(), {\n            nonTerminated: false\n        });\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeValueExpression(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const tail = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === \"mdxJsxAttribute\");\n        /** @type {MdxJsxAttributeValueExpression} */ const node = {\n            type: \"mdxJsxAttributeValueExpression\",\n            value: this.resume()\n        };\n        const estree = token.estree;\n        if (estree) {\n            node.data = {\n                estree\n            };\n        }\n        tail.value = node;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position !== undefined);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagSelfClosingMarker() {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.selfClosing = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTag(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        const tail = stack[stack.length - 1];\n        if (tag.close && tail.name !== tag.name) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected closing tag `\" + serializeAbbreviatedTag(tag) + \"`, expected corresponding closing tag for `\" + serializeAbbreviatedTag(tail) + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(tail) + \")\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n        }\n        // End of a tag, so drop the buffer.\n        this.resume();\n        if (tag.close) {\n            stack.pop();\n        } else {\n            this.enter({\n                type: token.type === \"mdxJsxTextTag\" ? \"mdxJsxTextElement\" : \"mdxJsxFlowElement\",\n                name: tag.name || null,\n                attributes: tag.attributes,\n                children: []\n            }, token, onErrorRightIsTag);\n        }\n        if (tag.selfClosing || tag.close) {\n            this.exit(token, onErrorLeftIsTag);\n        } else {\n            stack.push(tag);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {OnEnterError}\n   */ function onErrorRightIsTag(closing, open) {\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        const tag = stack[stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const place = closing ? \" before the end of `\" + closing.type + \"`\" : \"\";\n        const position = closing ? {\n            start: closing.start,\n            end: closing.end\n        } : undefined;\n        throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Expected a closing tag for `\" + serializeAbbreviatedTag(tag) + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)({\n            start: open.start,\n            end: open.end\n        }) + \")\" + place, position, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {OnExitError}\n   */ function onErrorLeftIsTag(a, b) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Expected the closing tag `\" + serializeAbbreviatedTag(tag) + \"` either after the end of `\" + b.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.end) + \") or another opening tag after the start of `\" + b.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.start) + \")\", {\n            start: a.start,\n            end: a.end\n        }, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n    }\n    /**\n   * Serialize a tag, excluding attributes.\n   * `self-closing` is not supported, because we donâ€™t need it yet.\n   *\n   * @param {Tag} tag\n   * @returns {string}\n   */ function serializeAbbreviatedTag(tag) {\n        return \"<\" + (tag.close ? \"/\" : \"\") + (tag.name || \"\") + \">\";\n    }\n}\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX JSX.\n *\n * This extension configures `mdast-util-to-markdown` with\n * `options.fences: true` and `options.resourceLink: true` too, do not\n * overwrite them!\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX JSX.\n */ function mdxJsxToMarkdown(options) {\n    const options_ = options || {};\n    const quote = options_.quote || '\"';\n    const quoteSmart = options_.quoteSmart || false;\n    const tightSelfClosing = options_.tightSelfClosing || false;\n    const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;\n    const alternative = quote === '\"' ? \"'\" : '\"';\n    if (quote !== '\"' && quote !== \"'\") {\n        throw new Error(\"Cannot serialize attribute values with `\" + quote + \"` for `options.quote`, expected `\\\"`, or `'`\");\n    }\n    mdxElement.peek = peekElement;\n    return {\n        handlers: {\n            mdxJsxFlowElement: mdxElement,\n            mdxJsxTextElement: mdxElement\n        },\n        unsafe: [\n            {\n                character: \"<\",\n                inConstruct: [\n                    \"phrasing\"\n                ]\n            },\n            {\n                atBreak: true,\n                character: \"<\"\n            }\n        ],\n        // Always generate fenced code (never indented code).\n        fences: true,\n        // Always generate links with resources (never autolinks).\n        resourceLink: true\n    };\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n   */ // eslint-disable-next-line complexity\n    function mdxElement(node, _, state, info) {\n        const flow = node.type === \"mdxJsxFlowElement\";\n        const selfClosing = node.name ? !node.children || node.children.length === 0 : false;\n        const depth = inferDepth(state);\n        const currentIndent = createIndent(depth);\n        const trackerOneLine = state.createTracker(info);\n        const trackerMultiLine = state.createTracker(info);\n        /** @type {Array<string>} */ const serializedAttributes = [];\n        const prefix = (flow ? currentIndent : \"\") + \"<\" + (node.name || \"\");\n        const exit = state.enter(node.type);\n        trackerOneLine.move(prefix);\n        trackerMultiLine.move(prefix);\n        // None.\n        if (node.attributes && node.attributes.length > 0) {\n            if (!node.name) {\n                throw new Error(\"Cannot serialize fragment w/ attributes\");\n            }\n            let index = -1;\n            while(++index < node.attributes.length){\n                const attribute = node.attributes[index];\n                /** @type {string} */ let result;\n                if (attribute.type === \"mdxJsxExpressionAttribute\") {\n                    result = \"{\" + (attribute.value || \"\") + \"}\";\n                } else {\n                    if (!attribute.name) {\n                        throw new Error(\"Cannot serialize attribute w/o name\");\n                    }\n                    const value = attribute.value;\n                    const left = attribute.name;\n                    /** @type {string} */ let right = \"\";\n                    if (value === null || value === undefined) {\n                    // Empty.\n                    } else if (typeof value === \"object\") {\n                        right = \"{\" + (value.value || \"\") + \"}\";\n                    } else {\n                        // If the alternative is less common than `quote`, switch.\n                        const appliedQuote = quoteSmart && (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, quote) > (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, alternative) ? alternative : quote;\n                        right = appliedQuote + (0,stringify_entities__WEBPACK_IMPORTED_MODULE_5__.stringifyEntitiesLight)(value, {\n                            subset: [\n                                appliedQuote\n                            ]\n                        }) + appliedQuote;\n                    }\n                    result = left + (right ? \"=\" : \"\") + right;\n                }\n                serializedAttributes.push(result);\n            }\n        }\n        let attributesOnTheirOwnLine = false;\n        const attributesOnOneLine = serializedAttributes.join(\" \");\n        if (// Block:\n        flow && // Including a line ending (expressions).\n        (/\\r?\\n|\\r/.test(attributesOnOneLine) || // Current position (including `<tag`).\n        trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.\n        // Attributes joined by spaces.\n        attributesOnOneLine.length + // ` />`.\n        (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)) {\n            attributesOnTheirOwnLine = true;\n        }\n        let tracker = trackerOneLine;\n        let value = prefix;\n        if (attributesOnTheirOwnLine) {\n            tracker = trackerMultiLine;\n            let index = -1;\n            while(++index < serializedAttributes.length){\n                // Only indent first line of of attributes, we canâ€™t indent attribute\n                // values.\n                serializedAttributes[index] = currentIndent + indent + serializedAttributes[index];\n            }\n            value += tracker.move(\"\\n\" + serializedAttributes.join(\"\\n\") + \"\\n\" + currentIndent);\n        } else if (attributesOnOneLine) {\n            value += tracker.move(\" \" + attributesOnOneLine);\n        }\n        if (selfClosing) {\n            value += tracker.move((tightSelfClosing || attributesOnTheirOwnLine ? \"\" : \" \") + \"/\");\n        }\n        value += tracker.move(\">\");\n        if (node.children && node.children.length > 0) {\n            if (node.type === \"mdxJsxTextElement\") {\n                value += tracker.move(// @ts-expect-error: `containerPhrasing` is typed correctly, but TS\n                // generates *hardcoded* types, which means that our dynamically added\n                // directives are not present.\n                // At some point, TS should fix that, and `from-markdown` should be fine.\n                state.containerPhrasing(node, {\n                    ...tracker.current(),\n                    before: \">\",\n                    after: \"<\"\n                }));\n            } else {\n                tracker.shift(2);\n                value += tracker.move(\"\\n\");\n                value += tracker.move(containerFlow(node, state, tracker.current()));\n                value += tracker.move(\"\\n\");\n            }\n        }\n        if (!selfClosing) {\n            value += tracker.move((flow ? currentIndent : \"\") + \"</\" + (node.name || \"\") + \">\");\n        }\n        exit();\n        return value;\n    }\n}\n// Modified copy of:\n// <https://github.com/syntax-tree/mdast-util-to-markdown/blob/a381cbc/lib/util/container-flow.js>.\n//\n// To do: add `indent` support to `mdast-util-to-markdown`.\n// As indents are only used for JSX, itâ€™s fine for now, but perhaps better\n// there.\n/**\n * @param {MdxJsxFlowElement} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {ReturnType<Tracker['current']>} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */ function containerFlow(parent, state, info) {\n    const indexStack = state.indexStack;\n    const children = parent.children;\n    const tracker = state.createTracker(info);\n    const currentIndent = createIndent(inferDepth(state));\n    /** @type {Array<string>} */ const results = [];\n    let index = -1;\n    indexStack.push(-1);\n    while(++index < children.length){\n        const child = children[index];\n        indexStack[indexStack.length - 1] = index;\n        const childInfo = {\n            before: \"\\n\",\n            after: \"\\n\",\n            ...tracker.current()\n        };\n        const result = state.handle(child, parent, state, childInfo);\n        const serializedChild = child.type === \"mdxJsxFlowElement\" ? result : state.indentLines(result, function(line, _, blank) {\n            return (blank ? \"\" : currentIndent) + line;\n        });\n        results.push(tracker.move(serializedChild));\n        if (child.type !== \"list\") {\n            state.bulletLastUsed = undefined;\n        }\n        if (index < children.length - 1) {\n            results.push(tracker.move(\"\\n\\n\"));\n        }\n    }\n    indexStack.pop();\n    return results.join(\"\");\n}\n/**\n * @param {State} state\n * @returns {number}\n */ function inferDepth(state) {\n    let depth = 0;\n    let index = state.stack.length;\n    while(--index > -1){\n        const name = state.stack[index];\n        if (name === \"blockquote\" || name === \"listItem\") break;\n        if (name === \"mdxJsxFlowElement\") depth++;\n    }\n    return depth;\n}\n/**\n * @param {number} depth\n * @returns {string}\n */ function createIndent(depth) {\n    return indent.repeat(depth);\n}\n/**\n * @type {ToMarkdownHandle}\n */ function peekElement() {\n    return \"<\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tZHgtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBRTRCO0FBQ007QUFDUztBQUNhO0FBQ007QUFDckI7QUFFMUMsTUFBTU8sU0FBUztBQUVmOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0M7SUFDZCxPQUFPO1FBQ0xDLGdCQUFnQjtZQUFDO1NBQW9CO1FBQ3JDQyxPQUFPO1lBQ0xDLGVBQWVDO1lBQ2ZDLDRCQUE0QkM7WUFDNUJDLHdCQUF3QkM7WUFDeEJDLGtDQUFrQ0M7WUFDbENDLG9DQUFvQ0M7WUFDcENDLHVDQUF1Q0Q7WUFDdkNFLGdDQUFnQ0M7WUFFaENDLGVBQWVaO1lBQ2ZhLDRCQUE0Qlg7WUFDNUJZLHdCQUF3QlY7WUFDeEJXLGtDQUFrQ1Q7WUFDbENVLG9DQUFvQ1I7WUFDcENTLHVDQUF1Q1Q7WUFDdkNVLGdDQUFnQ1A7UUFDbEM7UUFDQVEsTUFBTTtZQUNKbEIsNEJBQTRCbUI7WUFDNUJDLDBCQUEwQkM7WUFDMUJDLHlCQUF5QkM7WUFDekJDLHdCQUF3QkM7WUFDeEJyQixrQ0FBa0NzQjtZQUNsQ0MsdUNBQXVDQztZQUN2Q0MsbUNBQW1DQztZQUNuQ0MsaUNBQWlDQztZQUNqQzFCLG9DQUFvQzJCO1lBQ3BDQyx5Q0FBeUNOO1lBQ3pDcEIsdUNBQ0UyQjtZQUNGQyw0Q0FBNENSO1lBQzVDbkIsZ0NBQWdDNEI7WUFDaEN2QyxlQUFld0M7WUFFZjFCLDRCQUE0Qk87WUFDNUJvQiwwQkFBMEJsQjtZQUMxQm1CLHlCQUF5QmpCO1lBQ3pCa0Isd0JBQXdCaEI7WUFDeEJYLGtDQUFrQ1k7WUFDbENnQix1Q0FBdUNkO1lBQ3ZDZSxtQ0FBbUNiO1lBQ25DYyxpQ0FBaUNaO1lBQ2pDakIsb0NBQW9Da0I7WUFDcENZLHlDQUF5Q2pCO1lBQ3pDWix1Q0FDRW1CO1lBQ0ZXLDRD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LFFBQVE3RSxJQUFJLENBQUNxRSxRQUFRZCxJQUFJLENBQUMwQjtRQUUxQixJQUFJSCxNQUFNN0UsSUFBSSxLQUFLLFFBQVE7WUFDekIwQyxNQUFNeUMsY0FBYyxHQUFHaEc7UUFDekI7UUFFQSxJQUFJb0UsUUFBUTdDLFNBQVNkLE1BQU0sR0FBRyxHQUFHO1lBQy9CZ0YsUUFBUTdFLElBQUksQ0FBQ3FFLFFBQVFkLElBQUksQ0FBQztRQUM1QjtJQUNGO0lBRUFxQixXQUFXbEUsR0FBRztJQUVkLE9BQU9tRSxRQUFRWixJQUFJLENBQUM7QUFDdEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTbEIsV0FBV0osS0FBSztJQUN2QixJQUFJRyxRQUFRO0lBQ1osSUFBSVUsUUFBUWIsTUFBTS9DLEtBQUssQ0FBQ0MsTUFBTTtJQUU5QixNQUFPLEVBQUUyRCxRQUFRLENBQUMsRUFBRztRQUNuQixNQUFNckUsT0FBT3dELE1BQU0vQyxLQUFLLENBQUM0RCxNQUFNO1FBRS9CLElBQUlyRSxTQUFTLGdCQUFnQkEsU0FBUyxZQUFZO1FBQ2xELElBQUlBLFNBQVMscUJBQXFCMkQ7SUFDcEM7SUFFQSxPQUFPQTtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0csYUFBYUgsS0FBSztJQUN6QixPQUFPekgsT0FBT2dLLE1BQU0sQ0FBQ3ZDO0FBQ3ZCO0FBRUE7O0NBRUMsR0FDRCxTQUFTZDtJQUNQLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2lwdC13My8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLW1keC1qc3gvbGliL2luZGV4LmpzPzk3NTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtDb21waWxlQ29udGV4dCwgRXh0ZW5zaW9uIGFzIEZyb21NYXJrZG93bkV4dGVuc2lvbiwgSGFuZGxlIGFzIEZyb21NYXJrZG93bkhhbmRsZSwgT25FbnRlckVycm9yLCBPbkV4aXRFcnJvciwgVG9rZW59IGZyb20gJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bidcbiAqIEBpbXBvcnQge0hhbmRsZSBhcyBUb01hcmtkb3duSGFuZGxlLCBPcHRpb25zIGFzIFRvTWFya2Rvd25FeHRlbnNpb24sIFN0YXRlLCBUcmFja2VyfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7UG9pbnR9IGZyb20gJ3VuaXN0J1xuICogQGltcG9ydCB7TWR4SnN4QXR0cmlidXRlLCBNZHhKc3hBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb24sIE1keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUsIE1keEpzeEZsb3dFbGVtZW50LCBNZHhKc3hUZXh0RWxlbWVudH0gZnJvbSAnLi4vaW5kZXguanMnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUYWdcbiAqICAgU2luZ2xlIHRhZy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBuYW1lXG4gKiAgIE5hbWUgb2YgdGFnLCBvciBgdW5kZWZpbmVkYCBmb3IgZnJhZ21lbnQuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGBudWxsYCBpcyB1c2VkIGluIHRoZSBBU1QgZm9yIGZyYWdtZW50cywgYXMgaXQgc2VyaWFsaXplcyBpblxuICogICA+IEpTT04uXG4gKiBAcHJvcGVydHkge0FycmF5PE1keEpzeEF0dHJpYnV0ZSB8IE1keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGU+fSBhdHRyaWJ1dGVzXG4gKiAgIEF0dHJpYnV0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsb3NlXG4gKiAgIFdoZXRoZXIgdGhlIHRhZyBpcyBjbG9zaW5nIChgPC94PmApLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzZWxmQ2xvc2luZ1xuICogICBXaGV0aGVyIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nIChgPHgvPmApLlxuICogQHByb3BlcnR5IHtUb2tlblsnc3RhcnQnXX0gc3RhcnRcbiAqICAgU3RhcnQgcG9pbnQuXG4gKiBAcHJvcGVydHkge1Rva2VuWydzdGFydCddfSBlbmRcbiAqICAgRW5kIHBvaW50LlxuICpcbiAqIEB0eXBlZGVmIFRvTWFya2Rvd25PcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkgeydcIicgfCBcIidcIiB8IG51bGwgfCB1bmRlZmluZWR9IFtxdW90ZT0nXCInXVxuICogICBQcmVmZXJyZWQgcXVvdGUgdG8gdXNlIGFyb3VuZCBhdHRyaWJ1dGUgdmFsdWVzIChkZWZhdWx0OiBgJ1wiJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3F1b3RlU21hcnQ9ZmFsc2VdXG4gKiAgIFVzZSB0aGUgb3RoZXIgcXVvdGUgaWYgdGhhdCByZXN1bHRzIGluIGxlc3MgYnl0ZXMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RpZ2h0U2VsZkNsb3Npbmc9ZmFsc2VdXG4gKiAgIERvIG5vdCB1c2UgYW4gZXh0cmEgc3BhY2Ugd2hlbiBjbG9zaW5nIHNlbGYtY2xvc2luZyBlbGVtZW50czogYDxpbWcvPmBcbiAqICAgaW5zdGVhZCBvZiBgPGltZyAvPmAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJpbnRXaWR0aD1JbmZpbml0eV1cbiAqICAgVHJ5IGFuZCB3cmFwIHN5bnRheCBhdCB0aGlzIHdpZHRoIChkZWZhdWx0OiBgSW5maW5pdHlgKS5cbiAqXG4gKiAgIFdoZW4gc2V0IHRvIGEgZmluaXRlIG51bWJlciAoc2F5LCBgODBgKSwgdGhlIGZvcm1hdHRlciB3aWxsIHByaW50XG4gKiAgIGF0dHJpYnV0ZXMgb24gc2VwYXJhdGUgbGluZXMgd2hlbiBhIHRhZyBkb2VzbuKAmXQgZml0IG9uIG9uZSBsaW5lLlxuICogICBUaGUgbm9ybWFsIGJlaGF2aW9yIGlzIHRvIHByaW50IGF0dHJpYnV0ZXMgd2l0aCBzcGFjZXMgYmV0d2VlbiB0aGVtXG4gKiAgIGluc3RlYWQgb2YgbGluZSBlbmRpbmdzLlxuICovXG5cbmltcG9ydCB7Y2NvdW50fSBmcm9tICdjY291bnQnXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtwYXJzZUVudGl0aWVzfSBmcm9tICdwYXJzZS1lbnRpdGllcydcbmltcG9ydCB7c3RyaW5naWZ5RW50aXRpZXNMaWdodH0gZnJvbSAnc3RyaW5naWZ5LWVudGl0aWVzJ1xuaW1wb3J0IHtzdHJpbmdpZnlQb3NpdGlvbn0gZnJvbSAndW5pc3QtdXRpbC1zdHJpbmdpZnktcG9zaXRpb24nXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcblxuY29uc3QgaW5kZW50ID0gJyAgJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICpcbiAqIEByZXR1cm5zIHtGcm9tTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtZnJvbS1tYXJrZG93bmAgdG8gZW5hYmxlIE1EWCBKU1guXG4gKlxuICogICBXaGVuIHVzaW5nIHRoZSBzeW50YXggZXh0ZW5zaW9uIHdpdGggYGFkZFJlc3VsdGAsIG5vZGVzIHdpbGwgaGF2ZSBhXG4gKiAgIGBkYXRhLmVzdHJlZWAgZmllbGQgc2V0IHRvIGFuIEVTVHJlZSBgUHJvZ3JhbWAgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1keEpzeEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5Db250YWluRW9sczogWydtZHhKc3hUZXh0RWxlbWVudCddLFxuICAgIGVudGVyOiB7XG4gICAgICBtZHhKc3hGbG93VGFnOiBlbnRlck1keEpzeFRhZyxcbiAgICAgIG1keEpzeEZsb3dUYWdDbG9zaW5nTWFya2VyOiBlbnRlck1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0F0dHJpYnV0ZSxcbiAgICAgIG1keEpzeEZsb3dUYWdFeHByZXNzaW9uQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsOiBidWZmZXIsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOiBidWZmZXIsXG4gICAgICBtZHhKc3hGbG93VGFnU2VsZkNsb3NpbmdNYXJrZXI6IGVudGVyTWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIsXG5cbiAgICAgIG1keEpzeFRleHRUYWc6IGVudGVyTWR4SnN4VGFnLFxuICAgICAgbWR4SnN4VGV4dFRhZ0Nsb3NpbmdNYXJrZXI6IGVudGVyTWR4SnN4VGFnQ2xvc2luZ01hcmtlcixcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGU6IGVudGVyTWR4SnN4VGFnQXR0cmlidXRlLFxuICAgICAgbWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGU6IGVudGVyTWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWw6IGJ1ZmZlcixcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb246IGJ1ZmZlcixcbiAgICAgIG1keEpzeFRleHRUYWdTZWxmQ2xvc2luZ01hcmtlcjogZW50ZXJNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlclxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbWR4SnN4Rmxvd1RhZ0Nsb3NpbmdNYXJrZXI6IGV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ05hbWVQcmltYXJ5OiBleGl0TWR4SnN4VGFnTmFtZVByaW1hcnksXG4gICAgICBtZHhKc3hGbG93VGFnTmFtZU1lbWJlcjogZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIsXG4gICAgICBtZHhKc3hGbG93VGFnTmFtZUxvY2FsOiBleGl0TWR4SnN4VGFnTmFtZUxvY2FsLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGU6IGV4aXRNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeTogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5LFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZU5hbWVMb2NhbDogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCxcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWw6IGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOlxuICAgICAgICBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvblZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4Rmxvd1RhZ1NlbGZDbG9zaW5nTWFya2VyOiBleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hGbG93VGFnOiBleGl0TWR4SnN4VGFnLFxuXG4gICAgICBtZHhKc3hUZXh0VGFnQ2xvc2luZ01hcmtlcjogZXhpdE1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnTmFtZVByaW1hcnk6IGV4aXRNZHhKc3hUYWdOYW1lUHJpbWFyeSxcbiAgICAgIG1keEpzeFRleHRUYWdOYW1lTWVtYmVyOiBleGl0TWR4SnN4VGFnTmFtZU1lbWJlcixcbiAgICAgIG1keEpzeFRleHRUYWdOYW1lTG9jYWw6IGV4aXRNZHhKc3hUYWdOYW1lTG9jYWwsXG4gICAgICBtZHhKc3hUZXh0VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZTogZXhpdE1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hUZXh0VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5OiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZVByaW1hcnksXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlTmFtZUxvY2FsOiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZUxvY2FsLFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbDogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbCxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWxWYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb246XG4gICAgICAgIGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb24sXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hUZXh0VGFnU2VsZkNsb3NpbmdNYXJrZXI6IGV4aXRNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlcixcbiAgICAgIG1keEpzeFRleHRUYWc6IGV4aXRNZHhKc3hUYWdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5IGEgcG9pbnQtbGlrZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludH0gZFxuICAgKiAgIFBvaW50LWxpa2UgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtQb2ludH1cbiAgICogICB1bmlzdCBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIHBvaW50KGQpIHtcbiAgICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBkYXRhKHRva2VuKSB7XG4gICAgdGhpcy5jb25maWcuZW50ZXIuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIHRoaXMuY29uZmlnLmV4aXQuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnKHRva2VuKSB7XG4gICAgLyoqIEB0eXBlIHtUYWd9ICovXG4gICAgY29uc3QgdGFnID0ge1xuICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBjbG9zZTogZmFsc2UsXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBzdGFydDogdG9rZW4uc3RhcnQsXG4gICAgICBlbmQ6IHRva2VuLmVuZFxuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5tZHhKc3hUYWdTdGFjaykgdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrID0gW11cbiAgICB0aGlzLmRhdGEubWR4SnN4VGFnID0gdGFnXG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnQ2xvc2luZ01hcmtlcih0b2tlbikge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBjbG9zaW5nIHNsYXNoIGAvYCBpbiB0YWcsIGV4cGVjdGVkIGFuIG9wZW4gdGFnIGZpcnN0JyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OnVuZXhwZWN0ZWQtY2xvc2luZy1zbGFzaCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNZHhKc3hUYWdBbnlBdHRyaWJ1dGUodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcblxuICAgIGlmICh0YWcuY2xvc2UpIHtcbiAgICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGF0dHJpYnV0ZSBpbiBjbG9zaW5nIHRhZywgZXhwZWN0ZWQgdGhlIGVuZCBvZiB0aGUgdGFnJyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OnVuZXhwZWN0ZWQtYXR0cmlidXRlJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICBpZiAodGFnLmNsb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBzZWxmLWNsb3Npbmcgc2xhc2ggYC9gIGluIGNsb3NpbmcgdGFnLCBleHBlY3RlZCB0aGUgZW5kIG9mIHRoZSB0YWcnLFxuICAgICAgICB7c3RhcnQ6IHRva2VuLnN0YXJ0LCBlbmQ6IHRva2VuLmVuZH0sXG4gICAgICAgICdtZGFzdC11dGlsLW1keC1qc3g6dW5leHBlY3RlZC1zZWxmLWNsb3Npbmctc2xhc2gnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIHRhZy5jbG9zZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnTmFtZVByaW1hcnkodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSArPSAnLicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdOYW1lTG9jYWwodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcubmFtZSArPSAnOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnQXR0cmlidXRlKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgZW50ZXJNZHhKc3hUYWdBbnlBdHRyaWJ1dGUuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB0YWcuYXR0cmlidXRlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdtZHhKc3hBdHRyaWJ1dGUnLFxuICAgICAgbmFtZTogJycsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwb2ludCh0b2tlbi5zdGFydCksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cbiAgICAgICAgZW5kOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGVudGVyTWR4SnN4VGFnQW55QXR0cmlidXRlLmNhbGwodGhpcywgdG9rZW4pXG4gICAgdGFnLmF0dHJpYnV0ZXMucHVzaCh7dHlwZTogJ21keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUnLCB2YWx1ZTogJyd9KVxuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHRhaWwgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIGFzc2VydCh0YWlsLnR5cGUgPT09ICdtZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlJylcbiAgICBjb25zdCBlc3RyZWUgPSB0b2tlbi5lc3RyZWVcblxuICAgIHRhaWwudmFsdWUgPSB0aGlzLnJlc3VtZSgpXG5cbiAgICBpZiAoZXN0cmVlKSB7XG4gICAgICB0YWlsLmRhdGEgPSB7ZXN0cmVlfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZVByaW1hcnkodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBub2RlID0gdGFnLmF0dHJpYnV0ZXNbdGFnLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbWR4SnN4QXR0cmlidXRlJylcbiAgICBub2RlLm5hbWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IG5vZGUgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdtZHhKc3hBdHRyaWJ1dGUnKVxuICAgIG5vZGUubmFtZSArPSAnOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbCh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IG5vZGUgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIG5vZGUudmFsdWUgPSBwYXJzZUVudGl0aWVzKHRoaXMucmVzdW1lKCksIHtub25UZXJtaW5hdGVkOiBmYWxzZX0pXG4gICAgYXNzZXJ0KG5vZGUucG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICBub2RlLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgY29uc3QgdGFpbCA9IHRhZy5hdHRyaWJ1dGVzW3RhZy5hdHRyaWJ1dGVzLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KHRhaWwudHlwZSA9PT0gJ21keEpzeEF0dHJpYnV0ZScpXG4gICAgLyoqIEB0eXBlIHtNZHhKc3hBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb259ICovXG4gICAgY29uc3Qgbm9kZSA9IHt0eXBlOiAnbWR4SnN4QXR0cmlidXRlVmFsdWVFeHByZXNzaW9uJywgdmFsdWU6IHRoaXMucmVzdW1lKCl9XG4gICAgY29uc3QgZXN0cmVlID0gdG9rZW4uZXN0cmVlXG5cbiAgICBpZiAoZXN0cmVlKSB7XG4gICAgICBub2RlLmRhdGEgPSB7ZXN0cmVlfVxuICAgIH1cblxuICAgIHRhaWwudmFsdWUgPSBub2RlXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICB0YWcuc2VsZkNsb3NpbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZyh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG4gICAgY29uc3QgdGFpbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAodGFnLmNsb3NlICYmIHRhaWwubmFtZSAhPT0gdGFnLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAgICdVbmV4cGVjdGVkIGNsb3NpbmcgdGFnIGAnICtcbiAgICAgICAgICBzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyh0YWcpICtcbiAgICAgICAgICAnYCwgZXhwZWN0ZWQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHRhZyBmb3IgYCcgK1xuICAgICAgICAgIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhaWwpICtcbiAgICAgICAgICAnYCAoJyArXG4gICAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24odGFpbCkgK1xuICAgICAgICAgICcpJyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OmVuZC10YWctbWlzbWF0Y2gnXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIGEgdGFnLCBzbyBkcm9wIHRoZSBidWZmZXIuXG4gICAgdGhpcy5yZXN1bWUoKVxuXG4gICAgaWYgKHRhZy5jbG9zZSkge1xuICAgICAgc3RhY2sucG9wKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbnRlcihcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSAnbWR4SnN4VGV4dFRhZydcbiAgICAgICAgICAgICAgPyAnbWR4SnN4VGV4dEVsZW1lbnQnXG4gICAgICAgICAgICAgIDogJ21keEpzeEZsb3dFbGVtZW50JyxcbiAgICAgICAgICBuYW1lOiB0YWcubmFtZSB8fCBudWxsLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRhZy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9LFxuICAgICAgICB0b2tlbixcbiAgICAgICAgb25FcnJvclJpZ2h0SXNUYWdcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGFnLnNlbGZDbG9zaW5nIHx8IHRhZy5jbG9zZSkge1xuICAgICAgdGhpcy5leGl0KHRva2VuLCBvbkVycm9yTGVmdElzVGFnKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHRhZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7T25FbnRlckVycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gb25FcnJvclJpZ2h0SXNUYWcoY2xvc2luZywgb3Blbikge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5kYXRhLm1keEpzeFRhZ1N0YWNrXG4gICAgYXNzZXJ0KHN0YWNrLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ1N0YWNrYCcpXG4gICAgY29uc3QgdGFnID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHBsYWNlID0gY2xvc2luZyA/ICcgYmVmb3JlIHRoZSBlbmQgb2YgYCcgKyBjbG9zaW5nLnR5cGUgKyAnYCcgOiAnJ1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY2xvc2luZ1xuICAgICAgPyB7c3RhcnQ6IGNsb3Npbmcuc3RhcnQsIGVuZDogY2xvc2luZy5lbmR9XG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgICdFeHBlY3RlZCBhIGNsb3NpbmcgdGFnIGZvciBgJyArXG4gICAgICAgIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhZykgK1xuICAgICAgICAnYCAoJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogb3Blbi5zdGFydCwgZW5kOiBvcGVuLmVuZH0pICtcbiAgICAgICAgJyknICtcbiAgICAgICAgcGxhY2UsXG4gICAgICBwb3NpdGlvbixcbiAgICAgICdtZGFzdC11dGlsLW1keC1qc3g6ZW5kLXRhZy1taXNtYXRjaCdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7T25FeGl0RXJyb3J9XG4gICAqL1xuICBmdW5jdGlvbiBvbkVycm9yTGVmdElzVGFnKGEsIGIpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcblxuICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAnRXhwZWN0ZWQgdGhlIGNsb3NpbmcgdGFnIGAnICtcbiAgICAgICAgc2VyaWFsaXplQWJicmV2aWF0ZWRUYWcodGFnKSArXG4gICAgICAgICdgIGVpdGhlciBhZnRlciB0aGUgZW5kIG9mIGAnICtcbiAgICAgICAgYi50eXBlICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbihiLmVuZCkgK1xuICAgICAgICAnKSBvciBhbm90aGVyIG9wZW5pbmcgdGFnIGFmdGVyIHRoZSBzdGFydCBvZiBgJyArXG4gICAgICAgIGIudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oYi5zdGFydCkgK1xuICAgICAgICAnKScsXG4gICAgICB7c3RhcnQ6IGEuc3RhcnQsIGVuZDogYS5lbmR9LFxuICAgICAgJ21kYXN0LXV0aWwtbWR4LWpzeDplbmQtdGFnLW1pc21hdGNoJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSB0YWcsIGV4Y2x1ZGluZyBhdHRyaWJ1dGVzLlxuICAgKiBgc2VsZi1jbG9zaW5nYCBpcyBub3Qgc3VwcG9ydGVkLCBiZWNhdXNlIHdlIGRvbuKAmXQgbmVlZCBpdCB5ZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFnfSB0YWdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhZykge1xuICAgIHJldHVybiAnPCcgKyAodGFnLmNsb3NlID8gJy8nIDogJycpICsgKHRhZy5uYW1lIHx8ICcnKSArICc+J1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICpcbiAqIFRoaXMgZXh0ZW5zaW9uIGNvbmZpZ3VyZXMgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHdpdGhcbiAqIGBvcHRpb25zLmZlbmNlczogdHJ1ZWAgYW5kIGBvcHRpb25zLnJlc291cmNlTGluazogdHJ1ZWAgdG9vLCBkbyBub3RcbiAqIG92ZXJ3cml0ZSB0aGVtIVxuICpcbiAqIEBwYXJhbSB7VG9NYXJrZG93bk9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWR4SnN4VG9NYXJrZG93bihvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBxdW90ZSA9IG9wdGlvbnNfLnF1b3RlIHx8ICdcIidcbiAgY29uc3QgcXVvdGVTbWFydCA9IG9wdGlvbnNfLnF1b3RlU21hcnQgfHwgZmFsc2VcbiAgY29uc3QgdGlnaHRTZWxmQ2xvc2luZyA9IG9wdGlvbnNfLnRpZ2h0U2VsZkNsb3NpbmcgfHwgZmFsc2VcbiAgY29uc3QgcHJpbnRXaWR0aCA9IG9wdGlvbnNfLnByaW50V2lkdGggfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIGNvbnN0IGFsdGVybmF0aXZlID0gcXVvdGUgPT09ICdcIicgPyBcIidcIiA6ICdcIidcblxuICBpZiAocXVvdGUgIT09ICdcIicgJiYgcXVvdGUgIT09IFwiJ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBzZXJpYWxpemUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGAnICtcbiAgICAgICAgcXVvdGUgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMucXVvdGVgLCBleHBlY3RlZCBgXCJgLCBvciBgXFwnYCdcbiAgICApXG4gIH1cblxuICBtZHhFbGVtZW50LnBlZWsgPSBwZWVrRWxlbWVudFxuXG4gIHJldHVybiB7XG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIG1keEpzeEZsb3dFbGVtZW50OiBtZHhFbGVtZW50LFxuICAgICAgbWR4SnN4VGV4dEVsZW1lbnQ6IG1keEVsZW1lbnRcbiAgICB9LFxuICAgIHVuc2FmZTogW1xuICAgICAge2NoYXJhY3RlcjogJzwnLCBpbkNvbnN0cnVjdDogWydwaHJhc2luZyddfSxcbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICc8J31cbiAgICBdLFxuICAgIC8vIEFsd2F5cyBnZW5lcmF0ZSBmZW5jZWQgY29kZSAobmV2ZXIgaW5kZW50ZWQgY29kZSkuXG4gICAgZmVuY2VzOiB0cnVlLFxuICAgIC8vIEFsd2F5cyBnZW5lcmF0ZSBsaW5rcyB3aXRoIHJlc291cmNlcyAobmV2ZXIgYXV0b2xpbmtzKS5cbiAgICByZXNvdXJjZUxpbms6IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtNZHhKc3hGbG93RWxlbWVudCB8IE1keEpzeFRleHRFbGVtZW50fSBub2RlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBmdW5jdGlvbiBtZHhFbGVtZW50KG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gICAgY29uc3QgZmxvdyA9IG5vZGUudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50J1xuICAgIGNvbnN0IHNlbGZDbG9zaW5nID0gbm9kZS5uYW1lXG4gICAgICA/ICFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwXG4gICAgICA6IGZhbHNlXG4gICAgY29uc3QgZGVwdGggPSBpbmZlckRlcHRoKHN0YXRlKVxuICAgIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSBjcmVhdGVJbmRlbnQoZGVwdGgpXG4gICAgY29uc3QgdHJhY2tlck9uZUxpbmUgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gICAgY29uc3QgdHJhY2tlck11bHRpTGluZSA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gICAgY29uc3Qgc2VyaWFsaXplZEF0dHJpYnV0ZXMgPSBbXVxuICAgIGNvbnN0IHByZWZpeCA9IChmbG93ID8gY3VycmVudEluZGVudCA6ICcnKSArICc8JyArIChub2RlLm5hbWUgfHwgJycpXG4gICAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKG5vZGUudHlwZSlcblxuICAgIHRyYWNrZXJPbmVMaW5lLm1vdmUocHJlZml4KVxuICAgIHRyYWNrZXJNdWx0aUxpbmUubW92ZShwcmVmaXgpXG5cbiAgICAvLyBOb25lLlxuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghbm9kZS5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlcmlhbGl6ZSBmcmFnbWVudCB3LyBhdHRyaWJ1dGVzJylcbiAgICAgIH1cblxuICAgICAgbGV0IGluZGV4ID0gLTFcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbaW5kZXhdXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICBsZXQgcmVzdWx0XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnbWR4SnN4RXhwcmVzc2lvbkF0dHJpYnV0ZScpIHtcbiAgICAgICAgICByZXN1bHQgPSAneycgKyAoYXR0cmlidXRlLnZhbHVlIHx8ICcnKSArICd9J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0cmlidXRlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlcmlhbGl6ZSBhdHRyaWJ1dGUgdy9vIG5hbWUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlXG4gICAgICAgICAgY29uc3QgbGVmdCA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgICAgbGV0IHJpZ2h0ID0gJydcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBFbXB0eS5cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gJ3snICsgKHZhbHVlLnZhbHVlIHx8ICcnKSArICd9J1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYWx0ZXJuYXRpdmUgaXMgbGVzcyBjb21tb24gdGhhbiBgcXVvdGVgLCBzd2l0Y2guXG4gICAgICAgICAgICBjb25zdCBhcHBsaWVkUXVvdGUgPVxuICAgICAgICAgICAgICBxdW90ZVNtYXJ0ICYmIGNjb3VudCh2YWx1ZSwgcXVvdGUpID4gY2NvdW50KHZhbHVlLCBhbHRlcm5hdGl2ZSlcbiAgICAgICAgICAgICAgICA/IGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgOiBxdW90ZVxuICAgICAgICAgICAgcmlnaHQgPVxuICAgICAgICAgICAgICBhcHBsaWVkUXVvdGUgK1xuICAgICAgICAgICAgICBzdHJpbmdpZnlFbnRpdGllc0xpZ2h0KHZhbHVlLCB7c3Vic2V0OiBbYXBwbGllZFF1b3RlXX0pICtcbiAgICAgICAgICAgICAgYXBwbGllZFF1b3RlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gbGVmdCArIChyaWdodCA/ICc9JyA6ICcnKSArIHJpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkQXR0cmlidXRlcy5wdXNoKHJlc3VsdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlc09uVGhlaXJPd25MaW5lID0gZmFsc2VcbiAgICBjb25zdCBhdHRyaWJ1dGVzT25PbmVMaW5lID0gc2VyaWFsaXplZEF0dHJpYnV0ZXMuam9pbignICcpXG5cbiAgICBpZiAoXG4gICAgICAvLyBCbG9jazpcbiAgICAgIGZsb3cgJiZcbiAgICAgIC8vIEluY2x1ZGluZyBhIGxpbmUgZW5kaW5nIChleHByZXNzaW9ucykuXG4gICAgICAoL1xccj9cXG58XFxyLy50ZXN0KGF0dHJpYnV0ZXNPbk9uZUxpbmUpIHx8XG4gICAgICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gKGluY2x1ZGluZyBgPHRhZ2ApLlxuICAgICAgICB0cmFja2VyT25lTGluZS5jdXJyZW50KCkubm93LmNvbHVtbiArXG4gICAgICAgICAgLy8gLTEgYmVjYXVzZSBjb2x1bW5zLCArMSBmb3IgYCBgIGJlZm9yZSBhdHRyaWJ1dGVzLlxuICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgam9pbmVkIGJ5IHNwYWNlcy5cbiAgICAgICAgICBhdHRyaWJ1dGVzT25PbmVMaW5lLmxlbmd0aCArXG4gICAgICAgICAgLy8gYCAvPmAuXG4gICAgICAgICAgKHNlbGZDbG9zaW5nID8gKHRpZ2h0U2VsZkNsb3NpbmcgPyAyIDogMykgOiAxKSA+XG4gICAgICAgICAgcHJpbnRXaWR0aClcbiAgICApIHtcbiAgICAgIGF0dHJpYnV0ZXNPblRoZWlyT3duTGluZSA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgdHJhY2tlciA9IHRyYWNrZXJPbmVMaW5lXG4gICAgbGV0IHZhbHVlID0gcHJlZml4XG5cbiAgICBpZiAoYXR0cmlidXRlc09uVGhlaXJPd25MaW5lKSB7XG4gICAgICB0cmFja2VyID0gdHJhY2tlck11bHRpTGluZVxuXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNlcmlhbGl6ZWRBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBPbmx5IGluZGVudCBmaXJzdCBsaW5lIG9mIG9mIGF0dHJpYnV0ZXMsIHdlIGNhbuKAmXQgaW5kZW50IGF0dHJpYnV0ZVxuICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgIHNlcmlhbGl6ZWRBdHRyaWJ1dGVzW2luZGV4XSA9XG4gICAgICAgICAgY3VycmVudEluZGVudCArIGluZGVudCArIHNlcmlhbGl6ZWRBdHRyaWJ1dGVzW2luZGV4XVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAgICdcXG4nICsgc2VyaWFsaXplZEF0dHJpYnV0ZXMuam9pbignXFxuJykgKyAnXFxuJyArIGN1cnJlbnRJbmRlbnRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXNPbk9uZUxpbmUpIHtcbiAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnICcgKyBhdHRyaWJ1dGVzT25PbmVMaW5lKVxuICAgIH1cblxuICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAodGlnaHRTZWxmQ2xvc2luZyB8fCBhdHRyaWJ1dGVzT25UaGVpck93bkxpbmUgPyAnJyA6ICcgJykgKyAnLydcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJz4nKVxuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnbWR4SnN4VGV4dEVsZW1lbnQnKSB7XG4gICAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgY29udGFpbmVyUGhyYXNpbmdgIGlzIHR5cGVkIGNvcnJlY3RseSwgYnV0IFRTXG4gICAgICAgICAgLy8gZ2VuZXJhdGVzICpoYXJkY29kZWQqIHR5cGVzLCB3aGljaCBtZWFucyB0aGF0IG91ciBkeW5hbWljYWxseSBhZGRlZFxuICAgICAgICAgIC8vIGRpcmVjdGl2ZXMgYXJlIG5vdCBwcmVzZW50LlxuICAgICAgICAgIC8vIEF0IHNvbWUgcG9pbnQsIFRTIHNob3VsZCBmaXggdGhhdCwgYW5kIGBmcm9tLW1hcmtkb3duYCBzaG91bGQgYmUgZmluZS5cbiAgICAgICAgICBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgICAgICAgIGJlZm9yZTogJz4nLFxuICAgICAgICAgICAgYWZ0ZXI6ICc8J1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrZXIuc2hpZnQoMilcbiAgICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuICAgICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoY29udGFpbmVyRmxvdyhub2RlLCBzdGF0ZSwgdHJhY2tlci5jdXJyZW50KCkpKVxuICAgICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ1xcbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAoZmxvdyA/IGN1cnJlbnRJbmRlbnQgOiAnJykgKyAnPC8nICsgKG5vZGUubmFtZSB8fCAnJykgKyAnPidcbiAgICAgIClcbiAgICB9XG5cbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyBNb2RpZmllZCBjb3B5IG9mOlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvYTM4MWNiYy9saWIvdXRpbC9jb250YWluZXItZmxvdy5qcz4uXG4vL1xuLy8gVG8gZG86IGFkZCBgaW5kZW50YCBzdXBwb3J0IHRvIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYC5cbi8vIEFzIGluZGVudHMgYXJlIG9ubHkgdXNlZCBmb3IgSlNYLCBpdOKAmXMgZmluZSBmb3Igbm93LCBidXQgcGVyaGFwcyBiZXR0ZXJcbi8vIHRoZXJlLlxuLyoqXG4gKiBAcGFyYW0ge01keEpzeEZsb3dFbGVtZW50fSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGZsb3cgbm9kZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge1JldHVyblR5cGU8VHJhY2tlclsnY3VycmVudCddPn0gaW5mb1xuICogICBJbmZvIG9uIHdoZXJlIHdlIGFyZSBpbiB0aGUgZG9jdW1lbnQgd2UgYXJlIGdlbmVyYXRpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIGNoaWxkcmVuLCBqb2luZWQgYnkgKGJsYW5rKSBsaW5lcy5cbiAqL1xuZnVuY3Rpb24gY29udGFpbmVyRmxvdyhwYXJlbnQsIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IGluZGV4U3RhY2sgPSBzdGF0ZS5pbmRleFN0YWNrXG4gIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGNvbnN0IGN1cnJlbnRJbmRlbnQgPSBjcmVhdGVJbmRlbnQoaW5mZXJEZXB0aChzdGF0ZSkpXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgaW5kZXhTdGFjay5wdXNoKC0xKVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF1cblxuICAgIGluZGV4U3RhY2tbaW5kZXhTdGFjay5sZW5ndGggLSAxXSA9IGluZGV4XG5cbiAgICBjb25zdCBjaGlsZEluZm8gPSB7YmVmb3JlOiAnXFxuJywgYWZ0ZXI6ICdcXG4nLCAuLi50cmFja2VyLmN1cnJlbnQoKX1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRlLmhhbmRsZShjaGlsZCwgcGFyZW50LCBzdGF0ZSwgY2hpbGRJbmZvKVxuXG4gICAgY29uc3Qgc2VyaWFsaXplZENoaWxkID1cbiAgICAgIGNoaWxkLnR5cGUgPT09ICdtZHhKc3hGbG93RWxlbWVudCdcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiBzdGF0ZS5pbmRlbnRMaW5lcyhyZXN1bHQsIGZ1bmN0aW9uIChsaW5lLCBfLCBibGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIChibGFuayA/ICcnIDogY3VycmVudEluZGVudCkgKyBsaW5lXG4gICAgICAgICAgfSlcblxuICAgIHJlc3VsdHMucHVzaCh0cmFja2VyLm1vdmUoc2VyaWFsaXplZENoaWxkKSlcblxuICAgIGlmIChjaGlsZC50eXBlICE9PSAnbGlzdCcpIHtcbiAgICAgIHN0YXRlLmJ1bGxldExhc3RVc2VkID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHRyYWNrZXIubW92ZSgnXFxuXFxuJykpXG4gICAgfVxuICB9XG5cbiAgaW5kZXhTdGFjay5wb3AoKVxuXG4gIHJldHVybiByZXN1bHRzLmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGluZmVyRGVwdGgoc3RhdGUpIHtcbiAgbGV0IGRlcHRoID0gMFxuICBsZXQgaW5kZXggPSBzdGF0ZS5zdGFjay5sZW5ndGhcblxuICB3aGlsZSAoLS1pbmRleCA+IC0xKSB7XG4gICAgY29uc3QgbmFtZSA9IHN0YXRlLnN0YWNrW2luZGV4XVxuXG4gICAgaWYgKG5hbWUgPT09ICdibG9ja3F1b3RlJyB8fCBuYW1lID09PSAnbGlzdEl0ZW0nKSBicmVha1xuICAgIGlmIChuYW1lID09PSAnbWR4SnN4Rmxvd0VsZW1lbnQnKSBkZXB0aCsrXG4gIH1cblxuICByZXR1cm4gZGVwdGhcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGVudChkZXB0aCkge1xuICByZXR1cm4gaW5kZW50LnJlcGVhdChkZXB0aClcbn1cblxuLyoqXG4gKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gcGVla0VsZW1lbnQoKSB7XG4gIHJldHVybiAnPCdcbn1cbiJdLCJuYW1lcyI6WyJjY291bnQiLCJvayIsImFzc2VydCIsInBhcnNlRW50aXRpZXMiLCJzdHJpbmdpZnlFbnRpdGllc0xpZ2h0Iiwic3RyaW5naWZ5UG9zaXRpb24iLCJWRmlsZU1lc3NhZ2UiLCJpbmRlbnQiLCJtZHhKc3hGcm9tTWFya2Rvd24iLCJjYW5Db250YWluRW9scyIsImVudGVyIiwibWR4SnN4Rmxvd1RhZyIsImVudGVyTWR4SnN4VGFnIiwibWR4SnN4Rmxvd1RhZ0Nsb3NpbmdNYXJrZXIiLCJlbnRlck1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlIiwiZW50ZXJNZHhKc3hUYWdBdHRyaWJ1dGUiLCJtZHhKc3hGbG93VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSIsImVudGVyTWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSIsIm1keEpzeEZsb3dUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwiLCJidWZmZXIiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uIiwibWR4SnN4Rmxvd1RhZ1NlbGZDbG9zaW5nTWFya2VyIiwiZW50ZXJNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlciIsIm1keEpzeFRleHRUYWciLCJtZHhKc3hUZXh0VGFnQ2xvc2luZ01hcmtlciIsIm1keEpzeFRleHRUYWdBdHRyaWJ1dGUiLCJtZHhKc3hUZXh0VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSIsIm1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uIiwibWR4SnN4VGV4dFRhZ1NlbGZDbG9zaW5nTWFya2VyIiwiZXhpdCIsImV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyIiwibWR4SnN4Rmxvd1RhZ05hbWVQcmltYXJ5IiwiZXhpdE1keEpzeFRhZ05hbWVQcmltYXJ5IiwibWR4SnN4Rmxvd1RhZ05hbWVNZW1iZXIiLCJleGl0TWR4SnN4VGFnTmFtZU1lbWJlciIsIm1keEpzeEZsb3dUYWdOYW1lTG9jYWwiLCJleGl0TWR4SnN4VGFnTmFtZUxvY2FsIiwiZXhpdE1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUiLCJtZHhKc3hGbG93VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlIiwiZGF0YSIsIm1keEpzeEZsb3dUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeSIsImV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeSIsIm1keEpzeEZsb3dUYWdBdHRyaWJ1dGVOYW1lTG9jYWwiLCJleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZUxvY2FsIiwiZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbCIsIm1keEpzeEZsb3dUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWxWYWx1ZSIsImV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb24iLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uVmFsdWUiLCJleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIiLCJleGl0TWR4SnN4VGFnIiwibWR4SnN4VGV4dFRhZ05hbWVQcmltYXJ5IiwibWR4SnN4VGV4dFRhZ05hbWVNZW1iZXIiLCJtZHhKc3hUZXh0VGFnTmFtZUxvY2FsIiwibWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZSIsIm1keEpzeFRleHRUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeSIsIm1keEpzeFRleHRUYWdBdHRyaWJ1dGVOYW1lTG9jYWwiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsVmFsdWUiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uVmFsdWUiLCJwb2ludCIsImQiLCJsaW5lIiwiY29sdW1uIiwib2Zmc2V0IiwidG9rZW4iLCJjb25maWciLCJjYWxsIiwidGFnIiwibmFtZSIsInVuZGVmaW5lZCIsImF0dHJpYnV0ZXMiLCJjbG9zZSIsInNlbGZDbG9zaW5nIiwic3RhcnQiLCJlbmQiLCJtZHhKc3hUYWdTdGFjayIsIm1keEpzeFRhZyIsInN0YWNrIiwibGVuZ3RoIiwiZW50ZXJNZHhKc3hUYWdBbnlBdHRyaWJ1dGUiLCJzbGljZVNlcmlhbGl6ZSIsInB1c2giLCJ0eXBlIiwidmFsdWUiLCJwb3NpdGlvbiIsInRhaWwiLCJlc3RyZWUiLCJyZXN1bWUiLCJub2RlIiwibm9uVGVybWluYXRlZCIsInNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnIiwicG9wIiwiY2hpbGRyZW4iLCJvbkVycm9yUmlnaHRJc1RhZyIsIm9uRXJyb3JMZWZ0SXNUYWciLCJjbG9zaW5nIiwib3BlbiIsInBsYWNlIiwiYSIsImIiLCJtZHhKc3hUb01hcmtkb3duIiwib3B0aW9ucyIsIm9wdGlvbnNfIiwicXVvdGUiLCJxdW90ZVNtYXJ0IiwidGlnaHRTZWxmQ2xvc2luZyIsInByaW50V2lkdGgiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImFsdGVybmF0aXZlIiwiRXJyb3IiLCJtZHhFbGVtZW50IiwicGVlayIsInBlZWtFbGVtZW50IiwiaGFuZGxlcnMiLCJtZHhKc3hGbG93RWxlbWVudCIsIm1keEpzeFRleHRFbGVtZW50IiwidW5zYWZlIiwiY2hhcmFjdGVyIiwiaW5Db25zdHJ1Y3QiLCJhdEJyZWFrIiwiZmVuY2VzIiwicmVzb3VyY2VMaW5rIiwiXyIsInN0YXRlIiwiaW5mbyIsImZsb3ciLCJkZXB0aCIsImluZmVyRGVwdGgiLCJjdXJyZW50SW5kZW50IiwiY3JlYXRlSW5kZW50IiwidHJhY2tlck9uZUxpbmUiLCJjcmVhdGVUcmFja2VyIiwidHJhY2tlck11bHRpTGluZSIsInNlcmlhbGl6ZWRBdHRyaWJ1dGVzIiwicHJlZml4IiwibW92ZSIsImluZGV4IiwiYXR0cmlidXRlIiwicmVzdWx0IiwibGVmdCIsInJpZ2h0IiwiYXBwbGllZFF1b3RlIiwic3Vic2V0IiwiYXR0cmlidXRlc09uVGhlaXJPd25MaW5lIiwiYXR0cmlidXRlc09uT25lTGluZSIsImpvaW4iLCJ0ZXN0IiwiY3VycmVudCIsIm5vdyIsInRyYWNrZXIiLCJjb250YWluZXJQaHJhc2luZyIsImJlZm9yZSIsImFmdGVyIiwic2hpZnQiLCJjb250YWluZXJGbG93IiwicGFyZW50IiwiaW5kZXhTdGFjayIsInJlc3VsdHMiLCJjaGlsZCIsImNoaWxkSW5mbyIsImhhbmRsZSIsInNlcmlhbGl6ZWRDaGlsZCIsImluZGVudExpbmVzIiwiYmxhbmsiLCJidWxsZXRMYXN0VXNlZCIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-mdx-jsx/lib/index.js\n");

/***/ })

};
;