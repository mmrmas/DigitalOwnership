"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-mdx-expression";
exports.ids = ["vendor-chunks/micromark-extension-mdx-expression"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js":
/*!***************************************************************************!*\
  !*** ./node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxExpression: () => (/* binding */ mdxExpression)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-mdx-expression */ \"(ssr)/./node_modules/micromark-factory-mdx-expression/dev/index.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/**\n * @typedef {import('micromark-util-events-to-acorn').Acorn} Acorn\n * @typedef {import('micromark-util-events-to-acorn').AcornOptions} AcornOptions\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */ /**\n * @typedef Options\n *   Configuration (optional).\n * @property {Acorn | null | undefined} [acorn]\n *   Acorn parser to use (optional).\n * @property {AcornOptions | null | undefined} [acornOptions]\n *   Configuration for acorn (default: `{ecmaVersion: 2024, locations: true,\n *   sourceType: 'module'}`).\n *\n *   All fields except `locations` can be set.\n * @property {boolean | null | undefined} [addResult=false]\n *   Whether to add `estree` fields to tokens with results from acorn (default:\n *   `false`).\n * @property {boolean | null | undefined} [spread=false]\n *   Undocumented option to parse only a spread (used by\n *   `micromark-extension-mdx-jsx` to parse spread attributes) (default:\n *   `false`).\n * @property {boolean | null | undefined} [allowEmpty=true]\n *   Undocumented option to disallow empty attributes (used by\n *   `micromark-extension-mdx-jsx` to prohobit empty attribute values)\n *   (default: `false`).\n */ \n\n\n\n\n/**\n * Create an extension for `micromark` to enable MDX expression syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable MDX\n *   expression syntax.\n */ function mdxExpression(options) {\n    const options_ = options || {};\n    const addResult = options_.addResult;\n    const acorn = options_.acorn;\n    // Hidden: `micromark-extension-mdx-jsx` supports expressions in tags,\n    // and one of them is only “spread” elements.\n    // It also has expressions that are not allowed to be empty (`<x y={}/>`).\n    // Instead of duplicating code there, this are two small hidden feature here\n    // to test that behavior.\n    const spread = options_.spread;\n    let allowEmpty = options_.allowEmpty;\n    /** @type {AcornOptions} */ let acornOptions;\n    if (allowEmpty === null || allowEmpty === undefined) {\n        allowEmpty = true;\n    }\n    if (acorn) {\n        if (!acorn.parseExpressionAt) {\n            throw new Error(\"Expected a proper `acorn` instance passed in as `options.acorn`\");\n        }\n        acornOptions = Object.assign({\n            ecmaVersion: 2024,\n            sourceType: \"module\"\n        }, options_.acornOptions);\n    } else if (options_.acornOptions || options_.addResult) {\n        throw new Error(\"Expected an `acorn` instance passed in as `options.acorn`\");\n    }\n    return {\n        flow: {\n            [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n                name: \"mdxFlowExpression\",\n                tokenize: tokenizeFlowExpression,\n                concrete: true\n            }\n        },\n        text: {\n            [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace]: {\n                name: \"mdxTextExpression\",\n                tokenize: tokenizeTextExpression\n            }\n        }\n    };\n    /**\n   * MDX expression (flow).\n   *\n   * ```markdown\n   * > | {Math.PI}\n   *     ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */ function tokenizeFlowExpression(effects, ok, nok) {\n        const self = this;\n        return start;\n        /**\n     * Start of an MDX expression (flow).\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */ function start(code) {\n            // To do: in `markdown-rs`, constructs need to parse the indent themselves.\n            // This should also be introduced in `micromark-js`.\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, \"expected `{`\");\n            return before(code);\n        }\n        /**\n     * After optional whitespace, before expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */ function before(code) {\n            return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(self, effects, after, \"mdxFlowExpression\", \"mdxFlowExpressionMarker\", \"mdxFlowExpressionChunk\", acorn, acornOptions, addResult, spread, allowEmpty)(code);\n        }\n        /**\n     * After expression.\n     *\n     * ```markdown\n     * > | {Math.PI}\n     *              ^\n     * ```\n     *\n     * @type {State}\n     */ function after(code) {\n            return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code) ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, end, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.types.whitespace)(code) : end(code);\n        }\n        /**\n     * After expression, after optional whitespace.\n     *\n     * ```markdown\n     * > | {Math.PI}␠␊\n     *               ^\n     * ```\n     *\n     * @type {State}\n     */ function end(code) {\n            // We want to allow tags directly after expressions.\n            //\n            // This case is useful:\n            //\n            // ```mdx\n            // <a>{b}</a>\n            // ```\n            //\n            // This case is not (very?) useful:\n            //\n            // ```mdx\n            // {a}<b/>\n            // ```\n            //\n            // …but it would be tougher than needed to disallow.\n            //\n            // To allow that, here we call the flow construct of\n            // `micromark-extension-mdx-jsx`, and there we call this one.\n            //\n            // It would introduce a cyclical interdependency if we test JSX and\n            // expressions here.\n            // Because the JSX extension already uses parts of this monorepo, we\n            // instead test it there.\n            const lessThanValue = self.parser.constructs.flow[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan];\n            const constructs = Array.isArray(lessThanValue) ? lessThanValue : /* c8 ignore next 3 -- always a list when normalized. */ lessThanValue ? [\n                lessThanValue\n            ] : [];\n            const jsxTag = constructs.find(function(d) {\n                return d.name === \"mdxJsxFlowTag\";\n            });\n            /* c8 ignore next 3 -- this is tested in `micromark-extension-mdx-jsx` */ if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan && jsxTag) {\n                return effects.attempt(jsxTag, end, nok)(code);\n            }\n            return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code) ? ok(code) : nok(code);\n        }\n    }\n    /**\n   * MDX expression (text).\n   *\n   * ```markdown\n   * > | a {Math.PI} c.\n   *       ^^^^^^^^^\n   * ```\n   *\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */ function tokenizeTextExpression(effects, ok) {\n        const self = this;\n        return start;\n        /**\n     * Start of an MDX expression (text).\n     *\n     * ```markdown\n     * > | a {Math.PI} c.\n     *       ^\n     * ```\n     *\n     *\n     * @type {State}\n     */ function start(code) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace, \"expected `{`\");\n            return micromark_factory_mdx_expression__WEBPACK_IMPORTED_MODULE_2__.factoryMdxExpression.call(self, effects, ok, \"mdxTextExpression\", \"mdxTextExpressionMarker\", \"mdxTextExpressionChunk\", acorn, acornOptions, addResult, spread, allowEmpty, true)(code);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtZXhwcmVzc2lvbi9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FFa0M7QUFDa0M7QUFDakI7QUFDc0I7QUFDeEI7QUFFbEQ7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTUSxjQUFjQyxPQUFPO0lBQ25DLE1BQU1DLFdBQVdELFdBQVcsQ0FBQztJQUM3QixNQUFNRSxZQUFZRCxTQUFTQyxTQUFTO0lBQ3BDLE1BQU1DLFFBQVFGLFNBQVNFLEtBQUs7SUFDNUIsc0VBQXNFO0lBQ3RFLDZDQUE2QztJQUM3QywwRUFBMEU7SUFDMUUsNEVBQTRFO0lBQzVFLHlCQUF5QjtJQUN6QixNQUFNQyxTQUFTSCxTQUFTRyxNQUFNO0lBQzlCLElBQUlDLGFBQWFKLFNBQVNJLFVBQVU7SUFDcEMseUJBQXlCLEdBQ3pCLElBQUlDO0lBRUosSUFBSUQsZUFBZSxRQUFRQSxlQUFlRSxXQUFXO1FBQ25ERixhQUFhO0lBQ2Y7SUFFQSxJQUFJRixPQUFPO1FBQ1QsSUFBSSxDQUFDQSxNQUFNSyxpQkFBaUIsRUFBRTtZQUM1QixNQUFNLElBQUlDLE1BQ1I7UUFFSjtRQUVBSCxlQUFlSSxPQUFPQyxNQUFNLENBQzFCO1lBQUNDLGFBQWE7WUFBTUMsWUFBWTtRQUFRLEdBQ3hDWixTQUFTSyxZQUFZO0lBRXpCLE9BQU8sSUFBSUwsU0FBU0ssWUFBWSxJQUFJTCxTQUFTQyxTQUFTLEVBQUU7UUFDdEQsTUFBTSxJQUFJTyxNQUFNO0lBQ2xCO0lBRUEsT0FBTztRQUNMSyxNQUFNO1lBQ0osQ0FBQ2pCLHdEQUFLQSxDQUFDa0IsY0FBYyxDQUFDLEVBQUU7Z0JBQ3RCQyxNQUFNO2dCQUNOQyxVQUFVQztnQkFDVkMsVUFBVTtZQUNaO1FBQ0Y7UUFDQUMsTUFBTTtZQUNKLENBQUN2Qix3REFBS0EsQ0FBQ2tCLGNBQWMsQ0FBQyxFQUFFO2dCQUN0QkMsTUFBTTtnQkFDTkMsVUFBVUk7WUFDWjtRQUNGO0lBQ0Y7SUFFQTs7Ozs7Ozs7OztHQVVDLEdBQ0QsU0FBU0gsdUJBQXVCSSxPQUFPLEVBQUUvQixFQUFFLEVBQUVnQyxHQUFHO1FBQzlDLE1BQU1DLE9BQU8sSUFBSTtRQUVqQixPQUFPQztRQUVQOzs7Ozs7Ozs7S0FTQyxHQUNELFNBQVNBLE1BQU1DLElBQUk7WUFDakIsMkVBQTJFO1lBQzNFLG9EQUFvRDtZQUNwRGxDLDBDQUFNQSxDQUFDa0MsU0FBUzdCLHdEQUFLQSxDQUFDa0IsY0FBYyxFQUFFO1lBQ3RDLE9BQU9ZLE9BQU9EO1FBQ2hCO1FBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsU0FBU0MsT0FBT0QsSUFBSTtZQUNsQixPQUFPakMsa0ZBQW9CQSxDQUFDbUMsSUFBSSxDQUM5QkosTUFDQUYsU0FDQU8sT0FDQSxxQkFDQSwyQkFDQSwwQkFDQTFCLE9BQ0FHLGNBQ0FKLFdBQ0FFLFFBQ0FDLFlBQ0FxQjtRQUNKO1FBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsU0FBU0csTUFBTUgsSUFBSTtZQUNqQixPQUFPOUIsdUVBQWFBLENBQUM4QixRQUNqQmhDLHFFQUFZQSxDQUFDNEIsU0FBU1EsS0FBS2hDLHdEQUFLQSxDQUFDaUMsVUFBVSxFQUFFTCxRQUM3Q0ksSUFBSUo7UUFDVjtRQUVBOzs7Ozs7Ozs7S0FTQyxHQUNELFNBQVNJLElBQUlKLElBQUk7WUFDZixvREFBb0Q7WUFDcEQsRUFBRTtZQUNGLHVCQUF1QjtZQUN2QixFQUFFO1lBQ0YsU0FBUztZQUNULGFBQWE7WUFDYixNQUFNO1lBQ04sRUFBRTtZQUNGLG1DQUFtQztZQUNuQyxFQUFFO1lBQ0YsU0FBUztZQUNULFVBQVU7WUFDVixNQUFNO1lBQ04sRUFBRTtZQUNGLG9EQUFvRDtZQUNwRCxFQUFFO1lBQ0Ysb0RBQW9EO1lBQ3BELDZEQUE2RDtZQUM3RCxFQUFFO1lBQ0YsbUVBQW1FO1lBQ25FLG9CQUFvQjtZQUNwQixvRUFBb0U7WUFDcEUseUJBQXlCO1lBQ3pCLE1BQU1NLGdCQUFnQlIsS0FBS1MsTUFBTSxDQUFDQyxVQUFVLENBQUNwQixJQUFJLENBQUNqQix3REFBS0EsQ0FBQ3NDLFFBQVEsQ0FBQztZQUNqRSxNQUFNRCxhQUFhRSxNQUFNQyxPQUFPLENBQUNMLGlCQUM3QkEsZ0JBQ0Esc0RBQXNELEdBQ3hEQSxnQkFDRTtnQkFBQ0E7YUFBYyxHQUNmLEVBQUU7WUFDTixNQUFNTSxTQUFTSixXQUFXSyxJQUFJLENBQUMsU0FBVUMsQ0FBQztnQkFDeEMsT0FBT0EsRUFBRXhCLElBQUksS0FBSztZQUNwQjtZQUVBLHVFQUF1RSxHQUN2RSxJQUFJVSxTQUFTN0Isd0RBQUtBLENBQUNzQyxRQUFRLElBQUlHLFFBQVE7Z0JBQ3JDLE9BQU9oQixRQUFRbUIsT0FBTyxDQUFDSCxRQUFRUixLQUFLUCxLQUFLRztZQUMzQztZQUVBLE9BQU9BLFNBQVM3Qix3REFBS0EsQ0FBQzZDLEdBQUcsSUFBSS9DLDRFQUFrQkEsQ0FBQytCLFFBQzVDbkMsR0FBR21DLFFBQ0hILElBQUlHO1FBQ1Y7SUFDRjtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRCxTQUFTTCx1QkFBdUJDLE9BQU8sRUFBRS9CLEVBQUU7UUFDekMsTUFBTWlDLE9BQU8sSUFBSTtRQUVqQixPQUFPQztRQUVQOzs7Ozs7Ozs7O0tBVUMsR0FDRCxTQUFTQSxNQUFNQyxJQUFJO1lBQ2pCbEMsMENBQU1BLENBQUNrQyxTQUFTN0Isd0RBQUtBLENBQUNrQixjQUFjLEVBQUU7WUFDdEMsT0FBT3RCLGtGQUFvQkEsQ0FBQ21DLElBQUksQ0FDOUJKLE1BQ0FGLFNBQ0EvQixJQUNBLHFCQUNBLDJCQUNBLDBCQUNBWSxPQUNBRyxjQUNBSixXQUNBRSxRQUNBQyxZQUNBLE1BQ0FxQjtRQUNKO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2lwdC13My8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uL2Rldi9saWIvc3ludGF4LmpzPzU2ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4nKS5BY29ybn0gQWNvcm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybicpLkFjb3JuT3B0aW9uc30gQWNvcm5PcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZXJ9IFRva2VuaXplclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Fjb3JuXVxuICogICBBY29ybiBwYXJzZXIgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0Fjb3JuT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFthY29ybk9wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIGFjb3JuIChkZWZhdWx0OiBge2VjbWFWZXJzaW9uOiAyMDI0LCBsb2NhdGlvbnM6IHRydWUsXG4gKiAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnfWApLlxuICpcbiAqICAgQWxsIGZpZWxkcyBleGNlcHQgYGxvY2F0aW9uc2AgY2FuIGJlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthZGRSZXN1bHQ9ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdG8gYWRkIGBlc3RyZWVgIGZpZWxkcyB0byB0b2tlbnMgd2l0aCByZXN1bHRzIGZyb20gYWNvcm4gKGRlZmF1bHQ6XG4gKiAgIGBmYWxzZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwcmVhZD1mYWxzZV1cbiAqICAgVW5kb2N1bWVudGVkIG9wdGlvbiB0byBwYXJzZSBvbmx5IGEgc3ByZWFkICh1c2VkIGJ5XG4gKiAgIGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHRvIHBhcnNlIHNwcmVhZCBhdHRyaWJ1dGVzKSAoZGVmYXVsdDpcbiAqICAgYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWxsb3dFbXB0eT10cnVlXVxuICogICBVbmRvY3VtZW50ZWQgb3B0aW9uIHRvIGRpc2FsbG93IGVtcHR5IGF0dHJpYnV0ZXMgKHVzZWQgYnlcbiAqICAgYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAgdG8gcHJvaG9iaXQgZW1wdHkgYXR0cmlidXRlIHZhbHVlcylcbiAqICAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge2ZhY3RvcnlNZHhFeHByZXNzaW9ufSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1tZHgtZXhwcmVzc2lvbidcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nLCBtYXJrZG93blNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIGVuYWJsZSBNRFggZXhwcmVzc2lvbiBzeW50YXguXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCB0byBlbmFibGUgTURYXG4gKiAgIGV4cHJlc3Npb24gc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWR4RXhwcmVzc2lvbihvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBhZGRSZXN1bHQgPSBvcHRpb25zXy5hZGRSZXN1bHRcbiAgY29uc3QgYWNvcm4gPSBvcHRpb25zXy5hY29yblxuICAvLyBIaWRkZW46IGBtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1qc3hgIHN1cHBvcnRzIGV4cHJlc3Npb25zIGluIHRhZ3MsXG4gIC8vIGFuZCBvbmUgb2YgdGhlbSBpcyBvbmx5IOKAnHNwcmVhZOKAnSBlbGVtZW50cy5cbiAgLy8gSXQgYWxzbyBoYXMgZXhwcmVzc2lvbnMgdGhhdCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHkgKGA8eCB5PXt9Lz5gKS5cbiAgLy8gSW5zdGVhZCBvZiBkdXBsaWNhdGluZyBjb2RlIHRoZXJlLCB0aGlzIGFyZSB0d28gc21hbGwgaGlkZGVuIGZlYXR1cmUgaGVyZVxuICAvLyB0byB0ZXN0IHRoYXQgYmVoYXZpb3IuXG4gIGNvbnN0IHNwcmVhZCA9IG9wdGlvbnNfLnNwcmVhZFxuICBsZXQgYWxsb3dFbXB0eSA9IG9wdGlvbnNfLmFsbG93RW1wdHlcbiAgLyoqIEB0eXBlIHtBY29ybk9wdGlvbnN9ICovXG4gIGxldCBhY29ybk9wdGlvbnNcblxuICBpZiAoYWxsb3dFbXB0eSA9PT0gbnVsbCB8fCBhbGxvd0VtcHR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBhbGxvd0VtcHR5ID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGFjb3JuKSB7XG4gICAgaWYgKCFhY29ybi5wYXJzZUV4cHJlc3Npb25BdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYSBwcm9wZXIgYGFjb3JuYCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgYG9wdGlvbnMuYWNvcm5gJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7ZWNtYVZlcnNpb246IDIwMjQsIHNvdXJjZVR5cGU6ICdtb2R1bGUnfSxcbiAgICAgIG9wdGlvbnNfLmFjb3JuT3B0aW9uc1xuICAgIClcbiAgfSBlbHNlIGlmIChvcHRpb25zXy5hY29ybk9wdGlvbnMgfHwgb3B0aW9uc18uYWRkUmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBgYWNvcm5gIGluc3RhbmNlIHBhc3NlZCBpbiBhcyBgb3B0aW9ucy5hY29ybmAnKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbG93OiB7XG4gICAgICBbY29kZXMubGVmdEN1cmx5QnJhY2VdOiB7XG4gICAgICAgIG5hbWU6ICdtZHhGbG93RXhwcmVzc2lvbicsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZUZsb3dFeHByZXNzaW9uLFxuICAgICAgICBjb25jcmV0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgW2NvZGVzLmxlZnRDdXJseUJyYWNlXToge1xuICAgICAgICBuYW1lOiAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemVUZXh0RXhwcmVzc2lvblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNRFggZXhwcmVzc2lvbiAoZmxvdykuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB7TWF0aC5QSX1cbiAgICogICAgIF5eXl5eXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAgICogQHR5cGUge1Rva2VuaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRva2VuaXplRmxvd0V4cHJlc3Npb24oZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uIChmbG93KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIGNvbnN0cnVjdHMgbmVlZCB0byBwYXJzZSB0aGUgaW5kZW50IHRoZW1zZWx2ZXMuXG4gICAgICAvLyBUaGlzIHNob3VsZCBhbHNvIGJlIGludHJvZHVjZWQgaW4gYG1pY3JvbWFyay1qc2AuXG4gICAgICBhc3NlcnQoY29kZSA9PT0gY29kZXMubGVmdEN1cmx5QnJhY2UsICdleHBlY3RlZCBge2AnKVxuICAgICAgcmV0dXJuIGJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UsIGJlZm9yZSBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiA+IHwge01hdGguUEl9XG4gICAgICogICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUoY29kZSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlNZHhFeHByZXNzaW9uLmNhbGwoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGFmdGVyLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb24nLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25NYXJrZXInLFxuICAgICAgICAnbWR4Rmxvd0V4cHJlc3Npb25DaHVuaycsXG4gICAgICAgIGFjb3JuLFxuICAgICAgICBhY29ybk9wdGlvbnMsXG4gICAgICAgIGFkZFJlc3VsdCxcbiAgICAgICAgc3ByZWFkLFxuICAgICAgICBhbGxvd0VtcHR5XG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IHtNYXRoLlBJfVxuICAgICAqICAgICAgICAgICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgICAgcmV0dXJuIG1hcmtkb3duU3BhY2UoY29kZSlcbiAgICAgICAgPyBmYWN0b3J5U3BhY2UoZWZmZWN0cywgZW5kLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgICAgICA6IGVuZChjb2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIGV4cHJlc3Npb24sIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCB7TWF0aC5QSX3ikKDikIpcbiAgICAgKiAgICAgICAgICAgICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmQoY29kZSkge1xuICAgICAgLy8gV2Ugd2FudCB0byBhbGxvdyB0YWdzIGRpcmVjdGx5IGFmdGVyIGV4cHJlc3Npb25zLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FzZSBpcyB1c2VmdWw6XG4gICAgICAvL1xuICAgICAgLy8gYGBgbWR4XG4gICAgICAvLyA8YT57Yn08L2E+XG4gICAgICAvLyBgYGBcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGNhc2UgaXMgbm90ICh2ZXJ5PykgdXNlZnVsOlxuICAgICAgLy9cbiAgICAgIC8vIGBgYG1keFxuICAgICAgLy8ge2F9PGIvPlxuICAgICAgLy8gYGBgXG4gICAgICAvL1xuICAgICAgLy8g4oCmYnV0IGl0IHdvdWxkIGJlIHRvdWdoZXIgdGhhbiBuZWVkZWQgdG8gZGlzYWxsb3cuXG4gICAgICAvL1xuICAgICAgLy8gVG8gYWxsb3cgdGhhdCwgaGVyZSB3ZSBjYWxsIHRoZSBmbG93IGNvbnN0cnVjdCBvZlxuICAgICAgLy8gYG1pY3JvbWFyay1leHRlbnNpb24tbWR4LWpzeGAsIGFuZCB0aGVyZSB3ZSBjYWxsIHRoaXMgb25lLlxuICAgICAgLy9cbiAgICAgIC8vIEl0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xpY2FsIGludGVyZGVwZW5kZW5jeSBpZiB3ZSB0ZXN0IEpTWCBhbmRcbiAgICAgIC8vIGV4cHJlc3Npb25zIGhlcmUuXG4gICAgICAvLyBCZWNhdXNlIHRoZSBKU1ggZXh0ZW5zaW9uIGFscmVhZHkgdXNlcyBwYXJ0cyBvZiB0aGlzIG1vbm9yZXBvLCB3ZVxuICAgICAgLy8gaW5zdGVhZCB0ZXN0IGl0IHRoZXJlLlxuICAgICAgY29uc3QgbGVzc1RoYW5WYWx1ZSA9IHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZmxvd1tjb2Rlcy5sZXNzVGhhbl1cbiAgICAgIGNvbnN0IGNvbnN0cnVjdHMgPSBBcnJheS5pc0FycmF5KGxlc3NUaGFuVmFsdWUpXG4gICAgICAgID8gbGVzc1RoYW5WYWx1ZVxuICAgICAgICA6IC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYWx3YXlzIGEgbGlzdCB3aGVuIG5vcm1hbGl6ZWQuICovXG4gICAgICAgIGxlc3NUaGFuVmFsdWVcbiAgICAgICAgPyBbbGVzc1RoYW5WYWx1ZV1cbiAgICAgICAgOiBbXVxuICAgICAgY29uc3QganN4VGFnID0gY29uc3RydWN0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLm5hbWUgPT09ICdtZHhKc3hGbG93VGFnJ1xuICAgICAgfSlcblxuICAgICAgLyogYzggaWdub3JlIG5leHQgMyAtLSB0aGlzIGlzIHRlc3RlZCBpbiBgbWljcm9tYXJrLWV4dGVuc2lvbi1tZHgtanN4YCAqL1xuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmxlc3NUaGFuICYmIGpzeFRhZykge1xuICAgICAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KGpzeFRhZywgZW5kLCBub2spKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpXG4gICAgICAgID8gb2soY29kZSlcbiAgICAgICAgOiBub2soY29kZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTURYIGV4cHJlc3Npb24gKHRleHQpLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSB7TWF0aC5QSX0gYy5cbiAgICogICAgICAgXl5eXl5eXl5eXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICAgKiBAdHlwZSB7VG9rZW5pemVyfVxuICAgKi9cbiAgZnVuY3Rpb24gdG9rZW5pemVUZXh0RXhwcmVzc2lvbihlZmZlY3RzLCBvaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICByZXR1cm4gc3RhcnRcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGFuIE1EWCBleHByZXNzaW9uICh0ZXh0KS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogPiB8IGEge01hdGguUEl9IGMuXG4gICAgICogICAgICAgXlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmxlZnRDdXJseUJyYWNlLCAnZXhwZWN0ZWQgYHtgJylcbiAgICAgIHJldHVybiBmYWN0b3J5TWR4RXhwcmVzc2lvbi5jYWxsKFxuICAgICAgICBzZWxmLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBvayxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uTWFya2VyJyxcbiAgICAgICAgJ21keFRleHRFeHByZXNzaW9uQ2h1bmsnLFxuICAgICAgICBhY29ybixcbiAgICAgICAgYWNvcm5PcHRpb25zLFxuICAgICAgICBhZGRSZXN1bHQsXG4gICAgICAgIHNwcmVhZCxcbiAgICAgICAgYWxsb3dFbXB0eSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKShjb2RlKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiZmFjdG9yeU1keEV4cHJlc3Npb24iLCJmYWN0b3J5U3BhY2UiLCJtYXJrZG93bkxpbmVFbmRpbmciLCJtYXJrZG93blNwYWNlIiwiY29kZXMiLCJ0eXBlcyIsIm1keEV4cHJlc3Npb24iLCJvcHRpb25zIiwib3B0aW9uc18iLCJhZGRSZXN1bHQiLCJhY29ybiIsInNwcmVhZCIsImFsbG93RW1wdHkiLCJhY29ybk9wdGlvbnMiLCJ1bmRlZmluZWQiLCJwYXJzZUV4cHJlc3Npb25BdCIsIkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwiZmxvdyIsImxlZnRDdXJseUJyYWNlIiwibmFtZSIsInRva2VuaXplIiwidG9rZW5pemVGbG93RXhwcmVzc2lvbiIsImNvbmNyZXRlIiwidGV4dCIsInRva2VuaXplVGV4dEV4cHJlc3Npb24iLCJlZmZlY3RzIiwibm9rIiwic2VsZiIsInN0YXJ0IiwiY29kZSIsImJlZm9yZSIsImNhbGwiLCJhZnRlciIsImVuZCIsIndoaXRlc3BhY2UiLCJsZXNzVGhhblZhbHVlIiwicGFyc2VyIiwiY29uc3RydWN0cyIsImxlc3NUaGFuIiwiQXJyYXkiLCJpc0FycmF5IiwianN4VGFnIiwiZmluZCIsImQiLCJhdHRlbXB0IiwiZW9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js\n");

/***/ })

};
;