/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/acorn";
exports.ids = ["vendor-chunks/acorn"];
exports.modules = {

/***/ "(ssr)/./node_modules/acorn/dist/acorn.js":
/*!******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    // This file was generated. Do not modify manually!\n    var astralIdentifierCodes = [\n        509,\n        0,\n        227,\n        0,\n        150,\n        4,\n        294,\n        9,\n        1368,\n        2,\n        2,\n        1,\n        6,\n        3,\n        41,\n        2,\n        5,\n        0,\n        166,\n        1,\n        574,\n        3,\n        9,\n        9,\n        370,\n        1,\n        81,\n        2,\n        71,\n        10,\n        50,\n        3,\n        123,\n        2,\n        54,\n        14,\n        32,\n        10,\n        3,\n        1,\n        11,\n        3,\n        46,\n        10,\n        8,\n        0,\n        46,\n        9,\n        7,\n        2,\n        37,\n        13,\n        2,\n        9,\n        6,\n        1,\n        45,\n        0,\n        13,\n        2,\n        49,\n        13,\n        9,\n        3,\n        2,\n        11,\n        83,\n        11,\n        7,\n        0,\n        3,\n        0,\n        158,\n        11,\n        6,\n        9,\n        7,\n        3,\n        56,\n        1,\n        2,\n        6,\n        3,\n        1,\n        3,\n        2,\n        10,\n        0,\n        11,\n        1,\n        3,\n        6,\n        4,\n        4,\n        193,\n        17,\n        10,\n        9,\n        5,\n        0,\n        82,\n        19,\n        13,\n        9,\n        214,\n        6,\n        3,\n        8,\n        28,\n        1,\n        83,\n        16,\n        16,\n        9,\n        82,\n        12,\n        9,\n        9,\n        84,\n        14,\n        5,\n        9,\n        243,\n        14,\n        166,\n        9,\n        71,\n        5,\n        2,\n        1,\n        3,\n        3,\n        2,\n        0,\n        2,\n        1,\n        13,\n        9,\n        120,\n        6,\n        3,\n        6,\n        4,\n        0,\n        29,\n        9,\n        41,\n        6,\n        2,\n        3,\n        9,\n        0,\n        10,\n        10,\n        47,\n        15,\n        406,\n        7,\n        2,\n        7,\n        17,\n        9,\n        57,\n        21,\n        2,\n        13,\n        123,\n        5,\n        4,\n        0,\n        2,\n        1,\n        2,\n        6,\n        2,\n        0,\n        9,\n        9,\n        49,\n        4,\n        2,\n        1,\n        2,\n        4,\n        9,\n        9,\n        330,\n        3,\n        10,\n        1,\n        2,\n        0,\n        49,\n        6,\n        4,\n        4,\n        14,\n        9,\n        5351,\n        0,\n        7,\n        14,\n        13835,\n        9,\n        87,\n        9,\n        39,\n        4,\n        60,\n        6,\n        26,\n        9,\n        1014,\n        0,\n        2,\n        54,\n        8,\n        3,\n        82,\n        0,\n        12,\n        1,\n        19628,\n        1,\n        4706,\n        45,\n        3,\n        22,\n        543,\n        4,\n        4,\n        5,\n        9,\n        7,\n        3,\n        6,\n        31,\n        3,\n        149,\n        2,\n        1418,\n        49,\n        513,\n        54,\n        5,\n        49,\n        9,\n        0,\n        15,\n        0,\n        23,\n        4,\n        2,\n        14,\n        1361,\n        6,\n        2,\n        16,\n        3,\n        6,\n        2,\n        1,\n        2,\n        4,\n        101,\n        0,\n        161,\n        6,\n        10,\n        9,\n        357,\n        0,\n        62,\n        13,\n        499,\n        13,\n        983,\n        6,\n        110,\n        6,\n        6,\n        9,\n        4759,\n        9,\n        787719,\n        239\n    ];\n    // This file was generated. Do not modify manually!\n    var astralIdentifierStartCodes = [\n        0,\n        11,\n        2,\n        25,\n        2,\n        18,\n        2,\n        1,\n        2,\n        14,\n        3,\n        13,\n        35,\n        122,\n        70,\n        52,\n        268,\n        28,\n        4,\n        48,\n        48,\n        31,\n        14,\n        29,\n        6,\n        37,\n        11,\n        29,\n        3,\n        35,\n        5,\n        7,\n        2,\n        4,\n        43,\n        157,\n        19,\n        35,\n        5,\n        35,\n        5,\n        39,\n        9,\n        51,\n        13,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        2,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        68,\n        310,\n        10,\n        21,\n        11,\n        7,\n        25,\n        5,\n        2,\n        41,\n        2,\n        8,\n        70,\n        5,\n        3,\n        0,\n        2,\n        43,\n        2,\n        1,\n        4,\n        0,\n        3,\n        22,\n        11,\n        22,\n        10,\n        30,\n        66,\n        18,\n        2,\n        1,\n        11,\n        21,\n        11,\n        25,\n        71,\n        55,\n        7,\n        1,\n        65,\n        0,\n        16,\n        3,\n        2,\n        2,\n        2,\n        28,\n        43,\n        28,\n        4,\n        28,\n        36,\n        7,\n        2,\n        27,\n        28,\n        53,\n        11,\n        21,\n        11,\n        18,\n        14,\n        17,\n        111,\n        72,\n        56,\n        50,\n        14,\n        50,\n        14,\n        35,\n        349,\n        41,\n        7,\n        1,\n        79,\n        28,\n        11,\n        0,\n        9,\n        21,\n        43,\n        17,\n        47,\n        20,\n        28,\n        22,\n        13,\n        52,\n        58,\n        1,\n        3,\n        0,\n        14,\n        44,\n        33,\n        24,\n        27,\n        35,\n        30,\n        0,\n        3,\n        0,\n        9,\n        34,\n        4,\n        0,\n        13,\n        47,\n        15,\n        3,\n        22,\n        0,\n        2,\n        0,\n        36,\n        17,\n        2,\n        24,\n        20,\n        1,\n        64,\n        6,\n        2,\n        0,\n        2,\n        3,\n        2,\n        14,\n        2,\n        9,\n        8,\n        46,\n        39,\n        7,\n        3,\n        1,\n        3,\n        21,\n        2,\n        6,\n        2,\n        1,\n        2,\n        4,\n        4,\n        0,\n        19,\n        0,\n        13,\n        4,\n        159,\n        52,\n        19,\n        3,\n        21,\n        2,\n        31,\n        47,\n        21,\n        1,\n        2,\n        0,\n        185,\n        46,\n        42,\n        3,\n        37,\n        47,\n        21,\n        0,\n        60,\n        42,\n        14,\n        0,\n        72,\n        26,\n        38,\n        6,\n        186,\n        43,\n        117,\n        63,\n        32,\n        7,\n        3,\n        0,\n        3,\n        7,\n        2,\n        1,\n        2,\n        23,\n        16,\n        0,\n        2,\n        0,\n        95,\n        7,\n        3,\n        38,\n        17,\n        0,\n        2,\n        0,\n        29,\n        0,\n        11,\n        39,\n        8,\n        0,\n        22,\n        0,\n        12,\n        45,\n        20,\n        0,\n        19,\n        72,\n        264,\n        8,\n        2,\n        36,\n        18,\n        0,\n        50,\n        29,\n        113,\n        6,\n        2,\n        1,\n        2,\n        37,\n        22,\n        0,\n        26,\n        5,\n        2,\n        1,\n        2,\n        31,\n        15,\n        0,\n        328,\n        18,\n        16,\n        0,\n        2,\n        12,\n        2,\n        33,\n        125,\n        0,\n        80,\n        921,\n        103,\n        110,\n        18,\n        195,\n        2637,\n        96,\n        16,\n        1071,\n        18,\n        5,\n        4026,\n        582,\n        8634,\n        568,\n        8,\n        30,\n        18,\n        78,\n        18,\n        29,\n        19,\n        47,\n        17,\n        3,\n        32,\n        20,\n        6,\n        18,\n        689,\n        63,\n        129,\n        74,\n        6,\n        0,\n        67,\n        12,\n        65,\n        1,\n        2,\n        0,\n        29,\n        6135,\n        9,\n        1237,\n        43,\n        8,\n        8936,\n        3,\n        2,\n        6,\n        2,\n        1,\n        2,\n        290,\n        16,\n        0,\n        30,\n        2,\n        3,\n        0,\n        15,\n        3,\n        9,\n        395,\n        2309,\n        106,\n        6,\n        12,\n        4,\n        8,\n        8,\n        9,\n        5991,\n        84,\n        2,\n        70,\n        2,\n        1,\n        3,\n        0,\n        3,\n        1,\n        3,\n        3,\n        2,\n        11,\n        2,\n        0,\n        2,\n        6,\n        2,\n        64,\n        2,\n        3,\n        3,\n        7,\n        2,\n        6,\n        2,\n        27,\n        2,\n        3,\n        2,\n        4,\n        2,\n        0,\n        4,\n        6,\n        2,\n        339,\n        3,\n        24,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        7,\n        1845,\n        30,\n        7,\n        5,\n        262,\n        61,\n        147,\n        44,\n        11,\n        6,\n        17,\n        0,\n        322,\n        29,\n        19,\n        43,\n        485,\n        27,\n        757,\n        6,\n        2,\n        3,\n        2,\n        1,\n        2,\n        14,\n        2,\n        196,\n        60,\n        67,\n        8,\n        0,\n        1205,\n        3,\n        2,\n        26,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        9,\n        2,\n        3,\n        2,\n        0,\n        2,\n        0,\n        7,\n        0,\n        5,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        2,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        1,\n        2,\n        0,\n        3,\n        3,\n        2,\n        6,\n        2,\n        3,\n        2,\n        3,\n        2,\n        0,\n        2,\n        9,\n        2,\n        16,\n        6,\n        2,\n        2,\n        4,\n        2,\n        16,\n        4421,\n        42719,\n        33,\n        4153,\n        7,\n        221,\n        3,\n        5761,\n        15,\n        7472,\n        16,\n        621,\n        2467,\n        541,\n        1507,\n        4938,\n        6,\n        4191\n    ];\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･\";\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n    // These are a run-length and offset encoded representation of the\n    // >0xffff code points that are a valid part of identifiers. The\n    // offset starts at 0x10000, and each pair of numbers represents an\n    // offset to the next range, and then a size of the range.\n    // Reserved word lists for various dialects of the language\n    var reservedWords = {\n        3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n        5: \"class enum extends super const export import\",\n        6: \"enum\",\n        strict: \"implements interface let package private protected public static yield\",\n        strictBind: \"eval arguments\"\n    };\n    // And the keywords\n    var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n    var keywords$1 = {\n        5: ecma5AndLessKeywords,\n        \"5module\": ecma5AndLessKeywords + \" export import\",\n        6: ecma5AndLessKeywords + \" const class extends export import super\"\n    };\n    var keywordRelationalOperator = /^in(stanceof)?$/;\n    // ## Character categories\n    var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n    var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n    // This has a complexity linear to the value of the code. The\n    // assumption is that looking up astral identifier characters is\n    // rare.\n    function isInAstralSet(code, set) {\n        var pos = 0x10000;\n        for(var i = 0; i < set.length; i += 2){\n            pos += set[i];\n            if (pos > code) {\n                return false;\n            }\n            pos += set[i + 1];\n            if (pos >= code) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Test whether a given character code starts an identifier.\n    function isIdentifierStart(code, astral) {\n        if (code < 65) {\n            return code === 36;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes);\n    }\n    // Test whether a given character is part of an identifier.\n    function isIdentifierChar(code, astral) {\n        if (code < 48) {\n            return code === 36;\n        }\n        if (code < 58) {\n            return true;\n        }\n        if (code < 65) {\n            return false;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n    }\n    // ## Token types\n    // The assignment of fine-grained, information-carrying type objects\n    // allows the tokenizer to store the information it has about a\n    // token in a way that is very cheap for the parser to look up.\n    // All token type variables start with an underscore, to make them\n    // easy to recognize.\n    // The `beforeExpr` property is used to disambiguate between regular\n    // expressions and divisions. It is set on all token types that can\n    // be followed by an expression (thus, a slash after them would be a\n    // regular expression).\n    //\n    // The `startsExpr` property is used to check if the token ends a\n    // `yield` expression. It is set on all token types that either can\n    // directly start an expression (like a quotation mark) or can\n    // continue an expression (like the body of a string).\n    //\n    // `isLoop` marks a keyword as starting a loop, which is important\n    // to know when parsing a label, in order to allow or disallow\n    // continue jumps to that label.\n    var TokenType = function TokenType(label, conf) {\n        if (conf === void 0) conf = {};\n        this.label = label;\n        this.keyword = conf.keyword;\n        this.beforeExpr = !!conf.beforeExpr;\n        this.startsExpr = !!conf.startsExpr;\n        this.isLoop = !!conf.isLoop;\n        this.isAssign = !!conf.isAssign;\n        this.prefix = !!conf.prefix;\n        this.postfix = !!conf.postfix;\n        this.binop = conf.binop || null;\n        this.updateContext = null;\n    };\n    function binop(name, prec) {\n        return new TokenType(name, {\n            beforeExpr: true,\n            binop: prec\n        });\n    }\n    var beforeExpr = {\n        beforeExpr: true\n    }, startsExpr = {\n        startsExpr: true\n    };\n    // Map keyword names to token types.\n    var keywords = {};\n    // Succinct definitions of keyword token types\n    function kw(name, options) {\n        if (options === void 0) options = {};\n        options.keyword = name;\n        return keywords[name] = new TokenType(name, options);\n    }\n    var types$1 = {\n        num: new TokenType(\"num\", startsExpr),\n        regexp: new TokenType(\"regexp\", startsExpr),\n        string: new TokenType(\"string\", startsExpr),\n        name: new TokenType(\"name\", startsExpr),\n        privateId: new TokenType(\"privateId\", startsExpr),\n        eof: new TokenType(\"eof\"),\n        // Punctuation token types.\n        bracketL: new TokenType(\"[\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        bracketR: new TokenType(\"]\"),\n        braceL: new TokenType(\"{\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        braceR: new TokenType(\"}\"),\n        parenL: new TokenType(\"(\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        parenR: new TokenType(\")\"),\n        comma: new TokenType(\",\", beforeExpr),\n        semi: new TokenType(\";\", beforeExpr),\n        colon: new TokenType(\":\", beforeExpr),\n        dot: new TokenType(\".\"),\n        question: new TokenType(\"?\", beforeExpr),\n        questionDot: new TokenType(\"?.\"),\n        arrow: new TokenType(\"=>\", beforeExpr),\n        template: new TokenType(\"template\"),\n        invalidTemplate: new TokenType(\"invalidTemplate\"),\n        ellipsis: new TokenType(\"...\", beforeExpr),\n        backQuote: new TokenType(\"`\", startsExpr),\n        dollarBraceL: new TokenType(\"${\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        // Operators. These carry several kinds of properties to help the\n        // parser use them properly (the presence of these properties is\n        // what categorizes them as operators).\n        //\n        // `binop`, when present, specifies that this operator is a binary\n        // operator, and will refer to its precedence.\n        //\n        // `prefix` and `postfix` mark the operator as a prefix or postfix\n        // unary operator.\n        //\n        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n        // binary operators with a very low precedence, that should result\n        // in AssignmentExpression nodes.\n        eq: new TokenType(\"=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        assign: new TokenType(\"_=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        incDec: new TokenType(\"++/--\", {\n            prefix: true,\n            postfix: true,\n            startsExpr: true\n        }),\n        prefix: new TokenType(\"!/~\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        logicalOR: binop(\"||\", 1),\n        logicalAND: binop(\"&&\", 2),\n        bitwiseOR: binop(\"|\", 3),\n        bitwiseXOR: binop(\"^\", 4),\n        bitwiseAND: binop(\"&\", 5),\n        equality: binop(\"==/!=/===/!==\", 6),\n        relational: binop(\"</>/<=/>=\", 7),\n        bitShift: binop(\"<</>>/>>>\", 8),\n        plusMin: new TokenType(\"+/-\", {\n            beforeExpr: true,\n            binop: 9,\n            prefix: true,\n            startsExpr: true\n        }),\n        modulo: binop(\"%\", 10),\n        star: binop(\"*\", 10),\n        slash: binop(\"/\", 10),\n        starstar: new TokenType(\"**\", {\n            beforeExpr: true\n        }),\n        coalesce: binop(\"??\", 1),\n        // Keyword token types.\n        _break: kw(\"break\"),\n        _case: kw(\"case\", beforeExpr),\n        _catch: kw(\"catch\"),\n        _continue: kw(\"continue\"),\n        _debugger: kw(\"debugger\"),\n        _default: kw(\"default\", beforeExpr),\n        _do: kw(\"do\", {\n            isLoop: true,\n            beforeExpr: true\n        }),\n        _else: kw(\"else\", beforeExpr),\n        _finally: kw(\"finally\"),\n        _for: kw(\"for\", {\n            isLoop: true\n        }),\n        _function: kw(\"function\", startsExpr),\n        _if: kw(\"if\"),\n        _return: kw(\"return\", beforeExpr),\n        _switch: kw(\"switch\"),\n        _throw: kw(\"throw\", beforeExpr),\n        _try: kw(\"try\"),\n        _var: kw(\"var\"),\n        _const: kw(\"const\"),\n        _while: kw(\"while\", {\n            isLoop: true\n        }),\n        _with: kw(\"with\"),\n        _new: kw(\"new\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        _this: kw(\"this\", startsExpr),\n        _super: kw(\"super\", startsExpr),\n        _class: kw(\"class\", startsExpr),\n        _extends: kw(\"extends\", beforeExpr),\n        _export: kw(\"export\"),\n        _import: kw(\"import\", startsExpr),\n        _null: kw(\"null\", startsExpr),\n        _true: kw(\"true\", startsExpr),\n        _false: kw(\"false\", startsExpr),\n        _in: kw(\"in\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _instanceof: kw(\"instanceof\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _typeof: kw(\"typeof\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _void: kw(\"void\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _delete: kw(\"delete\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        })\n    };\n    // Matches a whole line break (where CRLF is considered a single\n    // line break). Used to count lines.\n    var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n    var lineBreakG = new RegExp(lineBreak.source, \"g\");\n    function isNewLine(code) {\n        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n    }\n    function nextLineBreak(code, from, end) {\n        if (end === void 0) end = code.length;\n        for(var i = from; i < end; i++){\n            var next = code.charCodeAt(i);\n            if (isNewLine(next)) {\n                return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n            }\n        }\n        return -1;\n    }\n    var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n    var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n    var ref = Object.prototype;\n    var hasOwnProperty = ref.hasOwnProperty;\n    var toString = ref.toString;\n    var hasOwn = Object.hasOwn || function(obj, propName) {\n        return hasOwnProperty.call(obj, propName);\n    };\n    var isArray = Array.isArray || function(obj) {\n        return toString.call(obj) === \"[object Array]\";\n    };\n    var regexpCache = Object.create(null);\n    function wordsRegexp(words) {\n        return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"));\n    }\n    function codePointToString(code) {\n        // UTF-16 Decoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        code -= 0x10000;\n        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n    }\n    var loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n    // These are used when `options.locations` is on, for the\n    // `startLoc` and `endLoc` properties.\n    var Position = function Position(line, col) {\n        this.line = line;\n        this.column = col;\n    };\n    Position.prototype.offset = function offset(n) {\n        return new Position(this.line, this.column + n);\n    };\n    var SourceLocation = function SourceLocation(p, start, end) {\n        this.start = start;\n        this.end = end;\n        if (p.sourceFile !== null) {\n            this.source = p.sourceFile;\n        }\n    };\n    // The `getLineInfo` function is mostly useful when the\n    // `locations` option is off (for performance reasons) and you\n    // want to find the line/column position for a given character\n    // offset. `input` should be the code string that the offset refers\n    // into.\n    function getLineInfo(input, offset) {\n        for(var line = 1, cur = 0;;){\n            var nextBreak = nextLineBreak(input, cur, offset);\n            if (nextBreak < 0) {\n                return new Position(line, offset - cur);\n            }\n            ++line;\n            cur = nextBreak;\n        }\n    }\n    // A second argument must be given to configure the parser process.\n    // These options are recognized (only `ecmaVersion` is required):\n    var defaultOptions = {\n        // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n        // (the latest version the library supports). This influences\n        // support for strict mode, the set of reserved words, and support\n        // for new syntax features.\n        ecmaVersion: null,\n        // `sourceType` indicates the mode the code should be parsed in.\n        // Can be either `\"script\"` or `\"module\"`. This influences global\n        // strict mode and parsing of `import` and `export` declarations.\n        sourceType: \"script\",\n        // `onInsertedSemicolon` can be a callback that will be called when\n        // a semicolon is automatically inserted. It will be passed the\n        // position of the inserted semicolon as an offset, and if\n        // `locations` is enabled, it is given the location as a `{line,\n        // column}` object as second argument.\n        onInsertedSemicolon: null,\n        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n        // trailing commas.\n        onTrailingComma: null,\n        // By default, reserved words are only enforced if ecmaVersion >= 5.\n        // Set `allowReserved` to a boolean value to explicitly turn this on\n        // an off. When this option has the value \"never\", reserved words\n        // and keywords can also not be used as property names.\n        allowReserved: null,\n        // When enabled, a return at the top level is not considered an\n        // error.\n        allowReturnOutsideFunction: false,\n        // When enabled, import/export statements are not constrained to\n        // appearing at the top of the program, and an import.meta expression\n        // in a script isn't considered an error.\n        allowImportExportEverywhere: false,\n        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n        // When enabled, await identifiers are allowed to appear at the top-level scope,\n        // but they are still not allowed in non-async functions.\n        allowAwaitOutsideFunction: null,\n        // When enabled, super identifiers are not constrained to\n        // appearing in methods and do not raise an error when they appear elsewhere.\n        allowSuperOutsideMethod: null,\n        // When enabled, hashbang directive in the beginning of file is\n        // allowed and treated as a line comment. Enabled by default when\n        // `ecmaVersion` >= 2023.\n        allowHashBang: false,\n        // By default, the parser will verify that private properties are\n        // only used in places where they are valid and have been declared.\n        // Set this to false to turn such checks off.\n        checkPrivateFields: true,\n        // When `locations` is on, `loc` properties holding objects with\n        // `start` and `end` properties in `{line, column}` form (with\n        // line being 1-based and column 0-based) will be attached to the\n        // nodes.\n        locations: false,\n        // A function can be passed as `onToken` option, which will\n        // cause Acorn to call that function with object in the same\n        // format as tokens returned from `tokenizer().getToken()`. Note\n        // that you are not allowed to call the parser from the\n        // callback—that will corrupt its internal state.\n        onToken: null,\n        // A function can be passed as `onComment` option, which will\n        // cause Acorn to call that function with `(block, text, start,\n        // end)` parameters whenever a comment is skipped. `block` is a\n        // boolean indicating whether this is a block (`/* */`) comment,\n        // `text` is the content of the comment, and `start` and `end` are\n        // character offsets that denote the start and end of the comment.\n        // When the `locations` option is on, two more parameters are\n        // passed, the full `{line, column}` locations of the start and\n        // end of the comments. Note that you are not allowed to call the\n        // parser from the callback—that will corrupt its internal state.\n        // When this option has an array as value, objects representing the\n        // comments are pushed to it.\n        onComment: null,\n        // Nodes have their start and end characters offsets recorded in\n        // `start` and `end` properties (directly on the node, rather than\n        // the `loc` object, which holds line/column data. To also add a\n        // [semi-standardized][range] `range` property holding a `[start,\n        // end]` array with the same numbers, set the `ranges` option to\n        // `true`.\n        //\n        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n        ranges: false,\n        // It is possible to parse multiple files into a single AST by\n        // passing the tree produced by parsing the first file as\n        // `program` option in subsequent parses. This will add the\n        // toplevel forms of the parsed file to the `Program` (top) node\n        // of an existing parse tree.\n        program: null,\n        // When `locations` is on, you can pass this to record the source\n        // file in every node's `loc` object.\n        sourceFile: null,\n        // This value, if given, is stored in every node, whether\n        // `locations` is on or off.\n        directSourceFile: null,\n        // When enabled, parenthesized expressions are represented by\n        // (non-standard) ParenthesizedExpression nodes\n        preserveParens: false\n    };\n    // Interpret and default an options object\n    var warnedAboutEcmaVersion = false;\n    function getOptions(opts) {\n        var options = {};\n        for(var opt in defaultOptions){\n            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n        }\n        if (options.ecmaVersion === \"latest\") {\n            options.ecmaVersion = 1e8;\n        } else if (options.ecmaVersion == null) {\n            if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n                warnedAboutEcmaVersion = true;\n                console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n            }\n            options.ecmaVersion = 11;\n        } else if (options.ecmaVersion >= 2015) {\n            options.ecmaVersion -= 2009;\n        }\n        if (options.allowReserved == null) {\n            options.allowReserved = options.ecmaVersion < 5;\n        }\n        if (!opts || opts.allowHashBang == null) {\n            options.allowHashBang = options.ecmaVersion >= 14;\n        }\n        if (isArray(options.onToken)) {\n            var tokens = options.onToken;\n            options.onToken = function(token) {\n                return tokens.push(token);\n            };\n        }\n        if (isArray(options.onComment)) {\n            options.onComment = pushComment(options, options.onComment);\n        }\n        return options;\n    }\n    function pushComment(options, array) {\n        return function(block, text, start, end, startLoc, endLoc) {\n            var comment = {\n                type: block ? \"Block\" : \"Line\",\n                value: text,\n                start: start,\n                end: end\n            };\n            if (options.locations) {\n                comment.loc = new SourceLocation(this, startLoc, endLoc);\n            }\n            if (options.ranges) {\n                comment.range = [\n                    start,\n                    end\n                ];\n            }\n            array.push(comment);\n        };\n    }\n    // Each scope gets a bitset that may contain these flags\n    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n    function functionFlags(async, generator) {\n        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n    }\n    // Used in checkLVal* and declareName to determine the type of a binding\n    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n    var Parser = function Parser(options, input, startPos) {\n        this.options = options = getOptions(options);\n        this.sourceFile = options.sourceFile;\n        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n        var reserved = \"\";\n        if (options.allowReserved !== true) {\n            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n            if (options.sourceType === \"module\") {\n                reserved += \" await\";\n            }\n        }\n        this.reservedWords = wordsRegexp(reserved);\n        var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n        this.reservedWordsStrict = wordsRegexp(reservedStrict);\n        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n        this.input = String(input);\n        // Used to signal to callers of `readWord1` whether the word\n        // contained any escape sequences. This is needed because words with\n        // escape sequences must not be interpreted as keywords.\n        this.containsEsc = false;\n        // Set up token state\n        // The current position of the tokenizer in the input.\n        if (startPos) {\n            this.pos = startPos;\n            this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n        } else {\n            this.pos = this.lineStart = 0;\n            this.curLine = 1;\n        }\n        // Properties of the current token:\n        // Its type\n        this.type = types$1.eof;\n        // For tokens that include more information than their type, the value\n        this.value = null;\n        // Its start and end offset\n        this.start = this.end = this.pos;\n        // And, if locations are used, the {line, column} object\n        // corresponding to those offsets\n        this.startLoc = this.endLoc = this.curPosition();\n        // Position information for the previous token\n        this.lastTokEndLoc = this.lastTokStartLoc = null;\n        this.lastTokStart = this.lastTokEnd = this.pos;\n        // The context stack is used to superficially track syntactic\n        // context to predict whether a regular expression is allowed in a\n        // given position.\n        this.context = this.initialContext();\n        this.exprAllowed = true;\n        // Figure out if it's a module code.\n        this.inModule = options.sourceType === \"module\";\n        this.strict = this.inModule || this.strictDirective(this.pos);\n        // Used to signify the start of a potential arrow function\n        this.potentialArrowAt = -1;\n        this.potentialArrowInForAwait = false;\n        // Positions to delayed-check that yield/await does not exist in default parameters.\n        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n        // Labels in scope.\n        this.labels = [];\n        // Thus-far undefined exports.\n        this.undefinedExports = Object.create(null);\n        // If enabled, skip leading hashbang line.\n        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n            this.skipLineComment(2);\n        }\n        // Scope tracking for duplicate variable names (see scope.js)\n        this.scopeStack = [];\n        this.enterScope(SCOPE_TOP);\n        // For RegExp validation\n        this.regexpState = null;\n        // The stack of private names.\n        // Each element has two properties: 'declared' and 'used'.\n        // When it exited from the outermost class definition, all used private names must be declared.\n        this.privateNameStack = [];\n    };\n    var prototypeAccessors = {\n        inFunction: {\n            configurable: true\n        },\n        inGenerator: {\n            configurable: true\n        },\n        inAsync: {\n            configurable: true\n        },\n        canAwait: {\n            configurable: true\n        },\n        allowSuper: {\n            configurable: true\n        },\n        allowDirectSuper: {\n            configurable: true\n        },\n        treatFunctionsAsVar: {\n            configurable: true\n        },\n        allowNewDotTarget: {\n            configurable: true\n        },\n        inClassStaticBlock: {\n            configurable: true\n        }\n    };\n    Parser.prototype.parse = function parse() {\n        var node = this.options.program || this.startNode();\n        this.nextToken();\n        return this.parseTopLevel(node);\n    };\n    prototypeAccessors.inFunction.get = function() {\n        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n    };\n    prototypeAccessors.inGenerator.get = function() {\n        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n    };\n    prototypeAccessors.inAsync.get = function() {\n        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n    };\n    prototypeAccessors.canAwait.get = function() {\n        for(var i = this.scopeStack.length - 1; i >= 0; i--){\n            var scope = this.scopeStack[i];\n            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {\n                return false;\n            }\n            if (scope.flags & SCOPE_FUNCTION) {\n                return (scope.flags & SCOPE_ASYNC) > 0;\n            }\n        }\n        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n    };\n    prototypeAccessors.allowSuper.get = function() {\n        var ref = this.currentThisScope();\n        var flags = ref.flags;\n        var inClassFieldInit = ref.inClassFieldInit;\n        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n    };\n    prototypeAccessors.allowDirectSuper.get = function() {\n        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n    };\n    prototypeAccessors.treatFunctionsAsVar.get = function() {\n        return this.treatFunctionsAsVarInScope(this.currentScope());\n    };\n    prototypeAccessors.allowNewDotTarget.get = function() {\n        var ref = this.currentThisScope();\n        var flags = ref.flags;\n        var inClassFieldInit = ref.inClassFieldInit;\n        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n    };\n    prototypeAccessors.inClassStaticBlock.get = function() {\n        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n    };\n    Parser.extend = function extend() {\n        var plugins = [], len = arguments.length;\n        while(len--)plugins[len] = arguments[len];\n        var cls = this;\n        for(var i = 0; i < plugins.length; i++){\n            cls = plugins[i](cls);\n        }\n        return cls;\n    };\n    Parser.parse = function parse(input, options) {\n        return new this(options, input).parse();\n    };\n    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n        var parser = new this(options, input, pos);\n        parser.nextToken();\n        return parser.parseExpression();\n    };\n    Parser.tokenizer = function tokenizer(input, options) {\n        return new this(options, input);\n    };\n    Object.defineProperties(Parser.prototype, prototypeAccessors);\n    var pp$9 = Parser.prototype;\n    // ## Parser utilities\n    var literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n    pp$9.strictDirective = function(start) {\n        if (this.options.ecmaVersion < 5) {\n            return false;\n        }\n        for(;;){\n            // Try to find string literal.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            var match = literal.exec(this.input.slice(start));\n            if (!match) {\n                return false;\n            }\n            if ((match[1] || match[2]) === \"use strict\") {\n                skipWhiteSpace.lastIndex = start + match[0].length;\n                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n                var next = this.input.charAt(end);\n                return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n            }\n            start += match[0].length;\n            // Skip semicolon, if any.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            if (this.input[start] === \";\") {\n                start++;\n            }\n        }\n    };\n    // Predicate that tests whether the next token is of the given\n    // type, and if yes, consumes it as a side effect.\n    pp$9.eat = function(type) {\n        if (this.type === type) {\n            this.next();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    // Tests whether parsed token is a contextual keyword.\n    pp$9.isContextual = function(name) {\n        return this.type === types$1.name && this.value === name && !this.containsEsc;\n    };\n    // Consumes contextual keyword if possible.\n    pp$9.eatContextual = function(name) {\n        if (!this.isContextual(name)) {\n            return false;\n        }\n        this.next();\n        return true;\n    };\n    // Asserts that following token is given contextual keyword.\n    pp$9.expectContextual = function(name) {\n        if (!this.eatContextual(name)) {\n            this.unexpected();\n        }\n    };\n    // Test whether a semicolon can be inserted at the current position.\n    pp$9.canInsertSemicolon = function() {\n        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    pp$9.insertSemicolon = function() {\n        if (this.canInsertSemicolon()) {\n            if (this.options.onInsertedSemicolon) {\n                this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n            }\n            return true;\n        }\n    };\n    // Consume a semicolon, or, failing that, see if we are allowed to\n    // pretend that there is a semicolon at this position.\n    pp$9.semicolon = function() {\n        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n            this.unexpected();\n        }\n    };\n    pp$9.afterTrailingComma = function(tokType, notNext) {\n        if (this.type === tokType) {\n            if (this.options.onTrailingComma) {\n                this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n            }\n            if (!notNext) {\n                this.next();\n            }\n            return true;\n        }\n    };\n    // Expect a token of a given type. If found, consume it, otherwise,\n    // raise an unexpected token error.\n    pp$9.expect = function(type) {\n        this.eat(type) || this.unexpected();\n    };\n    // Raise an unexpected token error.\n    pp$9.unexpected = function(pos) {\n        this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n    };\n    var DestructuringErrors = function DestructuringErrors() {\n        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n    };\n    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n        if (!refDestructuringErrors) {\n            return;\n        }\n        if (refDestructuringErrors.trailingComma > -1) {\n            this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n        }\n        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n        if (parens > -1) {\n            this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n        }\n    };\n    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n        if (!refDestructuringErrors) {\n            return false;\n        }\n        var shorthandAssign = refDestructuringErrors.shorthandAssign;\n        var doubleProto = refDestructuringErrors.doubleProto;\n        if (!andThrow) {\n            return shorthandAssign >= 0 || doubleProto >= 0;\n        }\n        if (shorthandAssign >= 0) {\n            this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n        }\n        if (doubleProto >= 0) {\n            this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n        }\n    };\n    pp$9.checkYieldAwaitInDefaultParams = function() {\n        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n            this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n        }\n        if (this.awaitPos) {\n            this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n        }\n    };\n    pp$9.isSimpleAssignTarget = function(expr) {\n        if (expr.type === \"ParenthesizedExpression\") {\n            return this.isSimpleAssignTarget(expr.expression);\n        }\n        return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n    };\n    var pp$8 = Parser.prototype;\n    // ### Statement parsing\n    // Parse a program. Initializes the parser, reads any number of\n    // statements, and wraps them in a Program node.  Optionally takes a\n    // `program` argument.  If present, the statements will be appended\n    // to its body instead of creating a new node.\n    pp$8.parseTopLevel = function(node) {\n        var exports1 = Object.create(null);\n        if (!node.body) {\n            node.body = [];\n        }\n        while(this.type !== types$1.eof){\n            var stmt = this.parseStatement(null, true, exports1);\n            node.body.push(stmt);\n        }\n        if (this.inModule) {\n            for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n                var name = list[i];\n                this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n            }\n        }\n        this.adaptDirectivePrologue(node.body);\n        this.next();\n        node.sourceType = this.options.sourceType;\n        return this.finishNode(node, \"Program\");\n    };\n    var loopLabel = {\n        kind: \"loop\"\n    }, switchLabel = {\n        kind: \"switch\"\n    };\n    pp$8.isLet = function(context) {\n        if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        // For ambiguous cases, determine if a LexicalDeclaration (or only a\n        // Statement) is allowed here. If context is not empty then only a Statement\n        // is allowed. However, `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        if (nextCh === 91 || nextCh === 92) {\n            return true;\n        } // '[', '/'\n        if (context) {\n            return false;\n        }\n        if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        } // '{', astral\n        if (isIdentifierStart(nextCh, true)) {\n            var pos = next + 1;\n            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n                ++pos;\n            }\n            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n                return true;\n            }\n            var ident = this.input.slice(next, pos);\n            if (!keywordRelationalOperator.test(ident)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // check 'async [no LineTerminator here] function'\n    // - 'async /*foo*/ function' is OK.\n    // - 'async /*\\n*/ function' is invalid.\n    pp$8.isAsyncFunction = function() {\n        if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, after;\n        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n    };\n    // Parse a single statement.\n    //\n    // If expecting a statement and finding a slash operator, parse a\n    // regular expression literal. This is to handle cases like\n    // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n    // does not help.\n    pp$8.parseStatement = function(context, topLevel, exports1) {\n        var starttype = this.type, node = this.startNode(), kind;\n        if (this.isLet(context)) {\n            starttype = types$1._var;\n            kind = \"let\";\n        }\n        // Most types of statements are recognized by the keyword they\n        // start with. Many are trivial to parse, some require a bit of\n        // complexity.\n        switch(starttype){\n            case types$1._break:\n            case types$1._continue:\n                return this.parseBreakContinueStatement(node, starttype.keyword);\n            case types$1._debugger:\n                return this.parseDebuggerStatement(node);\n            case types$1._do:\n                return this.parseDoStatement(node);\n            case types$1._for:\n                return this.parseForStatement(node);\n            case types$1._function:\n                // Function as sole body of either an if statement or a labeled statement\n                // works, but not when it is part of a labeled statement that is the sole\n                // body of an if statement.\n                if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                    this.unexpected();\n                }\n                return this.parseFunctionStatement(node, false, !context);\n            case types$1._class:\n                if (context) {\n                    this.unexpected();\n                }\n                return this.parseClass(node, true);\n            case types$1._if:\n                return this.parseIfStatement(node);\n            case types$1._return:\n                return this.parseReturnStatement(node);\n            case types$1._switch:\n                return this.parseSwitchStatement(node);\n            case types$1._throw:\n                return this.parseThrowStatement(node);\n            case types$1._try:\n                return this.parseTryStatement(node);\n            case types$1._const:\n            case types$1._var:\n                kind = kind || this.value;\n                if (context && kind !== \"var\") {\n                    this.unexpected();\n                }\n                return this.parseVarStatement(node, kind);\n            case types$1._while:\n                return this.parseWhileStatement(node);\n            case types$1._with:\n                return this.parseWithStatement(node);\n            case types$1.braceL:\n                return this.parseBlock(true, node);\n            case types$1.semi:\n                return this.parseEmptyStatement(node);\n            case types$1._export:\n            case types$1._import:\n                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                    skipWhiteSpace.lastIndex = this.pos;\n                    var skip = skipWhiteSpace.exec(this.input);\n                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                    if (nextCh === 40 || nextCh === 46) {\n                        return this.parseExpressionStatement(node, this.parseExpression());\n                    }\n                }\n                if (!this.options.allowImportExportEverywhere) {\n                    if (!topLevel) {\n                        this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                    }\n                    if (!this.inModule) {\n                        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                    }\n                }\n                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);\n            // If the statement does not start with a statement keyword or a\n            // brace, it's an ExpressionStatement or LabeledStatement. We\n            // simply start parsing an expression, and afterwards, if the\n            // next token is a colon and the expression was a simple\n            // Identifier node, we switch to interpreting it as a label.\n            default:\n                if (this.isAsyncFunction()) {\n                    if (context) {\n                        this.unexpected();\n                    }\n                    this.next();\n                    return this.parseFunctionStatement(node, true, !context);\n                }\n                var maybeName = this.value, expr = this.parseExpression();\n                if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                    return this.parseLabeledStatement(node, maybeName, expr, context);\n                } else {\n                    return this.parseExpressionStatement(node, expr);\n                }\n        }\n    };\n    pp$8.parseBreakContinueStatement = function(node, keyword) {\n        var isBreak = keyword === \"break\";\n        this.next();\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.label = null;\n        } else if (this.type !== types$1.name) {\n            this.unexpected();\n        } else {\n            node.label = this.parseIdent();\n            this.semicolon();\n        }\n        // Verify that there is an actual destination to break or\n        // continue to.\n        var i = 0;\n        for(; i < this.labels.length; ++i){\n            var lab = this.labels[i];\n            if (node.label == null || lab.name === node.label.name) {\n                if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                    break;\n                }\n                if (node.label && isBreak) {\n                    break;\n                }\n            }\n        }\n        if (i === this.labels.length) {\n            this.raise(node.start, \"Unsyntactic \" + keyword);\n        }\n        return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n    };\n    pp$8.parseDebuggerStatement = function(node) {\n        this.next();\n        this.semicolon();\n        return this.finishNode(node, \"DebuggerStatement\");\n    };\n    pp$8.parseDoStatement = function(node) {\n        this.next();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"do\");\n        this.labels.pop();\n        this.expect(types$1._while);\n        node.test = this.parseParenExpression();\n        if (this.options.ecmaVersion >= 6) {\n            this.eat(types$1.semi);\n        } else {\n            this.semicolon();\n        }\n        return this.finishNode(node, \"DoWhileStatement\");\n    };\n    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n    // loop is non-trivial. Basically, we have to parse the init `var`\n    // statement or expression, disallowing the `in` operator (see\n    // the second parameter to `parseExpression`), and then check\n    // whether the next token is `in` or `of`. When there is no init\n    // part (semicolon immediately after the opening parenthesis), it\n    // is a regular `for` loop.\n    pp$8.parseForStatement = function(node) {\n        this.next();\n        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n        this.labels.push(loopLabel);\n        this.enterScope(0);\n        this.expect(types$1.parenL);\n        if (this.type === types$1.semi) {\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, null);\n        }\n        var isLet = this.isLet();\n        if (this.type === types$1._var || this.type === types$1._const || isLet) {\n            var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n            this.next();\n            this.parseVar(init$1, true, kind);\n            this.finishNode(init$1, \"VariableDeclaration\");\n            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n                if (this.options.ecmaVersion >= 9) {\n                    if (this.type === types$1._in) {\n                        if (awaitAt > -1) {\n                            this.unexpected(awaitAt);\n                        }\n                    } else {\n                        node.await = awaitAt > -1;\n                    }\n                }\n                return this.parseForIn(node, init$1);\n            }\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, init$1);\n        }\n        var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n        var refDestructuringErrors = new DestructuringErrors;\n        var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === types$1._in) {\n                    if (awaitAt > -1) {\n                        this.unexpected(awaitAt);\n                    }\n                } else {\n                    node.await = awaitAt > -1;\n                }\n            }\n            if (startsWithLet && isForOf) {\n                this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n            }\n            this.toAssignable(init, false, refDestructuringErrors);\n            this.checkLValPattern(init);\n            return this.parseForIn(node, init);\n        } else {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n    };\n    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n        this.next();\n        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n    };\n    pp$8.parseIfStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        // allow function declarations in branches, but only in non-strict mode\n        node.consequent = this.parseStatement(\"if\");\n        node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n        return this.finishNode(node, \"IfStatement\");\n    };\n    pp$8.parseReturnStatement = function(node) {\n        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n            this.raise(this.start, \"'return' outside of function\");\n        }\n        this.next();\n        // In `return` (and `break`/`continue`), the keywords with\n        // optional arguments, we eagerly look for a semicolon or the\n        // possibility to insert one.\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.argument = null;\n        } else {\n            node.argument = this.parseExpression();\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ReturnStatement\");\n    };\n    pp$8.parseSwitchStatement = function(node) {\n        this.next();\n        node.discriminant = this.parseParenExpression();\n        node.cases = [];\n        this.expect(types$1.braceL);\n        this.labels.push(switchLabel);\n        this.enterScope(0);\n        // Statements under must be grouped (by label) in SwitchCase\n        // nodes. `cur` is used to keep the node that we are currently\n        // adding statements to.\n        var cur;\n        for(var sawDefault = false; this.type !== types$1.braceR;){\n            if (this.type === types$1._case || this.type === types$1._default) {\n                var isCase = this.type === types$1._case;\n                if (cur) {\n                    this.finishNode(cur, \"SwitchCase\");\n                }\n                node.cases.push(cur = this.startNode());\n                cur.consequent = [];\n                this.next();\n                if (isCase) {\n                    cur.test = this.parseExpression();\n                } else {\n                    if (sawDefault) {\n                        this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                    }\n                    sawDefault = true;\n                    cur.test = null;\n                }\n                this.expect(types$1.colon);\n            } else {\n                if (!cur) {\n                    this.unexpected();\n                }\n                cur.consequent.push(this.parseStatement(null));\n            }\n        }\n        this.exitScope();\n        if (cur) {\n            this.finishNode(cur, \"SwitchCase\");\n        }\n        this.next(); // Closing brace\n        this.labels.pop();\n        return this.finishNode(node, \"SwitchStatement\");\n    };\n    pp$8.parseThrowStatement = function(node) {\n        this.next();\n        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n            this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n        }\n        node.argument = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ThrowStatement\");\n    };\n    // Reused empty array added for node fields that are always empty.\n    var empty$1 = [];\n    pp$8.parseCatchClauseParam = function() {\n        var param = this.parseBindingAtom();\n        var simple = param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types$1.parenR);\n        return param;\n    };\n    pp$8.parseTryStatement = function(node) {\n        this.next();\n        node.block = this.parseBlock();\n        node.handler = null;\n        if (this.type === types$1._catch) {\n            var clause = this.startNode();\n            this.next();\n            if (this.eat(types$1.parenL)) {\n                clause.param = this.parseCatchClauseParam();\n            } else {\n                if (this.options.ecmaVersion < 10) {\n                    this.unexpected();\n                }\n                clause.param = null;\n                this.enterScope(0);\n            }\n            clause.body = this.parseBlock(false);\n            this.exitScope();\n            node.handler = this.finishNode(clause, \"CatchClause\");\n        }\n        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n        if (!node.handler && !node.finalizer) {\n            this.raise(node.start, \"Missing catch or finally clause\");\n        }\n        return this.finishNode(node, \"TryStatement\");\n    };\n    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n        this.next();\n        this.parseVar(node, false, kind, allowMissingInitializer);\n        this.semicolon();\n        return this.finishNode(node, \"VariableDeclaration\");\n    };\n    pp$8.parseWhileStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"while\");\n        this.labels.pop();\n        return this.finishNode(node, \"WhileStatement\");\n    };\n    pp$8.parseWithStatement = function(node) {\n        if (this.strict) {\n            this.raise(this.start, \"'with' in strict mode\");\n        }\n        this.next();\n        node.object = this.parseParenExpression();\n        node.body = this.parseStatement(\"with\");\n        return this.finishNode(node, \"WithStatement\");\n    };\n    pp$8.parseEmptyStatement = function(node) {\n        this.next();\n        return this.finishNode(node, \"EmptyStatement\");\n    };\n    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n            var label = list[i$1];\n            if (label.name === maybeName) {\n                this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n            }\n        }\n        var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n        for(var i = this.labels.length - 1; i >= 0; i--){\n            var label$1 = this.labels[i];\n            if (label$1.statementStart === node.start) {\n                // Update information about previous labels on this node\n                label$1.statementStart = this.start;\n                label$1.kind = kind;\n            } else {\n                break;\n            }\n        }\n        this.labels.push({\n            name: maybeName,\n            kind: kind,\n            statementStart: this.start\n        });\n        node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n        this.labels.pop();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\");\n    };\n    pp$8.parseExpressionStatement = function(node, expr) {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n    };\n    // Parse a semicolon-enclosed block of statements, handling `\"use\n    // strict\"` declarations when `allowStrict` is true (used for\n    // function bodies).\n    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n        if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n        if (node === void 0) node = this.startNode();\n        node.body = [];\n        this.expect(types$1.braceL);\n        if (createNewLexicalScope) {\n            this.enterScope(0);\n        }\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        if (exitStrict) {\n            this.strict = false;\n        }\n        this.next();\n        if (createNewLexicalScope) {\n            this.exitScope();\n        }\n        return this.finishNode(node, \"BlockStatement\");\n    };\n    // Parse a regular `for` loop. The disambiguation code in\n    // `parseStatement` will already have parsed the init statement or\n    // expression.\n    pp$8.parseFor = function(node, init) {\n        node.init = init;\n        this.expect(types$1.semi);\n        node.test = this.type === types$1.semi ? null : this.parseExpression();\n        this.expect(types$1.semi);\n        node.update = this.type === types$1.parenR ? null : this.parseExpression();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, \"ForStatement\");\n    };\n    // Parse a `for`/`in` and `for`/`of` loop, which are almost\n    // same from parser's perspective.\n    pp$8.parseForIn = function(node, init) {\n        var isForIn = this.type === types$1._in;\n        this.next();\n        if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n            this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n        }\n        node.left = init;\n        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n    };\n    // Parse a list of variable declarations.\n    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n        node.declarations = [];\n        node.kind = kind;\n        for(;;){\n            var decl = this.startNode();\n            this.parseVarId(decl, kind);\n            if (this.eat(types$1.eq)) {\n                decl.init = this.parseMaybeAssign(isFor);\n            } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n                this.unexpected();\n            } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n                this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n            } else {\n                decl.init = null;\n            }\n            node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n            if (!this.eat(types$1.comma)) {\n                break;\n            }\n        }\n        return node;\n    };\n    pp$8.parseVarId = function(decl, kind) {\n        decl.id = this.parseBindingAtom();\n        this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n    };\n    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n    // Parse a function declaration or literal (depending on the\n    // `statement & FUNC_STATEMENT`).\n    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n                this.unexpected();\n            }\n            node.generator = this.eat(types$1.star);\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        if (statement & FUNC_STATEMENT) {\n            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n            // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n            // mode depends on properties of the current scope (see\n            // treatFunctionsAsVar).\n            {\n                this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n            }\n        }\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(node.async, node.generator));\n        if (!(statement & FUNC_STATEMENT)) {\n            node.id = this.type === types$1.name ? this.parseIdent() : null;\n        }\n        this.parseFunctionParams(node);\n        this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    };\n    pp$8.parseFunctionParams = function(node) {\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n    };\n    // Parse a class declaration or literal (depending on the\n    // `isStatement` parameter).\n    pp$8.parseClass = function(node, isStatement) {\n        this.next();\n        // ecma-262 14.6 Class Definitions\n        // A class definition is always strict mode code.\n        var oldStrict = this.strict;\n        this.strict = true;\n        this.parseClassId(node, isStatement);\n        this.parseClassSuper(node);\n        var privateNameMap = this.enterClassBody();\n        var classBody = this.startNode();\n        var hadConstructor = false;\n        classBody.body = [];\n        this.expect(types$1.braceL);\n        while(this.type !== types$1.braceR){\n            var element = this.parseClassElement(node.superClass !== null);\n            if (element) {\n                classBody.body.push(element);\n                if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                    if (hadConstructor) {\n                        this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                    }\n                    hadConstructor = true;\n                } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                    this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n                }\n            }\n        }\n        this.strict = oldStrict;\n        this.next();\n        node.body = this.finishNode(classBody, \"ClassBody\");\n        this.exitClassBody();\n        return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n    };\n    pp$8.parseClassElement = function(constructorAllowsSuper) {\n        if (this.eat(types$1.semi)) {\n            return null;\n        }\n        var ecmaVersion = this.options.ecmaVersion;\n        var node = this.startNode();\n        var keyName = \"\";\n        var isGenerator = false;\n        var isAsync = false;\n        var kind = \"method\";\n        var isStatic = false;\n        if (this.eatContextual(\"static\")) {\n            // Parse static init block\n            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n                this.parseClassStaticBlock(node);\n                return node;\n            }\n            if (this.isClassElementNameStart() || this.type === types$1.star) {\n                isStatic = true;\n            } else {\n                keyName = \"static\";\n            }\n        }\n        node.static = isStatic;\n        if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n                isAsync = true;\n            } else {\n                keyName = \"async\";\n            }\n        }\n        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n            isGenerator = true;\n        }\n        if (!keyName && !isAsync && !isGenerator) {\n            var lastValue = this.value;\n            if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n                if (this.isClassElementNameStart()) {\n                    kind = lastValue;\n                } else {\n                    keyName = lastValue;\n                }\n            }\n        }\n        // Parse element name\n        if (keyName) {\n            // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n            // The last token is any of those. Make it the element name.\n            node.computed = false;\n            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n            node.key.name = keyName;\n            this.finishNode(node.key, \"Identifier\");\n        } else {\n            this.parseClassElementName(node);\n        }\n        // Parse element value\n        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n            var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n            var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n            if (isConstructor && kind !== \"method\") {\n                this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n            }\n            node.kind = isConstructor ? \"constructor\" : kind;\n            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n        } else {\n            this.parseClassField(node);\n        }\n        return node;\n    };\n    pp$8.isClassElementNameStart = function() {\n        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n    };\n    pp$8.parseClassElementName = function(element) {\n        if (this.type === types$1.privateId) {\n            if (this.value === \"constructor\") {\n                this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n            }\n            element.computed = false;\n            element.key = this.parsePrivateIdent();\n        } else {\n            this.parsePropertyName(element);\n        }\n    };\n    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n        // Check key and flags\n        var key = method.key;\n        if (method.kind === \"constructor\") {\n            if (isGenerator) {\n                this.raise(key.start, \"Constructor can't be a generator\");\n            }\n            if (isAsync) {\n                this.raise(key.start, \"Constructor can't be an async method\");\n            }\n        } else if (method.static && checkKeyName(method, \"prototype\")) {\n            this.raise(key.start, \"Classes may not have a static property named prototype\");\n        }\n        // Parse value\n        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n        // Check value\n        if (method.kind === \"get\" && value.params.length !== 0) {\n            this.raiseRecoverable(value.start, \"getter should have no params\");\n        }\n        if (method.kind === \"set\" && value.params.length !== 1) {\n            this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n        }\n        if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n        }\n        return this.finishNode(method, \"MethodDefinition\");\n    };\n    pp$8.parseClassField = function(field) {\n        if (checkKeyName(field, \"constructor\")) {\n            this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n        } else if (field.static && checkKeyName(field, \"prototype\")) {\n            this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n        }\n        if (this.eat(types$1.eq)) {\n            // To raise SyntaxError if 'arguments' exists in the initializer.\n            var scope = this.currentThisScope();\n            var inClassFieldInit = scope.inClassFieldInit;\n            scope.inClassFieldInit = true;\n            field.value = this.parseMaybeAssign();\n            scope.inClassFieldInit = inClassFieldInit;\n        } else {\n            field.value = null;\n        }\n        this.semicolon();\n        return this.finishNode(field, \"PropertyDefinition\");\n    };\n    pp$8.parseClassStaticBlock = function(node) {\n        node.body = [];\n        var oldLabels = this.labels;\n        this.labels = [];\n        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        this.next();\n        this.exitScope();\n        this.labels = oldLabels;\n        return this.finishNode(node, \"StaticBlock\");\n    };\n    pp$8.parseClassId = function(node, isStatement) {\n        if (this.type === types$1.name) {\n            node.id = this.parseIdent();\n            if (isStatement) {\n                this.checkLValSimple(node.id, BIND_LEXICAL, false);\n            }\n        } else {\n            if (isStatement === true) {\n                this.unexpected();\n            }\n            node.id = null;\n        }\n    };\n    pp$8.parseClassSuper = function(node) {\n        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n    };\n    pp$8.enterClassBody = function() {\n        var element = {\n            declared: Object.create(null),\n            used: []\n        };\n        this.privateNameStack.push(element);\n        return element.declared;\n    };\n    pp$8.exitClassBody = function() {\n        var ref = this.privateNameStack.pop();\n        var declared = ref.declared;\n        var used = ref.used;\n        if (!this.options.checkPrivateFields) {\n            return;\n        }\n        var len = this.privateNameStack.length;\n        var parent = len === 0 ? null : this.privateNameStack[len - 1];\n        for(var i = 0; i < used.length; ++i){\n            var id = used[i];\n            if (!hasOwn(declared, id.name)) {\n                if (parent) {\n                    parent.used.push(id);\n                } else {\n                    this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n                }\n            }\n        }\n    };\n    function isPrivateNameConflicted(privateNameMap, element) {\n        var name = element.key.name;\n        var curr = privateNameMap[name];\n        var next = \"true\";\n        if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n            next = (element.static ? \"s\" : \"i\") + element.kind;\n        }\n        // `class { get #a(){}; static set #a(_){} }` is also conflict.\n        if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n            privateNameMap[name] = \"true\";\n            return false;\n        } else if (!curr) {\n            privateNameMap[name] = next;\n            return false;\n        } else {\n            return true;\n        }\n    }\n    function checkKeyName(node, name) {\n        var computed = node.computed;\n        var key = node.key;\n        return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n    }\n    // Parses module export declaration.\n    pp$8.parseExportAllDeclaration = function(node, exports1) {\n        if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual(\"as\")) {\n                node.exported = this.parseModuleExportName();\n                this.checkExport(exports1, node.exported, this.lastTokStart);\n            } else {\n                node.exported = null;\n            }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== types$1.string) {\n            this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n    };\n    pp$8.parseExport = function(node, exports1) {\n        this.next();\n        // export * from '...'\n        if (this.eat(types$1.star)) {\n            return this.parseExportAllDeclaration(node, exports1);\n        }\n        if (this.eat(types$1._default)) {\n            this.checkExport(exports1, \"default\", this.lastTokStart);\n            node.declaration = this.parseExportDefaultDeclaration();\n            return this.finishNode(node, \"ExportDefaultDeclaration\");\n        }\n        // export var|const|let|function|class ...\n        if (this.shouldParseExportStatement()) {\n            node.declaration = this.parseExportDeclaration(node);\n            if (node.declaration.type === \"VariableDeclaration\") {\n                this.checkVariableExport(exports1, node.declaration.declarations);\n            } else {\n                this.checkExport(exports1, node.declaration.id, node.declaration.id.start);\n            }\n            node.specifiers = [];\n            node.source = null;\n        } else {\n            node.declaration = null;\n            node.specifiers = this.parseExportSpecifiers(exports1);\n            if (this.eatContextual(\"from\")) {\n                if (this.type !== types$1.string) {\n                    this.unexpected();\n                }\n                node.source = this.parseExprAtom();\n            } else {\n                for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                    // check for keywords used as local names\n                    var spec = list[i];\n                    this.checkUnreserved(spec.local);\n                    // check if export is defined\n                    this.checkLocalExport(spec.local);\n                    if (spec.local.type === \"Literal\") {\n                        this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                    }\n                }\n                node.source = null;\n            }\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n    };\n    pp$8.parseExportDeclaration = function(node) {\n        return this.parseStatement(null);\n    };\n    pp$8.parseExportDefaultDeclaration = function() {\n        var isAsync;\n        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n            var fNode = this.startNode();\n            this.next();\n            if (isAsync) {\n                this.next();\n            }\n            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === types$1._class) {\n            var cNode = this.startNode();\n            return this.parseClass(cNode, \"nullableID\");\n        } else {\n            var declaration = this.parseMaybeAssign();\n            this.semicolon();\n            return declaration;\n        }\n    };\n    pp$8.checkExport = function(exports1, name, pos) {\n        if (!exports1) {\n            return;\n        }\n        if (typeof name !== \"string\") {\n            name = name.type === \"Identifier\" ? name.name : name.value;\n        }\n        if (hasOwn(exports1, name)) {\n            this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n        }\n        exports1[name] = true;\n    };\n    pp$8.checkPatternExport = function(exports1, pat) {\n        var type = pat.type;\n        if (type === \"Identifier\") {\n            this.checkExport(exports1, pat, pat.start);\n        } else if (type === \"ObjectPattern\") {\n            for(var i = 0, list = pat.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkPatternExport(exports1, prop);\n            }\n        } else if (type === \"ArrayPattern\") {\n            for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n                var elt = list$1[i$1];\n                if (elt) {\n                    this.checkPatternExport(exports1, elt);\n                }\n            }\n        } else if (type === \"Property\") {\n            this.checkPatternExport(exports1, pat.value);\n        } else if (type === \"AssignmentPattern\") {\n            this.checkPatternExport(exports1, pat.left);\n        } else if (type === \"RestElement\") {\n            this.checkPatternExport(exports1, pat.argument);\n        }\n    };\n    pp$8.checkVariableExport = function(exports1, decls) {\n        if (!exports1) {\n            return;\n        }\n        for(var i = 0, list = decls; i < list.length; i += 1){\n            var decl = list[i];\n            this.checkPatternExport(exports1, decl.id);\n        }\n    };\n    pp$8.shouldParseExportStatement = function() {\n        return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n    };\n    // Parses a comma-separated list of module exports.\n    pp$8.parseExportSpecifier = function(exports1) {\n        var node = this.startNode();\n        node.local = this.parseModuleExportName();\n        node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n        this.checkExport(exports1, node.exported, node.exported.start);\n        return this.finishNode(node, \"ExportSpecifier\");\n    };\n    pp$8.parseExportSpecifiers = function(exports1) {\n        var nodes = [], first = true;\n        // export { x, y as z } [from '...']\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseExportSpecifier(exports1));\n        }\n        return nodes;\n    };\n    // Parses import declaration.\n    pp$8.parseImport = function(node) {\n        this.next();\n        // import '...'\n        if (this.type === types$1.string) {\n            node.specifiers = empty$1;\n            node.source = this.parseExprAtom();\n        } else {\n            node.specifiers = this.parseImportSpecifiers();\n            this.expectContextual(\"from\");\n            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n    };\n    // Parses a comma-separated list of module imports.\n    pp$8.parseImportSpecifier = function() {\n        var node = this.startNode();\n        node.imported = this.parseModuleExportName();\n        if (this.eatContextual(\"as\")) {\n            node.local = this.parseIdent();\n        } else {\n            this.checkUnreserved(node.imported);\n            node.local = node.imported;\n        }\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportSpecifier\");\n    };\n    pp$8.parseImportDefaultSpecifier = function() {\n        // import defaultObj, { x, y as z } from '...'\n        var node = this.startNode();\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportDefaultSpecifier\");\n    };\n    pp$8.parseImportNamespaceSpecifier = function() {\n        var node = this.startNode();\n        this.next();\n        this.expectContextual(\"as\");\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportNamespaceSpecifier\");\n    };\n    pp$8.parseImportSpecifiers = function() {\n        var nodes = [], first = true;\n        if (this.type === types$1.name) {\n            nodes.push(this.parseImportDefaultSpecifier());\n            if (!this.eat(types$1.comma)) {\n                return nodes;\n            }\n        }\n        if (this.type === types$1.star) {\n            nodes.push(this.parseImportNamespaceSpecifier());\n            return nodes;\n        }\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseImportSpecifier());\n        }\n        return nodes;\n    };\n    pp$8.parseModuleExportName = function() {\n        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n            var stringLiteral = this.parseLiteral(this.value);\n            if (loneSurrogate.test(stringLiteral.value)) {\n                this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n            }\n            return stringLiteral;\n        }\n        return this.parseIdent(true);\n    };\n    // Set `ExpressionStatement#directive` property for directive prologues.\n    pp$8.adaptDirectivePrologue = function(statements) {\n        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\n        }\n    };\n    pp$8.isDirectiveCandidate = function(statement) {\n        return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n        (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n    };\n    var pp$7 = Parser.prototype;\n    // Convert existing expression atom to assignable pattern\n    // if possible.\n    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 6 && node) {\n            switch(node.type){\n                case \"Identifier\":\n                    if (this.inAsync && node.name === \"await\") {\n                        this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                    }\n                    break;\n                case \"ObjectPattern\":\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"RestElement\":\n                    break;\n                case \"ObjectExpression\":\n                    node.type = \"ObjectPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    for(var i = 0, list = node.properties; i < list.length; i += 1){\n                        var prop = list[i];\n                        this.toAssignable(prop, isBinding);\n                        // Early error:\n                        //   AssignmentRestProperty[Yield, Await] :\n                        //     `...` DestructuringAssignmentTarget[Yield, Await]\n                        //\n                        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                        if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                            this.raise(prop.argument.start, \"Unexpected token\");\n                        }\n                    }\n                    break;\n                case \"Property\":\n                    // AssignmentProperty has type === \"Property\"\n                    if (node.kind !== \"init\") {\n                        this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                    }\n                    this.toAssignable(node.value, isBinding);\n                    break;\n                case \"ArrayExpression\":\n                    node.type = \"ArrayPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    this.toAssignableList(node.elements, isBinding);\n                    break;\n                case \"SpreadElement\":\n                    node.type = \"RestElement\";\n                    this.toAssignable(node.argument, isBinding);\n                    if (node.argument.type === \"AssignmentPattern\") {\n                        this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                    }\n                    break;\n                case \"AssignmentExpression\":\n                    if (node.operator !== \"=\") {\n                        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                    }\n                    node.type = \"AssignmentPattern\";\n                    delete node.operator;\n                    this.toAssignable(node.left, isBinding);\n                    break;\n                case \"ParenthesizedExpression\":\n                    this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                    break;\n                case \"ChainExpression\":\n                    this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                    break;\n                case \"MemberExpression\":\n                    if (!isBinding) {\n                        break;\n                    }\n                default:\n                    this.raise(node.start, \"Assigning to rvalue\");\n            }\n        } else if (refDestructuringErrors) {\n            this.checkPatternErrors(refDestructuringErrors, true);\n        }\n        return node;\n    };\n    // Convert list of expression atoms to binding list.\n    pp$7.toAssignableList = function(exprList, isBinding) {\n        var end = exprList.length;\n        for(var i = 0; i < end; i++){\n            var elt = exprList[i];\n            if (elt) {\n                this.toAssignable(elt, isBinding);\n            }\n        }\n        if (end) {\n            var last = exprList[end - 1];\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n                this.unexpected(last.argument.start);\n            }\n        }\n        return exprList;\n    };\n    // Parses spread element.\n    pp$7.parseSpread = function(refDestructuringErrors) {\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        return this.finishNode(node, \"SpreadElement\");\n    };\n    pp$7.parseRestBinding = function() {\n        var node = this.startNode();\n        this.next();\n        // RestElement inside of a function parameter must be an identifier\n        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n            this.unexpected();\n        }\n        node.argument = this.parseBindingAtom();\n        return this.finishNode(node, \"RestElement\");\n    };\n    // Parses lvalue (assignable) atom.\n    pp$7.parseBindingAtom = function() {\n        if (this.options.ecmaVersion >= 6) {\n            switch(this.type){\n                case types$1.bracketL:\n                    var node = this.startNode();\n                    this.next();\n                    node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                    return this.finishNode(node, \"ArrayPattern\");\n                case types$1.braceL:\n                    return this.parseObj(true);\n            }\n        }\n        return this.parseIdent();\n    };\n    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (first) {\n                first = false;\n            } else {\n                this.expect(types$1.comma);\n            }\n            if (allowEmpty && this.type === types$1.comma) {\n                elts.push(null);\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                var rest = this.parseRestBinding();\n                this.parseBindingListItem(rest);\n                elts.push(rest);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                this.expect(close);\n                break;\n            } else {\n                elts.push(this.parseAssignableListItem(allowModifiers));\n            }\n        }\n        return elts;\n    };\n    pp$7.parseAssignableListItem = function(allowModifiers) {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        return elem;\n    };\n    pp$7.parseBindingListItem = function(param) {\n        return param;\n    };\n    // Parses assignment pattern around given atom if possible.\n    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n        left = left || this.parseBindingAtom();\n        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n            return left;\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.right = this.parseMaybeAssign();\n        return this.finishNode(node, \"AssignmentPattern\");\n    };\n    // The following three functions all verify that a node is an lvalue —\n    // something that can be bound, or assigned to. In order to do so, they perform\n    // a variety of checks:\n    //\n    // - Check that none of the bound/assigned-to identifiers are reserved words.\n    // - Record name declarations for bindings in the appropriate scope.\n    // - Check duplicate argument names, if checkClashes is set.\n    //\n    // If a complex binding pattern is encountered (e.g., object and array\n    // destructuring), the entire pattern is recursively checked.\n    //\n    // There are three versions of checkLVal*() appropriate for different\n    // circumstances:\n    //\n    // - checkLValSimple() shall be used if the syntactic construct supports\n    //   nothing other than identifiers and member expressions. Parenthesized\n    //   expressions are also correctly handled. This is generally appropriate for\n    //   constructs for which the spec says\n    //\n    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   It is also appropriate for checking if an identifier is valid and not\n    //   defined elsewhere, like import declarations or function/class identifiers.\n    //\n    //   Examples where this is used include:\n    //     a += …;\n    //     import a from '…';\n    //   where a is the node to be checked.\n    //\n    // - checkLValPattern() shall be used if the syntactic construct supports\n    //   anything checkLValSimple() supports, as well as object and array\n    //   destructuring patterns. This is generally appropriate for constructs for\n    //   which the spec says\n    //\n    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   Examples where this is used include:\n    //     (a = …);\n    //     const a = …;\n    //     try { … } catch (a) { … }\n    //   where a is the node to be checked.\n    //\n    // - checkLValInnerPattern() shall be used if the syntactic construct supports\n    //   anything checkLValPattern() supports, as well as default assignment\n    //   patterns, rest elements, and other constructs that may appear within an\n    //   object or array destructuring pattern.\n    //\n    //   As a special case, function parameters also use checkLValInnerPattern(),\n    //   as they also support defaults and rest constructs.\n    //\n    // These functions deliberately support both assignment and binding constructs,\n    // as the logic for both is exceedingly similar. If the node is the target of\n    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n    // should be set to the appropriate BIND_* constant, like BIND_VAR or\n    // BIND_LEXICAL.\n    //\n    // If the function is called with a non-BIND_NONE bindingType, then\n    // additionally a checkClashes object may be specified to allow checking for\n    // duplicate argument names. checkClashes is ignored if the provided construct\n    // is an assignment (i.e., bindingType is BIND_NONE).\n    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        var isBind = bindingType !== BIND_NONE;\n        switch(expr.type){\n            case \"Identifier\":\n                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                    this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n                }\n                if (isBind) {\n                    if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                        this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                    }\n                    if (checkClashes) {\n                        if (hasOwn(checkClashes, expr.name)) {\n                            this.raiseRecoverable(expr.start, \"Argument name clash\");\n                        }\n                        checkClashes[expr.name] = true;\n                    }\n                    if (bindingType !== BIND_OUTSIDE) {\n                        this.declareName(expr.name, bindingType, expr.start);\n                    }\n                }\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding member expression\");\n                }\n                break;\n            case \"ParenthesizedExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n                }\n                return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n            default:\n                this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n        }\n    };\n    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"ObjectPattern\":\n                for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n                }\n                break;\n            case \"ArrayPattern\":\n                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                    var elem = list$1[i$1];\n                    if (elem) {\n                        this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                    }\n                }\n                break;\n            default:\n                this.checkLValSimple(expr, bindingType, checkClashes);\n        }\n    };\n    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n                break;\n            case \"AssignmentPattern\":\n                this.checkLValPattern(expr.left, bindingType, checkClashes);\n                break;\n            case \"RestElement\":\n                this.checkLValPattern(expr.argument, bindingType, checkClashes);\n                break;\n            default:\n                this.checkLValPattern(expr, bindingType, checkClashes);\n        }\n    };\n    // The algorithm used to determine whether a regexp can appear at a\n    // given point in the program is loosely based on sweet.js' approach.\n    // See https://github.com/mozilla/sweet.js/wiki/design\n    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n        this.token = token;\n        this.isExpr = !!isExpr;\n        this.preserveSpace = !!preserveSpace;\n        this.override = override;\n        this.generator = !!generator;\n    };\n    var types = {\n        b_stat: new TokContext(\"{\", false),\n        b_expr: new TokContext(\"{\", true),\n        b_tmpl: new TokContext(\"${\", false),\n        p_stat: new TokContext(\"(\", false),\n        p_expr: new TokContext(\"(\", true),\n        q_tmpl: new TokContext(\"`\", true, true, function(p) {\n            return p.tryReadTemplateToken();\n        }),\n        f_stat: new TokContext(\"function\", false),\n        f_expr: new TokContext(\"function\", true),\n        f_expr_gen: new TokContext(\"function\", true, false, null, true),\n        f_gen: new TokContext(\"function\", false, false, null, true)\n    };\n    var pp$6 = Parser.prototype;\n    pp$6.initialContext = function() {\n        return [\n            types.b_stat\n        ];\n    };\n    pp$6.curContext = function() {\n        return this.context[this.context.length - 1];\n    };\n    pp$6.braceIsBlock = function(prevType) {\n        var parent = this.curContext();\n        if (parent === types.f_expr || parent === types.f_stat) {\n            return true;\n        }\n        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n            return !parent.isExpr;\n        }\n        // The check for `tt.name && exprAllowed` detects whether we are\n        // after a `yield` or `of` construct. See the `updateContext` for\n        // `tt.name`.\n        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n            return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n        }\n        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n            return true;\n        }\n        if (prevType === types$1.braceL) {\n            return parent === types.b_stat;\n        }\n        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n            return false;\n        }\n        return !this.exprAllowed;\n    };\n    pp$6.inGeneratorContext = function() {\n        for(var i = this.context.length - 1; i >= 1; i--){\n            var context = this.context[i];\n            if (context.token === \"function\") {\n                return context.generator;\n            }\n        }\n        return false;\n    };\n    pp$6.updateContext = function(prevType) {\n        var update, type = this.type;\n        if (type.keyword && prevType === types$1.dot) {\n            this.exprAllowed = false;\n        } else if (update = type.updateContext) {\n            update.call(this, prevType);\n        } else {\n            this.exprAllowed = type.beforeExpr;\n        }\n    };\n    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n    pp$6.overrideContext = function(tokenCtx) {\n        if (this.curContext() !== tokenCtx) {\n            this.context[this.context.length - 1] = tokenCtx;\n        }\n    };\n    // Token-specific context update code\n    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n        if (this.context.length === 1) {\n            this.exprAllowed = true;\n            return;\n        }\n        var out = this.context.pop();\n        if (out === types.b_stat && this.curContext().token === \"function\") {\n            out = this.context.pop();\n        }\n        this.exprAllowed = !out.isExpr;\n    };\n    types$1.braceL.updateContext = function(prevType) {\n        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n        this.exprAllowed = true;\n    };\n    types$1.dollarBraceL.updateContext = function() {\n        this.context.push(types.b_tmpl);\n        this.exprAllowed = true;\n    };\n    types$1.parenL.updateContext = function(prevType) {\n        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n        this.context.push(statementParens ? types.p_stat : types.p_expr);\n        this.exprAllowed = true;\n    };\n    types$1.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n    };\n    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n            this.context.push(types.f_expr);\n        } else {\n            this.context.push(types.f_stat);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.colon.updateContext = function() {\n        if (this.curContext().token === \"function\") {\n            this.context.pop();\n        }\n        this.exprAllowed = true;\n    };\n    types$1.backQuote.updateContext = function() {\n        if (this.curContext() === types.q_tmpl) {\n            this.context.pop();\n        } else {\n            this.context.push(types.q_tmpl);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.star.updateContext = function(prevType) {\n        if (prevType === types$1._function) {\n            var index = this.context.length - 1;\n            if (this.context[index] === types.f_expr) {\n                this.context[index] = types.f_expr_gen;\n            } else {\n                this.context[index] = types.f_gen;\n            }\n        }\n        this.exprAllowed = true;\n    };\n    types$1.name.updateContext = function(prevType) {\n        var allowed = false;\n        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n            if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n                allowed = true;\n            }\n        }\n        this.exprAllowed = allowed;\n    };\n    // A recursive descent parser operates by defining functions for all\n    // syntactic elements, and recursively calling those, each function\n    // advancing the input stream and returning an AST node. Precedence\n    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n    // instead of `(!x)[1]` is handled by the fact that the parser\n    // function that parses unary prefix operators is called first, and\n    // in turn calls the function that parses `[]` subscripts — that\n    // way, it'll receive the node for `x[1]` already parsed, and wraps\n    // *that* in the unary operator node.\n    //\n    // Acorn uses an [operator precedence parser][opp] to handle binary\n    // operator precedence, because it is much more compact than using\n    // the technique outlined above, which uses different, nesting\n    // functions to specify precedence, for all of the ten binary\n    // precedence levels that JavaScript defines.\n    //\n    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n    var pp$5 = Parser.prototype;\n    // Check if property name clashes with already added.\n    // Object/class getters and setters are not allowed to clash —\n    // either with each other or with an init property — and in\n    // strict mode, init properties are also not allowed to be repeated.\n    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n            return;\n        }\n        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n            return;\n        }\n        var key = prop.key;\n        var name;\n        switch(key.type){\n            case \"Identifier\":\n                name = key.name;\n                break;\n            case \"Literal\":\n                name = String(key.value);\n                break;\n            default:\n                return;\n        }\n        var kind = prop.kind;\n        if (this.options.ecmaVersion >= 6) {\n            if (name === \"__proto__\" && kind === \"init\") {\n                if (propHash.proto) {\n                    if (refDestructuringErrors) {\n                        if (refDestructuringErrors.doubleProto < 0) {\n                            refDestructuringErrors.doubleProto = key.start;\n                        }\n                    } else {\n                        this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                    }\n                }\n                propHash.proto = true;\n            }\n            return;\n        }\n        name = \"$\" + name;\n        var other = propHash[name];\n        if (other) {\n            var redefinition;\n            if (kind === \"init\") {\n                redefinition = this.strict && other.init || other.get || other.set;\n            } else {\n                redefinition = other.init || other[kind];\n            }\n            if (redefinition) {\n                this.raiseRecoverable(key.start, \"Redefinition of property\");\n            }\n        } else {\n            other = propHash[name] = {\n                init: false,\n                get: false,\n                set: false\n            };\n        }\n        other[kind] = true;\n    };\n    // ### Expression parsing\n    // These nest, from the most general expression type at the top to\n    // 'atomic', nondivisible expression types at the bottom. Most of\n    // the functions will simply let the function(s) below them parse,\n    // and, *if* the syntactic construct they handle is present, wrap\n    // the AST node that the inner parser gave them in another node.\n    // Parse a full expression. The optional arguments are used to\n    // forbid the `in` operator (in for loops initalization expressions)\n    // and provide reference for storing '=' operator inside shorthand\n    // property assignment in contexts where both object expression\n    // and object pattern might appear (so it's possible to raise\n    // delayed syntax error at correct position).\n    pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n        if (this.type === types$1.comma) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.expressions = [\n                expr\n            ];\n            while(this.eat(types$1.comma)){\n                node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n            }\n            return this.finishNode(node, \"SequenceExpression\");\n        }\n        return expr;\n    };\n    // Parse an assignment expression. This includes applications of\n    // operators like `+=`.\n    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n        if (this.isContextual(\"yield\")) {\n            if (this.inGenerator) {\n                return this.parseYield(forInit);\n            } else {\n                this.exprAllowed = false;\n            }\n        }\n        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n        if (refDestructuringErrors) {\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n            oldTrailingComma = refDestructuringErrors.trailingComma;\n            oldDoubleProto = refDestructuringErrors.doubleProto;\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n        } else {\n            refDestructuringErrors = new DestructuringErrors;\n            ownDestructuringErrors = true;\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        if (this.type === types$1.parenL || this.type === types$1.name) {\n            this.potentialArrowAt = this.start;\n            this.potentialArrowInForAwait = forInit === \"await\";\n        }\n        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n        if (afterLeftParse) {\n            left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        if (this.type.isAssign) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.operator = this.value;\n            if (this.type === types$1.eq) {\n                left = this.toAssignable(left, false, refDestructuringErrors);\n            }\n            if (!ownDestructuringErrors) {\n                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n            }\n            if (refDestructuringErrors.shorthandAssign >= left.start) {\n                refDestructuringErrors.shorthandAssign = -1;\n            } // reset because shorthand default was used correctly\n            if (this.type === types$1.eq) {\n                this.checkLValPattern(left);\n            } else {\n                this.checkLValSimple(left);\n            }\n            node.left = left;\n            this.next();\n            node.right = this.parseMaybeAssign(forInit);\n            if (oldDoubleProto > -1) {\n                refDestructuringErrors.doubleProto = oldDoubleProto;\n            }\n            return this.finishNode(node, \"AssignmentExpression\");\n        } else {\n            if (ownDestructuringErrors) {\n                this.checkExpressionErrors(refDestructuringErrors, true);\n            }\n        }\n        if (oldParenAssign > -1) {\n            refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n        }\n        if (oldTrailingComma > -1) {\n            refDestructuringErrors.trailingComma = oldTrailingComma;\n        }\n        return left;\n    };\n    // Parse a ternary conditional (`?:`) operator.\n    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprOps(forInit, refDestructuringErrors);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        if (this.eat(types$1.question)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.test = expr;\n            node.consequent = this.parseMaybeAssign();\n            this.expect(types$1.colon);\n            node.alternate = this.parseMaybeAssign(forInit);\n            return this.finishNode(node, \"ConditionalExpression\");\n        }\n        return expr;\n    };\n    // Start the precedence parser.\n    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n    };\n    // Parse binary operators with the operator precedence parsing\n    // algorithm. `left` is the left-hand side of the operator.\n    // `minPrec` provides context that allows the function to stop and\n    // defer further parser to one of its callers when it encounters an\n    // operator that has a lower precedence than the set it is parsing.\n    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n        var prec = this.type.binop;\n        if (prec != null && (!forInit || this.type !== types$1._in)) {\n            if (prec > minPrec) {\n                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n                var coalesce = this.type === types$1.coalesce;\n                if (coalesce) {\n                    // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                    // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                    prec = types$1.logicalAND.binop;\n                }\n                var op = this.value;\n                this.next();\n                var startPos = this.start, startLoc = this.startLoc;\n                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                    this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n                }\n                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n            }\n        }\n        return left;\n    };\n    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n        if (right.type === \"PrivateIdentifier\") {\n            this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.operator = op;\n        node.right = right;\n        return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n    };\n    // Parse unary operators, both prefix and postfix.\n    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, expr;\n        if (this.isContextual(\"await\") && this.canAwait) {\n            expr = this.parseAwait(forInit);\n            sawUnary = true;\n        } else if (this.type.prefix) {\n            var node = this.startNode(), update = this.type === types$1.incDec;\n            node.operator = this.value;\n            node.prefix = true;\n            this.next();\n            node.argument = this.parseMaybeUnary(null, true, update, forInit);\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            if (update) {\n                this.checkLValSimple(node.argument);\n            } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n            } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n                this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n            } else {\n                sawUnary = true;\n            }\n            expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n        } else if (!sawUnary && this.type === types$1.privateId) {\n            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n                this.unexpected();\n            }\n            expr = this.parsePrivateIdent();\n            // only could be private fields in 'in', such as #x in obj\n            if (this.type !== types$1._in) {\n                this.unexpected();\n            }\n        } else {\n            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n            if (this.checkExpressionErrors(refDestructuringErrors)) {\n                return expr;\n            }\n            while(this.type.postfix && !this.canInsertSemicolon()){\n                var node$1 = this.startNodeAt(startPos, startLoc);\n                node$1.operator = this.value;\n                node$1.prefix = false;\n                node$1.argument = expr;\n                this.checkLValSimple(expr);\n                this.next();\n                expr = this.finishNode(node$1, \"UpdateExpression\");\n            }\n        }\n        if (!incDec && this.eat(types$1.starstar)) {\n            if (sawUnary) {\n                this.unexpected(this.lastTokStart);\n            } else {\n                return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n            }\n        } else {\n            return expr;\n        }\n    };\n    function isPrivateFieldAccess(node) {\n        return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression);\n    }\n    // Parse call, dot, and `[]`-subscript expressions.\n    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n        if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n            return expr;\n        }\n        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n        if (refDestructuringErrors && result.type === \"MemberExpression\") {\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n                refDestructuringErrors.parenthesizedAssign = -1;\n            }\n            if (refDestructuringErrors.parenthesizedBind >= result.start) {\n                refDestructuringErrors.parenthesizedBind = -1;\n            }\n            if (refDestructuringErrors.trailingComma >= result.start) {\n                refDestructuringErrors.trailingComma = -1;\n            }\n        }\n        return result;\n    };\n    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n        var optionalChained = false;\n        while(true){\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n            if (element.optional) {\n                optionalChained = true;\n            }\n            if (element === base || element.type === \"ArrowFunctionExpression\") {\n                if (optionalChained) {\n                    var chainNode = this.startNodeAt(startPos, startLoc);\n                    chainNode.expression = element;\n                    element = this.finishNode(chainNode, \"ChainExpression\");\n                }\n                return element;\n            }\n            base = element;\n        }\n    };\n    pp$5.shouldParseAsyncArrow = function() {\n        return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n    };\n    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n    };\n    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n        var optionalSupported = this.options.ecmaVersion >= 11;\n        var optional = optionalSupported && this.eat(types$1.questionDot);\n        if (noCalls && optional) {\n            this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n        }\n        var computed = this.eat(types$1.bracketL);\n        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.object = base;\n            if (computed) {\n                node.property = this.parseExpression();\n                this.expect(types$1.bracketR);\n            } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n                node.property = this.parsePrivateIdent();\n            } else {\n                node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n            }\n            node.computed = !!computed;\n            if (optionalSupported) {\n                node.optional = optional;\n            }\n            base = this.finishNode(node, \"MemberExpression\");\n        } else if (!noCalls && this.eat(types$1.parenL)) {\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            this.awaitIdentPos = 0;\n            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                if (this.awaitIdentPos > 0) {\n                    this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                this.awaitIdentPos = oldAwaitIdentPos;\n                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.callee = base;\n            node$1.arguments = exprList;\n            if (optionalSupported) {\n                node$1.optional = optional;\n            }\n            base = this.finishNode(node$1, \"CallExpression\");\n        } else if (this.type === types$1.backQuote) {\n            if (optional || optionalChained) {\n                this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n            }\n            var node$2 = this.startNodeAt(startPos, startLoc);\n            node$2.tag = base;\n            node$2.quasi = this.parseTemplate({\n                isTagged: true\n            });\n            base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n        }\n        return base;\n    };\n    // Parse an atomic expression — either a single token that is an\n    // expression, an expression started by a keyword like `function` or\n    // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n    // or `{}`.\n    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n        // If a division operator appears in an expression position, the\n        // tokenizer got confused, and we force it to read a regexp instead.\n        if (this.type === types$1.slash) {\n            this.readRegexp();\n        }\n        var node, canBeArrow = this.potentialArrowAt === this.start;\n        switch(this.type){\n            case types$1._super:\n                if (!this.allowSuper) {\n                    this.raise(this.start, \"'super' keyword outside a method\");\n                }\n                node = this.startNode();\n                this.next();\n                if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                    this.raise(node.start, \"super() call outside constructor of a subclass\");\n                }\n                // The `super` keyword can appear at below:\n                // SuperProperty:\n                //     super [ Expression ]\n                //     super . IdentifierName\n                // SuperCall:\n                //     super ( Arguments )\n                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                    this.unexpected();\n                }\n                return this.finishNode(node, \"Super\");\n            case types$1._this:\n                node = this.startNode();\n                this.next();\n                return this.finishNode(node, \"ThisExpression\");\n            case types$1.name:\n                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n                var id = this.parseIdent(false);\n                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                    this.overrideContext(types.f_expr);\n                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n                }\n                if (canBeArrow && !this.canInsertSemicolon()) {\n                    if (this.eat(types$1.arrow)) {\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], false, forInit);\n                    }\n                    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                        id = this.parseIdent(false);\n                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                            this.unexpected();\n                        }\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], true, forInit);\n                    }\n                }\n                return id;\n            case types$1.regexp:\n                var value = this.value;\n                node = this.parseLiteral(value.value);\n                node.regex = {\n                    pattern: value.pattern,\n                    flags: value.flags\n                };\n                return node;\n            case types$1.num:\n            case types$1.string:\n                return this.parseLiteral(this.value);\n            case types$1._null:\n            case types$1._true:\n            case types$1._false:\n                node = this.startNode();\n                node.value = this.type === types$1._null ? null : this.type === types$1._true;\n                node.raw = this.type.keyword;\n                this.next();\n                return this.finishNode(node, \"Literal\");\n            case types$1.parenL:\n                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                        refDestructuringErrors.parenthesizedAssign = start;\n                    }\n                    if (refDestructuringErrors.parenthesizedBind < 0) {\n                        refDestructuringErrors.parenthesizedBind = start;\n                    }\n                }\n                return expr;\n            case types$1.bracketL:\n                node = this.startNode();\n                this.next();\n                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n                return this.finishNode(node, \"ArrayExpression\");\n            case types$1.braceL:\n                this.overrideContext(types.b_expr);\n                return this.parseObj(false, refDestructuringErrors);\n            case types$1._function:\n                node = this.startNode();\n                this.next();\n                return this.parseFunction(node, 0);\n            case types$1._class:\n                return this.parseClass(this.startNode(), false);\n            case types$1._new:\n                return this.parseNew();\n            case types$1.backQuote:\n                return this.parseTemplate();\n            case types$1._import:\n                if (this.options.ecmaVersion >= 11) {\n                    return this.parseExprImport(forNew);\n                } else {\n                    return this.unexpected();\n                }\n            default:\n                return this.parseExprAtomDefault();\n        }\n    };\n    pp$5.parseExprAtomDefault = function() {\n        this.unexpected();\n    };\n    pp$5.parseExprImport = function(forNew) {\n        var node = this.startNode();\n        // Consume `import` as an identifier for `import.meta`.\n        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n        }\n        var meta = this.parseIdent(true);\n        if (this.type === types$1.parenL && !forNew) {\n            return this.parseDynamicImport(node);\n        } else if (this.type === types$1.dot) {\n            node.meta = meta;\n            return this.parseImportMeta(node);\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parseDynamicImport = function(node) {\n        this.next(); // skip `(`\n        // Parse node.source.\n        node.source = this.parseMaybeAssign();\n        // Verify ending.\n        if (!this.eat(types$1.parenR)) {\n            var errorPos = this.start;\n            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n                this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n            } else {\n                this.unexpected(errorPos);\n            }\n        }\n        return this.finishNode(node, \"ImportExpression\");\n    };\n    pp$5.parseImportMeta = function(node) {\n        this.next(); // skip `.`\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"meta\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n        }\n        if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n            this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    };\n    pp$5.parseLiteral = function(value) {\n        var node = this.startNode();\n        node.value = value;\n        node.raw = this.input.slice(this.start, this.end);\n        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n            node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n        }\n        this.next();\n        return this.finishNode(node, \"Literal\");\n    };\n    pp$5.parseParenExpression = function() {\n        this.expect(types$1.parenL);\n        var val = this.parseExpression();\n        this.expect(types$1.parenR);\n        return val;\n    };\n    pp$5.shouldParseArrow = function(exprList) {\n        return !this.canInsertSemicolon();\n    };\n    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n        if (this.options.ecmaVersion >= 6) {\n            this.next();\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\n            var exprList = [], first = true, lastIsComma = false;\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            // Do not save awaitIdentPos to allow checking awaits nested in parameters\n            while(this.type !== types$1.parenR){\n                first ? first = false : this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                    lastIsComma = true;\n                    break;\n                } else if (this.type === types$1.ellipsis) {\n                    spreadStart = this.start;\n                    exprList.push(this.parseParenItem(this.parseRestBinding()));\n                    if (this.type === types$1.comma) {\n                        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                    }\n                    break;\n                } else {\n                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n                }\n            }\n            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n            this.expect(types$1.parenR);\n            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n            }\n            if (!exprList.length || lastIsComma) {\n                this.unexpected(this.lastTokStart);\n            }\n            if (spreadStart) {\n                this.unexpected(spreadStart);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            if (exprList.length > 1) {\n                val = this.startNodeAt(innerStartPos, innerStartLoc);\n                val.expressions = exprList;\n                this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n            } else {\n                val = exprList[0];\n            }\n        } else {\n            val = this.parseParenExpression();\n        }\n        if (this.options.preserveParens) {\n            var par = this.startNodeAt(startPos, startLoc);\n            par.expression = val;\n            return this.finishNode(par, \"ParenthesizedExpression\");\n        } else {\n            return val;\n        }\n    };\n    pp$5.parseParenItem = function(item) {\n        return item;\n    };\n    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n    };\n    // New's precedence is slightly tricky. It must allow its argument to\n    // be a `[]` or dot subscript expression, but not a call — at least,\n    // not without wrapping it in parentheses. Thus, it uses the noCalls\n    // argument to parseSubscripts to prevent it from consuming the\n    // argument list.\n    var empty = [];\n    pp$5.parseNew = function() {\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n        }\n        var node = this.startNode();\n        this.next();\n        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n            var meta = this.startNodeAt(node.start, node.startLoc);\n            meta.name = \"new\";\n            node.meta = this.finishNode(meta, \"Identifier\");\n            this.next();\n            var containsEsc = this.containsEsc;\n            node.property = this.parseIdent(true);\n            if (node.property.name !== \"target\") {\n                this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n            }\n            if (containsEsc) {\n                this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n            }\n            if (!this.allowNewDotTarget) {\n                this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n            }\n            return this.finishNode(node, \"MetaProperty\");\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n        if (this.eat(types$1.parenL)) {\n            node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n        } else {\n            node.arguments = empty;\n        }\n        return this.finishNode(node, \"NewExpression\");\n    };\n    // Parse template expression.\n    pp$5.parseTemplateElement = function(ref) {\n        var isTagged = ref.isTagged;\n        var elem = this.startNode();\n        if (this.type === types$1.invalidTemplate) {\n            if (!isTagged) {\n                this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n            }\n            elem.value = {\n                raw: this.value,\n                cooked: null\n            };\n        } else {\n            elem.value = {\n                raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n                cooked: this.value\n            };\n        }\n        this.next();\n        elem.tail = this.type === types$1.backQuote;\n        return this.finishNode(elem, \"TemplateElement\");\n    };\n    pp$5.parseTemplate = function(ref) {\n        if (ref === void 0) ref = {};\n        var isTagged = ref.isTagged;\n        if (isTagged === void 0) isTagged = false;\n        var node = this.startNode();\n        this.next();\n        node.expressions = [];\n        var curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        });\n        node.quasis = [\n            curElt\n        ];\n        while(!curElt.tail){\n            if (this.type === types$1.eof) {\n                this.raise(this.pos, \"Unterminated template literal\");\n            }\n            this.expect(types$1.dollarBraceL);\n            node.expressions.push(this.parseExpression());\n            this.expect(types$1.braceR);\n            node.quasis.push(curElt = this.parseTemplateElement({\n                isTagged: isTagged\n            }));\n        }\n        this.next();\n        return this.finishNode(node, \"TemplateLiteral\");\n    };\n    pp$5.isAsyncProp = function(prop) {\n        return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    // Parse an object literal or binding pattern.\n    pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n        var node = this.startNode(), first = true, propHash = {};\n        node.properties = [];\n        this.next();\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\n            if (!isPattern) {\n                this.checkPropClash(prop, propHash, refDestructuringErrors);\n            }\n            node.properties.push(prop);\n        }\n        return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n    };\n    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n            if (isPattern) {\n                prop.argument = this.parseIdent(false);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                return this.finishNode(prop, \"RestElement\");\n            }\n            // Parse argument.\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n            // To disallow trailing comma via `this.toAssignable()`.\n            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n            // Finish\n            return this.finishNode(prop, \"SpreadElement\");\n        }\n        if (this.options.ecmaVersion >= 6) {\n            prop.method = false;\n            prop.shorthand = false;\n            if (isPattern || refDestructuringErrors) {\n                startPos = this.start;\n                startLoc = this.startLoc;\n            }\n            if (!isPattern) {\n                isGenerator = this.eat(types$1.star);\n            }\n        }\n        var containsEsc = this.containsEsc;\n        this.parsePropertyName(prop);\n        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n            isAsync = true;\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n            this.parsePropertyName(prop);\n        } else {\n            isAsync = false;\n        }\n        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n        return this.finishNode(prop, \"Property\");\n    };\n    pp$5.parseGetterSetter = function(prop) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n        var paramCount = prop.kind === \"get\" ? 0 : 1;\n        if (prop.value.params.length !== paramCount) {\n            var start = prop.value.start;\n            if (prop.kind === \"get\") {\n                this.raiseRecoverable(start, \"getter should have no params\");\n            } else {\n                this.raiseRecoverable(start, \"setter should have exactly one param\");\n            }\n        } else {\n            if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n                this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n            }\n        }\n    };\n    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n        if ((isGenerator || isAsync) && this.type === types$1.colon) {\n            this.unexpected();\n        }\n        if (this.eat(types$1.colon)) {\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n            prop.kind = \"init\";\n        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n            if (isPattern) {\n                this.unexpected();\n            }\n            prop.kind = \"init\";\n            prop.method = true;\n            prop.value = this.parseMethod(isGenerator, isAsync);\n        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.parseGetterSetter(prop);\n        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.checkUnreserved(prop.key);\n            if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = startPos;\n            }\n            prop.kind = \"init\";\n            if (isPattern) {\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else if (this.type === types$1.eq && refDestructuringErrors) {\n                if (refDestructuringErrors.shorthandAssign < 0) {\n                    refDestructuringErrors.shorthandAssign = this.start;\n                }\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else {\n                prop.value = this.copyNode(prop.key);\n            }\n            prop.shorthand = true;\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parsePropertyName = function(prop) {\n        if (this.options.ecmaVersion >= 6) {\n            if (this.eat(types$1.bracketL)) {\n                prop.computed = true;\n                prop.key = this.parseMaybeAssign();\n                this.expect(types$1.bracketR);\n                return prop.key;\n            } else {\n                prop.computed = false;\n            }\n        }\n        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n    };\n    // Initialize empty function node.\n    pp$5.initFunction = function(node) {\n        node.id = null;\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = node.expression = false;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = false;\n        }\n    };\n    // Parse object or class method.\n    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = isGenerator;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n        this.parseFunctionBody(node, false, true, false);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"FunctionExpression\");\n    };\n    // Parse arrow function expression with given parameters.\n    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        node.params = this.toAssignableList(params, true);\n        this.parseFunctionBody(node, true, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"ArrowFunctionExpression\");\n    };\n    // Parse function body and check parameters.\n    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n        var isExpression = isArrowFunction && this.type !== types$1.braceL;\n        var oldStrict = this.strict, useStrict = false;\n        if (isExpression) {\n            node.body = this.parseMaybeAssign(forInit);\n            node.expression = true;\n            this.checkParams(node, false);\n        } else {\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n            if (!oldStrict || nonSimple) {\n                useStrict = this.strictDirective(this.end);\n                // If this is a strict mode function, verify that argument names\n                // are not repeated, and it does not try to bind the words `eval`\n                // or `arguments`.\n                if (useStrict && nonSimple) {\n                    this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n                }\n            }\n            // Start a new scope with regard to labels and the `inFunction`\n            // flag (restore them to their old value afterwards).\n            var oldLabels = this.labels;\n            this.labels = [];\n            if (useStrict) {\n                this.strict = true;\n            }\n            // Add the params to varDeclaredNames to ensure that an error is thrown\n            // if a let/const declaration in the function clashes with one of the params.\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n            if (this.strict && node.id) {\n                this.checkLValSimple(node.id, BIND_OUTSIDE);\n            }\n            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n            node.expression = false;\n            this.adaptDirectivePrologue(node.body.body);\n            this.labels = oldLabels;\n        }\n        this.exitScope();\n    };\n    pp$5.isSimpleParamList = function(params) {\n        for(var i = 0, list = params; i < list.length; i += 1){\n            var param = list[i];\n            if (param.type !== \"Identifier\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Checks function params for various disallowed patterns such as using \"eval\"\n    // or \"arguments\" and duplicate parameters.\n    pp$5.checkParams = function(node, allowDuplicates) {\n        var nameHash = Object.create(null);\n        for(var i = 0, list = node.params; i < list.length; i += 1){\n            var param = list[i];\n            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n        }\n    };\n    // Parses a comma-separated list of expressions, and returns them as\n    // an array. `close` is the token type that ends the list, and\n    // `allowEmpty` can be turned on to allow subsequent commas with\n    // nothing in between them to be parsed as `null` (which is needed\n    // for array literals).\n    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(close)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var elt = void 0;\n            if (allowEmpty && this.type === types$1.comma) {\n                elt = null;\n            } else if (this.type === types$1.ellipsis) {\n                elt = this.parseSpread(refDestructuringErrors);\n                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                    refDestructuringErrors.trailingComma = this.start;\n                }\n            } else {\n                elt = this.parseMaybeAssign(false, refDestructuringErrors);\n            }\n            elts.push(elt);\n        }\n        return elts;\n    };\n    pp$5.checkUnreserved = function(ref) {\n        var start = ref.start;\n        var end = ref.end;\n        var name = ref.name;\n        if (this.inGenerator && name === \"yield\") {\n            this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n        }\n        if (this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n        }\n        if (this.currentThisScope().inClassFieldInit && name === \"arguments\") {\n            this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n        }\n        if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n            this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n        }\n        if (this.keywords.test(name)) {\n            this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n        }\n        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n            return;\n        }\n        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n        if (re.test(name)) {\n            if (!this.inAsync && name === \"await\") {\n                this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n            }\n            this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n        }\n    };\n    // Parse the next token as an identifier. If `liberal` is true (used\n    // when parsing properties), it will also convert keywords into\n    // identifiers.\n    pp$5.parseIdent = function(liberal) {\n        var node = this.parseIdentNode();\n        this.next(!!liberal);\n        this.finishNode(node, \"Identifier\");\n        if (!liberal) {\n            this.checkUnreserved(node);\n            if (node.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = node.start;\n            }\n        }\n        return node;\n    };\n    pp$5.parseIdentNode = function() {\n        var node = this.startNode();\n        if (this.type === types$1.name) {\n            node.name = this.value;\n        } else if (this.type.keyword) {\n            node.name = this.type.keyword;\n            // To fix https://github.com/acornjs/acorn/issues/575\n            // `class` and `function` keywords push new context into this.context.\n            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n            if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n                this.context.pop();\n            }\n            this.type = types$1.name;\n        } else {\n            this.unexpected();\n        }\n        return node;\n    };\n    pp$5.parsePrivateIdent = function() {\n        var node = this.startNode();\n        if (this.type === types$1.privateId) {\n            node.name = this.value;\n        } else {\n            this.unexpected();\n        }\n        this.next();\n        this.finishNode(node, \"PrivateIdentifier\");\n        // For validating existence\n        if (this.options.checkPrivateFields) {\n            if (this.privateNameStack.length === 0) {\n                this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n            } else {\n                this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n            }\n        }\n        return node;\n    };\n    // Parses yield expression inside generator.\n    pp$5.parseYield = function(forInit) {\n        if (!this.yieldPos) {\n            this.yieldPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n            node.delegate = false;\n            node.argument = null;\n        } else {\n            node.delegate = this.eat(types$1.star);\n            node.argument = this.parseMaybeAssign(forInit);\n        }\n        return this.finishNode(node, \"YieldExpression\");\n    };\n    pp$5.parseAwait = function(forInit) {\n        if (!this.awaitPos) {\n            this.awaitPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, false, forInit);\n        return this.finishNode(node, \"AwaitExpression\");\n    };\n    var pp$4 = Parser.prototype;\n    // This function is used to raise exceptions on parse errors. It\n    // takes an offset integer (into the current `input`) to indicate\n    // the location of the error, attaches the position to the end\n    // of the error message, and then raises a `SyntaxError` with that\n    // message.\n    pp$4.raise = function(pos, message) {\n        var loc = getLineInfo(this.input, pos);\n        message += \" (\" + loc.line + \":\" + loc.column + \")\";\n        var err = new SyntaxError(message);\n        err.pos = pos;\n        err.loc = loc;\n        err.raisedAt = this.pos;\n        throw err;\n    };\n    pp$4.raiseRecoverable = pp$4.raise;\n    pp$4.curPosition = function() {\n        if (this.options.locations) {\n            return new Position(this.curLine, this.pos - this.lineStart);\n        }\n    };\n    var pp$3 = Parser.prototype;\n    var Scope = function Scope(flags) {\n        this.flags = flags;\n        // A list of var-declared names in the current lexical scope\n        this.var = [];\n        // A list of lexically-declared names in the current lexical scope\n        this.lexical = [];\n        // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n        this.functions = [];\n        // A switch to disallow the identifier reference 'arguments'\n        this.inClassFieldInit = false;\n    };\n    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n    pp$3.enterScope = function(flags) {\n        this.scopeStack.push(new Scope(flags));\n    };\n    pp$3.exitScope = function() {\n        this.scopeStack.pop();\n    };\n    // The spec says:\n    // > At the top level of a function, or script, function declarations are\n    // > treated like var declarations rather than like lexical declarations.\n    pp$3.treatFunctionsAsVarInScope = function(scope) {\n        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n    };\n    pp$3.declareName = function(name, bindingType, pos) {\n        var redeclared = false;\n        if (bindingType === BIND_LEXICAL) {\n            var scope = this.currentScope();\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n            scope.lexical.push(name);\n            if (this.inModule && scope.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n        } else if (bindingType === BIND_SIMPLE_CATCH) {\n            var scope$1 = this.currentScope();\n            scope$1.lexical.push(name);\n        } else if (bindingType === BIND_FUNCTION) {\n            var scope$2 = this.currentScope();\n            if (this.treatFunctionsAsVar) {\n                redeclared = scope$2.lexical.indexOf(name) > -1;\n            } else {\n                redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n            }\n            scope$2.functions.push(name);\n        } else {\n            for(var i = this.scopeStack.length - 1; i >= 0; --i){\n                var scope$3 = this.scopeStack[i];\n                if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                    redeclared = true;\n                    break;\n                }\n                scope$3.var.push(name);\n                if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                    delete this.undefinedExports[name];\n                }\n                if (scope$3.flags & SCOPE_VAR) {\n                    break;\n                }\n            }\n        }\n        if (redeclared) {\n            this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n        }\n    };\n    pp$3.checkLocalExport = function(id) {\n        // scope.functions must be empty as Module code is always strict.\n        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n            this.undefinedExports[id.name] = id;\n        }\n    };\n    pp$3.currentScope = function() {\n        return this.scopeStack[this.scopeStack.length - 1];\n    };\n    pp$3.currentVarScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & SCOPE_VAR) {\n                return scope;\n            }\n        }\n    };\n    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n    pp$3.currentThisScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {\n                return scope;\n            }\n        }\n    };\n    var Node = function Node(parser, pos, loc) {\n        this.type = \"\";\n        this.start = pos;\n        this.end = 0;\n        if (parser.options.locations) {\n            this.loc = new SourceLocation(parser, loc);\n        }\n        if (parser.options.directSourceFile) {\n            this.sourceFile = parser.options.directSourceFile;\n        }\n        if (parser.options.ranges) {\n            this.range = [\n                pos,\n                0\n            ];\n        }\n    };\n    // Start an AST node, attaching a start offset.\n    var pp$2 = Parser.prototype;\n    pp$2.startNode = function() {\n        return new Node(this, this.start, this.startLoc);\n    };\n    pp$2.startNodeAt = function(pos, loc) {\n        return new Node(this, pos, loc);\n    };\n    // Finish an AST node, adding `type` and `end` properties.\n    function finishNodeAt(node, type, pos, loc) {\n        node.type = type;\n        node.end = pos;\n        if (this.options.locations) {\n            node.loc.end = loc;\n        }\n        if (this.options.ranges) {\n            node.range[1] = pos;\n        }\n        return node;\n    }\n    pp$2.finishNode = function(node, type) {\n        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n    };\n    // Finish node at given position\n    pp$2.finishNodeAt = function(node, type, pos, loc) {\n        return finishNodeAt.call(this, node, type, pos, loc);\n    };\n    pp$2.copyNode = function(node) {\n        var newNode = new Node(this, node.start, this.startLoc);\n        for(var prop in node){\n            newNode[prop] = node[prop];\n        }\n        return newNode;\n    };\n    // This file contains Unicode properties extracted from the ECMAScript specification.\n    // The lists are extracted like so:\n    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n    // #table-binary-unicode-properties\n    var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n    var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n    var ecma11BinaryProperties = ecma10BinaryProperties;\n    var ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\n    var ecma13BinaryProperties = ecma12BinaryProperties;\n    var ecma14BinaryProperties = ecma13BinaryProperties;\n    var unicodeBinaryProperties = {\n        9: ecma9BinaryProperties,\n        10: ecma10BinaryProperties,\n        11: ecma11BinaryProperties,\n        12: ecma12BinaryProperties,\n        13: ecma13BinaryProperties,\n        14: ecma14BinaryProperties\n    };\n    // #table-binary-unicode-properties-of-strings\n    var ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n    var unicodeBinaryPropertiesOfStrings = {\n        9: \"\",\n        10: \"\",\n        11: \"\",\n        12: \"\",\n        13: \"\",\n        14: ecma14BinaryPropertiesOfStrings\n    };\n    // #table-unicode-general-category-values\n    var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n    // #table-unicode-script-values\n    var ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n    var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n    var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n    var ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\n    var ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\n    var ecma14ScriptValues = ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\n    var unicodeScriptValues = {\n        9: ecma9ScriptValues,\n        10: ecma10ScriptValues,\n        11: ecma11ScriptValues,\n        12: ecma12ScriptValues,\n        13: ecma13ScriptValues,\n        14: ecma14ScriptValues\n    };\n    var data = {};\n    function buildUnicodeData(ecmaVersion) {\n        var d = data[ecmaVersion] = {\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n            nonBinary: {\n                General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n            }\n        };\n        d.nonBinary.Script_Extensions = d.nonBinary.Script;\n        d.nonBinary.gc = d.nonBinary.General_Category;\n        d.nonBinary.sc = d.nonBinary.Script;\n        d.nonBinary.scx = d.nonBinary.Script_Extensions;\n    }\n    for(var i = 0, list = [\n        9,\n        10,\n        11,\n        12,\n        13,\n        14\n    ]; i < list.length; i += 1){\n        var ecmaVersion = list[i];\n        buildUnicodeData(ecmaVersion);\n    }\n    var pp$1 = Parser.prototype;\n    var RegExpValidationState = function RegExpValidationState(parser) {\n        this.parser = parser;\n        this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n        this.source = \"\";\n        this.flags = \"\";\n        this.start = 0;\n        this.switchU = false;\n        this.switchV = false;\n        this.switchN = false;\n        this.pos = 0;\n        this.lastIntValue = 0;\n        this.lastStringValue = \"\";\n        this.lastAssertionIsQuantifiable = false;\n        this.numCapturingParens = 0;\n        this.maxBackReference = 0;\n        this.groupNames = [];\n        this.backReferenceNames = [];\n    };\n    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n        var unicodeSets = flags.indexOf(\"v\") !== -1;\n        var unicode = flags.indexOf(\"u\") !== -1;\n        this.start = start | 0;\n        this.source = pattern + \"\";\n        this.flags = flags;\n        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n            this.switchU = true;\n            this.switchV = true;\n            this.switchN = true;\n        } else {\n            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n            this.switchV = false;\n            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n        }\n    };\n    RegExpValidationState.prototype.raise = function raise(message) {\n        this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n    };\n    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n    RegExpValidationState.prototype.at = function at(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return -1;\n        }\n        var c = s.charCodeAt(i);\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n            return c;\n        }\n        var next = s.charCodeAt(i + 1);\n        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n    };\n    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return l;\n        }\n        var c = s.charCodeAt(i), next;\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n            return i + 1;\n        }\n        return i + 2;\n    };\n    RegExpValidationState.prototype.current = function current(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.nextIndex(this.pos, forceU), forceU);\n    };\n    RegExpValidationState.prototype.advance = function advance(forceU) {\n        if (forceU === void 0) forceU = false;\n        this.pos = this.nextIndex(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.eat = function eat(ch, forceU) {\n        if (forceU === void 0) forceU = false;\n        if (this.current(forceU) === ch) {\n            this.advance(forceU);\n            return true;\n        }\n        return false;\n    };\n    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n        if (forceU === void 0) forceU = false;\n        var pos = this.pos;\n        for(var i = 0, list = chs; i < list.length; i += 1){\n            var ch = list[i];\n            var current = this.at(pos, forceU);\n            if (current === -1 || current !== ch) {\n                return false;\n            }\n            pos = this.nextIndex(pos, forceU);\n        }\n        this.pos = pos;\n        return true;\n    };\n    /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpFlags = function(state) {\n        var validFlags = state.validFlags;\n        var flags = state.flags;\n        var u = false;\n        var v = false;\n        for(var i = 0; i < flags.length; i++){\n            var flag = flags.charAt(i);\n            if (validFlags.indexOf(flag) === -1) {\n                this.raise(state.start, \"Invalid regular expression flag\");\n            }\n            if (flags.indexOf(flag, i + 1) > -1) {\n                this.raise(state.start, \"Duplicate regular expression flag\");\n            }\n            if (flag === \"u\") {\n                u = true;\n            }\n            if (flag === \"v\") {\n                v = true;\n            }\n        }\n        if (this.options.ecmaVersion >= 15 && u && v) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n    };\n    /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpPattern = function(state) {\n        this.regexp_pattern(state);\n        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n        // parsing contains a |GroupName|, reparse with the goal symbol\n        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n        // exception if _P_ did not conform to the grammar, if any elements of _P_\n        // were not matched by the parse, or if any Early Error conditions exist.\n        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n            state.switchN = true;\n            this.regexp_pattern(state);\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n    pp$1.regexp_pattern = function(state) {\n        state.pos = 0;\n        state.lastIntValue = 0;\n        state.lastStringValue = \"\";\n        state.lastAssertionIsQuantifiable = false;\n        state.numCapturingParens = 0;\n        state.maxBackReference = 0;\n        state.groupNames.length = 0;\n        state.backReferenceNames.length = 0;\n        this.regexp_disjunction(state);\n        if (state.pos !== state.source.length) {\n            // Make the same messages as V8.\n            if (state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unmatched ')'\");\n            }\n            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n                state.raise(\"Lone quantifier brackets\");\n            }\n        }\n        if (state.maxBackReference > state.numCapturingParens) {\n            state.raise(\"Invalid escape\");\n        }\n        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n            var name = list[i];\n            if (state.groupNames.indexOf(name) === -1) {\n                state.raise(\"Invalid named capture referenced\");\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n    pp$1.regexp_disjunction = function(state) {\n        this.regexp_alternative(state);\n        while(state.eat(0x7C /* | */ )){\n            this.regexp_alternative(state);\n        }\n        // Make the same message as V8.\n        if (this.regexp_eatQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        if (state.eat(0x7B /* { */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n    pp$1.regexp_alternative = function(state) {\n        while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n    pp$1.regexp_eatTerm = function(state) {\n        if (this.regexp_eatAssertion(state)) {\n            // Handle `QuantifiableAssertion Quantifier` alternative.\n            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n            // is a QuantifiableAssertion.\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n                // Make the same message as V8.\n                if (state.switchU) {\n                    state.raise(\"Invalid quantifier\");\n                }\n            }\n            return true;\n        }\n        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n            this.regexp_eatQuantifier(state);\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n    pp$1.regexp_eatAssertion = function(state) {\n        var start = state.pos;\n        state.lastAssertionIsQuantifiable = false;\n        // ^, $\n        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n            return true;\n        }\n        // \\b \\B\n        if (state.eat(0x5C /* \\ */ )) {\n            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n                return true;\n            }\n            state.pos = start;\n        }\n        // Lookahead / Lookbehind\n        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n            var lookbehind = false;\n            if (this.options.ecmaVersion >= 9) {\n                lookbehind = state.eat(0x3C /* < */ );\n            }\n            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n                this.regexp_disjunction(state);\n                if (!state.eat(0x29 /* ) */ )) {\n                    state.raise(\"Unterminated group\");\n                }\n                state.lastAssertionIsQuantifiable = !lookbehind;\n                return true;\n            }\n        }\n        state.pos = start;\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n    pp$1.regexp_eatQuantifier = function(state, noError) {\n        if (noError === void 0) noError = false;\n        if (this.regexp_eatQuantifierPrefix(state, noError)) {\n            state.eat(0x3F /* ? */ );\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n    };\n    pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n        var start = state.pos;\n        if (state.eat(0x7B /* { */ )) {\n            var min = 0, max = -1;\n            if (this.regexp_eatDecimalDigits(state)) {\n                min = state.lastIntValue;\n                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                    max = state.lastIntValue;\n                }\n                if (state.eat(0x7D /* } */ )) {\n                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                    if (max !== -1 && max < min && !noError) {\n                        state.raise(\"numbers out of order in {} quantifier\");\n                    }\n                    return true;\n                }\n            }\n            if (state.switchU && !noError) {\n                state.raise(\"Incomplete quantifier\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n    pp$1.regexp_eatAtom = function(state) {\n        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n    };\n    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatAtomEscape(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatUncapturingGroup = function(state) {\n        var start = state.pos;\n        if (state.eat(0x28 /* ( */ )) {\n            if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {\n                this.regexp_disjunction(state);\n                if (state.eat(0x29 /* ) */ )) {\n                    return true;\n                }\n                state.raise(\"Unterminated group\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatCapturingGroup = function(state) {\n        if (state.eat(0x28 /* ( */ )) {\n            if (this.options.ecmaVersion >= 9) {\n                this.regexp_groupSpecifier(state);\n            } else if (state.current() === 0x3F /* ? */ ) {\n                state.raise(\"Invalid group\");\n            }\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) {\n                state.numCapturingParens += 1;\n                return true;\n            }\n            state.raise(\"Unterminated group\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n    pp$1.regexp_eatExtendedAtom = function(state) {\n        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n        if (this.regexp_eatBracedQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n    pp$1.regexp_eatSyntaxCharacter = function(state) {\n        var ch = state.current();\n        if (isSyntaxCharacter(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isSyntaxCharacter(ch) {\n        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n    // But eat eager.\n    pp$1.regexp_eatPatternCharacters = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n    pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n        var ch = state.current();\n        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // GroupSpecifier ::\n    //   [empty]\n    //   `?` GroupName\n    pp$1.regexp_groupSpecifier = function(state) {\n        if (state.eat(0x3F /* ? */ )) {\n            if (this.regexp_eatGroupName(state)) {\n                if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n                    state.raise(\"Duplicate capture group name\");\n                }\n                state.groupNames.push(state.lastStringValue);\n                return;\n            }\n            state.raise(\"Invalid group\");\n        }\n    };\n    // GroupName ::\n    //   `<` RegExpIdentifierName `>`\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatGroupName = function(state) {\n        state.lastStringValue = \"\";\n        if (state.eat(0x3C /* < */ )) {\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n                return true;\n            }\n            state.raise(\"Invalid capture group name\");\n        }\n        return false;\n    };\n    // RegExpIdentifierName ::\n    //   RegExpIdentifierStart\n    //   RegExpIdentifierName RegExpIdentifierPart\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatRegExpIdentifierName = function(state) {\n        state.lastStringValue = \"\";\n        if (this.regexp_eatRegExpIdentifierStart(state)) {\n            state.lastStringValue += codePointToString(state.lastIntValue);\n            while(this.regexp_eatRegExpIdentifierPart(state)){\n                state.lastStringValue += codePointToString(state.lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    };\n    // RegExpIdentifierStart ::\n    //   UnicodeIDStart\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierStart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierStart(ch) {\n        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n    }\n    // RegExpIdentifierPart ::\n    //   UnicodeIDContinue\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    //   <ZWNJ>\n    //   <ZWJ>\n    pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierPart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierPart(ch) {\n        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n    pp$1.regexp_eatAtomEscape = function(state) {\n        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            if (state.current() === 0x63 /* c */ ) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        return false;\n    };\n    pp$1.regexp_eatBackReference = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatDecimalEscape(state)) {\n            var n = state.lastIntValue;\n            if (state.switchU) {\n                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n                if (n > state.maxBackReference) {\n                    state.maxBackReference = n;\n                }\n                return true;\n            }\n            if (n <= state.numCapturingParens) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatKGroupName = function(state) {\n        if (state.eat(0x6B /* k */ )) {\n            if (this.regexp_eatGroupName(state)) {\n                state.backReferenceNames.push(state.lastStringValue);\n                return true;\n            }\n            state.raise(\"Invalid named reference\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n    pp$1.regexp_eatCharacterEscape = function(state) {\n        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n    };\n    pp$1.regexp_eatCControlLetter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatZero = function(state) {\n        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n            state.lastIntValue = 0;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n    pp$1.regexp_eatControlEscape = function(state) {\n        var ch = state.current();\n        if (ch === 0x74 /* t */ ) {\n            state.lastIntValue = 0x09; /* \\t */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x6E /* n */ ) {\n            state.lastIntValue = 0x0A; /* \\n */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x76 /* v */ ) {\n            state.lastIntValue = 0x0B; /* \\v */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x66 /* f */ ) {\n            state.lastIntValue = 0x0C; /* \\f */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x72 /* r */ ) {\n            state.lastIntValue = 0x0D; /* \\r */ \n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n    pp$1.regexp_eatControlLetter = function(state) {\n        var ch = state.current();\n        if (isControlLetter(ch)) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isControlLetter(ch) {\n        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n        if (forceU === void 0) forceU = false;\n        var start = state.pos;\n        var switchU = forceU || state.switchU;\n        if (state.eat(0x75 /* u */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\n                var lead = state.lastIntValue;\n                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                    var leadSurrogateEnd = state.pos;\n                    if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                        var trail = state.lastIntValue;\n                        if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                            return true;\n                        }\n                    }\n                    state.pos = leadSurrogateEnd;\n                    state.lastIntValue = lead;\n                }\n                return true;\n            }\n            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n                return true;\n            }\n            if (switchU) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    function isValidUnicode(ch) {\n        return ch >= 0 && ch <= 0x10FFFF;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n    pp$1.regexp_eatIdentityEscape = function(state) {\n        if (state.switchU) {\n            if (this.regexp_eatSyntaxCharacter(state)) {\n                return true;\n            }\n            if (state.eat(0x2F /* / */ )) {\n                state.lastIntValue = 0x2F; /* / */ \n                return true;\n            }\n            return false;\n        }\n        var ch = state.current();\n        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n    pp$1.regexp_eatDecimalEscape = function(state) {\n        state.lastIntValue = 0;\n        var ch = state.current();\n        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n            do {\n                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n                state.advance();\n            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n            return true;\n        }\n        return false;\n    };\n    // Return values used by character set parsing methods, needed to\n    // forbid negation of sets that can match strings.\n    var CharSetNone = 0; // Nothing parsed\n    var CharSetOk = 1; // Construct parsed, cannot contain strings\n    var CharSetString = 2; // Construct parsed, can contain strings\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n    pp$1.regexp_eatCharacterClassEscape = function(state) {\n        var ch = state.current();\n        if (isCharacterClassEscape(ch)) {\n            state.lastIntValue = -1;\n            state.advance();\n            return CharSetOk;\n        }\n        var negate = false;\n        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n            state.lastIntValue = -1;\n            state.advance();\n            var result;\n            if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Invalid property name\");\n                }\n                return result;\n            }\n            state.raise(\"Invalid property name\");\n        }\n        return CharSetNone;\n    };\n    function isCharacterClassEscape(ch) {\n        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n    }\n    // UnicodePropertyValueExpression ::\n    //   UnicodePropertyName `=` UnicodePropertyValue\n    //   LoneUnicodePropertyNameOrValue\n    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n        var start = state.pos;\n        // UnicodePropertyName `=` UnicodePropertyValue\n        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n            var name = state.lastStringValue;\n            if (this.regexp_eatUnicodePropertyValue(state)) {\n                var value = state.lastStringValue;\n                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n                return CharSetOk;\n            }\n        }\n        state.pos = start;\n        // LoneUnicodePropertyNameOrValue\n        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n            var nameOrValue = state.lastStringValue;\n            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n        }\n        return CharSetNone;\n    };\n    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n            state.raise(\"Invalid property name\");\n        }\n        if (!state.unicodeProperties.nonBinary[name].test(value)) {\n            state.raise(\"Invalid property value\");\n        }\n    };\n    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n        if (state.unicodeProperties.binary.test(nameOrValue)) {\n            return CharSetOk;\n        }\n        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n            return CharSetString;\n        }\n        state.raise(\"Invalid property name\");\n    };\n    // UnicodePropertyName ::\n    //   UnicodePropertyNameCharacters\n    pp$1.regexp_eatUnicodePropertyName = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyNameCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyNameCharacter(ch) {\n        return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n    }\n    // UnicodePropertyValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatUnicodePropertyValue = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyValueCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyValueCharacter(ch) {\n        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n    }\n    // LoneUnicodePropertyNameOrValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n        return this.regexp_eatUnicodePropertyValue(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n    pp$1.regexp_eatCharacterClass = function(state) {\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (!state.eat(0x5D /* ] */ )) {\n                state.raise(\"Unterminated character class\");\n            }\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassContents\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n    pp$1.regexp_classContents = function(state) {\n        if (state.current() === 0x5D /* ] */ ) {\n            return CharSetOk;\n        }\n        if (state.switchV) {\n            return this.regexp_classSetExpression(state);\n        }\n        this.regexp_nonEmptyClassRanges(state);\n        return CharSetOk;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n    pp$1.regexp_nonEmptyClassRanges = function(state) {\n        while(this.regexp_eatClassAtom(state)){\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n                var right = state.lastIntValue;\n                if (state.switchU && (left === -1 || right === -1)) {\n                    state.raise(\"Invalid character class\");\n                }\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n    pp$1.regexp_eatClassAtom = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatClassEscape(state)) {\n                return true;\n            }\n            if (state.switchU) {\n                // Make the same message as V8.\n                var ch$1 = state.current();\n                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                    state.raise(\"Invalid class escape\");\n                }\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        var ch = state.current();\n        if (ch !== 0x5D /* ] */ ) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n    pp$1.regexp_eatClassEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        if (state.switchU && state.eat(0x2D /* - */ )) {\n            state.lastIntValue = 0x2D; /* - */ \n            return true;\n        }\n        if (!state.switchU && state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatClassControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetExpression\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    pp$1.regexp_classSetExpression = function(state) {\n        var result = CharSetOk, subResult;\n        if (this.regexp_eatClassSetRange(state)) ;\n        else if (subResult = this.regexp_eatClassSetOperand(state)) {\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n            // https://tc39.es/ecma262/#prod-ClassIntersection\n            var start = state.pos;\n            while(state.eatChars([\n                0x26,\n                0x26\n            ])){\n                if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                    if (subResult !== CharSetString) {\n                        result = CharSetOk;\n                    }\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n            // https://tc39.es/ecma262/#prod-ClassSubtraction\n            while(state.eatChars([\n                0x2D,\n                0x2D\n            ])){\n                if (this.regexp_eatClassSetOperand(state)) {\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n        } else {\n            state.raise(\"Invalid character in character class\");\n        }\n        // https://tc39.es/ecma262/#prod-ClassUnion\n        for(;;){\n            if (this.regexp_eatClassSetRange(state)) {\n                continue;\n            }\n            subResult = this.regexp_eatClassSetOperand(state);\n            if (!subResult) {\n                return result;\n            }\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n        }\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetRange\n    pp$1.regexp_eatClassSetRange = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatClassSetCharacter(state)) {\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n                var right = state.lastIntValue;\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetOperand\n    pp$1.regexp_eatClassSetOperand = function(state) {\n        if (this.regexp_eatClassSetCharacter(state)) {\n            return CharSetOk;\n        }\n        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n    };\n    // https://tc39.es/ecma262/#prod-NestedClass\n    pp$1.regexp_eatNestedClass = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (state.eat(0x5D /* ] */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Negated character class may contain strings\");\n                }\n                return result;\n            }\n            state.pos = start;\n        }\n        if (state.eat(0x5C /* \\ */ )) {\n            var result$1 = this.regexp_eatCharacterClassEscape(state);\n            if (result$1) {\n                return result$1;\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunction\n    pp$1.regexp_eatClassStringDisjunction = function(state) {\n        var start = state.pos;\n        if (state.eatChars([\n            0x5C,\n            0x71\n        ])) {\n            if (state.eat(0x7B /* { */ )) {\n                var result = this.regexp_classStringDisjunctionContents(state);\n                if (state.eat(0x7D /* } */ )) {\n                    return result;\n                }\n            } else {\n                // Make the same message as V8.\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\n    pp$1.regexp_classStringDisjunctionContents = function(state) {\n        var result = this.regexp_classString(state);\n        while(state.eat(0x7C /* | */ )){\n            if (this.regexp_classString(state) === CharSetString) {\n                result = CharSetString;\n            }\n        }\n        return result;\n    };\n    // https://tc39.es/ecma262/#prod-ClassString\n    // https://tc39.es/ecma262/#prod-NonEmptyClassString\n    pp$1.regexp_classString = function(state) {\n        var count = 0;\n        while(this.regexp_eatClassSetCharacter(state)){\n            count++;\n        }\n        return count === 1 ? CharSetOk : CharSetString;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetCharacter\n    pp$1.regexp_eatClassSetCharacter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n                return true;\n            }\n            if (state.eat(0x62 /* b */ )) {\n                state.lastIntValue = 0x08; /* <BS> */ \n                return true;\n            }\n            state.pos = start;\n            return false;\n        }\n        var ch = state.current();\n        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n            return false;\n        }\n        if (isClassSetSyntaxCharacter(ch)) {\n            return false;\n        }\n        state.advance();\n        state.lastIntValue = ch;\n        return true;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\n    function isClassSetReservedDoublePunctuatorCharacter(ch) {\n        return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\n    function isClassSetSyntaxCharacter(ch) {\n        return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n        var ch = state.current();\n        if (isClassSetReservedPunctuator(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    function isClassSetReservedPunctuator(ch) {\n        return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n    pp$1.regexp_eatClassControlLetter = function(state) {\n        var ch = state.current();\n        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatHexEscapeSequence = function(state) {\n        var start = state.pos;\n        if (state.eat(0x78 /* x */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\n                return true;\n            }\n            if (state.switchU) {\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n    pp$1.regexp_eatDecimalDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isDecimalDigit(ch = state.current())){\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isDecimalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n    pp$1.regexp_eatHexDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isHexDigit(ch = state.current())){\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isHexDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n    }\n    function hexToInt(ch) {\n        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n            return 10 + (ch - 0x41 /* A */ );\n        }\n        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n            return 10 + (ch - 0x61 /* a */ );\n        }\n        return ch - 0x30 /* 0 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n    // Allows only 0-377(octal) i.e. 0-255(decimal).\n    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n        if (this.regexp_eatOctalDigit(state)) {\n            var n1 = state.lastIntValue;\n            if (this.regexp_eatOctalDigit(state)) {\n                var n2 = state.lastIntValue;\n                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n                } else {\n                    state.lastIntValue = n1 * 8 + n2;\n                }\n            } else {\n                state.lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n    pp$1.regexp_eatOctalDigit = function(state) {\n        var ch = state.current();\n        if (isOctalDigit(ch)) {\n            state.lastIntValue = ch - 0x30; /* 0 */ \n            state.advance();\n            return true;\n        }\n        state.lastIntValue = 0;\n        return false;\n    };\n    function isOctalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatFixedHexDigits = function(state, length) {\n        var start = state.pos;\n        state.lastIntValue = 0;\n        for(var i = 0; i < length; ++i){\n            var ch = state.current();\n            if (!isHexDigit(ch)) {\n                state.pos = start;\n                return false;\n            }\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return true;\n    };\n    // Object type used to represent tokens. Note that normally, tokens\n    // simply exist as properties on the parser object. This is only\n    // used for the onToken callback and the external tokenizer.\n    var Token = function Token(p) {\n        this.type = p.type;\n        this.value = p.value;\n        this.start = p.start;\n        this.end = p.end;\n        if (p.options.locations) {\n            this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n        }\n        if (p.options.ranges) {\n            this.range = [\n                p.start,\n                p.end\n            ];\n        }\n    };\n    // ## Tokenizer\n    var pp = Parser.prototype;\n    // Move to the next token\n    pp.next = function(ignoreEscapeSequenceInKeyword) {\n        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n        }\n        if (this.options.onToken) {\n            this.options.onToken(new Token(this));\n        }\n        this.lastTokEnd = this.end;\n        this.lastTokStart = this.start;\n        this.lastTokEndLoc = this.endLoc;\n        this.lastTokStartLoc = this.startLoc;\n        this.nextToken();\n    };\n    pp.getToken = function() {\n        this.next();\n        return new Token(this);\n    };\n    // If we're in an ES6 environment, make parsers iterable\n    if (typeof Symbol !== \"undefined\") {\n        pp[Symbol.iterator] = function() {\n            var this$1$1 = this;\n            return {\n                next: function() {\n                    var token = this$1$1.getToken();\n                    return {\n                        done: token.type === types$1.eof,\n                        value: token\n                    };\n                }\n            };\n        };\n    }\n    // Toggle strict mode. Re-reads the next number or string to please\n    // pedantic tests (`\"use strict\"; 010;` should fail).\n    // Read a single token, updating the parser object's token-related\n    // properties.\n    pp.nextToken = function() {\n        var curContext = this.curContext();\n        if (!curContext || !curContext.preserveSpace) {\n            this.skipSpace();\n        }\n        this.start = this.pos;\n        if (this.options.locations) {\n            this.startLoc = this.curPosition();\n        }\n        if (this.pos >= this.input.length) {\n            return this.finishToken(types$1.eof);\n        }\n        if (curContext.override) {\n            return curContext.override(this);\n        } else {\n            this.readToken(this.fullCharCodeAtPos());\n        }\n    };\n    pp.readToken = function(code) {\n        // Identifier or keyword. '\\uXXXX' sequences are allowed in\n        // identifiers, so '\\' also dispatches to that.\n        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n            return this.readWord();\n        }\n        return this.getTokenFromCode(code);\n    };\n    pp.fullCharCodeAtPos = function() {\n        var code = this.input.charCodeAt(this.pos);\n        if (code <= 0xd7ff || code >= 0xdc00) {\n            return code;\n        }\n        var next = this.input.charCodeAt(this.pos + 1);\n        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n    };\n    pp.skipBlockComment = function() {\n        var startLoc = this.options.onComment && this.curPosition();\n        var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n        if (end === -1) {\n            this.raise(this.pos - 2, \"Unterminated comment\");\n        }\n        this.pos = end + 2;\n        if (this.options.locations) {\n            for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n                ++this.curLine;\n                pos = this.lineStart = nextBreak;\n            }\n        }\n        if (this.options.onComment) {\n            this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    pp.skipLineComment = function(startSkip) {\n        var start = this.pos;\n        var startLoc = this.options.onComment && this.curPosition();\n        var ch = this.input.charCodeAt(this.pos += startSkip);\n        while(this.pos < this.input.length && !isNewLine(ch)){\n            ch = this.input.charCodeAt(++this.pos);\n        }\n        if (this.options.onComment) {\n            this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    // Called at the start of the parse and after every token. Skips\n    // whitespace and comments, and.\n    pp.skipSpace = function() {\n        loop: while(this.pos < this.input.length){\n            var ch = this.input.charCodeAt(this.pos);\n            switch(ch){\n                case 32:\n                case 160:\n                    ++this.pos;\n                    break;\n                case 13:\n                    if (this.input.charCodeAt(this.pos + 1) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                case 8232:\n                case 8233:\n                    ++this.pos;\n                    if (this.options.locations) {\n                        ++this.curLine;\n                        this.lineStart = this.pos;\n                    }\n                    break;\n                case 47:\n                    switch(this.input.charCodeAt(this.pos + 1)){\n                        case 42:\n                            this.skipBlockComment();\n                            break;\n                        case 47:\n                            this.skipLineComment(2);\n                            break;\n                        default:\n                            break loop;\n                    }\n                    break;\n                default:\n                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                        ++this.pos;\n                    } else {\n                        break loop;\n                    }\n            }\n        }\n    };\n    // Called at the end of every token. Sets `end`, `val`, and\n    // maintains `context` and `exprAllowed`, and skips the space after\n    // the token, so that the next one's `start` will point at the\n    // right position.\n    pp.finishToken = function(type, val) {\n        this.end = this.pos;\n        if (this.options.locations) {\n            this.endLoc = this.curPosition();\n        }\n        var prevType = this.type;\n        this.type = type;\n        this.value = val;\n        this.updateContext(prevType);\n    };\n    // ### Token reading\n    // This is the function that is called to fetch the next token. It\n    // is somewhat obscure, because it works in character codes rather\n    // than characters, and because operator parsing has been inlined\n    // into it.\n    //\n    // All in the name of speed.\n    //\n    pp.readToken_dot = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next >= 48 && next <= 57) {\n            return this.readNumber(true);\n        }\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n            this.pos += 3;\n            return this.finishToken(types$1.ellipsis);\n        } else {\n            ++this.pos;\n            return this.finishToken(types$1.dot);\n        }\n    };\n    pp.readToken_slash = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (this.exprAllowed) {\n            ++this.pos;\n            return this.readRegexp();\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.slash, 1);\n    };\n    pp.readToken_mult_modulo_exp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        var tokentype = code === 42 ? types$1.star : types$1.modulo;\n        // exponentiation operator ** and **=\n        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n            ++size;\n            tokentype = types$1.starstar;\n            next = this.input.charCodeAt(this.pos + 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(tokentype, size);\n    };\n    pp.readToken_pipe_amp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (this.options.ecmaVersion >= 12) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n    };\n    pp.readToken_caret = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.bitwiseXOR, 1);\n    };\n    pp.readToken_plus_min = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n                // A `-->` line comment\n                this.skipLineComment(3);\n                this.skipSpace();\n                return this.nextToken();\n            }\n            return this.finishOp(types$1.incDec, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.plusMin, 1);\n    };\n    pp.readToken_lt_gt = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        if (next === code) {\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n            if (this.input.charCodeAt(this.pos + size) === 61) {\n                return this.finishOp(types$1.assign, size + 1);\n            }\n            return this.finishOp(types$1.bitShift, size);\n        }\n        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n            // `<!--`, an XML-style comment that should be interpreted as a line comment\n            this.skipLineComment(4);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        if (next === 61) {\n            size = 2;\n        }\n        return this.finishOp(types$1.relational, size);\n    };\n    pp.readToken_eq_excl = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n        }\n        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n            this.pos += 2;\n            return this.finishToken(types$1.arrow);\n        }\n        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n    };\n    pp.readToken_question = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        if (ecmaVersion >= 11) {\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 46) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 < 48 || next2 > 57) {\n                    return this.finishOp(types$1.questionDot, 2);\n                }\n            }\n            if (next === 63) {\n                if (ecmaVersion >= 12) {\n                    var next2$1 = this.input.charCodeAt(this.pos + 2);\n                    if (next2$1 === 61) {\n                        return this.finishOp(types$1.assign, 3);\n                    }\n                }\n                return this.finishOp(types$1.coalesce, 2);\n            }\n        }\n        return this.finishOp(types$1.question, 1);\n    };\n    pp.readToken_numberSign = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        var code = 35; // '#'\n        if (ecmaVersion >= 13) {\n            ++this.pos;\n            code = this.fullCharCodeAtPos();\n            if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n                return this.finishToken(types$1.privateId, this.readWord1());\n            }\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.getTokenFromCode = function(code) {\n        switch(code){\n            // The interpretation of a dot depends on whether it is followed\n            // by a digit or another two dots.\n            case 46:\n                return this.readToken_dot();\n            // Punctuation tokens.\n            case 40:\n                ++this.pos;\n                return this.finishToken(types$1.parenL);\n            case 41:\n                ++this.pos;\n                return this.finishToken(types$1.parenR);\n            case 59:\n                ++this.pos;\n                return this.finishToken(types$1.semi);\n            case 44:\n                ++this.pos;\n                return this.finishToken(types$1.comma);\n            case 91:\n                ++this.pos;\n                return this.finishToken(types$1.bracketL);\n            case 93:\n                ++this.pos;\n                return this.finishToken(types$1.bracketR);\n            case 123:\n                ++this.pos;\n                return this.finishToken(types$1.braceL);\n            case 125:\n                ++this.pos;\n                return this.finishToken(types$1.braceR);\n            case 58:\n                ++this.pos;\n                return this.finishToken(types$1.colon);\n            case 96:\n                if (this.options.ecmaVersion < 6) {\n                    break;\n                }\n                ++this.pos;\n                return this.finishToken(types$1.backQuote);\n            case 48:\n                var next = this.input.charCodeAt(this.pos + 1);\n                if (next === 120 || next === 88) {\n                    return this.readRadixNumber(16);\n                } // '0x', '0X' - hex number\n                if (this.options.ecmaVersion >= 6) {\n                    if (next === 111 || next === 79) {\n                        return this.readRadixNumber(8);\n                    } // '0o', '0O' - octal number\n                    if (next === 98 || next === 66) {\n                        return this.readRadixNumber(2);\n                    } // '0b', '0B' - binary number\n                }\n            // Anything else beginning with a digit is an integer, octal\n            // number, or float.\n            case 49:\n            case 50:\n            case 51:\n            case 52:\n            case 53:\n            case 54:\n            case 55:\n            case 56:\n            case 57:\n                return this.readNumber(false);\n            // Quotes produce strings.\n            case 34:\n            case 39:\n                return this.readString(code);\n            // Operators are parsed inline in tiny state machines. '=' (61) is\n            // often referred to. `finishOp` simply skips the amount of\n            // characters it is given as second argument, and returns a token\n            // of the type given by its first argument.\n            case 47:\n                return this.readToken_slash();\n            case 37:\n            case 42:\n                return this.readToken_mult_modulo_exp(code);\n            case 124:\n            case 38:\n                return this.readToken_pipe_amp(code);\n            case 94:\n                return this.readToken_caret();\n            case 43:\n            case 45:\n                return this.readToken_plus_min(code);\n            case 60:\n            case 62:\n                return this.readToken_lt_gt(code);\n            case 61:\n            case 33:\n                return this.readToken_eq_excl(code);\n            case 63:\n                return this.readToken_question();\n            case 126:\n                return this.finishOp(types$1.prefix, 1);\n            case 35:\n                return this.readToken_numberSign();\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.finishOp = function(type, size) {\n        var str = this.input.slice(this.pos, this.pos + size);\n        this.pos += size;\n        return this.finishToken(type, str);\n    };\n    pp.readRegexp = function() {\n        var escaped, inClass, start = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            var ch = this.input.charAt(this.pos);\n            if (lineBreak.test(ch)) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            if (!escaped) {\n                if (ch === \"[\") {\n                    inClass = true;\n                } else if (ch === \"]\" && inClass) {\n                    inClass = false;\n                } else if (ch === \"/\" && !inClass) {\n                    break;\n                }\n                escaped = ch === \"\\\\\";\n            } else {\n                escaped = false;\n            }\n            ++this.pos;\n        }\n        var pattern = this.input.slice(start, this.pos);\n        ++this.pos;\n        var flagsStart = this.pos;\n        var flags = this.readWord1();\n        if (this.containsEsc) {\n            this.unexpected(flagsStart);\n        }\n        // Validate pattern\n        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n        state.reset(start, pattern, flags);\n        this.validateRegExpFlags(state);\n        this.validateRegExpPattern(state);\n        // Create Literal#value property value.\n        var value = null;\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n        // ESTree requires null if it failed to instantiate RegExp object.\n        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n        }\n        return this.finishToken(types$1.regexp, {\n            pattern: pattern,\n            flags: flags,\n            value: value\n        });\n    };\n    // Read an integer in the given radix. Return null if zero digits\n    // were read, the integer value otherwise. When `len` is given, this\n    // will return `null` unless the integer has exactly `len` digits.\n    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n        // `len` is used for character escape sequences. In that case, disallow separators.\n        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n        // and isn't fraction part nor exponent part. In that case, if the first digit\n        // is zero then disallow separators.\n        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n        var start = this.pos, total = 0, lastCode = 0;\n        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n            var code = this.input.charCodeAt(this.pos), val = void 0;\n            if (allowSeparators && code === 95) {\n                if (isLegacyOctalNumericLiteral) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n                }\n                if (lastCode === 95) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n                }\n                if (i === 0) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n                }\n                lastCode = code;\n                continue;\n            }\n            if (code >= 97) {\n                val = code - 97 + 10;\n            } else if (code >= 65) {\n                val = code - 65 + 10;\n            } else if (code >= 48 && code <= 57) {\n                val = code - 48;\n            } else {\n                val = Infinity;\n            }\n            if (val >= radix) {\n                break;\n            }\n            lastCode = code;\n            total = total * radix + val;\n        }\n        if (allowSeparators && lastCode === 95) {\n            this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n        }\n        if (this.pos === start || len != null && this.pos - start !== len) {\n            return null;\n        }\n        return total;\n    };\n    function stringToNumber(str, isLegacyOctalNumericLiteral) {\n        if (isLegacyOctalNumericLiteral) {\n            return parseInt(str, 8);\n        }\n        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n        return parseFloat(str.replace(/_/g, \"\"));\n    }\n    function stringToBigInt(str) {\n        if (typeof BigInt !== \"function\") {\n            return null;\n        }\n        // `BigInt(value)` throws syntax error if the string contains numeric separators.\n        return BigInt(str.replace(/_/g, \"\"));\n    }\n    pp.readRadixNumber = function(radix) {\n        var start = this.pos;\n        this.pos += 2; // 0x\n        var val = this.readInt(radix);\n        if (val == null) {\n            this.raise(this.start + 2, \"Expected number in radix \" + radix);\n        }\n        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n            val = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val);\n    };\n    // Read an integer, octal integer, or floating-point number.\n    pp.readNumber = function(startsWithDot) {\n        var start = this.pos;\n        if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n        if (octal && this.strict) {\n            this.raise(start, \"Invalid number\");\n        }\n        var next = this.input.charCodeAt(this.pos);\n        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n            var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n            if (isIdentifierStart(this.fullCharCodeAtPos())) {\n                this.raise(this.pos, \"Identifier directly after number\");\n            }\n            return this.finishToken(types$1.num, val$1);\n        }\n        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n            octal = false;\n        }\n        if (next === 46 && !octal) {\n            ++this.pos;\n            this.readInt(10);\n            next = this.input.charCodeAt(this.pos);\n        }\n        if ((next === 69 || next === 101) && !octal) {\n            next = this.input.charCodeAt(++this.pos);\n            if (next === 43 || next === 45) {\n                ++this.pos;\n            } // '+-'\n            if (this.readInt(10) === null) {\n                this.raise(start, \"Invalid number\");\n            }\n        }\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        var val = stringToNumber(this.input.slice(start, this.pos), octal);\n        return this.finishToken(types$1.num, val);\n    };\n    // Read a string value, interpreting backslash-escapes.\n    pp.readCodePoint = function() {\n        var ch = this.input.charCodeAt(this.pos), code;\n        if (ch === 123) {\n            if (this.options.ecmaVersion < 6) {\n                this.unexpected();\n            }\n            var codePos = ++this.pos;\n            code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n            ++this.pos;\n            if (code > 0x10FFFF) {\n                this.invalidStringToken(codePos, \"Code point out of bounds\");\n            }\n        } else {\n            code = this.readHexChar(4);\n        }\n        return code;\n    };\n    pp.readString = function(quote) {\n        var out = \"\", chunkStart = ++this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === quote) {\n                break;\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(false);\n                chunkStart = this.pos;\n            } else if (ch === 0x2028 || ch === 0x2029) {\n                if (this.options.ecmaVersion < 10) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n                if (this.options.locations) {\n                    this.curLine++;\n                    this.lineStart = this.pos;\n                }\n            } else {\n                if (isNewLine(ch)) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n            }\n        }\n        out += this.input.slice(chunkStart, this.pos++);\n        return this.finishToken(types$1.string, out);\n    };\n    // Reads template string tokens.\n    var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n    pp.tryReadTemplateToken = function() {\n        this.inTemplateElement = true;\n        try {\n            this.readTmplToken();\n        } catch (err) {\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n                this.readInvalidTemplateToken();\n            } else {\n                throw err;\n            }\n        }\n        this.inTemplateElement = false;\n    };\n    pp.invalidStringToken = function(position, message) {\n        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n            throw INVALID_TEMPLATE_ESCAPE_ERROR;\n        } else {\n            this.raise(position, message);\n        }\n    };\n    pp.readTmplToken = function() {\n        var out = \"\", chunkStart = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated template\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                    if (ch === 36) {\n                        this.pos += 2;\n                        return this.finishToken(types$1.dollarBraceL);\n                    } else {\n                        ++this.pos;\n                        return this.finishToken(types$1.backQuote);\n                    }\n                }\n                out += this.input.slice(chunkStart, this.pos);\n                return this.finishToken(types$1.template, out);\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(true);\n                chunkStart = this.pos;\n            } else if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.pos);\n                ++this.pos;\n                switch(ch){\n                    case 13:\n                        if (this.input.charCodeAt(this.pos) === 10) {\n                            ++this.pos;\n                        }\n                    case 10:\n                        out += \"\\n\";\n                        break;\n                    default:\n                        out += String.fromCharCode(ch);\n                        break;\n                }\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                chunkStart = this.pos;\n            } else {\n                ++this.pos;\n            }\n        }\n    };\n    // Reads a template token to search for the end, without validating any escape sequences\n    pp.readInvalidTemplateToken = function() {\n        for(; this.pos < this.input.length; this.pos++){\n            switch(this.input[this.pos]){\n                case \"\\\\\":\n                    ++this.pos;\n                    break;\n                case \"$\":\n                    if (this.input[this.pos + 1] !== \"{\") {\n                        break;\n                    }\n                // falls through\n                case \"`\":\n                    return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n            }\n        }\n        this.raise(this.start, \"Unterminated template\");\n    };\n    // Used to read escaped characters\n    pp.readEscapedChar = function(inTemplate) {\n        var ch = this.input.charCodeAt(++this.pos);\n        ++this.pos;\n        switch(ch){\n            case 110:\n                return \"\\n\" // 'n' -> '\\n'\n                ;\n            case 114:\n                return \"\\r\" // 'r' -> '\\r'\n                ;\n            case 120:\n                return String.fromCharCode(this.readHexChar(2)) // 'x'\n                ;\n            case 117:\n                return codePointToString(this.readCodePoint()) // 'u'\n                ;\n            case 116:\n                return \"\t\" // 't' -> '\\t'\n                ;\n            case 98:\n                return \"\\b\" // 'b' -> '\\b'\n                ;\n            case 118:\n                return \"\\v\" // 'v' -> '\\u000b'\n                ;\n            case 102:\n                return \"\\f\" // 'f' -> '\\f'\n                ;\n            case 13:\n                if (this.input.charCodeAt(this.pos) === 10) {\n                    ++this.pos;\n                } // '\\r\\n'\n            case 10:\n                if (this.options.locations) {\n                    this.lineStart = this.pos;\n                    ++this.curLine;\n                }\n                return \"\";\n            case 56:\n            case 57:\n                if (this.strict) {\n                    this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n                }\n                if (inTemplate) {\n                    var codePos = this.pos - 1;\n                    this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n                }\n            default:\n                if (ch >= 48 && ch <= 55) {\n                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                    var octal = parseInt(octalStr, 8);\n                    if (octal > 255) {\n                        octalStr = octalStr.slice(0, -1);\n                        octal = parseInt(octalStr, 8);\n                    }\n                    this.pos += octalStr.length - 1;\n                    ch = this.input.charCodeAt(this.pos);\n                    if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                        this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                    }\n                    return String.fromCharCode(octal);\n                }\n                if (isNewLine(ch)) {\n                    // Unicode new line characters after \\ get removed from output in both\n                    // template literals and strings\n                    return \"\";\n                }\n                return String.fromCharCode(ch);\n        }\n    };\n    // Used to read character escape sequences ('\\x', '\\u', '\\U').\n    pp.readHexChar = function(len) {\n        var codePos = this.pos;\n        var n = this.readInt(16, len);\n        if (n === null) {\n            this.invalidStringToken(codePos, \"Bad character escape sequence\");\n        }\n        return n;\n    };\n    // Read an identifier, and return it as a string. Sets `this.containsEsc`\n    // to whether the word contained a '\\u' escape.\n    //\n    // Incrementally adds only escaped chars, adding other chunks as-is\n    // as a micro-optimization.\n    pp.readWord1 = function() {\n        this.containsEsc = false;\n        var word = \"\", first = true, chunkStart = this.pos;\n        var astral = this.options.ecmaVersion >= 6;\n        while(this.pos < this.input.length){\n            var ch = this.fullCharCodeAtPos();\n            if (isIdentifierChar(ch, astral)) {\n                this.pos += ch <= 0xffff ? 1 : 2;\n            } else if (ch === 92) {\n                this.containsEsc = true;\n                word += this.input.slice(chunkStart, this.pos);\n                var escStart = this.pos;\n                if (this.input.charCodeAt(++this.pos) !== 117) {\n                    this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n                }\n                ++this.pos;\n                var esc = this.readCodePoint();\n                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                    this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n                }\n                word += codePointToString(esc);\n                chunkStart = this.pos;\n            } else {\n                break;\n            }\n            first = false;\n        }\n        return word + this.input.slice(chunkStart, this.pos);\n    };\n    // Read an identifier or keyword token. Will check for reserved\n    // words when necessary.\n    pp.readWord = function() {\n        var word = this.readWord1();\n        var type = types$1.name;\n        if (this.keywords.test(word)) {\n            type = keywords[word];\n        }\n        return this.finishToken(type, word);\n    };\n    // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n    //\n    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n    // various contributors and released under an MIT license.\n    //\n    // Git repositories for Acorn are available at\n    //\n    //     http://marijnhaverbeke.nl/git/acorn\n    //     https://github.com/acornjs/acorn.git\n    //\n    // Please use the [github bug tracker][ghbt] to report issues.\n    //\n    // [ghbt]: https://github.com/acornjs/acorn/issues\n    //\n    // [walk]: util/walk.js\n    var version = \"8.11.2\";\n    Parser.acorn = {\n        Parser: Parser,\n        version: version,\n        defaultOptions: defaultOptions,\n        Position: Position,\n        SourceLocation: SourceLocation,\n        getLineInfo: getLineInfo,\n        Node: Node,\n        TokenType: TokenType,\n        tokTypes: types$1,\n        keywordTypes: keywords,\n        TokContext: TokContext,\n        tokContexts: types,\n        isIdentifierChar: isIdentifierChar,\n        isIdentifierStart: isIdentifierStart,\n        Token: Token,\n        isNewLine: isNewLine,\n        lineBreak: lineBreak,\n        lineBreakG: lineBreakG,\n        nonASCIIwhitespace: nonASCIIwhitespace\n    };\n    // The main exported interface (under `self.acorn` when in the\n    // browser) is a `parse` function that takes a code string and\n    // returns an abstract syntax tree as specified by [Mozilla parser\n    // API][api].\n    //\n    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n    function parse(input, options) {\n        return Parser.parse(input, options);\n    }\n    // This function tries to parse a single expression at a given\n    // offset in a string. Useful for parsing mixed-language formats\n    // that embed JavaScript expressions.\n    function parseExpressionAt(input, pos, options) {\n        return Parser.parseExpressionAt(input, pos, options);\n    }\n    // Acorn is organized as a tokenizer and a recursive-descent parser.\n    // The `tokenizer` export provides an interface to the tokenizer.\n    function tokenizer(input, options) {\n        return Parser.tokenizer(input, options);\n    }\n    exports1.Node = Node;\n    exports1.Parser = Parser;\n    exports1.Position = Position;\n    exports1.SourceLocation = SourceLocation;\n    exports1.TokContext = TokContext;\n    exports1.Token = Token;\n    exports1.TokenType = TokenType;\n    exports1.defaultOptions = defaultOptions;\n    exports1.getLineInfo = getLineInfo;\n    exports1.isIdentifierChar = isIdentifierChar;\n    exports1.isIdentifierStart = isIdentifierStart;\n    exports1.isNewLine = isNewLine;\n    exports1.keywordTypes = keywords;\n    exports1.lineBreak = lineBreak;\n    exports1.lineBreakG = lineBreakG;\n    exports1.nonASCIIwhitespace = nonASCIIwhitespace;\n    exports1.parse = parse;\n    exports1.parseExpressionAt = parseExpressionAt;\n    exports1.tokContexts = types;\n    exports1.tokTypes = types$1;\n    exports1.tokenizer = tokenizer;\n    exports1.version = version;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDcUc7QUFDdkcsR0FBRyxJQUFJLEVBQUcsU0FBVUEsUUFBTztJQUFJO0lBRTdCLG1EQUFtRDtJQUNuRCxJQUFJTyx3QkFBd0I7UUFBQztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFLO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFNO1FBQUc7UUFBRztRQUFJO1FBQU87UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFPO1FBQUc7UUFBTTtRQUFJO1FBQUc7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBRztRQUFNO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFNO1FBQUc7UUFBUTtLQUFJO0lBRTVoQyxtREFBbUQ7SUFDbkQsSUFBSUMsNkJBQTZCO1FBQUM7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSztRQUFHO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQU07UUFBSTtRQUFJO1FBQU07UUFBSTtRQUFHO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFHO1FBQU07UUFBSTtRQUFHO1FBQU07UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFLO1FBQU07UUFBSztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFNO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFNO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFPO1FBQUk7UUFBTTtRQUFHO1FBQUs7UUFBRztRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFHO0tBQUs7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QUFTLEdBQUdBO0lBQ3BCaEMsU0FBUXdLLGNBQWMsR0FBR0E7SUFDekJ4SyxTQUFRb0ssV0FBVyxHQUFHQTtJQUN0QnBLLFNBQVErQixnQkFBZ0IsR0FBR0E7SUFDM0IvQixTQUFRMEIsaUJBQWlCLEdBQUdBO0lBQzVCMUIsU0FBUWdJLFNBQVMsR0FBR0E7SUFDcEJoSSxTQUFRNjVCLFlBQVksR0FBRy8yQjtJQUN2QjlDLFNBQVE2SCxTQUFTLEdBQUdBO0lBQ3BCN0gsU0FBUThILFVBQVUsR0FBR0E7SUFDckI5SCxTQUFRc0ksa0JBQWtCLEdBQUdBO0lBQzdCdEksU0FBUStRLEtBQUssR0FBR0E7SUFDaEIvUSxTQUFRaVMsaUJBQWlCLEdBQUdBO0lBQzVCalMsU0FBUTg1QixXQUFXLEdBQUcxWDtJQUN0QnBpQixTQUFRNDVCLFFBQVEsR0FBRzMyQjtJQUNuQmpELFNBQVFvUyxTQUFTLEdBQUdBO0lBQ3BCcFMsU0FBUTI1QixPQUFPLEdBQUdBO0FBRXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXB0LXczLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4uanM/ODZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmFjb3JuID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDM3MCwgMSwgODEsIDIsIDcxLCAxMCwgNTAsIDMsIDEyMywgMiwgNTQsIDE0LCAzMiwgMTAsIDMsIDEsIDExLCAzLCA0NiwgMTAsIDgsIDAsIDQ2LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAzLCAwLCAxNTgsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDQwNiwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTAsIDEsIDIsIDAsIDQ5LCA2LCA0LCA0LCAxNCwgOSwgNTM1MSwgMCwgNywgMTQsIDEzODM1LCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgMTAxNCwgMCwgMiwgNTQsIDgsIDMsIDgyLCAwLCAxMiwgMSwgMTk2MjgsIDEsIDQ3MDYsIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCA5ODMsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuXG4gIC8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkLiBEbyBub3QgbW9kaWZ5IG1hbnVhbGx5IVxuICB2YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwgMTEsIDIsIDI1LCAyLCAxOCwgMiwgMSwgMiwgMTQsIDMsIDEzLCAzNSwgMTIyLCA3MCwgNTIsIDI2OCwgMjgsIDQsIDQ4LCA0OCwgMzEsIDE0LCAyOSwgNiwgMzcsIDExLCAyOSwgMywgMzUsIDUsIDcsIDIsIDQsIDQzLCAxNTcsIDE5LCAzNSwgNSwgMzUsIDUsIDM5LCA5LCA1MSwgMTMsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgMiwgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCA2OCwgMzEwLCAxMCwgMjEsIDExLCA3LCAyNSwgNSwgMiwgNDEsIDIsIDgsIDcwLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzNDksIDQxLCA3LCAxLCA3OSwgMjgsIDExLCAwLCA5LCAyMSwgNDMsIDE3LCA0NywgMjAsIDI4LCAyMiwgMTMsIDUyLCA1OCwgMSwgMywgMCwgMTQsIDQ0LCAzMywgMjQsIDI3LCAzNSwgMzAsIDAsIDMsIDAsIDksIDM0LCA0LCAwLCAxMywgNDcsIDE1LCAzLCAyMiwgMCwgMiwgMCwgMzYsIDE3LCAyLCAyNCwgMjAsIDEsIDY0LCA2LCAyLCAwLCAyLCAzLCAyLCAxNCwgMiwgOSwgOCwgNDYsIDM5LCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgNCwgMCwgMTksIDAsIDEzLCA0LCAxNTksIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyNjQsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMzI4LCAxOCwgMTYsIDAsIDIsIDEyLCAyLCAzMywgMTI1LCAwLCA4MCwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjYzNywgOTYsIDE2LCAxMDcxLCAxOCwgNSwgNDAyNiwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxOCwgNzgsIDE4LCAyOSwgMTksIDQ3LCAxNywgMywgMzIsIDIwLCA2LCAxOCwgNjg5LCA2MywgMTI5LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMjksIDYxMzUsIDksIDEyMzcsIDQzLCA4LCA4OTM2LCAzLCAyLCA2LCAyLCAxLCAyLCAyOTAsIDE2LCAwLCAzMCwgMiwgMywgMCwgMTUsIDMsIDksIDM5NSwgMjMwOSwgMTA2LCA2LCAxMiwgNCwgOCwgOCwgOSwgNTk5MSwgODQsIDIsIDcwLCAyLCAxLCAzLCAwLCAzLCAxLCAzLCAzLCAyLCAxMSwgMiwgMCwgMiwgNiwgMiwgNjQsIDIsIDMsIDMsIDcsIDIsIDYsIDIsIDI3LCAyLCAzLCAyLCA0LCAyLCAwLCA0LCA2LCAyLCAzMzksIDMsIDI0LCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCA3LCAxODQ1LCAzMCwgNywgNSwgMjYyLCA2MSwgMTQ3LCA0NCwgMTEsIDYsIDE3LCAwLCAzMjIsIDI5LCAxOSwgNDMsIDQ4NSwgMjcsIDc1NywgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQxNTMsIDcsIDIyMSwgMywgNTc2MSwgMTUsIDc0NzIsIDE2LCA2MjEsIDI0NjcsIDU0MSwgMTUwNywgNDkzOCwgNiwgNDE5MV07XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4OTgtXFx1MDg5ZlxcdTA4Y2EtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NS1cXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2NcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwY2YzXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgxLVxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2VcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE1XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODBmLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWFiZi1cXHUxYWNlXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHUzMGZiXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODJjXFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcXHVmZjY1XCI7XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2FcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZDlcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5cbiAgLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gIC8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbiAgLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuICAvLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuXG5cbiAgLy8gUmVzZXJ2ZWQgd29yZCBsaXN0cyBmb3IgdmFyaW91cyBkaWFsZWN0cyBvZiB0aGUgbGFuZ3VhZ2VcblxuICB2YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogXCJlbnVtXCIsXG4gICAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbiAgfTtcblxuICAvLyBBbmQgdGhlIGtleXdvcmRzXG5cbiAgdmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxuICB2YXIga2V5d29yZHMkMSA9IHtcbiAgICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgICBcIjVtb2R1bGVcIjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxuICB9O1xuXG4gIHZhciBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL15pbihzdGFuY2VvZik/JC87XG5cbiAgLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuICAvLyBhc3N1bXB0aW9uIGlzIHRoYXQgbG9va2luZyB1cCBhc3RyYWwgaWRlbnRpZmllciBjaGFyYWN0ZXJzIGlzXG4gIC8vIHJhcmUuXG4gIGZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gICAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHBvcyArPSBzZXRbaV07XG4gICAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgNTgpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2RlcylcbiAgfVxuXG4gIC8vICMjIFRva2VuIHR5cGVzXG5cbiAgLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbiAgLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4gIC8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4gIC8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuICAvLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuICAvLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuICAvLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4gIC8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4gIC8vXG4gIC8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4gIC8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbiAgLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbiAgLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4gIC8vXG4gIC8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuICAvLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuICAvLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG4gIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbiAgfVxuICB2YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuICAvLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxuICB2YXIga2V5d29yZHMgPSB7fTtcblxuICAvLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG4gIGZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgcmV0dXJuIGtleXdvcmRzW25hbWVdID0gbmV3IFRva2VuVHlwZShuYW1lLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIHR5cGVzJDEgPSB7XG4gICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgcHJpdmF0ZUlkOiBuZXcgVG9rZW5UeXBlKFwicHJpdmF0ZUlkXCIsIHN0YXJ0c0V4cHIpLFxuICAgIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAgIC8vIFB1bmN0dWF0aW9uIHRva2VuIHR5cGVzLlxuICAgIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgICBicmFjZUw6IG5ldyBUb2tlblR5cGUoXCJ7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gICAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gICAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICAgIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gICAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICAgIHF1ZXN0aW9uRG90OiBuZXcgVG9rZW5UeXBlKFwiPy5cIiksXG4gICAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICAgIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICAgIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cbiAgICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAgIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgICAvL1xuICAgIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAgIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAgIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAgIC8vXG4gICAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICAgIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gICAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gICAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICAgIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gICAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gICAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICAgIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gICAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgY29hbGVzY2U6IGJpbm9wKFwiPz9cIiwgMSksXG5cbiAgICAvLyBLZXl3b3JkIHRva2VuIHR5cGVzLlxuICAgIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gICAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICAgIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gICAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gICAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgICBfaWY6IGt3KFwiaWZcIiksXG4gICAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gICAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gICAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICAgIF90cnk6IGt3KFwidHJ5XCIpLFxuICAgIF92YXI6IGt3KFwidmFyXCIpLFxuICAgIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF93aXRoOiBrdyhcIndpdGhcIiksXG4gICAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gICAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gICAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbiAgfTtcblxuICAvLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4gIC8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbiAgdmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCBjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0TGluZUJyZWFrKGNvZGUsIGZyb20sIGVuZCkge1xuICAgIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBjb2RlLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gY29kZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGlzTmV3TGluZShuZXh0KSlcbiAgICAgICAgeyByZXR1cm4gaSA8IGVuZCAtIDEgJiYgbmV4dCA9PT0gMTMgJiYgY29kZS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgPyBpICsgMiA6IGkgKyAxIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG4gIHZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG4gIHZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG4gIHZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuICB2YXIgaGFzT3duID0gT2JqZWN0Lmhhc093biB8fCAoZnVuY3Rpb24gKG9iaiwgcHJvcE5hbWUpIHsgcmV0dXJuIChcbiAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4gICk7IH0pO1xuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICAgIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4gICk7IH0pO1xuXG4gIHZhciByZWdleHBDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gcmVnZXhwQ2FjaGVbd29yZHNdIHx8IChyZWdleHBDYWNoZVt3b3Jkc10gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpKVxuICB9XG5cbiAgZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAgIC8vIFVURi0xNiBEZWNvZGluZ1xuICAgIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbiAgfVxuXG4gIHZhciBsb25lU3Vycm9nYXRlID0gLyg/OltcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS87XG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4gIC8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbiAgdmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbiAgfTtcblxuICB2YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbiAgfTtcblxuICAvLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4gIC8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4gIC8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gIC8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbiAgLy8gaW50by5cblxuICBmdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gICAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgICAgdmFyIG5leHRCcmVhayA9IG5leHRMaW5lQnJlYWsoaW5wdXQsIGN1ciwgb2Zmc2V0KTtcbiAgICAgIGlmIChuZXh0QnJlYWsgPCAwKSB7IHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKSB9XG4gICAgICArK2xpbmU7XG4gICAgICBjdXIgPSBuZXh0QnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBnaXZlbiB0byBjb25maWd1cmUgdGhlIHBhcnNlciBwcm9jZXNzLlxuICAvLyBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkIChvbmx5IGBlY21hVmVyc2lvbmAgaXMgcmVxdWlyZWQpOlxuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0IGJlXG4gICAgLy8gZWl0aGVyIDMsIDUsIDYgKG9yIDIwMTUpLCA3ICgyMDE2KSwgOCAoMjAxNyksIDkgKDIwMTgpLCAxMFxuICAgIC8vICgyMDE5KSwgMTEgKDIwMjApLCAxMiAoMjAyMSksIDEzICgyMDIyKSwgMTQgKDIwMjMpLCBvciBgXCJsYXRlc3RcImBcbiAgICAvLyAodGhlIGxhdGVzdCB2ZXJzaW9uIHRoZSBsaWJyYXJ5IHN1cHBvcnRzKS4gVGhpcyBpbmZsdWVuY2VzXG4gICAgLy8gc3VwcG9ydCBmb3Igc3RyaWN0IG1vZGUsIHRoZSBzZXQgb2YgcmVzZXJ2ZWQgd29yZHMsIGFuZCBzdXBwb3J0XG4gICAgLy8gZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuXG4gICAgZWNtYVZlcnNpb246IG51bGwsXG4gICAgLy8gYHNvdXJjZVR5cGVgIGluZGljYXRlcyB0aGUgbW9kZSB0aGUgY29kZSBzaG91bGQgYmUgcGFyc2VkIGluLlxuICAgIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAgIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gICAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgLy8gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgLy8gcG9zaXRpb24gb2YgdGhlIGluc2VydGVkIHNlbWljb2xvbiBhcyBhbiBvZmZzZXQsIGFuZCBpZlxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSxcbiAgICAvLyBjb2x1bW59YCBvYmplY3QgYXMgc2Vjb25kIGFyZ3VtZW50LlxuICAgIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gICAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgICAvLyB0cmFpbGluZyBjb21tYXMuXG4gICAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAgIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gICAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gICAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICAgIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gICAgLy8gZXJyb3IuXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbSwgYW5kIGFuIGltcG9ydC5tZXRhIGV4cHJlc3Npb25cbiAgICAvLyBpbiBhIHNjcmlwdCBpc24ndCBjb25zaWRlcmVkIGFuIGVycm9yLlxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgLy8gQnkgZGVmYXVsdCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUgb25seSBpZiBlY21hVmVyc2lvbiA+PSAyMDIyLlxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gICAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIHN1cGVyIGlkZW50aWZpZXJzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgICAvLyBhcHBlYXJpbmcgaW4gbWV0aG9kcyBhbmQgZG8gbm90IHJhaXNlIGFuIGVycm9yIHdoZW4gdGhleSBhcHBlYXIgZWxzZXdoZXJlLlxuICAgIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgaGFzaGJhbmcgZGlyZWN0aXZlIGluIHRoZSBiZWdpbm5pbmcgb2YgZmlsZSBpc1xuICAgIC8vIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuIEVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuXG4gICAgLy8gYGVjbWFWZXJzaW9uYCA+PSAyMDIzLlxuICAgIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBwYXJzZXIgd2lsbCB2ZXJpZnkgdGhhdCBwcml2YXRlIHByb3BlcnRpZXMgYXJlXG4gICAgLy8gb25seSB1c2VkIGluIHBsYWNlcyB3aGVyZSB0aGV5IGFyZSB2YWxpZCBhbmQgaGF2ZSBiZWVuIGRlY2xhcmVkLlxuICAgIC8vIFNldCB0aGlzIHRvIGZhbHNlIHRvIHR1cm4gc3VjaCBjaGVja3Mgb2ZmLlxuICAgIGNoZWNrUHJpdmF0ZUZpZWxkczogdHJ1ZSxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAgIC8vIG5vZGVzLlxuICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gICAgLy8gdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZVxuICAgIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAgIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAgIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gICAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgLy8gV2hlbiB0aGlzIG9wdGlvbiBoYXMgYW4gYXJyYXkgYXMgdmFsdWUsIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZVxuICAgIC8vIGNvbW1lbnRzIGFyZSBwdXNoZWQgdG8gaXQuXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gICAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gICAgLy8gYHRydWVgLlxuICAgIC8vXG4gICAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAgIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAgIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gICAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAgIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAgIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG4gIC8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG4gIHZhciB3YXJuZWRBYm91dEVjbWFWZXJzaW9uID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXNPd24ob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID09PSBcImxhdGVzdFwiKSB7XG4gICAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMWU4O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICBpZiAoIXdhcm5lZEFib3V0RWNtYVZlcnNpb24gJiYgdHlwZW9mIGNvbnNvbGUgPT09IFwib2JqZWN0XCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJTaW5jZSBBY29ybiA4LjAuMCwgb3B0aW9ucy5lY21hVmVyc2lvbiBpcyByZXF1aXJlZC5cXG5EZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5lY21hVmVyc2lvbiA9IDExO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KSB7XG4gICAgICBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gICAgaWYgKCFvcHRzIHx8IG9wdHMuYWxsb3dIYXNoQmFuZyA9PSBudWxsKVxuICAgICAgeyBvcHRpb25zLmFsbG93SGFzaEJhbmcgPSBvcHRpb25zLmVjbWFWZXJzaW9uID49IDE0OyB9XG5cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICAgIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xuICB2YXJcbiAgICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgICBTQ09QRV9BU1lOQyA9IDQsXG4gICAgICBTQ09QRV9HRU5FUkFUT1IgPSA4LFxuICAgICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICAgIFNDT1BFX1NJTVBMRV9DQVRDSCA9IDMyLFxuICAgICAgU0NPUEVfU1VQRVIgPSA2NCxcbiAgICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyOCxcbiAgICAgIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSyA9IDI1NixcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLO1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbiAgfVxuXG4gIC8vIFVzZWQgaW4gY2hlY2tMVmFsKiBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xuICB2YXJcbiAgICAgIEJJTkRfTk9ORSA9IDAsIC8vIE5vdCBhIGJpbmRpbmdcbiAgICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICAgIEJJTkRfTEVYSUNBTCA9IDIsIC8vIExldC0gb3IgY29uc3Qtc3R5bGUgYmluZGluZ1xuICAgICAgQklORF9GVU5DVElPTiA9IDMsIC8vIEZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgICBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxuICB2YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgICB0aGlzLmtleXdvcmRzID0gd29yZHNSZWdleHAoa2V5d29yZHMkMVtvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gICAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgICByZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDUgPyA1IDogM107XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gICAgLy8gSXRzIHR5cGVcbiAgICB0aGlzLnR5cGUgPSB0eXBlcyQxLmVvZjtcbiAgICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgLy8gSXRzIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRob3NlIG9mZnNldHNcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSBudWxsO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gICAgLy8gY29udGV4dCB0byBwcmVkaWN0IHdoZXRoZXIgYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBpbiBhXG4gICAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gICAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpO1xuXG4gICAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZmFsc2U7XG5cbiAgICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBUaGUgc3RhY2sgb2YgcHJpdmF0ZSBuYW1lcy5cbiAgICAvLyBFYWNoIGVsZW1lbnQgaGFzIHR3byBwcm9wZXJ0aWVzOiAnZGVjbGFyZWQnIGFuZCAndXNlZCcuXG4gICAgLy8gV2hlbiBpdCBleGl0ZWQgZnJvbSB0aGUgb3V0ZXJtb3N0IGNsYXNzIGRlZmluaXRpb24sIGFsbCB1c2VkIHByaXZhdGUgbmFtZXMgbXVzdCBiZSBkZWNsYXJlZC5cbiAgICB0aGlzLnByaXZhdGVOYW1lU3RhY2sgPSBbXTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY2FuQXdhaXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dOZXdEb3RUYXJnZXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5DbGFzc1N0YXRpY0Jsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgJiYgIXRoaXMuY3VycmVudFZhclNjb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmNhbkF3YWl0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCB8fCBzY29wZS5mbGFncyAmIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHsgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzKSB8fCB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvblxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgICB2YXIgZmxhZ3MgPSByZWYuZmxhZ3M7XG4gICAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHJlZi5pbkNsYXNzRmllbGRJbml0O1xuICAgIHJldHVybiAoZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIHx8IGluQ2xhc3NGaWVsZEluaXQgfHwgdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93TmV3RG90VGFyZ2V0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgICB2YXIgZmxhZ3MgPSByZWYuZmxhZ3M7XG4gICAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHJlZi5pbkNsYXNzRmllbGRJbml0O1xuICAgIHJldHVybiAoZmxhZ3MgJiAoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spKSA+IDAgfHwgaW5DbGFzc0ZpZWxkSW5pdFxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkNsYXNzU3RhdGljQmxvY2suZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgPiAwXG4gIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBjbHMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgICByZXR1cm4gY2xzXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gICAgcGFyc2VyLm5leHRUb2tlbigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbiAgfTtcblxuICBQYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vICMjIFBhcnNlciB1dGlsaXRpZXNcblxuICB2YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXidcXFxcXSkqPyknfFwiKCg/OlxcXFwufFteXCJcXFxcXSkqPylcIikvO1xuICBwcCQ5LnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgc3BhY2VBZnRlciA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCksIGVuZCA9IHNwYWNlQWZ0ZXIuaW5kZXggKyBzcGFjZUFmdGVyWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJBdChlbmQpO1xuICAgICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgICAobGluZUJyZWFrLnRlc3Qoc3BhY2VBZnRlclswXSkgJiZcbiAgICAgICAgICAgISgvWyhgLlsrXFwtLyolPD49LD9eJl0vLnRlc3QobmV4dCkgfHwgbmV4dCA9PT0gXCIhXCIgJiYgdGhpcy5pbnB1dC5jaGFyQXQoZW5kICsgMSkgPT09IFwiPVwiKSlcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgLy8gU2tpcCBzZW1pY29sb24sIGlmIGFueS5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5pbnB1dFtzdGFydF0gPT09IFwiO1wiKVxuICAgICAgICB7IHN0YXJ0Kys7IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbiAgLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxuICBwcCQ5LmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICAvLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBwcCQ5LmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xuICB9O1xuXG4gIC8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxuICBwcCQ5LmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbiAgcHAkOS5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICBwcCQ5LmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mIHx8XG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAkOS5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4gIC8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG4gIHBwJDkuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAkOS5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgICBpZiAoIW5vdE5leHQpXG4gICAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbiAgLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcCQ5LmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICAvLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIHBwJDkudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH07XG5cbiAgdmFyIERlc3RydWN0dXJpbmdFcnJvcnMgPSBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgICAtMTtcbiAgfTtcblxuICBwcCQ5LmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gICAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIGlzQXNzaWduID8gXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIgOiBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxuICB9O1xuXG4gIHBwJDkuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gICAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gIH07XG5cbiAgcHAkOS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcCQ5LmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxuICB9O1xuXG4gIHZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgcHAkOC5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH0gfVxuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG4gIH07XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG4gIHBwJDguaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gICAgLy8gU3RhdGVtZW50KSBpcyBhbGxvd2VkIGhlcmUuIElmIGNvbnRleHQgaXMgbm90IGVtcHR5IHRoZW4gb25seSBhIFN0YXRlbWVudFxuICAgIC8vIGlzIGFsbG93ZWQuIEhvd2V2ZXIsIGBsZXQgW2AgaXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgbG9va2FoZWFkIGZvclxuICAgIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgICBpZiAobmV4dENoID09PSA5MSB8fCBuZXh0Q2ggPT09IDkyKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snLCAnLydcbiAgICBpZiAoY29udGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG5leHRDaCA9PT0gMTIzIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAneycsIGFzdHJhbFxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIGlmIChuZXh0Q2ggPT09IDkyIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfVxuICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbiAgLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4gIC8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG4gIHBwJDguaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBhZnRlcjtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAgICEoaXNJZGVudGlmaWVyQ2hhcihhZnRlciA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgOCkpIHx8IGFmdGVyID4gMHhkN2ZmICYmIGFmdGVyIDwgMHhkYzAwKSlcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gIC8vXG4gIC8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4gIC8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbiAgLy8gZG9lcyBub3QgaGVscC5cblxuICBwcCQ4LnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICAgIGlmICh0aGlzLmlzTGV0KGNvbnRleHQpKSB7XG4gICAgICBzdGFydHR5cGUgPSB0eXBlcyQxLl92YXI7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG5cbiAgICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAgIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAgIC8vIGNvbXBsZXhpdHkuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5fYnJlYWs6IGNhc2UgdHlwZXMkMS5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgICBjYXNlIHR5cGVzJDEuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZnVuY3Rpb246XG4gICAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgICAvLyBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cbiAgICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgICBjYXNlIHR5cGVzJDEuX2NsYXNzOlxuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgICBjYXNlIHR5cGVzJDEuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fY29uc3Q6IGNhc2UgdHlwZXMkMS5fdmFyOlxuICAgICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gICAgY2FzZSB0eXBlcyQxLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcyQxLl9leHBvcnQ6XG4gICAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgc3RhcnR0eXBlID09PSB0eXBlcyQxLl9pbXBvcnQpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2ggPT09IDQwIHx8IG5leHRDaCA9PT0gNDYpIC8vICcoJyBvciAnLidcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcyQxLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcyQxLmNvbG9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAgIC8vIGNvbnRpbnVlIHRvLlxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyB0aGlzLmVhdCh0eXBlcyQxLnNlbWkpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4gIC8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuICAvLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuICAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4gIC8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbiAgLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbiAgLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbiAgcHAkOC5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmNhbkF3YWl0ICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pKSB7XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgICB9XG4gICAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIHZhciBzdGFydHNXaXRoTGV0ID0gdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIiksIGlzRm9yT2YgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oYXdhaXRBdCA+IC0xID8gXCJhd2FpdFwiIDogdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKGlzRm9yT2YgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0c1dpdGhMZXQgJiYgaXNGb3JPZikgeyB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLlwiKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxuICB9O1xuXG4gIHBwJDgucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxuICB9O1xuXG4gIHBwJDgucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcyQxLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG4gICAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gICAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICAgIHZhciBjdXI7XG4gICAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2RlZmF1bHQpIHtcbiAgICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDgucGFyc2VDYXRjaENsYXVzZVBhcmFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgdmFyIHNpbXBsZSA9IHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4ocGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICBwcCQ4LnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NhdGNoKSB7XG4gICAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICAgIH1cbiAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzJDEuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2VcbiAgLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3JcbiAgLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxuICBwcCQ4LnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5lbnRlclNjb3BlKDApOyB9XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4gIC8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuICAvLyBleHByZXNzaW9uLlxuXG4gIHBwJDgucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnNlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuICAvLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbiAgcHAkOC5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9pbjtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChcbiAgICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgICAgKFxuICAgICAgICAhaXNGb3JJbiB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICAgIHRoaXMuc3RyaWN0IHx8XG4gICAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5yYWlzZShcbiAgICAgICAgaW5pdC5zdGFydCxcbiAgICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICAgICk7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGluaXQ7XG4gICAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxuICBwcCQ4LnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgJiYga2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgJiYgZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQ4LnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbiAgLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4gIC8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG4gIHBwJDgucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYywgZm9ySW5pdCkge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlLCBmb3JJbml0KTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkOC5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgcHJpdmF0ZU5hbWVNYXAgPSB0aGlzLmVudGVyQ2xhc3NCb2R5KCk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZWxlbWVudC5rZXkuc3RhcnQsIChcIklkZW50aWZpZXIgJyNcIiArIChlbGVtZW50LmtleS5uYW1lKSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgICB0aGlzLmV4aXRDbGFzc0JvZHkoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwic3RhdGljXCIpKSB7XG4gICAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEzICYmIHRoaXMuZWF0KHR5cGVzJDEuYnJhY2VMKSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0YXIpIHtcbiAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5TmFtZSA9IFwic3RhdGljXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICAgIGlmICgodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleU5hbWUgPSBcImFzeW5jXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha2V5TmFtZSAmJiAoZWNtYVZlcnNpb24gPj0gOSB8fCAhaXNBc3luYykgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKSkge1xuICAgICAgaXNHZW5lcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWtleU5hbWUgJiYgIWlzQXN5bmMgJiYgIWlzR2VuZXJhdG9yKSB7XG4gICAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkpIHtcbiAgICAgICAgICBraW5kID0gbGFzdFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleU5hbWUgPSBsYXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50IG5hbWVcbiAgICBpZiAoa2V5TmFtZSkge1xuICAgICAgLy8gJ2FzeW5jJywgJ2dldCcsICdzZXQnLCBvciAnc3RhdGljJyB3ZXJlIG5vdCBhIGtleXdvcmQgY29udGV4dHVhbGx5LlxuICAgICAgLy8gVGhlIGxhc3QgdG9rZW4gaXMgYW55IG9mIHRob3NlLiBNYWtlIGl0IHRoZSBlbGVtZW50IG5hbWUuXG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBub2RlLmtleSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIG5vZGUua2V5Lm5hbWUgPSBrZXlOYW1lO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGVsZW1lbnQgdmFsdWVcbiAgICBpZiAoZWNtYVZlcnNpb24gPCAxMyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MIHx8IGtpbmQgIT09IFwibWV0aG9kXCIgfHwgaXNHZW5lcmF0b3IgfHwgaXNBc3luYykge1xuICAgICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBpc0NvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgICAvLyBDb3VsZG4ndCBtb3ZlIHRoaXMgY2hlY2sgaW50byB0aGUgJ3BhcnNlQ2xhc3NNZXRob2QnIG1ldGhvZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIG5vZGUua2luZCA9IGlzQ29uc3RydWN0b3IgPyBcImNvbnN0cnVjdG9yXCIgOiBraW5kO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0ZpZWxkKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkOC5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNrZXRMIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZFxuICAgIClcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShlbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGNoZWNrS2V5TmFtZShtZXRob2QsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdmFsdWVcbiAgICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgICAvLyBDaGVjayB2YWx1ZVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKGNoZWNrS2V5TmFtZShmaWVsZCwgXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkLnN0YXRpYyAmJiBjaGVja0tleU5hbWUoZmllbGQsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGZpZWxkLmtleS5zdGFydCwgXCJDbGFzc2VzIGNhbid0IGhhdmUgYSBzdGF0aWMgZmllbGQgbmFtZWQgJ3Byb3RvdHlwZSdcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuZXEpKSB7XG4gICAgICAvLyBUbyByYWlzZSBTeW50YXhFcnJvciBpZiAnYXJndW1lbnRzJyBleGlzdHMgaW4gdGhlIGluaXRpYWxpemVyLlxuICAgICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHNjb3BlLmluQ2xhc3NGaWVsZEluaXQ7XG4gICAgICBzY29wZS5pbkNsYXNzRmllbGRJbml0ID0gdHJ1ZTtcbiAgICAgIGZpZWxkLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICBzY29wZS5pbkNsYXNzRmllbGRJbml0ID0gaW5DbGFzc0ZpZWxkSW5pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NTdGF0aWNCbG9jayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmJvZHkgPSBbXTtcblxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0YXRpY0Jsb2NrXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzJDEuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKG51bGwsIGZhbHNlKSA6IG51bGw7XG4gIH07XG5cbiAgcHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0ge2RlY2xhcmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLCB1c2VkOiBbXX07XG4gICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbiAgfTtcblxuICBwcCQ4LmV4aXRDbGFzc0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICAgIHZhciBkZWNsYXJlZCA9IHJlZi5kZWNsYXJlZDtcbiAgICB2YXIgdXNlZCA9IHJlZi51c2VkO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICAgIHZhciBsZW4gPSB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoO1xuICAgIHZhciBwYXJlbnQgPSBsZW4gPT09IDAgPyBudWxsIDogdGhpcy5wcml2YXRlTmFtZVN0YWNrW2xlbiAtIDFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGlkID0gdXNlZFtpXTtcbiAgICAgIGlmICghaGFzT3duKGRlY2xhcmVkLCBpZC5uYW1lKSkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LnVzZWQucHVzaChpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWVDb25mbGljdGVkKHByaXZhdGVOYW1lTWFwLCBlbGVtZW50KSB7XG4gICAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICAgIHZhciBjdXJyID0gcHJpdmF0ZU5hbWVNYXBbbmFtZV07XG5cbiAgICB2YXIgbmV4dCA9IFwidHJ1ZVwiO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgICAgbmV4dCA9IChlbGVtZW50LnN0YXRpYyA/IFwic1wiIDogXCJpXCIpICsgZWxlbWVudC5raW5kO1xuICAgIH1cblxuICAgIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICAgIGlmIChcbiAgICAgIGN1cnIgPT09IFwiaWdldFwiICYmIG5leHQgPT09IFwiaXNldFwiIHx8XG4gICAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgICAgY3VyciA9PT0gXCJzZ2V0XCIgJiYgbmV4dCA9PT0gXCJzc2V0XCIgfHxcbiAgICAgIGN1cnIgPT09IFwic3NldFwiICYmIG5leHQgPT09IFwic2dldFwiXG4gICAgKSB7XG4gICAgICBwcml2YXRlTmFtZU1hcFtuYW1lXSA9IFwidHJ1ZVwiO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICghY3Vycikge1xuICAgICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBuZXh0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXlOYW1lKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBub2RlLmNvbXB1dGVkO1xuICAgIHZhciBrZXkgPSBub2RlLmtleTtcbiAgICByZXR1cm4gIWNvbXB1dGVkICYmIChcbiAgICAgIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gbmFtZSB8fFxuICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICAgIClcbiAgfVxuXG4gIC8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDgucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZCwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc3RhcikpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgZXhwb3J0cylcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGtleXdvcmRzIHVzZWQgYXMgbG9jYWwgbmFtZXNcbiAgICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgICAgICAvLyBjaGVjayBpZiBleHBvcnQgaXMgZGVmaW5lZFxuICAgICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcblxuICAgICAgICAgIGlmIChzcGVjLmxvY2FsLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHNwZWMubG9jYWwuc3RhcnQsIFwiQSBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBleHBvcnRlZCBiaW5kaW5nIHdpdGhvdXQgYGZyb21gLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNBc3luYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYylcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2xhc3MpIHtcbiAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gICAgfVxuICB9O1xuXG4gIHBwJDguY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgICB7IG5hbWUgPSBuYW1lLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gbmFtZS5uYW1lIDogbmFtZS52YWx1ZTsgfVxuICAgIGlmIChoYXNPd24oZXhwb3J0cywgbmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gICAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgcHAkOC5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQsIHBhdC5zdGFydCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXQucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gIH07XG5cbiAgcHAkOC5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDguc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG4gIHBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSA6IG5vZGUubG9jYWw7XG4gICAgdGhpcy5jaGVja0V4cG9ydChcbiAgICAgIGV4cG9ydHMsXG4gICAgICBub2RlLmV4cG9ydGVkLFxuICAgICAgbm9kZS5leHBvcnRlZC5zdGFydFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoZXhwb3J0cykpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICAvLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDgucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBpbXBvcnQgJy4uLidcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHkkMTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUuaW1wb3J0ZWQpO1xuICAgICAgbm9kZS5sb2NhbCA9IG5vZGUuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlTW9kdWxlRXhwb3J0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgdmFyIHN0cmluZ0xpdGVyYWwgPSB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChsb25lU3Vycm9nYXRlLnRlc3Qoc3RyaW5nTGl0ZXJhbC52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICB9O1xuXG4gIC8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxuICBwcCQ4LmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gIC8vIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuICAvLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbiAgcHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKGFsbG93TW9kaWZpZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgcmV0dXJuIGVsZW1cbiAgfTtcblxuICBwcCQ3LnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMkMS5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFsbCB2ZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbHVlIOKAlFxuICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4gIC8vIGEgdmFyaWV0eSBvZiBjaGVja3M6XG4gIC8vXG4gIC8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4gIC8vIC0gUmVjb3JkIG5hbWUgZGVjbGFyYXRpb25zIGZvciBiaW5kaW5ncyBpbiB0aGUgYXBwcm9wcmlhdGUgc2NvcGUuXG4gIC8vIC0gQ2hlY2sgZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLCBpZiBjaGVja0NsYXNoZXMgaXMgc2V0LlxuICAvL1xuICAvLyBJZiBhIGNvbXBsZXggYmluZGluZyBwYXR0ZXJuIGlzIGVuY291bnRlcmVkIChlLmcuLCBvYmplY3QgYW5kIGFycmF5XG4gIC8vIGRlc3RydWN0dXJpbmcpLCB0aGUgZW50aXJlIHBhdHRlcm4gaXMgcmVjdXJzaXZlbHkgY2hlY2tlZC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHRocmVlIHZlcnNpb25zIG9mIGNoZWNrTFZhbCooKSBhcHByb3ByaWF0ZSBmb3IgZGlmZmVyZW50XG4gIC8vIGNpcmN1bXN0YW5jZXM6XG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsU2ltcGxlKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIG5vdGhpbmcgb3RoZXIgdGhhbiBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLiBQYXJlbnRoZXNpemVkXG4gIC8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuICAvLyAgIGNvbnN0cnVjdHMgZm9yIHdoaWNoIHRoZSBzcGVjIHNheXNcbiAgLy9cbiAgLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4gIC8vICAgZGVmaW5lZCBlbHNld2hlcmUsIGxpa2UgaW1wb3J0IGRlY2xhcmF0aW9ucyBvciBmdW5jdGlvbi9jbGFzcyBpZGVudGlmaWVycy5cbiAgLy9cbiAgLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbiAgLy8gICAgIGEgKz0g4oCmO1xuICAvLyAgICAgaW1wb3J0IGEgZnJvbSAn4oCmJztcbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsUGF0dGVybigpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbiAgLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4gIC8vICAgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJucy4gVGhpcyBpcyBnZW5lcmFsbHkgYXBwcm9wcmlhdGUgZm9yIGNvbnN0cnVjdHMgZm9yXG4gIC8vICAgd2hpY2ggdGhlIHNwZWMgc2F5c1xuICAvL1xuICAvLyAgID4gSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgW3RoZSBwcm9kdWN0aW9uXSBpcyBuZWl0aGVyIGFuIE9iamVjdExpdGVyYWwgbm9yXG4gIC8vICAgPiBhbiBBcnJheUxpdGVyYWwgYW5kIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4gIC8vICAgICAoYSA9IOKApik7XG4gIC8vICAgICBjb25zdCBhID0g4oCmO1xuICAvLyAgICAgdHJ5IHsg4oCmIH0gY2F0Y2ggKGEpIHsg4oCmIH1cbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbiAgLy8gICBwYXR0ZXJucywgcmVzdCBlbGVtZW50cywgYW5kIG90aGVyIGNvbnN0cnVjdHMgdGhhdCBtYXkgYXBwZWFyIHdpdGhpbiBhblxuICAvLyAgIG9iamVjdCBvciBhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm4uXG4gIC8vXG4gIC8vICAgQXMgYSBzcGVjaWFsIGNhc2UsIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYWxzbyB1c2UgY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCksXG4gIC8vICAgYXMgdGhleSBhbHNvIHN1cHBvcnQgZGVmYXVsdHMgYW5kIHJlc3QgY29uc3RydWN0cy5cbiAgLy9cbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRlbGliZXJhdGVseSBzdXBwb3J0IGJvdGggYXNzaWdubWVudCBhbmQgYmluZGluZyBjb25zdHJ1Y3RzLFxuICAvLyBhcyB0aGUgbG9naWMgZm9yIGJvdGggaXMgZXhjZWVkaW5nbHkgc2ltaWxhci4gSWYgdGhlIG5vZGUgaXMgdGhlIHRhcmdldCBvZlxuICAvLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4gIC8vIHNob3VsZCBiZSBzZXQgdG8gdGhlIGFwcHJvcHJpYXRlIEJJTkRfKiBjb25zdGFudCwgbGlrZSBCSU5EX1ZBUiBvclxuICAvLyBCSU5EX0xFWElDQUwuXG4gIC8vXG4gIC8vIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIG5vbi1CSU5EX05PTkUgYmluZGluZ1R5cGUsIHRoZW5cbiAgLy8gYWRkaXRpb25hbGx5IGEgY2hlY2tDbGFzaGVzIG9iamVjdCBtYXkgYmUgc3BlY2lmaWVkIHRvIGFsbG93IGNoZWNraW5nIGZvclxuICAvLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RcbiAgLy8gaXMgYW4gYXNzaWdubWVudCAoaS5lLiwgYmluZGluZ1R5cGUgaXMgQklORF9OT05FKS5cblxuICBwcCQ3LmNoZWNrTFZhbFNpbXBsZSA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHZhciBpc0JpbmQgPSBiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChpc0JpbmQpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgICAgaWYgKGhhc093bihjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcylcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNy5jaGVja0xWYWxJbm5lclBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuICAvLyBnaXZlbiBwb2ludCBpbiB0aGUgcHJvZ3JhbSBpcyBsb29zZWx5IGJhc2VkIG9uIHN3ZWV0LmpzJyBhcHByb2FjaC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDYuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcy5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcy5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmFycm93KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbiAgfTtcblxuICBwcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMkMS5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBoYW5kbGUgZWRnZSBjYXNlcyB3aGVuIHRva2VuIGNvbnRleHQgY291bGQgbm90IGJlIGluZmVycmVkIGNvcnJlY3RseSBkdXJpbmcgdG9rZW5pemF0aW9uIHBoYXNlXG5cbiAgcHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdG9rZW5DdHgpIHtcbiAgICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gIHR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzJDEuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMkMS5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuY29sb24udXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG4gIC8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4gIC8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbiAgLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuICAvLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuICAvLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuICAvLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4gIC8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuICAvLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4gIC8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbiAgLy9cbiAgLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuICAvLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbiAgLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3RpbmdcbiAgLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuICAvLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbiAgLy9cbiAgLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQ1LmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7XG4gICAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cbiAgLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4gIC8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuICAvLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuICAvLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbiAgLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbiAgLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4gIC8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4gIC8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4gIC8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuICAvLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbiAgLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuICAvLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxuICBwcCQ1LnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoZm9ySW5pdCkgfVxuICAgICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkRG91YmxlUHJvdG8gPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgb2xkRG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDtcbiAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZm9ySW5pdCA9PT0gXCJhd2FpdFwiO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gICAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgbGVmdCA9IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBsZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGxlZnQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobGVmdCk7IH1cbiAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgICBpZiAob2xkRG91YmxlUHJvdG8gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gb2xkRG91YmxlUHJvdG87IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxuICBwcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgZm9ySW5pdClcbiAgfTtcblxuICAvLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuICAvLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuICAvLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbiAgLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuICAvLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbiAgcHAkNS5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIWZvckluaXQgfHwgdGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2FsZXNjZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGBub2RlLnJpZ2h0YCBzaG91bGRuJ3QgY29udGFpbiBsb2dpY2FsIGV4cHJlc3Npb25zIGluIG9yZGVyIHRvIGNoZWNrIHRoZSBtaXhlZCBlcnJvci5cbiAgICAgICAgICBwcmVjID0gdHlwZXMkMS5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBmb3JJbml0KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkNS5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQ1LnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5LCBpbmNEZWMsIGZvckluaXQpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgdGhpcy5jYW5Bd2FpdCkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdChmb3JJbml0KTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmFyZ3VtZW50KSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJQcml2YXRlIGZpZWxkcyBjYW4gbm90IGJlIGRlbGV0ZWRcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkKSB7XG4gICAgICBpZiAoKGZvckluaXQgfHwgdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCA9PT0gMCkgJiYgdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAgIC8vIG9ubHkgY291bGQgYmUgcHJpdmF0ZSBmaWVsZHMgaW4gJ2luJywgc3VjaCBhcyAjeCBpbiBvYmpcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuX2luKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwcik7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5jRGVjICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcnN0YXIpKSB7XG4gICAgICBpZiAoc2F3VW5hcnkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgXCIqKlwiLCBmYWxzZSkgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwclxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pXG4gICAgKVxuICB9XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkNS5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBmYWxzZSwgZm9ySW5pdCk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuc2hvdWxkUGFyc2VBc3luY0Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpXG4gIH07XG5cbiAgcHAkNS5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3cgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSwgZm9ySW5pdClcbiAgfTtcblxuICBwcCQ1LnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpO1xuICAgIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUkMS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBwcCQ1LnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0LCBmb3JOZXcpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyICggQXJndW1lbnRzIClcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMkMS5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVDb250ZXh0KHR5cGVzLmZfZXhwcik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICghdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgfHwgdGhpcy52YWx1ZSAhPT0gXCJvZlwiIHx8IHRoaXMuY29udGFpbnNFc2MpKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcyQxLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbnVsbDogY2FzZSB0eXBlcyQxLl90cnVlOiBjYXNlIHR5cGVzJDEuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEuYnJhY2VMOlxuICAgICAgdGhpcy5vdmVycmlkZUNvbnRleHQodHlwZXMuYl9leHByKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzJDEuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydChmb3JOZXcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICBwcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnRcIik7IH1cbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0TWV0YShub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNS5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYChgXG5cbiAgICAvLyBQYXJzZSBub2RlLnNvdXJjZS5cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gICAgLy8gVmVyaWZ5IGVuZGluZy5cbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVycm9yUG9zLCBcIlRyYWlsaW5nIGNvbW1hIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VJbXBvcnRNZXRhID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpOyAvLyBza2lwIGAuYFxuXG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJtZXRhXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIGltcG9ydCBpcyAnaW1wb3J0Lm1ldGEnXCIpOyB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlICE9PSBcIm1vZHVsZVwiICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiKTsgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9fL2csIFwiXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkNS5zaG91bGRQYXJzZUFycm93ID0gZnVuY3Rpb24oZXhwckxpc3QpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKClcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93LCBmb3JJbml0KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIC8vIERvIG5vdCBzYXZlIGF3YWl0SWRlbnRQb3MgdG8gYWxsb3cgY2hlY2tpbmcgYXdhaXRzIG5lc3RlZCBpbiBwYXJhbWV0ZXJzXG4gICAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKFxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMubGFzdFRva0VuZCwgaW5uZXJFbmRMb2MgPSB0aGlzLmxhc3RUb2tFbmRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBcnJvdyhleHByTGlzdCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgZmFsc2UsIGZvckluaXQpXG4gIH07XG5cbiAgLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4gIC8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbiAgLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbiAgLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4gIC8vIGFyZ3VtZW50IGxpc3QuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkNS5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUuc3RhcnQsIG5vZGUuc3RhcnRMb2MpO1xuICAgICAgbWV0YS5uYW1lID0gXCJuZXdcIjtcbiAgICAgIG5vZGUubWV0YSA9IHRoaXMuZmluaXNoTm9kZShtZXRhLCBcIklkZW50aWZpZXJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgJ25ldy50YXJnZXQnXCIpOyB9XG4gICAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuYWxsb3dOZXdEb3RUYXJnZXQpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zIGFuZCBjbGFzcyBzdGF0aWMgYmxvY2tcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKG51bGwsIGZhbHNlLCB0cnVlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5OyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG4gIHBwJDUucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgICAgfVxuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgICBjb29rZWQ6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmRvbGxhckJyYWNlTCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDUuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSkgJiZcbiAgICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG4gIHBwJDUucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuZWxsaXBzaXMpKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgICAgfVxuICAgICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gRmluaXNoXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpOyB9XG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlR2V0dGVyU2V0dGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICAgIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbG9uKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lcSkpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLnBhcnNlR2V0dGVyU2V0dGVyKHByb3ApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHRoaXMuY29weU5vZGUocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHRoaXMuY29weU5vZGUocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbiAgcHAkNS5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG4gIH07XG5cbiAgLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxuICBwcCQ1LnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG4gIHBwJDUucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgcHAkNS5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QsIGZvckluaXQpIHtcbiAgICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgICAgfVxuICAgICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gIH07XG5cbiAgcHAkNS5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4gIC8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG4gIHBwJDUuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4ocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuICAvLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuICAvLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4gIC8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuICAvLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG4gIHBwJDUucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2goZWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQ1LmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICBpZiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdCAmJiBuYW1lID09PSBcImFyZ3VtZW50c1wiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXJndW1lbnRzJyBpbiBjbGFzcyBmaWVsZCBpbml0aWFsaXplclwiKTsgfVxuICAgIGlmICh0aGlzLmluQ2xhc3NTdGF0aWNCbG9jayAmJiAobmFtZSA9PT0gXCJhcmd1bWVudHNcIiB8fCBuYW1lID09PSBcImF3YWl0XCIpKVxuICAgICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJDYW5ub3QgdXNlIFwiICsgbmFtZSArIFwiIGluIGNsYXNzIHN0YXRpYyBpbml0aWFsaXphdGlvbiBibG9ja1wiKSk7IH1cbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJVbmV4cGVjdGVkIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJ1wiKSk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgICBpZiAocmUudGVzdChuYW1lKSkge1xuICAgICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIChcIlRoZSBrZXl3b3JkICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIikpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuICAvLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbiAgLy8gaWRlbnRpZmllcnMuXG5cbiAgcHAkNS5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUlkZW50Tm9kZSgpO1xuICAgIHRoaXMubmV4dCghIWxpYmVyYWwpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQ1LnBhcnNlSWRlbnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgICB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlcyQxLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcml2YXRlSWRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcml2YXRlSWRlbnRpZmllclwiKTtcblxuICAgIC8vIEZvciB2YWxpZGF0aW5nIGV4aXN0ZW5jZVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKSB7XG4gICAgICBpZiAodGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIChcIlByaXZhdGUgZmllbGQgJyNcIiArIChub2RlLm5hbWUpICsgXCInIG11c3QgYmUgZGVjbGFyZWQgaW4gYW4gZW5jbG9zaW5nIGNsYXNzXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpdmF0ZU5hbWVTdGFja1t0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoIC0gMV0udXNlZC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxuICBwcCQ1LnBhcnNlWWllbGQgPSBmdW5jdGlvbihmb3JJbml0KSB7XG4gICAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlQXdhaXQgPSBmdW5jdGlvbihmb3JJbml0KSB7XG4gICAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUsIGZhbHNlLCBmb3JJbml0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgdmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbiAgLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbiAgLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4gIC8vIG1lc3NhZ2UuXG5cbiAgcHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICAgIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICAgIHRocm93IGVyclxuICB9O1xuXG4gIHBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbiAgcHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMudmFyID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy5sZXhpY2FsID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgIC8vIEEgc3dpdGNoIHRvIGRpc2FsbG93IHRoZSBpZGVudGlmaWVyIHJlZmVyZW5jZSAnYXJndW1lbnRzJ1xuICAgIHRoaXMuaW5DbGFzc0ZpZWxkSW5pdCA9IGZhbHNlO1xuICB9O1xuXG4gIC8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxuICBwcCQzLmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xuICB9O1xuXG4gIHBwJDMuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbiAgLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxuICBwcCQzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbiAgfTtcblxuICBwcCQzLmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxuICB9O1xuXG4gIHBwJDMuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbiAgfTtcblxuICBwcCQzLmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxuICBwcCQzLmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgdmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDIuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkMi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQyLmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbiAgcHAkMi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuICBwcCQyLmNvcHlOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcywgbm9kZS5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBub2RlKSB7IG5ld05vZGVbcHJvcF0gPSBub2RlW3Byb3BdOyB9XG4gICAgcmV0dXJuIG5ld05vZGVcbiAgfTtcblxuICAvLyBUaGlzIGZpbGUgY29udGFpbnMgVW5pY29kZSBwcm9wZXJ0aWVzIGV4dHJhY3RlZCBmcm9tIHRoZSBFQ01BU2NyaXB0IHNwZWNpZmljYXRpb24uXG4gIC8vIFRoZSBsaXN0cyBhcmUgZXh0cmFjdGVkIGxpa2Ugc286XG4gIC8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuICAvLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1xuICB2YXIgZWNtYTlCaW5hcnlQcm9wZXJ0aWVzID0gXCJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFNcIjtcbiAgdmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbiAgdmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xuICB2YXIgZWNtYTEyQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFQmFzZSBFQ29tcCBFTW9kIEVQcmVzIEV4dFBpY3RcIjtcbiAgdmFyIGVjbWExM0JpbmFyeVByb3BlcnRpZXMgPSBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzO1xuICB2YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllcyA9IGVjbWExM0JpbmFyeVByb3BlcnRpZXM7XG5cbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMjogZWNtYTEyQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMzogZWNtYTEzQmluYXJ5UHJvcGVydGllcyxcbiAgICAxNDogZWNtYTE0QmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIC8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzLW9mLXN0cmluZ3NcbiAgdmFyIGVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3MgPSBcIkJhc2ljX0Vtb2ppIEVtb2ppX0tleWNhcF9TZXF1ZW5jZSBSR0lfRW1vamlfTW9kaWZpZXJfU2VxdWVuY2UgUkdJX0Vtb2ppX0ZsYWdfU2VxdWVuY2UgUkdJX0Vtb2ppX1RhZ19TZXF1ZW5jZSBSR0lfRW1vamlfWldKX1NlcXVlbmNlIFJHSV9FbW9qaVwiO1xuXG4gIHZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IHtcbiAgICA5OiBcIlwiLFxuICAgIDEwOiBcIlwiLFxuICAgIDExOiBcIlwiLFxuICAgIDEyOiBcIlwiLFxuICAgIDEzOiBcIlwiLFxuICAgIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzXG4gIH07XG5cbiAgLy8gI3RhYmxlLXVuaWNvZGUtZ2VuZXJhbC1jYXRlZ29yeS12YWx1ZXNcbiAgdmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuICAvLyAjdGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXG4gIHZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xuICB2YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xuICB2YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG4gIHZhciBlY21hMTJTY3JpcHRWYWx1ZXMgPSBlY21hMTFTY3JpcHRWYWx1ZXMgKyBcIiBDaG9yYXNtaWFuIENocnMgRGlhayBEaXZlc19Ba3VydSBLaGl0YW5fU21hbGxfU2NyaXB0IEtpdHMgWWV6aSBZZXppZGlcIjtcbiAgdmFyIGVjbWExM1NjcmlwdFZhbHVlcyA9IGVjbWExMlNjcmlwdFZhbHVlcyArIFwiIEN5cHJvX01pbm9hbiBDcG1uIE9sZF9VeWdodXIgT3VnciBUYW5nc2EgVG5zYSBUb3RvIFZpdGhrdXFpIFZpdGhcIjtcbiAgdmFyIGVjbWExNFNjcmlwdFZhbHVlcyA9IGVjbWExM1NjcmlwdFZhbHVlcyArIFwiIEhya3QgS2F0YWthbmFfT3JfSGlyYWdhbmEgS2F3aSBOYWdfTXVuZGFyaSBOYWdtIFVua25vd24gWnp6elwiO1xuXG4gIHZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICAgIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAgIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gICAgMTE6IGVjbWExMVNjcmlwdFZhbHVlcyxcbiAgICAxMjogZWNtYTEyU2NyaXB0VmFsdWVzLFxuICAgIDEzOiBlY21hMTNTY3JpcHRWYWx1ZXMsXG4gICAgMTQ6IGVjbWExNFNjcmlwdFZhbHVlc1xuICB9O1xuXG4gIHZhciBkYXRhID0ge307XG4gIGZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgYmluYXJ5T2ZTdHJpbmdzOiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5nc1tlY21hVmVyc2lvbl0pLFxuICAgICAgbm9uQmluYXJ5OiB7XG4gICAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgICAgfVxuICAgIH07XG4gICAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gICAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gICAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMTRdOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBlY21hVmVyc2lvbiA9IGxpc3RbaV07XG5cbiAgICBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKTtcbiAgfVxuXG4gIHZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzID8gXCJkXCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSA/IFwidlwiIDogXCJcIik7XG4gICAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTQgPyAxNCA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hWID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgdmFyIHVuaWNvZGVTZXRzID0gZmxhZ3MuaW5kZXhPZihcInZcIikgIT09IC0xO1xuICAgIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgaWYgKHVuaWNvZGVTZXRzICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTUpIHtcbiAgICAgIHRoaXMuc3dpdGNoVSA9IHRydWU7XG4gICAgICB0aGlzLnN3aXRjaFYgPSB0cnVlO1xuICAgICAgdGhpcy5zd2l0Y2hOID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3dpdGNoTiA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5O1xuICAgIH1cbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbiAgfTtcblxuICAvLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuICAvLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gICAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGksIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiBsXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gaSArIDFcbiAgICB9XG4gICAgcmV0dXJuIGkgKyAyXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcywgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkIChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpLCBmb3JjZVUpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50KGZvcmNlVSkgPT09IGNoKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoZm9yY2VVKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0Q2hhcnMgPSBmdW5jdGlvbiBlYXRDaGFycyAoY2hzLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNoczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBjaCA9IGxpc3RbaV07XG5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0KHBvcywgZm9yY2VVKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSAtMSB8fCBjdXJyZW50ICE9PSBjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHBvcyA9IHRoaXMubmV4dEluZGV4KHBvcywgZm9yY2VVKTtcbiAgICB9XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcCQxLnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICAgIHZhciB1ID0gZmFsc2U7XG4gICAgdmFyIHYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZyA9PT0gXCJ1XCIpIHsgdSA9IHRydWU7IH1cbiAgICAgIGlmIChmbGFnID09PSBcInZcIikgeyB2ID0gdHJ1ZTsgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ICYmIHUgJiYgdikge1xuICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHBwJDEudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAgIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gICAgLy8gcGFyc2luZyBjb250YWlucyBhIHxHcm91cE5hbWV8LCByZXBhcnNlIHdpdGggdGhlIGdvYWwgc3ltYm9sXG4gICAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAgIC8vIHdlcmUgbm90IG1hdGNoZWQgYnkgdGhlIHBhcnNlLCBvciBpZiBhbnkgRWFybHkgRXJyb3IgY29uZGl0aW9ucyBleGlzdC5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuXG4gIHBwJDEucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLnBvcyA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlcyBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGlzanVuY3Rpb25cbiAgcHAkMS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB3aGlsZSAoc3RhdGUuZWF0KDB4N0MgLyogfCAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxuICBwcCQxLnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgICB7IH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxuICBwcCQxLnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgICAgLy8gaXMgYSBRdWFudGlmaWFibGVBc3NlcnRpb24uXG4gICAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1Bc3NlcnRpb25cbiAgcHAkMS5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgICAvLyBeLCAkXG4gICAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFxcYiBcXEJcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIC8vIExvb2thaGVhZCAvIExvb2tiZWhpbmRcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDNEIC8qID0gKi8pIHx8IHN0YXRlLmVhdCgweDIxIC8qICEgKi8pKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJcbiAgcHAkMS5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclByZWZpeFxuICBwcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkEgLyogKiAqLykgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgICApXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyAvKiAsICovKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQXRvbVxuICBwcCQxLnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pICYmIHN0YXRlLmVhdCgweDNBIC8qIDogKi8pKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDNGIC8qID8gKi8pIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZEF0b21cbiAgcHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIoc3RhdGUpXG4gICAgKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JbnZhbGlkQnJhY2VkUXVhbnRpZmllclxuICBwcCQxLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbiAgcHAkMS5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgICAgY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLyB8fFxuICAgICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUUgLyogXiAqLyB8fFxuICAgICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5DaGFyYWN0ZXJcbiAgLy8gQnV0IGVhdCBlYWdlci5cbiAgcHAkMS5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxuICBwcCQxLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoXG4gICAgICBjaCAhPT0gLTEgJiZcbiAgICAgIGNoICE9PSAweDI0IC8qICQgKi8gJiZcbiAgICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICAgIGNoICE9PSAweDJFIC8qIC4gKi8gJiZcbiAgICAgIGNoICE9PSAweDNGIC8qID8gKi8gJiZcbiAgICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICAgIGNoICE9PSAweDVFIC8qIF4gKi8gJiZcbiAgICAgIGNoICE9PSAweDdDIC8qIHwgKi9cbiAgICApIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIEdyb3VwU3BlY2lmaWVyIDo6XG4gIC8vICAgW2VtcHR5XVxuICAvLyAgIGA/YCBHcm91cE5hbWVcbiAgcHAkMS5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdyb3VwTmFtZSA6OlxuICAvLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZSBgPmBcbiAgLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG4gIHBwJDEucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0MgLyogPCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJOYW1lIDo6XG4gIC8vICAgUmVnRXhwSWRlbnRpZmllclN0YXJ0XG4gIC8vICAgUmVnRXhwSWRlbnRpZmllck5hbWUgUmVnRXhwSWRlbnRpZmllclBhcnRcbiAgLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG4gIHBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZWdFeHBJZGVudGlmaWVyU3RhcnQgOjpcbiAgLy8gICBVbmljb2RlSURTdGFydFxuICAvLyAgIGAkYFxuICAvLyAgIGBfYFxuICAvLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBSZWdFeHBJZGVudGlmaWVyUGFydCA6OlxuICAvLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4gIC8vICAgPFpXTko+XG4gIC8vICAgPFpXSj5cbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1BdG9tRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgLyogYyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAvLyBGb3IgU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy1hdG9tZXNjYXBlXG4gICAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZhbHNlKSB8fFxuICAgICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgLyogMCAqLyAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDZFIC8qIG4gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IC8qIFxcdiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDcyIC8qIHIgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxuICBwcCQxLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgICApXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUsIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgc3dpdGNoVSA9IGZvcmNlVSB8fCBzdGF0ZS5zd2l0Y2hVO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgc3dpdGNoVSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbiAgcHAkMS5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZXR1cm4gdmFsdWVzIHVzZWQgYnkgY2hhcmFjdGVyIHNldCBwYXJzaW5nIG1ldGhvZHMsIG5lZWRlZCB0b1xuICAvLyBmb3JiaWQgbmVnYXRpb24gb2Ygc2V0cyB0aGF0IGNhbiBtYXRjaCBzdHJpbmdzLlxuICB2YXIgQ2hhclNldE5vbmUgPSAwOyAvLyBOb3RoaW5nIHBhcnNlZFxuICB2YXIgQ2hhclNldE9rID0gMTsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2Fubm90IGNvbnRhaW4gc3RyaW5nc1xuICB2YXIgQ2hhclNldFN0cmluZyA9IDI7IC8vIENvbnN0cnVjdCBwYXJzZWQsIGNhbiBjb250YWluIHN0cmluZ3NcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gICAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBDaGFyU2V0T2tcbiAgICB9XG5cbiAgICB2YXIgbmVnYXRlID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAgICgobmVnYXRlID0gY2ggPT09IDB4NTAgLyogUCAqLykgfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgICApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgICAgKHJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgICApIHtcbiAgICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIENoYXJTZXROb25lXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gICAgKVxuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIENoYXJTZXRPa1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAgIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBDaGFyU2V0Tm9uZVxuICB9O1xuXG4gIHBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFoYXNPd24oc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICAgIGlmIChzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFYgJiYgc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5T2ZTdHJpbmdzLnRlc3QobmFtZU9yVmFsdWUpKSB7IHJldHVybiBDaGFyU2V0U3RyaW5nIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfTtcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxuICB9XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG4gIHBwJDEucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICAgIHZhciBuZWdhdGUgPSBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpXG4gICAgICAgIHsgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpOyB9XG4gICAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZylcbiAgICAgICAgeyBzdGF0ZS5yYWlzZShcIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3NcIik7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzQ29udGVudHNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbiAgcHAkMS5yZWdleHBfY2xhc3NDb250ZW50cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg1RCAvKiBdICovKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hWKSB7IHJldHVybiB0aGlzLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24oc3RhdGUpIH1cbiAgICB0aGlzLnJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICByZXR1cm4gQ2hhclNldE9rXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gIHBwJDEucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoY2gkMSA9PT0gMHg2MyAvKiBjICovIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NUQgLyogXSAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0VzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRFeHByZXNzaW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzVW5pb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NJbnRlcnNlY3Rpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICBwcCQxLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBDaGFyU2V0T2ssIHN1YlJlc3VsdDtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShzdGF0ZSkpIDsgZWxzZSBpZiAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkge1xuICAgICAgaWYgKHN1YlJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuICAgICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDI2LCAweDI2XSAvKiAmJiAqLykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRlLmN1cnJlbnQoKSAhPT0gMHgyNiAvKiAmICovICYmXG4gICAgICAgICAgKHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChzdWJSZXN1bHQgIT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldE9rOyB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gc3RhdGUucG9zKSB7IHJldHVybiByZXN1bHQgfVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICAgICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDJELCAweDJEXSAvKiAtLSAqLykpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSkpIHsgY29udGludWUgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gc3RhdGUucG9zKSB7IHJldHVybiByZXN1bHQgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICBzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpO1xuICAgICAgaWYgKCFzdWJSZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICBpZiAoc3ViUmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSYW5nZVxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldE9wZXJhbmRcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uKHN0YXRlKSB8fCB0aGlzLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyhzdGF0ZSlcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1OZXN0ZWRDbGFzc1xuICBwcCQxLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIF0gKi8pKSB7XG4gICAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICB2YXIgcmVzdWx0JDEgPSB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCQxXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0Q2hhcnMoWzB4NUMsIDB4NzFdIC8qIFxccSAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHNcbiAgcHAkMS5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmcoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKHN0YXRlKSA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1Ob25FbXB0eUNsYXNzU3RyaW5nXG4gIHBwJDEucmVnZXhwX2NsYXNzU3RyaW5nID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgY291bnQrKzsgfVxuICAgIHJldHVybiBjb3VudCA9PT0gMSA/IENoYXJTZXRPayA6IENoYXJTZXRTdHJpbmdcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldENoYXJhY3RlclxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihzdGF0ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPCAwIHx8IGNoID09PSBzdGF0ZS5sb29rYWhlYWQoKSAmJiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgICAgY2ggPj0gMHgyMyAvKiAjICovICYmIGNoIDw9IDB4MjYgLyogJiAqLyB8fFxuICAgICAgY2ggPj0gMHgyQSAvKiAqICovICYmIGNoIDw9IDB4MkMgLyogLCAqLyB8fFxuICAgICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4NDAgLyogQCAqLyB8fFxuICAgICAgY2ggPT09IDB4NUUgLyogXiAqLyB8fFxuICAgICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0U3ludGF4Q2hhcmFjdGVyXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjggLyogKCAqLyB8fFxuICAgICAgY2ggPT09IDB4MjkgLyogKSAqLyB8fFxuICAgICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgICAgY2ggPT09IDB4MkYgLyogLyAqLyB8fFxuICAgICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUQgLyogXSAqLyB8fFxuICAgICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgICAgY2ggPT09IDB4MjMgLyogIyAqLyB8fFxuICAgICAgY2ggPT09IDB4MjUgLyogJSAqLyB8fFxuICAgICAgY2ggPT09IDB4MjYgLyogJiAqLyB8fFxuICAgICAgY2ggPT09IDB4MkMgLyogLCAqLyB8fFxuICAgICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4M0UgLyogPiAqLyB8fFxuICAgICAgY2ggPT09IDB4NDAgLyogQCAqLyB8fFxuICAgICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG4gIHBwJDEucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbiAgcHAkMS5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICAgIClcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICAgIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gICAgfVxuICAgIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gICAgfVxuICAgIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2VcbiAgLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG4gIHBwJDEucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbiAgcHAkMS5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4gIC8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbiAgLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuICAvLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcC5lbmQ7XG4gICAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxuICB9O1xuXG4gIC8vICMjIFRva2VuaXplclxuXG4gIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG4gIHBwLm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICAgIGlmICghaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQgJiYgdGhpcy50eXBlLmtleXdvcmQgJiYgdGhpcy5jb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB0aGlzLnR5cGUua2V5d29yZCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICAgIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBwcC5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuZXcgVG9rZW4odGhpcylcbiAgfTtcblxuICAvLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7IHBwW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEkMS5nZXRUb2tlbigpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcyQxLmVvZixcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IH1cblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICAvLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbiAgLy8gcHJvcGVydGllcy5cblxuICBwcC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZW9mKSB9XG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gICAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbiAgfTtcblxuICBwcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gICAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfTtcblxuICBwcC5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGRjMDApIHsgcmV0dXJuIGNvZGUgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPD0gMHhkYmZmIHx8IG5leHQgPj0gMHhlMDAwID8gY29kZSA6IChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbiAgfTtcblxuICBwcC5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gICAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBuZXh0QnJlYWsgPSAodm9pZCAwKSwgcG9zID0gc3RhcnQ7IChuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKHRoaXMuaW5wdXQsIHBvcywgdGhpcy5wb3MpKSA+IC0xOykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgcG9zID0gdGhpcy5saW5lU3RhcnQgPSBuZXh0QnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgcHAuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuICAvLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG4gIHBwLnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4gIC8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbiAgLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbiAgLy8gcmlnaHQgcG9zaXRpb24uXG5cbiAgcHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gIH07XG5cbiAgLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbiAgLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4gIC8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4gIC8vIGludG8gaXQuXG4gIC8vXG4gIC8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbiAgLy9cbiAgcHAucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZWxsaXBzaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvdClcbiAgICB9XG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnNsYXNoLCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcyQxLnN0YXIgOiB0eXBlcyQxLm1vZHVsbztcblxuICAgIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgICsrc2l6ZTtcbiAgICAgIHRva2VudHlwZSA9IHR5cGVzJDEuc3RhcnN0YXI7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICBpZiAobmV4dDIgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmxvZ2ljYWxPUiA6IHR5cGVzJDEubG9naWNhbEFORCwgMilcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMkMS5iaXR3aXNlT1IgOiB0eXBlcyQxLmJpdHdpc2VBTkQsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnBsdXNNaW4sIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5yZWxhdGlvbmFsLCBzaXplKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYXJyb3cpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMkMS5lcSA6IHR5cGVzJDEucHJlZml4LCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9xdWVzdGlvbiA9IGZ1bmN0aW9uKCkgeyAvLyAnPydcbiAgICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICBpZiAobmV4dDIgPCA0OCB8fCBuZXh0MiA+IDU3KSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucXVlc3Rpb25Eb3QsIDIpIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgICB2YXIgbmV4dDIkMSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuY29hbGVzY2UsIDIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucXVlc3Rpb24sIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX251bWJlclNpZ24gPSBmdW5jdGlvbigpIHsgLy8gJyMnXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIHZhciBjb2RlID0gMzU7IC8vICcjJ1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMykge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdHJ1ZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnByaXZhdGVJZCwgdGhpcy5yZWFkV29yZDEoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgICBjYXNlIDQ2OiAvLyAnLidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICAgIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5MKVxuICAgIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc2VtaSlcbiAgICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmNvbW1hKVxuICAgIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0UilcbiAgICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFjZUwpXG4gICAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29sb24pXG5cbiAgICBjYXNlIDk2OiAvLyAnYCdcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJhY2tRdW90ZSlcblxuICAgIGNhc2UgNDg6IC8vICcwJ1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICAgIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICAgIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICAgIGNhc2UgOTQ6IC8vICdeJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gICAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gICAgY2FzZSA2MzogLy8gJz8nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gICAgY2FzZSAxMjY6IC8vICd+J1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5wcmVmaXgsIDEpXG5cbiAgICBjYXNlIDM1OiAvLyAnIydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKClcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwLmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxuICB9O1xuXG4gIHBwLnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICAgIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4gIC8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG4gIHBwLnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuLCBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBhbGxvd1NlcGFyYXRvcnMgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIgJiYgbGVuID09PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBgbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsYCBpcyB0cnVlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBwcmVmaXggKDB4LDBvLDBiKVxuICAgIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAgIC8vIGlzIHplcm8gdGhlbiBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgPSBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gNDg7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpLCArK3RoaXMucG9zKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuXG4gICAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBvY3RhbCBudW1lcmljIGxpdGVyYWxzXCIpOyB9XG4gICAgICAgIGlmIChsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIG11c3QgYmUgZXhhY3RseSBvbmUgdW5kZXJzY29yZVwiKTsgfVxuICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBmdW5jdGlvbiBzdHJpbmdUb051bWJlcihzdHIsIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gICAgfVxuXG4gICAgLy8gYHBhcnNlRmxvYXQodmFsdWUpYCBzdG9wcyBwYXJzaW5nIGF0IHRoZSBmaXJzdCBudW1lcmljIHNlcGFyYXRvciB0aGVuIHJldHVybnMgYSB3cm9uZyB2YWx1ZS5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQmlnSW50KHN0cikge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gICAgcmV0dXJuIEJpZ0ludChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIHBwLnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG4gIHBwLnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCwgdW5kZWZpbmVkLCB0cnVlKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICAgIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgICAgdmFyIHZhbCQxID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsJDEpXG4gICAgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gLy8gJystJ1xuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG5cbiAgICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbClcbiAgfTtcblxuICAvLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbiAgcHAucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9O1xuXG4gIHBwLnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgIHRoaXMuY3VyTGluZSsrO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc3RyaW5nLCBvdXQpXG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcC50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgcHAuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwLnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJhY2tRdW90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnRlbXBsYXRlLCBvdXQpXG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlYWRzIGEgdGVtcGxhdGUgdG9rZW4gdG8gc2VhcmNoIGZvciB0aGUgZW5kLCB3aXRob3V0IHZhbGlkYXRpbmcgYW55IGVzY2FwZSBzZXF1ZW5jZXNcbiAgcHAucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiYFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbiAgcHAucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gICAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxLFxuICAgICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgY29kZVBvcyxcbiAgICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbiAgcHAucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgICByZXR1cm4gblxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2BcbiAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gIC8vXG4gIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgcHAucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nKGVzYyk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4gIC8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG4gIHBwLnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMkMS5uYW1lO1xuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3Jkc1t3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbiAgfTtcblxuICAvLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuICAvL1xuICAvLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlLCBJbmd2YXIgU3RlcGFueWFuLCBhbmRcbiAgLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICAvL1xuICAvLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4gIC8vXG4gIC8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuICAvLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4uZ2l0XG4gIC8vXG4gIC8vIFBsZWFzZSB1c2UgdGhlIFtnaXRodWIgYnVnIHRyYWNrZXJdW2doYnRdIHRvIHJlcG9ydCBpc3N1ZXMuXG4gIC8vXG4gIC8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4gIC8vXG4gIC8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cblxuICB2YXIgdmVyc2lvbiA9IFwiOC4xMS4yXCI7XG5cbiAgUGFyc2VyLmFjb3JuID0ge1xuICAgIFBhcnNlcjogUGFyc2VyLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gICAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICAgIE5vZGU6IE5vZGUsXG4gICAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gICAgdG9rVHlwZXM6IHR5cGVzJDEsXG4gICAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyxcbiAgICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICAgIHRva0NvbnRleHRzOiB0eXBlcyxcbiAgICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICBUb2tlbjogVG9rZW4sXG4gICAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gICAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gICAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxuICB9O1xuXG4gIC8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4gIC8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kXG4gIC8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuICAvLyBBUEldW2FwaV0uXG4gIC8vXG4gIC8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uIGF0IGEgZ2l2ZW5cbiAgLy8gb2Zmc2V0IGluIGEgc3RyaW5nLiBVc2VmdWwgZm9yIHBhcnNpbmcgbWl4ZWQtbGFuZ3VhZ2UgZm9ybWF0c1xuICAvLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbiAgfVxuXG4gIC8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4gIC8vIFRoZSBgdG9rZW5pemVyYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICBleHBvcnRzLk5vZGUgPSBOb2RlO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuICBleHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG4gIGV4cG9ydHMuVG9rQ29udGV4dCA9IFRva0NvbnRleHQ7XG4gIGV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiAgZXhwb3J0cy5Ub2tlblR5cGUgPSBUb2tlblR5cGU7XG4gIGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGdldExpbmVJbmZvO1xuICBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuICBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gIGV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuICBleHBvcnRzLmtleXdvcmRUeXBlcyA9IGtleXdvcmRzO1xuICBleHBvcnRzLmxpbmVCcmVhayA9IGxpbmVCcmVhaztcbiAgZXhwb3J0cy5saW5lQnJlYWtHID0gbGluZUJyZWFrRztcbiAgZXhwb3J0cy5ub25BU0NJSXdoaXRlc3BhY2UgPSBub25BU0NJSXdoaXRlc3BhY2U7XG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgZXhwb3J0cy5wYXJzZUV4cHJlc3Npb25BdCA9IHBhcnNlRXhwcmVzc2lvbkF0O1xuICBleHBvcnRzLnRva0NvbnRleHRzID0gdHlwZXM7XG4gIGV4cG9ydHMudG9rVHlwZXMgPSB0eXBlcyQxO1xuICBleHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxufSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJhY29ybiIsImFzdHJhbElkZW50aWZpZXJDb2RlcyIsImFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzIiwibm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMiLCJub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzIiwicmVzZXJ2ZWRXb3JkcyIsInN0cmljdCIsInN0cmljdEJpbmQiLCJlY21hNUFuZExlc3NLZXl3b3JkcyIsImtleXdvcmRzJDEiLCJrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnQiLCJSZWdFeHAiLCJub25BU0NJSWlkZW50aWZpZXIiLCJpc0luQXN0cmFsU2V0IiwiY29kZSIsInNldCIsInBvcyIsImkiLCJsZW5ndGgiLCJpc0lkZW50aWZpZXJTdGFydCIsImFzdHJhbCIsInRlc3QiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpc0lkZW50aWZpZXJDaGFyIiwiVG9rZW5UeXBlIiwibGFiZWwiLCJjb25mIiwia2V5d29yZCIsImJlZm9yZUV4cHIiLCJzdGFydHNFeHByIiwiaXNMb29wIiwiaXNBc3NpZ24iLCJwcmVmaXgiLCJwb3N0Zml4IiwiYmlub3AiLCJ1cGRhdGVDb250ZXh0IiwibmFtZSIsInByZWMiLCJrZXl3b3JkcyIsImt3Iiwib3B0aW9ucyIsInR5cGVzJDEiLCJudW0iLCJyZWdleHAiLCJzdHJpbmciLCJwcml2YXRlSWQiLCJlb2YiLCJicmFja2V0TCIsImJyYWNrZXRSIiwiYnJhY2VMIiwiYnJhY2VSIiwicGFyZW5MIiwicGFyZW5SIiwiY29tbWEiLCJzZW1pIiwiY29sb24iLCJkb3QiLCJxdWVzdGlvbiIsInF1ZXN0aW9uRG90IiwiYXJyb3ciLCJ0ZW1wbGF0ZSIsImludmFsaWRUZW1wbGF0ZSIsImVsbGlwc2lzIiwiYmFja1F1b3RlIiwiZG9sbGFyQnJhY2VMIiwiZXEiLCJhc3NpZ24iLCJpbmNEZWMiLCJsb2dpY2FsT1IiLCJsb2dpY2FsQU5EIiwiYml0d2lzZU9SIiwiYml0d2lzZVhPUiIsImJpdHdpc2VBTkQiLCJlcXVhbGl0eSIsInJlbGF0aW9uYWwiLCJiaXRTaGlmdCIsInBsdXNNaW4iLCJtb2R1bG8iLCJzdGFyIiwic2xhc2giLCJzdGFyc3RhciIsImNvYWxlc2NlIiwiX2JyZWFrIiwiX2Nhc2UiLCJfY2F0Y2giLCJfY29udGludWUiLCJfZGVidWdnZXIiLCJfZGVmYXVsdCIsIl9kbyIsIl9lbHNlIiwiX2ZpbmFsbHkiLCJfZm9yIiwiX2Z1bmN0aW9uIiwiX2lmIiwiX3JldHVybiIsIl9zd2l0Y2giLCJfdGhyb3ciLCJfdHJ5IiwiX3ZhciIsIl9jb25zdCIsIl93aGlsZSIsIl93aXRoIiwiX25ldyIsIl90aGlzIiwiX3N1cGVyIiwiX2NsYXNzIiwiX2V4dGVuZHMiLCJfZXhwb3J0IiwiX2ltcG9ydCIsIl9udWxsIiwiX3RydWUiLCJfZmFsc2UiLCJfaW4iLCJfaW5zdGFuY2VvZiIsIl90eXBlb2YiLCJfdm9pZCIsIl9kZWxldGUiLCJsaW5lQnJlYWsiLCJsaW5lQnJlYWtHIiwic291cmNlIiwiaXNOZXdMaW5lIiwibmV4dExpbmVCcmVhayIsImZyb20iLCJlbmQiLCJuZXh0IiwiY2hhckNvZGVBdCIsIm5vbkFTQ0lJd2hpdGVzcGFjZSIsInNraXBXaGl0ZVNwYWNlIiwicmVmIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsImhhc093biIsIm9iaiIsInByb3BOYW1lIiwiY2FsbCIsImlzQXJyYXkiLCJBcnJheSIsInJlZ2V4cENhY2hlIiwiY3JlYXRlIiwid29yZHNSZWdleHAiLCJ3b3JkcyIsInJlcGxhY2UiLCJjb2RlUG9pbnRUb1N0cmluZyIsImxvbmVTdXJyb2dhdGUiLCJQb3NpdGlvbiIsImxpbmUiLCJjb2wiLCJjb2x1bW4iLCJvZmZzZXQiLCJuIiwiU291cmNlTG9jYXRpb24iLCJwIiwic3RhcnQiLCJzb3VyY2VGaWxlIiwiZ2V0TGluZUluZm8iLCJpbnB1dCIsImN1ciIsIm5leHRCcmVhayIsImRlZmF1bHRPcHRpb25zIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwib25JbnNlcnRlZFNlbWljb2xvbiIsIm9uVHJhaWxpbmdDb21tYSIsImFsbG93UmVzZXJ2ZWQiLCJhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbiIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24iLCJhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCIsImFsbG93SGFzaEJhbmciLCJjaGVja1ByaXZhdGVGaWVsZHMiLCJsb2NhdGlvbnMiLCJvblRva2VuIiwib25Db21tZW50IiwicmFuZ2VzIiwicHJvZ3JhbSIsImRpcmVjdFNvdXJjZUZpbGUiLCJwcmVzZXJ2ZVBhcmVucyIsIndhcm5lZEFib3V0RWNtYVZlcnNpb24iLCJnZXRPcHRpb25zIiwib3B0cyIsIm9wdCIsImNvbnNvbGUiLCJ3YXJuIiwidG9rZW5zIiwidG9rZW4iLCJwdXNoIiwicHVzaENvbW1lbnQiLCJhcnJheSIsImJsb2NrIiwidGV4dCIsInN0YXJ0TG9jIiwiZW5kTG9jIiwiY29tbWVudCIsInR5cGUiLCJ2YWx1ZSIsImxvYyIsInJhbmdlIiwiU0NPUEVfVE9QIiwiU0NPUEVfRlVOQ1RJT04iLCJTQ09QRV9BU1lOQyIsIlNDT1BFX0dFTkVSQVRPUiIsIlNDT1BFX0FSUk9XIiwiU0NPUEVfU0lNUExFX0NBVENIIiwiU0NPUEVfU1VQRVIiLCJTQ09QRV9ESVJFQ1RfU1VQRVIiLCJTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0siLCJTQ09QRV9WQVIiLCJmdW5jdGlvbkZsYWdzIiwiYXN5bmMiLCJnZW5lcmF0b3IiLCJCSU5EX05PTkUiLCJCSU5EX1ZBUiIsIkJJTkRfTEVYSUNBTCIsIkJJTkRfRlVOQ1RJT04iLCJCSU5EX1NJTVBMRV9DQVRDSCIsIkJJTkRfT1VUU0lERSIsIlBhcnNlciIsInN0YXJ0UG9zIiwicmVzZXJ2ZWQiLCJyZXNlcnZlZFN0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3QiLCJyZXNlcnZlZFdvcmRzU3RyaWN0QmluZCIsImNvbnRhaW5zRXNjIiwibGluZVN0YXJ0IiwibGFzdEluZGV4T2YiLCJjdXJMaW5lIiwic2xpY2UiLCJzcGxpdCIsImN1clBvc2l0aW9uIiwibGFzdFRva0VuZExvYyIsImxhc3RUb2tTdGFydExvYyIsImxhc3RUb2tTdGFydCIsImxhc3RUb2tFbmQiLCJjb250ZXh0IiwiaW5pdGlhbENvbnRleHQiLCJleHByQWxsb3dlZCIsImluTW9kdWxlIiwic3RyaWN0RGlyZWN0aXZlIiwicG90ZW50aWFsQXJyb3dBdCIsInBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCIsInlpZWxkUG9zIiwiYXdhaXRQb3MiLCJhd2FpdElkZW50UG9zIiwibGFiZWxzIiwidW5kZWZpbmVkRXhwb3J0cyIsInNraXBMaW5lQ29tbWVudCIsInNjb3BlU3RhY2siLCJlbnRlclNjb3BlIiwicmVnZXhwU3RhdGUiLCJwcml2YXRlTmFtZVN0YWNrIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiaW5GdW5jdGlvbiIsImNvbmZpZ3VyYWJsZSIsImluR2VuZXJhdG9yIiwiaW5Bc3luYyIsImNhbkF3YWl0IiwiYWxsb3dTdXBlciIsImFsbG93RGlyZWN0U3VwZXIiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFyIiwiYWxsb3dOZXdEb3RUYXJnZXQiLCJpbkNsYXNzU3RhdGljQmxvY2siLCJwYXJzZSIsIm5vZGUiLCJzdGFydE5vZGUiLCJuZXh0VG9rZW4iLCJwYXJzZVRvcExldmVsIiwiZ2V0IiwiY3VycmVudFZhclNjb3BlIiwiZmxhZ3MiLCJpbkNsYXNzRmllbGRJbml0Iiwic2NvcGUiLCJjdXJyZW50VGhpc1Njb3BlIiwidHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUiLCJjdXJyZW50U2NvcGUiLCJleHRlbmQiLCJwbHVnaW5zIiwibGVuIiwiYXJndW1lbnRzIiwiY2xzIiwicGFyc2VFeHByZXNzaW9uQXQiLCJwYXJzZXIiLCJwYXJzZUV4cHJlc3Npb24iLCJ0b2tlbml6ZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHAkOSIsImxpdGVyYWwiLCJsYXN0SW5kZXgiLCJleGVjIiwibWF0Y2giLCJzcGFjZUFmdGVyIiwiaW5kZXgiLCJjaGFyQXQiLCJlYXQiLCJpc0NvbnRleHR1YWwiLCJlYXRDb250ZXh0dWFsIiwiZXhwZWN0Q29udGV4dHVhbCIsInVuZXhwZWN0ZWQiLCJjYW5JbnNlcnRTZW1pY29sb24iLCJpbnNlcnRTZW1pY29sb24iLCJzZW1pY29sb24iLCJhZnRlclRyYWlsaW5nQ29tbWEiLCJ0b2tUeXBlIiwibm90TmV4dCIsImV4cGVjdCIsInJhaXNlIiwiRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInNob3J0aGFuZEFzc2lnbiIsInRyYWlsaW5nQ29tbWEiLCJwYXJlbnRoZXNpemVkQXNzaWduIiwicGFyZW50aGVzaXplZEJpbmQiLCJkb3VibGVQcm90byIsImNoZWNrUGF0dGVybkVycm9ycyIsInJlZkRlc3RydWN0dXJpbmdFcnJvcnMiLCJyYWlzZVJlY292ZXJhYmxlIiwicGFyZW5zIiwiY2hlY2tFeHByZXNzaW9uRXJyb3JzIiwiYW5kVGhyb3ciLCJjaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMiLCJpc1NpbXBsZUFzc2lnblRhcmdldCIsImV4cHIiLCJleHByZXNzaW9uIiwicHAkOCIsImJvZHkiLCJzdG10IiwicGFyc2VTdGF0ZW1lbnQiLCJsaXN0Iiwia2V5cyIsImFkYXB0RGlyZWN0aXZlUHJvbG9ndWUiLCJmaW5pc2hOb2RlIiwibG9vcExhYmVsIiwia2luZCIsInN3aXRjaExhYmVsIiwiaXNMZXQiLCJza2lwIiwibmV4dENoIiwiaWRlbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJhZnRlciIsInRvcExldmVsIiwic3RhcnR0eXBlIiwicGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQiLCJwYXJzZUNsYXNzIiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwicGFyc2VTd2l0Y2hTdGF0ZW1lbnQiLCJwYXJzZVRocm93U3RhdGVtZW50IiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJwYXJzZVZhclN0YXRlbWVudCIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZVdpdGhTdGF0ZW1lbnQiLCJwYXJzZUJsb2NrIiwicGFyc2VFbXB0eVN0YXRlbWVudCIsInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCIsInBhcnNlSW1wb3J0IiwicGFyc2VFeHBvcnQiLCJtYXliZU5hbWUiLCJwYXJzZUxhYmVsZWRTdGF0ZW1lbnQiLCJpc0JyZWFrIiwicGFyc2VJZGVudCIsImxhYiIsInBvcCIsInBhcnNlUGFyZW5FeHByZXNzaW9uIiwiYXdhaXRBdCIsInBhcnNlRm9yIiwiaW5pdCQxIiwicGFyc2VWYXIiLCJkZWNsYXJhdGlvbnMiLCJhd2FpdCIsInBhcnNlRm9ySW4iLCJzdGFydHNXaXRoTGV0IiwiaXNGb3JPZiIsImluaXQiLCJ0b0Fzc2lnbmFibGUiLCJjaGVja0xWYWxQYXR0ZXJuIiwiaXNBc3luYyIsImRlY2xhcmF0aW9uUG9zaXRpb24iLCJwYXJzZUZ1bmN0aW9uIiwiRlVOQ19TVEFURU1FTlQiLCJGVU5DX0hBTkdJTkdfU1RBVEVNRU5UIiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsImFyZ3VtZW50IiwiZGlzY3JpbWluYW50IiwiY2FzZXMiLCJzYXdEZWZhdWx0IiwiaXNDYXNlIiwiZXhpdFNjb3BlIiwiZW1wdHkkMSIsInBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSIsInBhcmFtIiwicGFyc2VCaW5kaW5nQXRvbSIsInNpbXBsZSIsImhhbmRsZXIiLCJjbGF1c2UiLCJmaW5hbGl6ZXIiLCJhbGxvd01pc3NpbmdJbml0aWFsaXplciIsIm9iamVjdCIsImkkMSIsImxhYmVsJDEiLCJzdGF0ZW1lbnRTdGFydCIsImluZGV4T2YiLCJjcmVhdGVOZXdMZXhpY2FsU2NvcGUiLCJleGl0U3RyaWN0IiwidXBkYXRlIiwiaXNGb3JJbiIsImlkIiwibGVmdCIsInJpZ2h0IiwicGFyc2VNYXliZUFzc2lnbiIsImlzRm9yIiwiZGVjbCIsInBhcnNlVmFySWQiLCJGVU5DX05VTExBQkxFX0lEIiwic3RhdGVtZW50IiwiYWxsb3dFeHByZXNzaW9uQm9keSIsImZvckluaXQiLCJpbml0RnVuY3Rpb24iLCJjaGVja0xWYWxTaW1wbGUiLCJvbGRZaWVsZFBvcyIsIm9sZEF3YWl0UG9zIiwib2xkQXdhaXRJZGVudFBvcyIsInBhcnNlRnVuY3Rpb25QYXJhbXMiLCJwYXJzZUZ1bmN0aW9uQm9keSIsInBhcmFtcyIsInBhcnNlQmluZGluZ0xpc3QiLCJpc1N0YXRlbWVudCIsIm9sZFN0cmljdCIsInBhcnNlQ2xhc3NJZCIsInBhcnNlQ2xhc3NTdXBlciIsInByaXZhdGVOYW1lTWFwIiwiZW50ZXJDbGFzc0JvZHkiLCJjbGFzc0JvZHkiLCJoYWRDb25zdHJ1Y3RvciIsImVsZW1lbnQiLCJwYXJzZUNsYXNzRWxlbWVudCIsInN1cGVyQ2xhc3MiLCJrZXkiLCJpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZCIsImV4aXRDbGFzc0JvZHkiLCJjb25zdHJ1Y3RvckFsbG93c1N1cGVyIiwia2V5TmFtZSIsImlzR2VuZXJhdG9yIiwiaXNTdGF0aWMiLCJwYXJzZUNsYXNzU3RhdGljQmxvY2siLCJpc0NsYXNzRWxlbWVudE5hbWVTdGFydCIsInN0YXRpYyIsImxhc3RWYWx1ZSIsImNvbXB1dGVkIiwic3RhcnROb2RlQXQiLCJwYXJzZUNsYXNzRWxlbWVudE5hbWUiLCJpc0NvbnN0cnVjdG9yIiwiY2hlY2tLZXlOYW1lIiwiYWxsb3dzRGlyZWN0U3VwZXIiLCJwYXJzZUNsYXNzTWV0aG9kIiwicGFyc2VDbGFzc0ZpZWxkIiwicGFyc2VQcml2YXRlSWRlbnQiLCJwYXJzZVByb3BlcnR5TmFtZSIsIm1ldGhvZCIsInBhcnNlTWV0aG9kIiwiZmllbGQiLCJvbGRMYWJlbHMiLCJwYXJzZUV4cHJTdWJzY3JpcHRzIiwiZGVjbGFyZWQiLCJ1c2VkIiwicGFyZW50IiwiY3VyciIsInBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJleHBvcnRlZCIsInBhcnNlTW9kdWxlRXhwb3J0TmFtZSIsImNoZWNrRXhwb3J0IiwicGFyc2VFeHByQXRvbSIsImRlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJzaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCIsInBhcnNlRXhwb3J0RGVjbGFyYXRpb24iLCJjaGVja1ZhcmlhYmxlRXhwb3J0Iiwic3BlY2lmaWVycyIsInBhcnNlRXhwb3J0U3BlY2lmaWVycyIsInNwZWMiLCJjaGVja1VucmVzZXJ2ZWQiLCJsb2NhbCIsImNoZWNrTG9jYWxFeHBvcnQiLCJmTm9kZSIsImNOb2RlIiwiY2hlY2tQYXR0ZXJuRXhwb3J0IiwicGF0IiwicHJvcGVydGllcyIsInByb3AiLCJsaXN0JDEiLCJlbGVtZW50cyIsImVsdCIsImRlY2xzIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJub2RlcyIsImZpcnN0IiwicGFyc2VJbXBvcnRTcGVjaWZpZXJzIiwicGFyc2VJbXBvcnRTcGVjaWZpZXIiLCJpbXBvcnRlZCIsInBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciIsInBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwic3RyaW5nTGl0ZXJhbCIsInBhcnNlTGl0ZXJhbCIsInN0YXRlbWVudHMiLCJpc0RpcmVjdGl2ZUNhbmRpZGF0ZSIsImRpcmVjdGl2ZSIsInJhdyIsInBwJDciLCJpc0JpbmRpbmciLCJ0b0Fzc2lnbmFibGVMaXN0Iiwib3BlcmF0b3IiLCJleHByTGlzdCIsImxhc3QiLCJwYXJzZVNwcmVhZCIsInBhcnNlUmVzdEJpbmRpbmciLCJwYXJzZU9iaiIsImNsb3NlIiwiYWxsb3dFbXB0eSIsImFsbG93VHJhaWxpbmdDb21tYSIsImFsbG93TW9kaWZpZXJzIiwiZWx0cyIsInJlc3QiLCJwYXJzZUJpbmRpbmdMaXN0SXRlbSIsInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtIiwiZWxlbSIsInBhcnNlTWF5YmVEZWZhdWx0IiwiYmluZGluZ1R5cGUiLCJjaGVja0NsYXNoZXMiLCJpc0JpbmQiLCJkZWNsYXJlTmFtZSIsImNoZWNrTFZhbElubmVyUGF0dGVybiIsIlRva0NvbnRleHQiLCJpc0V4cHIiLCJwcmVzZXJ2ZVNwYWNlIiwib3ZlcnJpZGUiLCJ0eXBlcyIsImJfc3RhdCIsImJfZXhwciIsImJfdG1wbCIsInBfc3RhdCIsInBfZXhwciIsInFfdG1wbCIsInRyeVJlYWRUZW1wbGF0ZVRva2VuIiwiZl9zdGF0IiwiZl9leHByIiwiZl9leHByX2dlbiIsImZfZ2VuIiwicHAkNiIsImN1ckNvbnRleHQiLCJicmFjZUlzQmxvY2siLCJwcmV2VHlwZSIsImluR2VuZXJhdG9yQ29udGV4dCIsIm92ZXJyaWRlQ29udGV4dCIsInRva2VuQ3R4Iiwib3V0Iiwic3RhdGVtZW50UGFyZW5zIiwiYWxsb3dlZCIsInBwJDUiLCJjaGVja1Byb3BDbGFzaCIsInByb3BIYXNoIiwic2hvcnRoYW5kIiwicHJvdG8iLCJvdGhlciIsInJlZGVmaW5pdGlvbiIsImV4cHJlc3Npb25zIiwiYWZ0ZXJMZWZ0UGFyc2UiLCJwYXJzZVlpZWxkIiwib3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsIm9sZFBhcmVuQXNzaWduIiwib2xkVHJhaWxpbmdDb21tYSIsIm9sZERvdWJsZVByb3RvIiwicGFyc2VNYXliZUNvbmRpdGlvbmFsIiwicGFyc2VFeHByT3BzIiwicGFyc2VNYXliZVVuYXJ5IiwicGFyc2VFeHByT3AiLCJsZWZ0U3RhcnRQb3MiLCJsZWZ0U3RhcnRMb2MiLCJtaW5QcmVjIiwibG9naWNhbCIsIm9wIiwiYnVpbGRCaW5hcnkiLCJzYXdVbmFyeSIsInBhcnNlQXdhaXQiLCJpc1ByaXZhdGVGaWVsZEFjY2VzcyIsIm5vZGUkMSIsInByb3BlcnR5IiwicmVzdWx0IiwicGFyc2VTdWJzY3JpcHRzIiwiYmFzZSIsIm5vQ2FsbHMiLCJtYXliZUFzeW5jQXJyb3ciLCJvcHRpb25hbENoYWluZWQiLCJwYXJzZVN1YnNjcmlwdCIsIm9wdGlvbmFsIiwiY2hhaW5Ob2RlIiwic2hvdWxkUGFyc2VBc3luY0Fycm93IiwicGFyc2VTdWJzY3JpcHRBc3luY0Fycm93IiwicGFyc2VBcnJvd0V4cHJlc3Npb24iLCJvcHRpb25hbFN1cHBvcnRlZCIsInBhcnNlRXhwckxpc3QiLCJjYWxsZWUiLCJub2RlJDIiLCJ0YWciLCJxdWFzaSIsInBhcnNlVGVtcGxhdGUiLCJpc1RhZ2dlZCIsImZvck5ldyIsInJlYWRSZWdleHAiLCJjYW5CZUFycm93IiwicmVnZXgiLCJwYXR0ZXJuIiwicGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiIsInBhcnNlTmV3IiwicGFyc2VFeHBySW1wb3J0IiwicGFyc2VFeHByQXRvbURlZmF1bHQiLCJtZXRhIiwicGFyc2VEeW5hbWljSW1wb3J0IiwicGFyc2VJbXBvcnRNZXRhIiwiZXJyb3JQb3MiLCJiaWdpbnQiLCJ2YWwiLCJzaG91bGRQYXJzZUFycm93IiwiaW5uZXJTdGFydFBvcyIsImlubmVyU3RhcnRMb2MiLCJsYXN0SXNDb21tYSIsInNwcmVhZFN0YXJ0IiwicGFyc2VQYXJlbkl0ZW0iLCJpbm5lckVuZFBvcyIsImlubmVyRW5kTG9jIiwicGFyc2VQYXJlbkFycm93TGlzdCIsImZpbmlzaE5vZGVBdCIsInBhciIsIml0ZW0iLCJlbXB0eSIsInBhcnNlVGVtcGxhdGVFbGVtZW50IiwiY29va2VkIiwidGFpbCIsImN1ckVsdCIsInF1YXNpcyIsImlzQXN5bmNQcm9wIiwiaXNQYXR0ZXJuIiwicGFyc2VQcm9wZXJ0eSIsInBhcnNlUHJvcGVydHlWYWx1ZSIsInBhcnNlR2V0dGVyU2V0dGVyIiwicGFyYW1Db3VudCIsImNvcHlOb2RlIiwiaXNBcnJvd0Z1bmN0aW9uIiwiaXNNZXRob2QiLCJpc0V4cHJlc3Npb24iLCJ1c2VTdHJpY3QiLCJjaGVja1BhcmFtcyIsIm5vblNpbXBsZSIsImlzU2ltcGxlUGFyYW1MaXN0IiwidW5kZWZpbmVkIiwiYWxsb3dEdXBsaWNhdGVzIiwibmFtZUhhc2giLCJyZSIsImxpYmVyYWwiLCJwYXJzZUlkZW50Tm9kZSIsImRlbGVnYXRlIiwicHAkNCIsIm1lc3NhZ2UiLCJlcnIiLCJTeW50YXhFcnJvciIsInJhaXNlZEF0IiwicHAkMyIsIlNjb3BlIiwidmFyIiwibGV4aWNhbCIsImZ1bmN0aW9ucyIsInJlZGVjbGFyZWQiLCJzY29wZSQxIiwic2NvcGUkMiIsInNjb3BlJDMiLCJOb2RlIiwicHAkMiIsIm5ld05vZGUiLCJlY21hOUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTBCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTExQmluYXJ5UHJvcGVydGllcyIsImVjbWExMkJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTNCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllcyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzIiwidW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyIsImVjbWE5U2NyaXB0VmFsdWVzIiwiZWNtYTEwU2NyaXB0VmFsdWVzIiwiZWNtYTExU2NyaXB0VmFsdWVzIiwiZWNtYTEyU2NyaXB0VmFsdWVzIiwiZWNtYTEzU2NyaXB0VmFsdWVzIiwiZWNtYTE0U2NyaXB0VmFsdWVzIiwidW5pY29kZVNjcmlwdFZhbHVlcyIsImRhdGEiLCJidWlsZFVuaWNvZGVEYXRhIiwiZCIsImJpbmFyeSIsImJpbmFyeU9mU3RyaW5ncyIsIm5vbkJpbmFyeSIsIkdlbmVyYWxfQ2F0ZWdvcnkiLCJTY3JpcHQiLCJTY3JpcHRfRXh0ZW5zaW9ucyIsImdjIiwic2MiLCJzY3giLCJwcCQxIiwiUmVnRXhwVmFsaWRhdGlvblN0YXRlIiwidmFsaWRGbGFncyIsInVuaWNvZGVQcm9wZXJ0aWVzIiwic3dpdGNoVSIsInN3aXRjaFYiLCJzd2l0Y2hOIiwibGFzdEludFZhbHVlIiwibGFzdFN0cmluZ1ZhbHVlIiwibGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlIiwibnVtQ2FwdHVyaW5nUGFyZW5zIiwibWF4QmFja1JlZmVyZW5jZSIsImdyb3VwTmFtZXMiLCJiYWNrUmVmZXJlbmNlTmFtZXMiLCJyZXNldCIsInVuaWNvZGVTZXRzIiwidW5pY29kZSIsImF0IiwiZm9yY2VVIiwicyIsImwiLCJjIiwibmV4dEluZGV4IiwiY3VycmVudCIsImxvb2thaGVhZCIsImFkdmFuY2UiLCJjaCIsImVhdENoYXJzIiwiY2hzIiwidmFsaWRhdGVSZWdFeHBGbGFncyIsInN0YXRlIiwidSIsInYiLCJmbGFnIiwidmFsaWRhdGVSZWdFeHBQYXR0ZXJuIiwicmVnZXhwX3BhdHRlcm4iLCJyZWdleHBfZGlzanVuY3Rpb24iLCJyZWdleHBfYWx0ZXJuYXRpdmUiLCJyZWdleHBfZWF0UXVhbnRpZmllciIsInJlZ2V4cF9lYXRUZXJtIiwicmVnZXhwX2VhdEFzc2VydGlvbiIsInJlZ2V4cF9lYXRBdG9tIiwicmVnZXhwX2VhdEV4dGVuZGVkQXRvbSIsImxvb2tiZWhpbmQiLCJub0Vycm9yIiwicmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgiLCJyZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciIsIm1pbiIsIm1heCIsInJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzIiwicmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzIiwicmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyIsInJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdEF0b21Fc2NhcGUiLCJyZWdleHBfZ3JvdXBTcGVjaWZpZXIiLCJyZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIiLCJyZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyIiwicmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciIsImlzU3ludGF4Q2hhcmFjdGVyIiwicmVnZXhwX2VhdEdyb3VwTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQiLCJyZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlIiwiaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJpc1JlZ0V4cElkZW50aWZpZXJQYXJ0IiwicmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UiLCJyZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUiLCJyZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlIiwicmVnZXhwX2VhdEtHcm91cE5hbWUiLCJyZWdleHBfZWF0RGVjaW1hbEVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sRXNjYXBlIiwicmVnZXhwX2VhdENDb250cm9sTGV0dGVyIiwicmVnZXhwX2VhdFplcm8iLCJyZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UiLCJyZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSIsInJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sTGV0dGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0NvbnRyb2xMZXR0ZXIiLCJyZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMiLCJsZWFkIiwibGVhZFN1cnJvZ2F0ZUVuZCIsInRyYWlsIiwicmVnZXhwX2VhdEhleERpZ2l0cyIsImlzVmFsaWRVbmljb2RlIiwiQ2hhclNldE5vbmUiLCJDaGFyU2V0T2siLCJDaGFyU2V0U3RyaW5nIiwiaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZSIsIm5lZ2F0ZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24iLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSIsInJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUiLCJuYW1lT3JWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIiwiaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyIiwiaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlciIsInJlZ2V4cF9jbGFzc0NvbnRlbnRzIiwicmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbiIsInJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzIiwicmVnZXhwX2VhdENsYXNzQXRvbSIsInJlZ2V4cF9lYXRDbGFzc0VzY2FwZSIsImNoJDEiLCJpc09jdGFsRGlnaXQiLCJyZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyIiwic3ViUmVzdWx0IiwicmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UiLCJyZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kIiwicmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyIiwicmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24iLCJyZWdleHBfZWF0TmVzdGVkQ2xhc3MiLCJyZXN1bHQkMSIsInJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMiLCJyZWdleHBfY2xhc3NTdHJpbmciLCJjb3VudCIsInJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIiLCJpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyIiwiaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzSGV4RGlnaXQiLCJoZXhUb0ludCIsInJlZ2V4cF9lYXRPY3RhbERpZ2l0IiwibjEiLCJuMiIsIlRva2VuIiwicHAiLCJpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCIsImdldFRva2VuIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0aGlzJDEkMSIsImRvbmUiLCJza2lwU3BhY2UiLCJmaW5pc2hUb2tlbiIsInJlYWRUb2tlbiIsImZ1bGxDaGFyQ29kZUF0UG9zIiwicmVhZFdvcmQiLCJnZXRUb2tlbkZyb21Db2RlIiwic2tpcEJsb2NrQ29tbWVudCIsInN0YXJ0U2tpcCIsImxvb3AiLCJyZWFkVG9rZW5fZG90IiwicmVhZE51bWJlciIsIm5leHQyIiwicmVhZFRva2VuX3NsYXNoIiwiZmluaXNoT3AiLCJyZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwIiwic2l6ZSIsInRva2VudHlwZSIsInJlYWRUb2tlbl9waXBlX2FtcCIsInJlYWRUb2tlbl9jYXJldCIsInJlYWRUb2tlbl9wbHVzX21pbiIsInJlYWRUb2tlbl9sdF9ndCIsInJlYWRUb2tlbl9lcV9leGNsIiwicmVhZFRva2VuX3F1ZXN0aW9uIiwibmV4dDIkMSIsInJlYWRUb2tlbl9udW1iZXJTaWduIiwicmVhZFdvcmQxIiwicmVhZFJhZGl4TnVtYmVyIiwicmVhZFN0cmluZyIsInN0ciIsImVzY2FwZWQiLCJpbkNsYXNzIiwiZmxhZ3NTdGFydCIsImUiLCJyZWFkSW50IiwicmFkaXgiLCJtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJhbGxvd1NlcGFyYXRvcnMiLCJpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJ0b3RhbCIsImxhc3RDb2RlIiwiSW5maW5pdHkiLCJzdHJpbmdUb051bWJlciIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsInN0cmluZ1RvQmlnSW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aERvdCIsIm9jdGFsIiwidmFsJDEiLCJyZWFkQ29kZVBvaW50IiwiY29kZVBvcyIsInJlYWRIZXhDaGFyIiwiaW52YWxpZFN0cmluZ1Rva2VuIiwicXVvdGUiLCJjaHVua1N0YXJ0IiwicmVhZEVzY2FwZWRDaGFyIiwiSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IiLCJpblRlbXBsYXRlRWxlbWVudCIsInJlYWRUbXBsVG9rZW4iLCJyZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4iLCJwb3NpdGlvbiIsImluVGVtcGxhdGUiLCJvY3RhbFN0ciIsInN1YnN0ciIsIndvcmQiLCJlc2NTdGFydCIsImVzYyIsInZlcnNpb24iLCJ0b2tUeXBlcyIsImtleXdvcmRUeXBlcyIsInRva0NvbnRleHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/acorn/dist/acorn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   SourceLocation: () => (/* binding */ SourceLocation),\n/* harmony export */   TokContext: () => (/* binding */ TokContext),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),\n/* harmony export */   getLineInfo: () => (/* binding */ getLineInfo),\n/* harmony export */   isIdentifierChar: () => (/* binding */ isIdentifierChar),\n/* harmony export */   isIdentifierStart: () => (/* binding */ isIdentifierStart),\n/* harmony export */   isNewLine: () => (/* binding */ isNewLine),\n/* harmony export */   keywordTypes: () => (/* binding */ keywords),\n/* harmony export */   lineBreak: () => (/* binding */ lineBreak),\n/* harmony export */   lineBreakG: () => (/* binding */ lineBreakG),\n/* harmony export */   nonASCIIwhitespace: () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseExpressionAt: () => (/* binding */ parseExpressionAt),\n/* harmony export */   tokContexts: () => (/* binding */ types),\n/* harmony export */   tokTypes: () => (/* binding */ types$1),\n/* harmony export */   tokenizer: () => (/* binding */ tokenizer),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [\n    509,\n    0,\n    227,\n    0,\n    150,\n    4,\n    294,\n    9,\n    1368,\n    2,\n    2,\n    1,\n    6,\n    3,\n    41,\n    2,\n    5,\n    0,\n    166,\n    1,\n    574,\n    3,\n    9,\n    9,\n    370,\n    1,\n    81,\n    2,\n    71,\n    10,\n    50,\n    3,\n    123,\n    2,\n    54,\n    14,\n    32,\n    10,\n    3,\n    1,\n    11,\n    3,\n    46,\n    10,\n    8,\n    0,\n    46,\n    9,\n    7,\n    2,\n    37,\n    13,\n    2,\n    9,\n    6,\n    1,\n    45,\n    0,\n    13,\n    2,\n    49,\n    13,\n    9,\n    3,\n    2,\n    11,\n    83,\n    11,\n    7,\n    0,\n    3,\n    0,\n    158,\n    11,\n    6,\n    9,\n    7,\n    3,\n    56,\n    1,\n    2,\n    6,\n    3,\n    1,\n    3,\n    2,\n    10,\n    0,\n    11,\n    1,\n    3,\n    6,\n    4,\n    4,\n    193,\n    17,\n    10,\n    9,\n    5,\n    0,\n    82,\n    19,\n    13,\n    9,\n    214,\n    6,\n    3,\n    8,\n    28,\n    1,\n    83,\n    16,\n    16,\n    9,\n    82,\n    12,\n    9,\n    9,\n    84,\n    14,\n    5,\n    9,\n    243,\n    14,\n    166,\n    9,\n    71,\n    5,\n    2,\n    1,\n    3,\n    3,\n    2,\n    0,\n    2,\n    1,\n    13,\n    9,\n    120,\n    6,\n    3,\n    6,\n    4,\n    0,\n    29,\n    9,\n    41,\n    6,\n    2,\n    3,\n    9,\n    0,\n    10,\n    10,\n    47,\n    15,\n    406,\n    7,\n    2,\n    7,\n    17,\n    9,\n    57,\n    21,\n    2,\n    13,\n    123,\n    5,\n    4,\n    0,\n    2,\n    1,\n    2,\n    6,\n    2,\n    0,\n    9,\n    9,\n    49,\n    4,\n    2,\n    1,\n    2,\n    4,\n    9,\n    9,\n    330,\n    3,\n    10,\n    1,\n    2,\n    0,\n    49,\n    6,\n    4,\n    4,\n    14,\n    9,\n    5351,\n    0,\n    7,\n    14,\n    13835,\n    9,\n    87,\n    9,\n    39,\n    4,\n    60,\n    6,\n    26,\n    9,\n    1014,\n    0,\n    2,\n    54,\n    8,\n    3,\n    82,\n    0,\n    12,\n    1,\n    19628,\n    1,\n    4706,\n    45,\n    3,\n    22,\n    543,\n    4,\n    4,\n    5,\n    9,\n    7,\n    3,\n    6,\n    31,\n    3,\n    149,\n    2,\n    1418,\n    49,\n    513,\n    54,\n    5,\n    49,\n    9,\n    0,\n    15,\n    0,\n    23,\n    4,\n    2,\n    14,\n    1361,\n    6,\n    2,\n    16,\n    3,\n    6,\n    2,\n    1,\n    2,\n    4,\n    101,\n    0,\n    161,\n    6,\n    10,\n    9,\n    357,\n    0,\n    62,\n    13,\n    499,\n    13,\n    983,\n    6,\n    110,\n    6,\n    6,\n    9,\n    4759,\n    9,\n    787719,\n    239\n];\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [\n    0,\n    11,\n    2,\n    25,\n    2,\n    18,\n    2,\n    1,\n    2,\n    14,\n    3,\n    13,\n    35,\n    122,\n    70,\n    52,\n    268,\n    28,\n    4,\n    48,\n    48,\n    31,\n    14,\n    29,\n    6,\n    37,\n    11,\n    29,\n    3,\n    35,\n    5,\n    7,\n    2,\n    4,\n    43,\n    157,\n    19,\n    35,\n    5,\n    35,\n    5,\n    39,\n    9,\n    51,\n    13,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    2,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    68,\n    310,\n    10,\n    21,\n    11,\n    7,\n    25,\n    5,\n    2,\n    41,\n    2,\n    8,\n    70,\n    5,\n    3,\n    0,\n    2,\n    43,\n    2,\n    1,\n    4,\n    0,\n    3,\n    22,\n    11,\n    22,\n    10,\n    30,\n    66,\n    18,\n    2,\n    1,\n    11,\n    21,\n    11,\n    25,\n    71,\n    55,\n    7,\n    1,\n    65,\n    0,\n    16,\n    3,\n    2,\n    2,\n    2,\n    28,\n    43,\n    28,\n    4,\n    28,\n    36,\n    7,\n    2,\n    27,\n    28,\n    53,\n    11,\n    21,\n    11,\n    18,\n    14,\n    17,\n    111,\n    72,\n    56,\n    50,\n    14,\n    50,\n    14,\n    35,\n    349,\n    41,\n    7,\n    1,\n    79,\n    28,\n    11,\n    0,\n    9,\n    21,\n    43,\n    17,\n    47,\n    20,\n    28,\n    22,\n    13,\n    52,\n    58,\n    1,\n    3,\n    0,\n    14,\n    44,\n    33,\n    24,\n    27,\n    35,\n    30,\n    0,\n    3,\n    0,\n    9,\n    34,\n    4,\n    0,\n    13,\n    47,\n    15,\n    3,\n    22,\n    0,\n    2,\n    0,\n    36,\n    17,\n    2,\n    24,\n    20,\n    1,\n    64,\n    6,\n    2,\n    0,\n    2,\n    3,\n    2,\n    14,\n    2,\n    9,\n    8,\n    46,\n    39,\n    7,\n    3,\n    1,\n    3,\n    21,\n    2,\n    6,\n    2,\n    1,\n    2,\n    4,\n    4,\n    0,\n    19,\n    0,\n    13,\n    4,\n    159,\n    52,\n    19,\n    3,\n    21,\n    2,\n    31,\n    47,\n    21,\n    1,\n    2,\n    0,\n    185,\n    46,\n    42,\n    3,\n    37,\n    47,\n    21,\n    0,\n    60,\n    42,\n    14,\n    0,\n    72,\n    26,\n    38,\n    6,\n    186,\n    43,\n    117,\n    63,\n    32,\n    7,\n    3,\n    0,\n    3,\n    7,\n    2,\n    1,\n    2,\n    23,\n    16,\n    0,\n    2,\n    0,\n    95,\n    7,\n    3,\n    38,\n    17,\n    0,\n    2,\n    0,\n    29,\n    0,\n    11,\n    39,\n    8,\n    0,\n    22,\n    0,\n    12,\n    45,\n    20,\n    0,\n    19,\n    72,\n    264,\n    8,\n    2,\n    36,\n    18,\n    0,\n    50,\n    29,\n    113,\n    6,\n    2,\n    1,\n    2,\n    37,\n    22,\n    0,\n    26,\n    5,\n    2,\n    1,\n    2,\n    31,\n    15,\n    0,\n    328,\n    18,\n    16,\n    0,\n    2,\n    12,\n    2,\n    33,\n    125,\n    0,\n    80,\n    921,\n    103,\n    110,\n    18,\n    195,\n    2637,\n    96,\n    16,\n    1071,\n    18,\n    5,\n    4026,\n    582,\n    8634,\n    568,\n    8,\n    30,\n    18,\n    78,\n    18,\n    29,\n    19,\n    47,\n    17,\n    3,\n    32,\n    20,\n    6,\n    18,\n    689,\n    63,\n    129,\n    74,\n    6,\n    0,\n    67,\n    12,\n    65,\n    1,\n    2,\n    0,\n    29,\n    6135,\n    9,\n    1237,\n    43,\n    8,\n    8936,\n    3,\n    2,\n    6,\n    2,\n    1,\n    2,\n    290,\n    16,\n    0,\n    30,\n    2,\n    3,\n    0,\n    15,\n    3,\n    9,\n    395,\n    2309,\n    106,\n    6,\n    12,\n    4,\n    8,\n    8,\n    9,\n    5991,\n    84,\n    2,\n    70,\n    2,\n    1,\n    3,\n    0,\n    3,\n    1,\n    3,\n    3,\n    2,\n    11,\n    2,\n    0,\n    2,\n    6,\n    2,\n    64,\n    2,\n    3,\n    3,\n    7,\n    2,\n    6,\n    2,\n    27,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    4,\n    6,\n    2,\n    339,\n    3,\n    24,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    7,\n    1845,\n    30,\n    7,\n    5,\n    262,\n    61,\n    147,\n    44,\n    11,\n    6,\n    17,\n    0,\n    322,\n    29,\n    19,\n    43,\n    485,\n    27,\n    757,\n    6,\n    2,\n    3,\n    2,\n    1,\n    2,\n    14,\n    2,\n    196,\n    60,\n    67,\n    8,\n    0,\n    1205,\n    3,\n    2,\n    26,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    9,\n    2,\n    3,\n    2,\n    0,\n    2,\n    0,\n    7,\n    0,\n    5,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    2,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    1,\n    2,\n    0,\n    3,\n    3,\n    2,\n    6,\n    2,\n    3,\n    2,\n    3,\n    2,\n    0,\n    2,\n    9,\n    2,\n    16,\n    6,\n    2,\n    2,\n    4,\n    2,\n    16,\n    4421,\n    42719,\n    33,\n    4153,\n    7,\n    221,\n    3,\n    5761,\n    15,\n    7472,\n    16,\n    621,\n    2467,\n    541,\n    1507,\n    4938,\n    6,\n    4191\n];\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･\";\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n// Reserved word lists for various dialects of the language\nvar reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n};\n// And the keywords\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords$1 = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n// ## Character categories\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for(var i = 0; i < set.length; i += 2){\n        pos += set[i];\n        if (pos > code) {\n            return false;\n        }\n        pos += set[i + 1];\n        if (pos >= code) {\n            return true;\n        }\n    }\n    return false;\n}\n// Test whether a given character code starts an identifier.\nfunction isIdentifierStart(code, astral) {\n    if (code < 65) {\n        return code === 36;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes);\n}\n// Test whether a given character is part of an identifier.\nfunction isIdentifierChar(code, astral) {\n    if (code < 48) {\n        return code === 36;\n    }\n    if (code < 58) {\n        return true;\n    }\n    if (code < 65) {\n        return false;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n// ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\nvar TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n};\nfunction binop(name, prec) {\n    return new TokenType(name, {\n        beforeExpr: true,\n        binop: prec\n    });\n}\nvar beforeExpr = {\n    beforeExpr: true\n}, startsExpr = {\n    startsExpr: true\n};\n// Map keyword names to token types.\nvar keywords = {};\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywords[name] = new TokenType(name, options);\n}\nvar types$1 = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    privateId: new TokenType(\"privateId\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    questionDot: new TokenType(\"?.\"),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n        prefix: true,\n        postfix: true,\n        startsExpr: true\n    }),\n    prefix: new TokenType(\"!/~\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n        beforeExpr: true,\n        binop: 9,\n        prefix: true,\n        startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n        beforeExpr: true\n    }),\n    coalesce: binop(\"??\", 1),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n        isLoop: true,\n        beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n        isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n        isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _void: kw(\"void\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    })\n};\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nfunction nextLineBreak(code, from, end) {\n    if (end === void 0) end = code.length;\n    for(var i = from; i < end; i++){\n        var next = code.charCodeAt(i);\n        if (isNewLine(next)) {\n            return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n        }\n    }\n    return -1;\n}\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\nvar hasOwn = Object.hasOwn || function(obj, propName) {\n    return hasOwnProperty.call(obj, propName);\n};\nvar isArray = Array.isArray || function(obj) {\n    return toString.call(obj) === \"[object Array]\";\n};\nvar regexpCache = Object.create(null);\nfunction wordsRegexp(words) {\n    return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"));\n}\nfunction codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) {\n        return String.fromCharCode(code);\n    }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\nvar Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n};\nPosition.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n};\nvar SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) {\n        this.source = p.sourceFile;\n    }\n};\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\nfunction getLineInfo(input, offset) {\n    for(var line = 1, cur = 0;;){\n        var nextBreak = nextLineBreak(input, cur, offset);\n        if (nextBreak < 0) {\n            return new Position(line, offset - cur);\n        }\n        ++line;\n        cur = nextBreak;\n    }\n}\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\nvar defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n    // (the latest version the library supports). This influences\n    // support for strict mode, the set of reserved words, and support\n    // for new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called when\n    // a semicolon is automatically inserted. It will be passed the\n    // position of the inserted semicolon as an offset, and if\n    // `locations` is enabled, it is given the location as a `{line,\n    // column}` object as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file is\n    // allowed and treated as a line comment. Enabled by default when\n    // `ecmaVersion` >= 2023.\n    allowHashBang: false,\n    // By default, the parser will verify that private properties are\n    // only used in places where they are valid and have been declared.\n    // Set this to false to turn such checks off.\n    checkPrivateFields: true,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    // When this option has an array as value, objects representing the\n    // comments are pushed to it.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n};\n// Interpret and default an options object\nvar warnedAboutEcmaVersion = false;\nfunction getOptions(opts) {\n    var options = {};\n    for(var opt in defaultOptions){\n        options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n    }\n    if (options.ecmaVersion === \"latest\") {\n        options.ecmaVersion = 1e8;\n    } else if (options.ecmaVersion == null) {\n        if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n            warnedAboutEcmaVersion = true;\n            console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n        }\n        options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) {\n        options.ecmaVersion -= 2009;\n    }\n    if (options.allowReserved == null) {\n        options.allowReserved = options.ecmaVersion < 5;\n    }\n    if (!opts || opts.allowHashBang == null) {\n        options.allowHashBang = options.ecmaVersion >= 14;\n    }\n    if (isArray(options.onToken)) {\n        var tokens = options.onToken;\n        options.onToken = function(token) {\n            return tokens.push(token);\n        };\n    }\n    if (isArray(options.onComment)) {\n        options.onComment = pushComment(options, options.onComment);\n    }\n    return options;\n}\nfunction pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n        var comment = {\n            type: block ? \"Block\" : \"Line\",\n            value: text,\n            start: start,\n            end: end\n        };\n        if (options.locations) {\n            comment.loc = new SourceLocation(this, startLoc, endLoc);\n        }\n        if (options.ranges) {\n            comment.range = [\n                start,\n                end\n            ];\n        }\n        array.push(comment);\n    };\n}\n// Each scope gets a bitset that may contain these flags\nvar SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\nfunction functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n}\n// Used in checkLVal* and declareName to determine the type of a binding\nvar BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\nvar Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n        if (options.sourceType === \"module\") {\n            reserved += \" await\";\n        }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n    // Set up token state\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n        this.pos = startPos;\n        this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n        this.pos = this.lineStart = 0;\n        this.curLine = 1;\n    }\n    // Properties of the current token:\n    // Its type\n    this.type = types$1.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n        this.skipLineComment(2);\n    }\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n    // For RegExp validation\n    this.regexpState = null;\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n};\nvar prototypeAccessors = {\n    inFunction: {\n        configurable: true\n    },\n    inGenerator: {\n        configurable: true\n    },\n    inAsync: {\n        configurable: true\n    },\n    canAwait: {\n        configurable: true\n    },\n    allowSuper: {\n        configurable: true\n    },\n    allowDirectSuper: {\n        configurable: true\n    },\n    treatFunctionsAsVar: {\n        configurable: true\n    },\n    allowNewDotTarget: {\n        configurable: true\n    },\n    inClassStaticBlock: {\n        configurable: true\n    }\n};\nParser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n};\nprototypeAccessors.inFunction.get = function() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n};\nprototypeAccessors.inGenerator.get = function() {\n    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n};\nprototypeAccessors.inAsync.get = function() {\n    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n};\nprototypeAccessors.canAwait.get = function() {\n    for(var i = this.scopeStack.length - 1; i >= 0; i--){\n        var scope = this.scopeStack[i];\n        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {\n            return false;\n        }\n        if (scope.flags & SCOPE_FUNCTION) {\n            return (scope.flags & SCOPE_ASYNC) > 0;\n        }\n    }\n    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n};\nprototypeAccessors.allowSuper.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n};\nprototypeAccessors.allowDirectSuper.get = function() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n};\nprototypeAccessors.treatFunctionsAsVar.get = function() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n};\nprototypeAccessors.allowNewDotTarget.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n};\nprototypeAccessors.inClassStaticBlock.get = function() {\n    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n};\nParser.extend = function extend() {\n    var plugins = [], len = arguments.length;\n    while(len--)plugins[len] = arguments[len];\n    var cls = this;\n    for(var i = 0; i < plugins.length; i++){\n        cls = plugins[i](cls);\n    }\n    return cls;\n};\nParser.parse = function parse(input, options) {\n    return new this(options, input).parse();\n};\nParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression();\n};\nParser.tokenizer = function tokenizer(input, options) {\n    return new this(options, input);\n};\nObject.defineProperties(Parser.prototype, prototypeAccessors);\nvar pp$9 = Parser.prototype;\n// ## Parser utilities\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) {\n        return false;\n    }\n    for(;;){\n        // Try to find string literal.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        var match = literal.exec(this.input.slice(start));\n        if (!match) {\n            return false;\n        }\n        if ((match[1] || match[2]) === \"use strict\") {\n            skipWhiteSpace.lastIndex = start + match[0].length;\n            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n            var next = this.input.charAt(end);\n            return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n        }\n        start += match[0].length;\n        // Skip semicolon, if any.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        if (this.input[start] === \";\") {\n            start++;\n        }\n    }\n};\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\npp$9.eat = function(type) {\n    if (this.type === type) {\n        this.next();\n        return true;\n    } else {\n        return false;\n    }\n};\n// Tests whether parsed token is a contextual keyword.\npp$9.isContextual = function(name) {\n    return this.type === types$1.name && this.value === name && !this.containsEsc;\n};\n// Consumes contextual keyword if possible.\npp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) {\n        return false;\n    }\n    this.next();\n    return true;\n};\n// Asserts that following token is given contextual keyword.\npp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) {\n        this.unexpected();\n    }\n};\n// Test whether a semicolon can be inserted at the current position.\npp$9.canInsertSemicolon = function() {\n    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\npp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n        if (this.options.onInsertedSemicolon) {\n            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n        }\n        return true;\n    }\n};\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\npp$9.semicolon = function() {\n    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n        this.unexpected();\n    }\n};\npp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n        if (this.options.onTrailingComma) {\n            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n        }\n        if (!notNext) {\n            this.next();\n        }\n        return true;\n    }\n};\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\npp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n};\n// Raise an unexpected token error.\npp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\nvar DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n};\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) {\n        return;\n    }\n    if (refDestructuringErrors.trailingComma > -1) {\n        this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) {\n        this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n    }\n};\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) {\n        return false;\n    }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) {\n        return shorthandAssign >= 0 || doubleProto >= 0;\n    }\n    if (shorthandAssign >= 0) {\n        this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n    }\n    if (doubleProto >= 0) {\n        this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n    }\n};\npp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n        this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    }\n    if (this.awaitPos) {\n        this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n    }\n};\npp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\") {\n        return this.isSimpleAssignTarget(expr.expression);\n    }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\nvar pp$8 = Parser.prototype;\n// ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\npp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) {\n        node.body = [];\n    }\n    while(this.type !== types$1.eof){\n        var stmt = this.parseStatement(null, true, exports);\n        node.body.push(stmt);\n    }\n    if (this.inModule) {\n        for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n            var name = list[i];\n            this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n        }\n    }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\");\n};\nvar loopLabel = {\n    kind: \"loop\"\n}, switchLabel = {\n    kind: \"switch\"\n};\npp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92) {\n        return true;\n    } // '[', '/'\n    if (context) {\n        return false;\n    }\n    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n        return true;\n    } // '{', astral\n    if (isIdentifierStart(nextCh, true)) {\n        var pos = next + 1;\n        while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n            ++pos;\n        }\n        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        }\n        var ident = this.input.slice(next, pos);\n        if (!keywordRelationalOperator.test(ident)) {\n            return true;\n        }\n    }\n    return false;\n};\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n};\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\npp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n    if (this.isLet(context)) {\n        starttype = types$1._var;\n        kind = \"let\";\n    }\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n    switch(starttype){\n        case types$1._break:\n        case types$1._continue:\n            return this.parseBreakContinueStatement(node, starttype.keyword);\n        case types$1._debugger:\n            return this.parseDebuggerStatement(node);\n        case types$1._do:\n            return this.parseDoStatement(node);\n        case types$1._for:\n            return this.parseForStatement(node);\n        case types$1._function:\n            // Function as sole body of either an if statement or a labeled statement\n            // works, but not when it is part of a labeled statement that is the sole\n            // body of an if statement.\n            if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                this.unexpected();\n            }\n            return this.parseFunctionStatement(node, false, !context);\n        case types$1._class:\n            if (context) {\n                this.unexpected();\n            }\n            return this.parseClass(node, true);\n        case types$1._if:\n            return this.parseIfStatement(node);\n        case types$1._return:\n            return this.parseReturnStatement(node);\n        case types$1._switch:\n            return this.parseSwitchStatement(node);\n        case types$1._throw:\n            return this.parseThrowStatement(node);\n        case types$1._try:\n            return this.parseTryStatement(node);\n        case types$1._const:\n        case types$1._var:\n            kind = kind || this.value;\n            if (context && kind !== \"var\") {\n                this.unexpected();\n            }\n            return this.parseVarStatement(node, kind);\n        case types$1._while:\n            return this.parseWhileStatement(node);\n        case types$1._with:\n            return this.parseWithStatement(node);\n        case types$1.braceL:\n            return this.parseBlock(true, node);\n        case types$1.semi:\n            return this.parseEmptyStatement(node);\n        case types$1._export:\n        case types$1._import:\n            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                skipWhiteSpace.lastIndex = this.pos;\n                var skip = skipWhiteSpace.exec(this.input);\n                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                if (nextCh === 40 || nextCh === 46) {\n                    return this.parseExpressionStatement(node, this.parseExpression());\n                }\n            }\n            if (!this.options.allowImportExportEverywhere) {\n                if (!topLevel) {\n                    this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                }\n                if (!this.inModule) {\n                    this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                }\n            }\n            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);\n        // If the statement does not start with a statement keyword or a\n        // brace, it's an ExpressionStatement or LabeledStatement. We\n        // simply start parsing an expression, and afterwards, if the\n        // next token is a colon and the expression was a simple\n        // Identifier node, we switch to interpreting it as a label.\n        default:\n            if (this.isAsyncFunction()) {\n                if (context) {\n                    this.unexpected();\n                }\n                this.next();\n                return this.parseFunctionStatement(node, true, !context);\n            }\n            var maybeName = this.value, expr = this.parseExpression();\n            if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                return this.parseLabeledStatement(node, maybeName, expr, context);\n            } else {\n                return this.parseExpressionStatement(node, expr);\n            }\n    }\n};\npp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.label = null;\n    } else if (this.type !== types$1.name) {\n        this.unexpected();\n    } else {\n        node.label = this.parseIdent();\n        this.semicolon();\n    }\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for(; i < this.labels.length; ++i){\n        var lab = this.labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                break;\n            }\n            if (node.label && isBreak) {\n                break;\n            }\n        }\n    }\n    if (i === this.labels.length) {\n        this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\npp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n};\npp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types$1._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) {\n        this.eat(types$1.semi);\n    } else {\n        this.semicolon();\n    }\n    return this.finishNode(node, \"DoWhileStatement\");\n};\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\npp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types$1.parenL);\n    if (this.type === types$1.semi) {\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, null);\n    }\n    var isLet = this.isLet();\n    if (this.type === types$1._var || this.type === types$1._const || isLet) {\n        var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n        this.next();\n        this.parseVar(init$1, true, kind);\n        this.finishNode(init$1, \"VariableDeclaration\");\n        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === types$1._in) {\n                    if (awaitAt > -1) {\n                        this.unexpected(awaitAt);\n                    }\n                } else {\n                    node.await = awaitAt > -1;\n                }\n            }\n            return this.parseForIn(node, init$1);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init$1);\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n        if (this.options.ecmaVersion >= 9) {\n            if (this.type === types$1._in) {\n                if (awaitAt > -1) {\n                    this.unexpected(awaitAt);\n                }\n            } else {\n                node.await = awaitAt > -1;\n            }\n        }\n        if (startsWithLet && isForOf) {\n            this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n        }\n        this.toAssignable(init, false, refDestructuringErrors);\n        this.checkLValPattern(init);\n        return this.parseForIn(node, init);\n    } else {\n        this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n};\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n};\npp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n};\npp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n        this.raise(this.start, \"'return' outside of function\");\n    }\n    this.next();\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.argument = null;\n    } else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n};\npp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types$1.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n    var cur;\n    for(var sawDefault = false; this.type !== types$1.braceR;){\n        if (this.type === types$1._case || this.type === types$1._default) {\n            var isCase = this.type === types$1._case;\n            if (cur) {\n                this.finishNode(cur, \"SwitchCase\");\n            }\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            this.next();\n            if (isCase) {\n                cur.test = this.parseExpression();\n            } else {\n                if (sawDefault) {\n                    this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                }\n                sawDefault = true;\n                cur.test = null;\n            }\n            this.expect(types$1.colon);\n        } else {\n            if (!cur) {\n                this.unexpected();\n            }\n            cur.consequent.push(this.parseStatement(null));\n        }\n    }\n    this.exitScope();\n    if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n    }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n};\npp$8.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n        this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n};\n// Reused empty array added for node fields that are always empty.\nvar empty$1 = [];\npp$8.parseCatchClauseParam = function() {\n    var param = this.parseBindingAtom();\n    var simple = param.type === \"Identifier\";\n    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n    this.expect(types$1.parenR);\n    return param;\n};\npp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types$1._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(types$1.parenL)) {\n            clause.param = this.parseCatchClauseParam();\n        } else {\n            if (this.options.ecmaVersion < 10) {\n                this.unexpected();\n            }\n            clause.param = null;\n            this.enterScope(0);\n        }\n        clause.body = this.parseBlock(false);\n        this.exitScope();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n        this.raise(node.start, \"Missing catch or finally clause\");\n    }\n    return this.finishNode(node, \"TryStatement\");\n};\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n};\npp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n};\npp$8.parseWithStatement = function(node) {\n    if (this.strict) {\n        this.raise(this.start, \"'with' in strict mode\");\n    }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\");\n};\npp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n};\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n        var label = list[i$1];\n        if (label.name === maybeName) {\n            this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        }\n    }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n    for(var i = this.labels.length - 1; i >= 0; i--){\n        var label$1 = this.labels[i];\n        if (label$1.statementStart === node.start) {\n            // Update information about previous labels on this node\n            label$1.statementStart = this.start;\n            label$1.kind = kind;\n        } else {\n            break;\n        }\n    }\n    this.labels.push({\n        name: maybeName,\n        kind: kind,\n        statementStart: this.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n};\npp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n};\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n    if (node === void 0) node = this.startNode();\n    node.body = [];\n    this.expect(types$1.braceL);\n    if (createNewLexicalScope) {\n        this.enterScope(0);\n    }\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    if (exitStrict) {\n        this.strict = false;\n    }\n    this.next();\n    if (createNewLexicalScope) {\n        this.exitScope();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n};\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\npp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types$1.semi);\n    node.test = this.type === types$1.semi ? null : this.parseExpression();\n    this.expect(types$1.semi);\n    node.update = this.type === types$1.parenR ? null : this.parseExpression();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n};\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\npp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === types$1._in;\n    this.next();\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n        this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n};\n// Parse a list of variable declarations.\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n    node.declarations = [];\n    node.kind = kind;\n    for(;;){\n        var decl = this.startNode();\n        this.parseVarId(decl, kind);\n        if (this.eat(types$1.eq)) {\n            decl.init = this.parseMaybeAssign(isFor);\n        } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            this.unexpected();\n        } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n            this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        } else {\n            decl.init = null;\n        }\n        node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n        if (!this.eat(types$1.comma)) {\n            break;\n        }\n    }\n    return node;\n};\npp$8.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n            this.unexpected();\n        }\n        node.generator = this.eat(types$1.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    if (statement & FUNC_STATEMENT) {\n        node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        {\n            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n        }\n    }\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n    if (!(statement & FUNC_STATEMENT)) {\n        node.id = this.type === types$1.name ? this.parseIdent() : null;\n    }\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\npp$8.parseFunctionParams = function(node) {\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n};\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\npp$8.parseClass = function(node, isStatement) {\n    this.next();\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types$1.braceL);\n    while(this.type !== types$1.braceR){\n        var element = this.parseClassElement(node.superClass !== null);\n        if (element) {\n            classBody.body.push(element);\n            if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                if (hadConstructor) {\n                    this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                }\n                hadConstructor = true;\n            } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n            }\n        }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\npp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat(types$1.semi)) {\n        return null;\n    }\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n    if (this.eatContextual(\"static\")) {\n        // Parse static init block\n        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n            this.parseClassStaticBlock(node);\n            return node;\n        }\n        if (this.isClassElementNameStart() || this.type === types$1.star) {\n            isStatic = true;\n        } else {\n            keyName = \"static\";\n        }\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n            isAsync = true;\n        } else {\n            keyName = \"async\";\n        }\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n        isGenerator = true;\n    }\n    if (!keyName && !isAsync && !isGenerator) {\n        var lastValue = this.value;\n        if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n            if (this.isClassElementNameStart()) {\n                kind = lastValue;\n            } else {\n                keyName = lastValue;\n            }\n        }\n    }\n    // Parse element name\n    if (keyName) {\n        // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n        // The last token is any of those. Make it the element name.\n        node.computed = false;\n        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n        node.key.name = keyName;\n        this.finishNode(node.key, \"Identifier\");\n    } else {\n        this.parseClassElementName(node);\n    }\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n        var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n        var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n        if (isConstructor && kind !== \"method\") {\n            this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n        }\n        node.kind = isConstructor ? \"constructor\" : kind;\n        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else {\n        this.parseClassField(node);\n    }\n    return node;\n};\npp$8.isClassElementNameStart = function() {\n    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n};\npp$8.parseClassElementName = function(element) {\n    if (this.type === types$1.privateId) {\n        if (this.value === \"constructor\") {\n            this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n        }\n        element.computed = false;\n        element.key = this.parsePrivateIdent();\n    } else {\n        this.parsePropertyName(element);\n    }\n};\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n        if (isGenerator) {\n            this.raise(key.start, \"Constructor can't be a generator\");\n        }\n        if (isAsync) {\n            this.raise(key.start, \"Constructor can't be an async method\");\n        }\n    } else if (method.static && checkKeyName(method, \"prototype\")) {\n        this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0) {\n        this.raiseRecoverable(value.start, \"getter should have no params\");\n    }\n    if (method.kind === \"set\" && value.params.length !== 1) {\n        this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n    }\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n    }\n    return this.finishNode(method, \"MethodDefinition\");\n};\npp$8.parseClassField = function(field) {\n    if (checkKeyName(field, \"constructor\")) {\n        this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    } else if (field.static && checkKeyName(field, \"prototype\")) {\n        this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    }\n    if (this.eat(types$1.eq)) {\n        // To raise SyntaxError if 'arguments' exists in the initializer.\n        var scope = this.currentThisScope();\n        var inClassFieldInit = scope.inClassFieldInit;\n        scope.inClassFieldInit = true;\n        field.value = this.parseMaybeAssign();\n        scope.inClassFieldInit = inClassFieldInit;\n    } else {\n        field.value = null;\n    }\n    this.semicolon();\n    return this.finishNode(field, \"PropertyDefinition\");\n};\npp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n    return this.finishNode(node, \"StaticBlock\");\n};\npp$8.parseClassId = function(node, isStatement) {\n    if (this.type === types$1.name) {\n        node.id = this.parseIdent();\n        if (isStatement) {\n            this.checkLValSimple(node.id, BIND_LEXICAL, false);\n        }\n    } else {\n        if (isStatement === true) {\n            this.unexpected();\n        }\n        node.id = null;\n    }\n};\npp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\npp$8.enterClassBody = function() {\n    var element = {\n        declared: Object.create(null),\n        used: []\n    };\n    this.privateNameStack.push(element);\n    return element.declared;\n};\npp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    if (!this.options.checkPrivateFields) {\n        return;\n    }\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for(var i = 0; i < used.length; ++i){\n        var id = used[i];\n        if (!hasOwn(declared, id.name)) {\n            if (parent) {\n                parent.used.push(id);\n            } else {\n                this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n            }\n        }\n    }\n};\nfunction isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n        next = (element.static ? \"s\" : \"i\") + element.kind;\n    }\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n        privateNameMap[name] = \"true\";\n        return false;\n    } else if (!curr) {\n        privateNameMap[name] = next;\n        return false;\n    } else {\n        return true;\n    }\n}\nfunction checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n}\n// Parses module export declaration.\npp$8.parseExportAllDeclaration = function(node, exports) {\n    if (this.options.ecmaVersion >= 11) {\n        if (this.eatContextual(\"as\")) {\n            node.exported = this.parseModuleExportName();\n            this.checkExport(exports, node.exported, this.lastTokStart);\n        } else {\n            node.exported = null;\n        }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types$1.string) {\n        this.unexpected();\n    }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n};\npp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types$1.star)) {\n        return this.parseExportAllDeclaration(node, exports);\n    }\n    if (this.eat(types$1._default)) {\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        node.declaration = this.parseExportDefaultDeclaration();\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseExportDeclaration(node);\n        if (node.declaration.type === \"VariableDeclaration\") {\n            this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n            this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n    } else {\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n            if (this.type !== types$1.string) {\n                this.unexpected();\n            }\n            node.source = this.parseExprAtom();\n        } else {\n            for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                // check for keywords used as local names\n                var spec = list[i];\n                this.checkUnreserved(spec.local);\n                // check if export is defined\n                this.checkLocalExport(spec.local);\n                if (spec.local.type === \"Literal\") {\n                    this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                }\n            }\n            node.source = null;\n        }\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n};\npp$8.parseExportDeclaration = function(node) {\n    return this.parseStatement(null);\n};\npp$8.parseExportDefaultDeclaration = function() {\n    var isAsync;\n    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) {\n            this.next();\n        }\n        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types$1._class) {\n        var cNode = this.startNode();\n        return this.parseClass(cNode, \"nullableID\");\n    } else {\n        var declaration = this.parseMaybeAssign();\n        this.semicolon();\n        return declaration;\n    }\n};\npp$8.checkExport = function(exports, name, pos) {\n    if (!exports) {\n        return;\n    }\n    if (typeof name !== \"string\") {\n        name = name.type === \"Identifier\" ? name.name : name.value;\n    }\n    if (hasOwn(exports, name)) {\n        this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    }\n    exports[name] = true;\n};\npp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\") {\n        this.checkExport(exports, pat, pat.start);\n    } else if (type === \"ObjectPattern\") {\n        for(var i = 0, list = pat.properties; i < list.length; i += 1){\n            var prop = list[i];\n            this.checkPatternExport(exports, prop);\n        }\n    } else if (type === \"ArrayPattern\") {\n        for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n            var elt = list$1[i$1];\n            if (elt) {\n                this.checkPatternExport(exports, elt);\n            }\n        }\n    } else if (type === \"Property\") {\n        this.checkPatternExport(exports, pat.value);\n    } else if (type === \"AssignmentPattern\") {\n        this.checkPatternExport(exports, pat.left);\n    } else if (type === \"RestElement\") {\n        this.checkPatternExport(exports, pat.argument);\n    }\n};\npp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) {\n        return;\n    }\n    for(var i = 0, list = decls; i < list.length; i += 1){\n        var decl = list[i];\n        this.checkPatternExport(exports, decl.id);\n    }\n};\npp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n};\n// Parses a comma-separated list of module exports.\npp$8.parseExportSpecifier = function(exports) {\n    var node = this.startNode();\n    node.local = this.parseModuleExportName();\n    node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n    this.checkExport(exports, node.exported, node.exported.start);\n    return this.finishNode(node, \"ExportSpecifier\");\n};\npp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseExportSpecifier(exports));\n    }\n    return nodes;\n};\n// Parses import declaration.\npp$8.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types$1.string) {\n        node.specifiers = empty$1;\n        node.source = this.parseExprAtom();\n    } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n};\n// Parses a comma-separated list of module imports.\npp$8.parseImportSpecifier = function() {\n    var node = this.startNode();\n    node.imported = this.parseModuleExportName();\n    if (this.eatContextual(\"as\")) {\n        node.local = this.parseIdent();\n    } else {\n        this.checkUnreserved(node.imported);\n        node.local = node.imported;\n    }\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportSpecifier\");\n};\npp$8.parseImportDefaultSpecifier = function() {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\npp$8.parseImportNamespaceSpecifier = function() {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportNamespaceSpecifier\");\n};\npp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types$1.name) {\n        nodes.push(this.parseImportDefaultSpecifier());\n        if (!this.eat(types$1.comma)) {\n            return nodes;\n        }\n    }\n    if (this.type === types$1.star) {\n        nodes.push(this.parseImportNamespaceSpecifier());\n        return nodes;\n    }\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseImportSpecifier());\n    }\n    return nodes;\n};\npp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n        var stringLiteral = this.parseLiteral(this.value);\n        if (loneSurrogate.test(stringLiteral.value)) {\n            this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n        }\n        return stringLiteral;\n    }\n    return this.parseIdent(true);\n};\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n        statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n};\npp$8.isDirectiveCandidate = function(statement) {\n    return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n    (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n};\nvar pp$7 = Parser.prototype;\n// Convert existing expression atom to assignable pattern\n// if possible.\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n        switch(node.type){\n            case \"Identifier\":\n                if (this.inAsync && node.name === \"await\") {\n                    this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                break;\n            case \"ObjectPattern\":\n            case \"ArrayPattern\":\n            case \"AssignmentPattern\":\n            case \"RestElement\":\n                break;\n            case \"ObjectExpression\":\n                node.type = \"ObjectPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                for(var i = 0, list = node.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.toAssignable(prop, isBinding);\n                    // Early error:\n                    //   AssignmentRestProperty[Yield, Await] :\n                    //     `...` DestructuringAssignmentTarget[Yield, Await]\n                    //\n                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                    if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                        this.raise(prop.argument.start, \"Unexpected token\");\n                    }\n                }\n                break;\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                if (node.kind !== \"init\") {\n                    this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                }\n                this.toAssignable(node.value, isBinding);\n                break;\n            case \"ArrayExpression\":\n                node.type = \"ArrayPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                this.toAssignableList(node.elements, isBinding);\n                break;\n            case \"SpreadElement\":\n                node.type = \"RestElement\";\n                this.toAssignable(node.argument, isBinding);\n                if (node.argument.type === \"AssignmentPattern\") {\n                    this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                }\n                break;\n            case \"AssignmentExpression\":\n                if (node.operator !== \"=\") {\n                    this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                }\n                node.type = \"AssignmentPattern\";\n                delete node.operator;\n                this.toAssignable(node.left, isBinding);\n                break;\n            case \"ParenthesizedExpression\":\n                this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (!isBinding) {\n                    break;\n                }\n            default:\n                this.raise(node.start, \"Assigning to rvalue\");\n        }\n    } else if (refDestructuringErrors) {\n        this.checkPatternErrors(refDestructuringErrors, true);\n    }\n    return node;\n};\n// Convert list of expression atoms to binding list.\npp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for(var i = 0; i < end; i++){\n        var elt = exprList[i];\n        if (elt) {\n            this.toAssignable(elt, isBinding);\n        }\n    }\n    if (end) {\n        var last = exprList[end - 1];\n        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n            this.unexpected(last.argument.start);\n        }\n    }\n    return exprList;\n};\n// Parses spread element.\npp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n};\npp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n        this.unexpected();\n    }\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n};\n// Parses lvalue (assignable) atom.\npp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n        switch(this.type){\n            case types$1.bracketL:\n                var node = this.startNode();\n                this.next();\n                node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                return this.finishNode(node, \"ArrayPattern\");\n            case types$1.braceL:\n                return this.parseObj(true);\n        }\n    }\n    return this.parseIdent();\n};\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (first) {\n            first = false;\n        } else {\n            this.expect(types$1.comma);\n        }\n        if (allowEmpty && this.type === types$1.comma) {\n            elts.push(null);\n        } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n            break;\n        } else if (this.type === types$1.ellipsis) {\n            var rest = this.parseRestBinding();\n            this.parseBindingListItem(rest);\n            elts.push(rest);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            this.expect(close);\n            break;\n        } else {\n            elts.push(this.parseAssignableListItem(allowModifiers));\n        }\n    }\n    return elts;\n};\npp$7.parseAssignableListItem = function(allowModifiers) {\n    var elem = this.parseMaybeDefault(this.start, this.startLoc);\n    this.parseBindingListItem(elem);\n    return elem;\n};\npp$7.parseBindingListItem = function(param) {\n    return param;\n};\n// Parses assignment pattern around given atom if possible.\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n        return left;\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n};\n// The following three functions all verify that a node is an lvalue —\n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += …;\n//     import a from '…';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = …);\n//     const a = …;\n//     try { … } catch (a) { … }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    var isBind = bindingType !== BIND_NONE;\n    switch(expr.type){\n        case \"Identifier\":\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n            }\n            if (isBind) {\n                if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                    this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                }\n                if (checkClashes) {\n                    if (hasOwn(checkClashes, expr.name)) {\n                        this.raiseRecoverable(expr.start, \"Argument name clash\");\n                    }\n                    checkClashes[expr.name] = true;\n                }\n                if (bindingType !== BIND_OUTSIDE) {\n                    this.declareName(expr.name, bindingType, expr.start);\n                }\n            }\n            break;\n        case \"ChainExpression\":\n            this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n            break;\n        case \"MemberExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding member expression\");\n            }\n            break;\n        case \"ParenthesizedExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n            }\n            return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n        default:\n            this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n};\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"ObjectPattern\":\n            for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkLValInnerPattern(prop, bindingType, checkClashes);\n            }\n            break;\n        case \"ArrayPattern\":\n            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                var elem = list$1[i$1];\n                if (elem) {\n                    this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                }\n            }\n            break;\n        default:\n            this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n};\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"Property\":\n            // AssignmentProperty has type === \"Property\"\n            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n            break;\n        case \"AssignmentPattern\":\n            this.checkLValPattern(expr.left, bindingType, checkClashes);\n            break;\n        case \"RestElement\":\n            this.checkLValPattern(expr.argument, bindingType, checkClashes);\n            break;\n        default:\n            this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n};\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n};\nvar types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function(p) {\n        return p.tryReadTemplateToken();\n    }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n};\nvar pp$6 = Parser.prototype;\npp$6.initialContext = function() {\n    return [\n        types.b_stat\n    ];\n};\npp$6.curContext = function() {\n    return this.context[this.context.length - 1];\n};\npp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types.f_expr || parent === types.f_stat) {\n        return true;\n    }\n    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n        return !parent.isExpr;\n    }\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    }\n    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n        return true;\n    }\n    if (prevType === types$1.braceL) {\n        return parent === types.b_stat;\n    }\n    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n        return false;\n    }\n    return !this.exprAllowed;\n};\npp$6.inGeneratorContext = function() {\n    for(var i = this.context.length - 1; i >= 1; i--){\n        var context = this.context[i];\n        if (context.token === \"function\") {\n            return context.generator;\n        }\n    }\n    return false;\n};\npp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types$1.dot) {\n        this.exprAllowed = false;\n    } else if (update = type.updateContext) {\n        update.call(this, prevType);\n    } else {\n        this.exprAllowed = type.beforeExpr;\n    }\n};\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\npp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) {\n        this.context[this.context.length - 1] = tokenCtx;\n    }\n};\n// Token-specific context update code\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n        this.exprAllowed = true;\n        return;\n    }\n    var out = this.context.pop();\n    if (out === types.b_stat && this.curContext().token === \"function\") {\n        out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n};\ntypes$1.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n};\ntypes$1.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n};\ntypes$1.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n};\ntypes$1.incDec.updateContext = function() {\n// tokExprAllowed stays unchanged\n};\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n        this.context.push(types.f_expr);\n    } else {\n        this.context.push(types.f_stat);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.colon.updateContext = function() {\n    if (this.curContext().token === \"function\") {\n        this.context.pop();\n    }\n    this.exprAllowed = true;\n};\ntypes$1.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl) {\n        this.context.pop();\n    } else {\n        this.context.push(types.q_tmpl);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.star.updateContext = function(prevType) {\n    if (prevType === types$1._function) {\n        var index = this.context.length - 1;\n        if (this.context[index] === types.f_expr) {\n            this.context[index] = types.f_expr_gen;\n        } else {\n            this.context[index] = types.f_gen;\n        }\n    }\n    this.exprAllowed = true;\n};\ntypes$1.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n        if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n            allowed = true;\n        }\n    }\n    this.exprAllowed = allowed;\n};\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\nvar pp$5 = Parser.prototype;\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n        return;\n    }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n        return;\n    }\n    var key = prop.key;\n    var name;\n    switch(key.type){\n        case \"Identifier\":\n            name = key.name;\n            break;\n        case \"Literal\":\n            name = String(key.value);\n            break;\n        default:\n            return;\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n        if (name === \"__proto__\" && kind === \"init\") {\n            if (propHash.proto) {\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.doubleProto < 0) {\n                        refDestructuringErrors.doubleProto = key.start;\n                    }\n                } else {\n                    this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                }\n            }\n            propHash.proto = true;\n        }\n        return;\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n        var redefinition;\n        if (kind === \"init\") {\n            redefinition = this.strict && other.init || other.get || other.set;\n        } else {\n            redefinition = other.init || other[kind];\n        }\n        if (redefinition) {\n            this.raiseRecoverable(key.start, \"Redefinition of property\");\n        }\n    } else {\n        other = propHash[name] = {\n            init: false,\n            get: false,\n            set: false\n        };\n    }\n    other[kind] = true;\n};\n// ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === types$1.comma) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.expressions = [\n            expr\n        ];\n        while(this.eat(types$1.comma)){\n            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n        }\n        return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n};\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n        if (this.inGenerator) {\n            return this.parseYield(forInit);\n        } else {\n            this.exprAllowed = false;\n        }\n    }\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n        oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n        oldTrailingComma = refDestructuringErrors.trailingComma;\n        oldDoubleProto = refDestructuringErrors.doubleProto;\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n        refDestructuringErrors = new DestructuringErrors;\n        ownDestructuringErrors = true;\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types$1.parenL || this.type === types$1.name) {\n        this.potentialArrowAt = this.start;\n        this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) {\n        left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (this.type.isAssign) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.operator = this.value;\n        if (this.type === types$1.eq) {\n            left = this.toAssignable(left, false, refDestructuringErrors);\n        }\n        if (!ownDestructuringErrors) {\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n        }\n        if (refDestructuringErrors.shorthandAssign >= left.start) {\n            refDestructuringErrors.shorthandAssign = -1;\n        } // reset because shorthand default was used correctly\n        if (this.type === types$1.eq) {\n            this.checkLValPattern(left);\n        } else {\n            this.checkLValSimple(left);\n        }\n        node.left = left;\n        this.next();\n        node.right = this.parseMaybeAssign(forInit);\n        if (oldDoubleProto > -1) {\n            refDestructuringErrors.doubleProto = oldDoubleProto;\n        }\n        return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n        if (ownDestructuringErrors) {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n    }\n    if (oldParenAssign > -1) {\n        refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    }\n    if (oldTrailingComma > -1) {\n        refDestructuringErrors.trailingComma = oldTrailingComma;\n    }\n    return left;\n};\n// Parse a ternary conditional (`?:`) operator.\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    if (this.eat(types$1.question)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.test = expr;\n        node.consequent = this.parseMaybeAssign();\n        this.expect(types$1.colon);\n        node.alternate = this.parseMaybeAssign(forInit);\n        return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n};\n// Start the precedence parser.\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n};\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== types$1._in)) {\n        if (prec > minPrec) {\n            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n            var coalesce = this.type === types$1.coalesce;\n            if (coalesce) {\n                // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                prec = types$1.logicalAND.binop;\n            }\n            var op = this.value;\n            this.next();\n            var startPos = this.start, startLoc = this.startLoc;\n            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n            }\n            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n        }\n    }\n    return left;\n};\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") {\n        this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n};\n// Parse unary operators, both prefix and postfix.\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n        expr = this.parseAwait(forInit);\n        sawUnary = true;\n    } else if (this.type.prefix) {\n        var node = this.startNode(), update = this.type === types$1.incDec;\n        node.operator = this.value;\n        node.prefix = true;\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, update, forInit);\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        if (update) {\n            this.checkLValSimple(node.argument);\n        } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n            this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n        } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n            this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n        } else {\n            sawUnary = true;\n        }\n        expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === types$1.privateId) {\n        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n            this.unexpected();\n        }\n        expr = this.parsePrivateIdent();\n        // only could be private fields in 'in', such as #x in obj\n        if (this.type !== types$1._in) {\n            this.unexpected();\n        }\n    } else {\n        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        while(this.type.postfix && !this.canInsertSemicolon()){\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.operator = this.value;\n            node$1.prefix = false;\n            node$1.argument = expr;\n            this.checkLValSimple(expr);\n            this.next();\n            expr = this.finishNode(node$1, \"UpdateExpression\");\n        }\n    }\n    if (!incDec && this.eat(types$1.starstar)) {\n        if (sawUnary) {\n            this.unexpected(this.lastTokStart);\n        } else {\n            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n        }\n    } else {\n        return expr;\n    }\n};\nfunction isPrivateFieldAccess(node) {\n    return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression);\n}\n// Parse call, dot, and `[]`-subscript expressions.\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n        return expr;\n    }\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n        if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n            refDestructuringErrors.parenthesizedAssign = -1;\n        }\n        if (refDestructuringErrors.parenthesizedBind >= result.start) {\n            refDestructuringErrors.parenthesizedBind = -1;\n        }\n        if (refDestructuringErrors.trailingComma >= result.start) {\n            refDestructuringErrors.trailingComma = -1;\n        }\n    }\n    return result;\n};\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n    var optionalChained = false;\n    while(true){\n        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n        if (element.optional) {\n            optionalChained = true;\n        }\n        if (element === base || element.type === \"ArrowFunctionExpression\") {\n            if (optionalChained) {\n                var chainNode = this.startNodeAt(startPos, startLoc);\n                chainNode.expression = element;\n                element = this.finishNode(chainNode, \"ChainExpression\");\n            }\n            return element;\n        }\n        base = element;\n    }\n};\npp$5.shouldParseAsyncArrow = function() {\n    return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n};\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n};\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat(types$1.questionDot);\n    if (noCalls && optional) {\n        this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n    }\n    var computed = this.eat(types$1.bracketL);\n    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.object = base;\n        if (computed) {\n            node.property = this.parseExpression();\n            this.expect(types$1.bracketR);\n        } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n            node.property = this.parsePrivateIdent();\n        } else {\n            node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n        }\n        node.computed = !!computed;\n        if (optionalSupported) {\n            node.optional = optional;\n        }\n        base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types$1.parenL)) {\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            if (this.awaitIdentPos > 0) {\n                this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n            }\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos;\n            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        if (optionalSupported) {\n            node$1.optional = optional;\n        }\n        base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types$1.backQuote) {\n        if (optional || optionalChained) {\n            this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n        }\n        var node$2 = this.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this.parseTemplate({\n            isTagged: true\n        });\n        base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base;\n};\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types$1.slash) {\n        this.readRegexp();\n    }\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch(this.type){\n        case types$1._super:\n            if (!this.allowSuper) {\n                this.raise(this.start, \"'super' keyword outside a method\");\n            }\n            node = this.startNode();\n            this.next();\n            if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                this.raise(node.start, \"super() call outside constructor of a subclass\");\n            }\n            // The `super` keyword can appear at below:\n            // SuperProperty:\n            //     super [ Expression ]\n            //     super . IdentifierName\n            // SuperCall:\n            //     super ( Arguments )\n            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                this.unexpected();\n            }\n            return this.finishNode(node, \"Super\");\n        case types$1._this:\n            node = this.startNode();\n            this.next();\n            return this.finishNode(node, \"ThisExpression\");\n        case types$1.name:\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n            var id = this.parseIdent(false);\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                this.overrideContext(types.f_expr);\n                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n            }\n            if (canBeArrow && !this.canInsertSemicolon()) {\n                if (this.eat(types$1.arrow)) {\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], false, forInit);\n                }\n                if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                    id = this.parseIdent(false);\n                    if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                        this.unexpected();\n                    }\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], true, forInit);\n                }\n            }\n            return id;\n        case types$1.regexp:\n            var value = this.value;\n            node = this.parseLiteral(value.value);\n            node.regex = {\n                pattern: value.pattern,\n                flags: value.flags\n            };\n            return node;\n        case types$1.num:\n        case types$1.string:\n            return this.parseLiteral(this.value);\n        case types$1._null:\n        case types$1._true:\n        case types$1._false:\n            node = this.startNode();\n            node.value = this.type === types$1._null ? null : this.type === types$1._true;\n            node.raw = this.type.keyword;\n            this.next();\n            return this.finishNode(node, \"Literal\");\n        case types$1.parenL:\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n            if (refDestructuringErrors) {\n                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                    refDestructuringErrors.parenthesizedAssign = start;\n                }\n                if (refDestructuringErrors.parenthesizedBind < 0) {\n                    refDestructuringErrors.parenthesizedBind = start;\n                }\n            }\n            return expr;\n        case types$1.bracketL:\n            node = this.startNode();\n            this.next();\n            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n            return this.finishNode(node, \"ArrayExpression\");\n        case types$1.braceL:\n            this.overrideContext(types.b_expr);\n            return this.parseObj(false, refDestructuringErrors);\n        case types$1._function:\n            node = this.startNode();\n            this.next();\n            return this.parseFunction(node, 0);\n        case types$1._class:\n            return this.parseClass(this.startNode(), false);\n        case types$1._new:\n            return this.parseNew();\n        case types$1.backQuote:\n            return this.parseTemplate();\n        case types$1._import:\n            if (this.options.ecmaVersion >= 11) {\n                return this.parseExprImport(forNew);\n            } else {\n                return this.unexpected();\n            }\n        default:\n            return this.parseExprAtomDefault();\n    }\n};\npp$5.parseExprAtomDefault = function() {\n    this.unexpected();\n};\npp$5.parseExprImport = function(forNew) {\n    var node = this.startNode();\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n    }\n    var meta = this.parseIdent(true);\n    if (this.type === types$1.parenL && !forNew) {\n        return this.parseDynamicImport(node);\n    } else if (this.type === types$1.dot) {\n        node.meta = meta;\n        return this.parseImportMeta(node);\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n    // Verify ending.\n    if (!this.eat(types$1.parenR)) {\n        var errorPos = this.start;\n        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n            this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n        } else {\n            this.unexpected(errorPos);\n        }\n    }\n    return this.finishNode(node, \"ImportExpression\");\n};\npp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n    }\n    if (containsEsc) {\n        this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n    }\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n        this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n    }\n    return this.finishNode(node, \"MetaProperty\");\n};\npp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n        node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n    }\n    this.next();\n    return this.finishNode(node, \"Literal\");\n};\npp$5.parseParenExpression = function() {\n    this.expect(types$1.parenL);\n    var val = this.parseExpression();\n    this.expect(types$1.parenR);\n    return val;\n};\npp$5.shouldParseArrow = function(exprList) {\n    return !this.canInsertSemicolon();\n};\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n        this.next();\n        var innerStartPos = this.start, innerStartLoc = this.startLoc;\n        var exprList = [], first = true, lastIsComma = false;\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        // Do not save awaitIdentPos to allow checking awaits nested in parameters\n        while(this.type !== types$1.parenR){\n            first ? first = false : this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                lastIsComma = true;\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                spreadStart = this.start;\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                break;\n            } else {\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n            }\n        }\n        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n        this.expect(types$1.parenR);\n        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n        }\n        if (!exprList.length || lastIsComma) {\n            this.unexpected(this.lastTokStart);\n        }\n        if (spreadStart) {\n            this.unexpected(spreadStart);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        if (exprList.length > 1) {\n            val = this.startNodeAt(innerStartPos, innerStartLoc);\n            val.expressions = exprList;\n            this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n        } else {\n            val = exprList[0];\n        }\n    } else {\n        val = this.parseParenExpression();\n    }\n    if (this.options.preserveParens) {\n        var par = this.startNodeAt(startPos, startLoc);\n        par.expression = val;\n        return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n        return val;\n    }\n};\npp$5.parseParenItem = function(item) {\n    return item;\n};\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n};\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nvar empty = [];\npp$5.parseNew = function() {\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n    }\n    var node = this.startNode();\n    this.next();\n    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n        var meta = this.startNodeAt(node.start, node.startLoc);\n        meta.name = \"new\";\n        node.meta = this.finishNode(meta, \"Identifier\");\n        this.next();\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"target\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n        }\n        if (!this.allowNewDotTarget) {\n            this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n    if (this.eat(types$1.parenL)) {\n        node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n    } else {\n        node.arguments = empty;\n    }\n    return this.finishNode(node, \"NewExpression\");\n};\n// Parse template expression.\npp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n    var elem = this.startNode();\n    if (this.type === types$1.invalidTemplate) {\n        if (!isTagged) {\n            this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n        }\n        elem.value = {\n            raw: this.value,\n            cooked: null\n        };\n    } else {\n        elem.value = {\n            raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n            cooked: this.value\n        };\n    }\n    this.next();\n    elem.tail = this.type === types$1.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n};\npp$5.parseTemplate = function(ref) {\n    if (ref === void 0) ref = {};\n    var isTagged = ref.isTagged;\n    if (isTagged === void 0) isTagged = false;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({\n        isTagged: isTagged\n    });\n    node.quasis = [\n        curElt\n    ];\n    while(!curElt.tail){\n        if (this.type === types$1.eof) {\n            this.raise(this.pos, \"Unterminated template literal\");\n        }\n        this.expect(types$1.dollarBraceL);\n        node.expressions.push(this.parseExpression());\n        this.expect(types$1.braceR);\n        node.quasis.push(curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        }));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n};\npp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n// Parse an object literal or binding pattern.\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var prop = this.parseProperty(isPattern, refDestructuringErrors);\n        if (!isPattern) {\n            this.checkPropClash(prop, propHash, refDestructuringErrors);\n        }\n        node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n        if (isPattern) {\n            prop.argument = this.parseIdent(false);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            return this.finishNode(prop, \"RestElement\");\n        }\n        // Parse argument.\n        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        // To disallow trailing comma via `this.toAssignable()`.\n        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n            refDestructuringErrors.trailingComma = this.start;\n        }\n        // Finish\n        return this.finishNode(prop, \"SpreadElement\");\n    }\n    if (this.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n        if (isPattern || refDestructuringErrors) {\n            startPos = this.start;\n            startLoc = this.startLoc;\n        }\n        if (!isPattern) {\n            isGenerator = this.eat(types$1.star);\n        }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n        this.parsePropertyName(prop);\n    } else {\n        isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\");\n};\npp$5.parseGetterSetter = function(prop) {\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") {\n            this.raiseRecoverable(start, \"getter should have no params\");\n        } else {\n            this.raiseRecoverable(start, \"setter should have exactly one param\");\n        }\n    } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n        }\n    }\n};\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types$1.colon) {\n        this.unexpected();\n    }\n    if (this.eat(types$1.colon)) {\n        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n        prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n        if (isPattern) {\n            this.unexpected();\n        }\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.parseGetterSetter(prop);\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.checkUnreserved(prop.key);\n        if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = startPos;\n        }\n        prop.kind = \"init\";\n        if (isPattern) {\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else if (this.type === types$1.eq && refDestructuringErrors) {\n            if (refDestructuringErrors.shorthandAssign < 0) {\n                refDestructuringErrors.shorthandAssign = this.start;\n            }\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else {\n            prop.value = this.copyNode(prop.key);\n        }\n        prop.shorthand = true;\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n        if (this.eat(types$1.bracketL)) {\n            prop.computed = true;\n            prop.key = this.parseMaybeAssign();\n            this.expect(types$1.bracketR);\n            return prop.key;\n        } else {\n            prop.computed = false;\n        }\n    }\n    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n};\n// Initialize empty function node.\npp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = false;\n    }\n};\n// Parse object or class method.\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = isGenerator;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\");\n};\n// Parse arrow function expression with given parameters.\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n// Parse function body and check parameters.\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== types$1.braceL;\n    var oldStrict = this.strict, useStrict = false;\n    if (isExpression) {\n        node.body = this.parseMaybeAssign(forInit);\n        node.expression = true;\n        this.checkParams(node, false);\n    } else {\n        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n        if (!oldStrict || nonSimple) {\n            useStrict = this.strictDirective(this.end);\n            // If this is a strict mode function, verify that argument names\n            // are not repeated, and it does not try to bind the words `eval`\n            // or `arguments`.\n            if (useStrict && nonSimple) {\n                this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n            }\n        }\n        // Start a new scope with regard to labels and the `inFunction`\n        // flag (restore them to their old value afterwards).\n        var oldLabels = this.labels;\n        this.labels = [];\n        if (useStrict) {\n            this.strict = true;\n        }\n        // Add the params to varDeclaredNames to ensure that an error is thrown\n        // if a let/const declaration in the function clashes with one of the params.\n        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n        if (this.strict && node.id) {\n            this.checkLValSimple(node.id, BIND_OUTSIDE);\n        }\n        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n        node.expression = false;\n        this.adaptDirectivePrologue(node.body.body);\n        this.labels = oldLabels;\n    }\n    this.exitScope();\n};\npp$5.isSimpleParamList = function(params) {\n    for(var i = 0, list = params; i < list.length; i += 1){\n        var param = list[i];\n        if (param.type !== \"Identifier\") {\n            return false;\n        }\n    }\n    return true;\n};\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\npp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for(var i = 0, list = node.params; i < list.length; i += 1){\n        var param = list[i];\n        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n};\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var elt = void 0;\n        if (allowEmpty && this.type === types$1.comma) {\n            elt = null;\n        } else if (this.type === types$1.ellipsis) {\n            elt = this.parseSpread(refDestructuringErrors);\n            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n        } else {\n            elt = this.parseMaybeAssign(false, refDestructuringErrors);\n        }\n        elts.push(elt);\n    }\n    return elts;\n};\npp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n    if (this.inGenerator && name === \"yield\") {\n        this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n    }\n    if (this.inAsync && name === \"await\") {\n        this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n    }\n    if (this.currentThisScope().inClassFieldInit && name === \"arguments\") {\n        this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n    }\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n        this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n    }\n    if (this.keywords.test(name)) {\n        this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n    }\n    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n        return;\n    }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n        if (!this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n        }\n        this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n    }\n};\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\npp$5.parseIdent = function(liberal) {\n    var node = this.parseIdentNode();\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n        this.checkUnreserved(node);\n        if (node.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = node.start;\n        }\n    }\n    return node;\n};\npp$5.parseIdentNode = function() {\n    var node = this.startNode();\n    if (this.type === types$1.name) {\n        node.name = this.value;\n    } else if (this.type.keyword) {\n        node.name = this.type.keyword;\n        // To fix https://github.com/acornjs/acorn/issues/575\n        // `class` and `function` keywords push new context into this.context.\n        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n        if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n            this.context.pop();\n        }\n        this.type = types$1.name;\n    } else {\n        this.unexpected();\n    }\n    return node;\n};\npp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === types$1.privateId) {\n        node.name = this.value;\n    } else {\n        this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n    // For validating existence\n    if (this.options.checkPrivateFields) {\n        if (this.privateNameStack.length === 0) {\n            this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n        } else {\n            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n        }\n    }\n    return node;\n};\n// Parses yield expression inside generator.\npp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) {\n        this.yieldPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n        node.delegate = false;\n        node.argument = null;\n    } else {\n        node.delegate = this.eat(types$1.star);\n        node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\");\n};\npp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) {\n        this.awaitPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\");\n};\nvar pp$4 = Parser.prototype;\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\npp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n};\npp$4.raiseRecoverable = pp$4.raise;\npp$4.curPosition = function() {\n    if (this.options.locations) {\n        return new Position(this.curLine, this.pos - this.lineStart);\n    }\n};\nvar pp$3 = Parser.prototype;\nvar Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n    // A switch to disallow the identifier reference 'arguments'\n    this.inClassFieldInit = false;\n};\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\npp$3.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n};\npp$3.exitScope = function() {\n    this.scopeStack.pop();\n};\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n};\npp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n        var scope = this.currentScope();\n        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n        scope.lexical.push(name);\n        if (this.inModule && scope.flags & SCOPE_TOP) {\n            delete this.undefinedExports[name];\n        }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n        var scope$1 = this.currentScope();\n        scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n        var scope$2 = this.currentScope();\n        if (this.treatFunctionsAsVar) {\n            redeclared = scope$2.lexical.indexOf(name) > -1;\n        } else {\n            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n        }\n        scope$2.functions.push(name);\n    } else {\n        for(var i = this.scopeStack.length - 1; i >= 0; --i){\n            var scope$3 = this.scopeStack[i];\n            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                redeclared = true;\n                break;\n            }\n            scope$3.var.push(name);\n            if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n            if (scope$3.flags & SCOPE_VAR) {\n                break;\n            }\n        }\n    }\n    if (redeclared) {\n        this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n    }\n};\npp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n        this.undefinedExports[id.name] = id;\n    }\n};\npp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1];\n};\npp$3.currentVarScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & SCOPE_VAR) {\n            return scope;\n        }\n    }\n};\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {\n            return scope;\n        }\n    }\n};\nvar Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) {\n        this.loc = new SourceLocation(parser, loc);\n    }\n    if (parser.options.directSourceFile) {\n        this.sourceFile = parser.options.directSourceFile;\n    }\n    if (parser.options.ranges) {\n        this.range = [\n            pos,\n            0\n        ];\n    }\n};\n// Start an AST node, attaching a start offset.\nvar pp$2 = Parser.prototype;\npp$2.startNode = function() {\n    return new Node(this, this.start, this.startLoc);\n};\npp$2.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc);\n};\n// Finish an AST node, adding `type` and `end` properties.\nfunction finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) {\n        node.loc.end = loc;\n    }\n    if (this.options.ranges) {\n        node.range[1] = pos;\n    }\n    return node;\n}\npp$2.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n// Finish node at given position\npp$2.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n};\npp$2.copyNode = function(node) {\n    var newNode = new Node(this, node.start, this.startLoc);\n    for(var prop in node){\n        newNode[prop] = node[prop];\n    }\n    return newNode;\n};\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\nvar unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties,\n    12: ecma12BinaryProperties,\n    13: ecma13BinaryProperties,\n    14: ecma14BinaryProperties\n};\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\nvar unicodeBinaryPropertiesOfStrings = {\n    9: \"\",\n    10: \"\",\n    11: \"\",\n    12: \"\",\n    13: \"\",\n    14: ecma14BinaryPropertiesOfStrings\n};\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\nvar unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues,\n    12: ecma12ScriptValues,\n    13: ecma13ScriptValues,\n    14: ecma14ScriptValues\n};\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n        binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n        nonBinary: {\n            General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n        }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nfor(var i = 0, list = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    14\n]; i < list.length; i += 1){\n    var ecmaVersion = list[i];\n    buildUnicodeData(ecmaVersion);\n}\nvar pp$1 = Parser.prototype;\nvar RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchV = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n};\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n    var unicodeSets = flags.indexOf(\"v\") !== -1;\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n        this.switchU = true;\n        this.switchV = true;\n        this.switchN = true;\n    } else {\n        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n        this.switchV = false;\n        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n    }\n};\nRegExpValidationState.prototype.raise = function raise(message) {\n    this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n};\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return -1;\n    }\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n        return c;\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\nRegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return l;\n    }\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n        return i + 1;\n    }\n    return i + 2;\n};\nRegExpValidationState.prototype.current = function current(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.pos, forceU);\n};\nRegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.nextIndex(this.pos, forceU), forceU);\n};\nRegExpValidationState.prototype.advance = function advance(forceU) {\n    if (forceU === void 0) forceU = false;\n    this.pos = this.nextIndex(this.pos, forceU);\n};\nRegExpValidationState.prototype.eat = function eat(ch, forceU) {\n    if (forceU === void 0) forceU = false;\n    if (this.current(forceU) === ch) {\n        this.advance(forceU);\n        return true;\n    }\n    return false;\n};\nRegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n    if (forceU === void 0) forceU = false;\n    var pos = this.pos;\n    for(var i = 0, list = chs; i < list.length; i += 1){\n        var ch = list[i];\n        var current = this.at(pos, forceU);\n        if (current === -1 || current !== ch) {\n            return false;\n        }\n        pos = this.nextIndex(pos, forceU);\n    }\n    this.pos = pos;\n    return true;\n};\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n    var u = false;\n    var v = false;\n    for(var i = 0; i < flags.length; i++){\n        var flag = flags.charAt(i);\n        if (validFlags.indexOf(flag) === -1) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n        if (flags.indexOf(flag, i + 1) > -1) {\n            this.raise(state.start, \"Duplicate regular expression flag\");\n        }\n        if (flag === \"u\") {\n            u = true;\n        }\n        if (flag === \"v\") {\n            v = true;\n        }\n    }\n    if (this.options.ecmaVersion >= 15 && u && v) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n    }\n};\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n        state.switchN = true;\n        this.regexp_pattern(state);\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n    this.regexp_disjunction(state);\n    if (state.pos !== state.source.length) {\n        // Make the same messages as V8.\n        if (state.eat(0x29 /* ) */ )) {\n            state.raise(\"Unmatched ')'\");\n        }\n        if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n        state.raise(\"Invalid escape\");\n    }\n    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n        var name = list[i];\n        if (state.groupNames.indexOf(name) === -1) {\n            state.raise(\"Invalid named capture referenced\");\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while(state.eat(0x7C /* | */ )){\n        this.regexp_alternative(state);\n    }\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */ )) {\n        state.raise(\"Lone quantifier brackets\");\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n    while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n        // Handle `QuantifiableAssertion Quantifier` alternative.\n        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n        // is a QuantifiableAssertion.\n        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n            // Make the same message as V8.\n            if (state.switchU) {\n                state.raise(\"Invalid quantifier\");\n            }\n        }\n        return true;\n    }\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n        this.regexp_eatQuantifier(state);\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n    // ^, $\n    if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n        return true;\n    }\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */ )) {\n        if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n            return true;\n        }\n        state.pos = start;\n    }\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n        var lookbehind = false;\n        if (this.options.ecmaVersion >= 9) {\n            lookbehind = state.eat(0x3C /* < */ );\n        }\n        if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n            this.regexp_disjunction(state);\n            if (!state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unterminated group\");\n            }\n            state.lastAssertionIsQuantifiable = !lookbehind;\n            return true;\n        }\n    }\n    state.pos = start;\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n    if (noError === void 0) noError = false;\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n        state.eat(0x3F /* ? */ );\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */ )) {\n        var min = 0, max = -1;\n        if (this.regexp_eatDecimalDigits(state)) {\n            min = state.lastIntValue;\n            if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                max = state.lastIntValue;\n            }\n            if (state.eat(0x7D /* } */ )) {\n                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                if (max !== -1 && max < min && !noError) {\n                    state.raise(\"numbers out of order in {} quantifier\");\n                }\n                return true;\n            }\n        }\n        if (state.switchU && !noError) {\n            state.raise(\"Incomplete quantifier\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatAtomEscape(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */ )) {\n        if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) {\n                return true;\n            }\n            state.raise(\"Unterminated group\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */ )) {\n        if (this.options.ecmaVersion >= 9) {\n            this.regexp_groupSpecifier(state);\n        } else if (state.current() === 0x3F /* ? */ ) {\n            state.raise(\"Invalid group\");\n        }\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */ )) {\n            state.numCapturingParens += 1;\n            return true;\n        }\n        state.raise(\"Unterminated group\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n    return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isSyntaxCharacter(ch) {\n    return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n        state.advance();\n    }\n    return state.pos !== start;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n                state.raise(\"Duplicate capture group name\");\n            }\n            state.groupNames.push(state.lastStringValue);\n            return;\n        }\n        state.raise(\"Invalid group\");\n    }\n};\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */ )) {\n        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n            return true;\n        }\n        state.raise(\"Invalid capture group name\");\n    }\n    return false;\n};\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n        while(this.regexp_eatRegExpIdentifierPart(state)){\n            state.lastStringValue += codePointToString(state.lastIntValue);\n        }\n        return true;\n    }\n    return false;\n};\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n}\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n        return true;\n    }\n    if (state.switchU) {\n        // Make the same message as V8.\n        if (state.current() === 0x63 /* c */ ) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.raise(\"Invalid escape\");\n    }\n    return false;\n};\npp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n        var n = state.lastIntValue;\n        if (state.switchU) {\n            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n            if (n > state.maxBackReference) {\n                state.maxBackReference = n;\n            }\n            return true;\n        }\n        if (n <= state.numCapturingParens) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            state.backReferenceNames.push(state.lastStringValue);\n            return true;\n        }\n        state.raise(\"Invalid named reference\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\npp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n        state.lastIntValue = 0;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */ ) {\n        state.lastIntValue = 0x09; /* \\t */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x6E /* n */ ) {\n        state.lastIntValue = 0x0A; /* \\n */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x76 /* v */ ) {\n        state.lastIntValue = 0x0B; /* \\v */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x66 /* f */ ) {\n        state.lastIntValue = 0x0C; /* \\f */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x72 /* r */ ) {\n        state.lastIntValue = 0x0D; /* \\r */ \n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isControlLetter(ch) {\n    return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if (forceU === void 0) forceU = false;\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n    if (state.eat(0x75 /* u */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 4)) {\n            var lead = state.lastIntValue;\n            if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                var leadSurrogateEnd = state.pos;\n                if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                    var trail = state.lastIntValue;\n                    if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                        return true;\n                    }\n                }\n                state.pos = leadSurrogateEnd;\n                state.lastIntValue = lead;\n            }\n            return true;\n        }\n        if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n            return true;\n        }\n        if (switchU) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\nfunction isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n        if (this.regexp_eatSyntaxCharacter(state)) {\n            return true;\n        }\n        if (state.eat(0x2F /* / */ )) {\n            state.lastIntValue = 0x2F; /* / */ \n            return true;\n        }\n        return false;\n    }\n    var ch = state.current();\n    if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n        do {\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n        return true;\n    }\n    return false;\n};\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n    if (isCharacterClassEscape(ch)) {\n        state.lastIntValue = -1;\n        state.advance();\n        return CharSetOk;\n    }\n    var negate = false;\n    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n        state.lastIntValue = -1;\n        state.advance();\n        var result;\n        if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Invalid property name\");\n            }\n            return result;\n        }\n        state.raise(\"Invalid property name\");\n    }\n    return CharSetNone;\n};\nfunction isCharacterClassEscape(ch) {\n    return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n}\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n        var name = state.lastStringValue;\n        if (this.regexp_eatUnicodePropertyValue(state)) {\n            var value = state.lastStringValue;\n            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n            return CharSetOk;\n        }\n    }\n    state.pos = start;\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n        var nameOrValue = state.lastStringValue;\n        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    }\n    return CharSetNone;\n};\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n        state.raise(\"Invalid property name\");\n    }\n    if (!state.unicodeProperties.nonBinary[name].test(value)) {\n        state.raise(\"Invalid property value\");\n    }\n};\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (state.unicodeProperties.binary.test(nameOrValue)) {\n        return CharSetOk;\n    }\n    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n        return CharSetString;\n    }\n    state.raise(\"Invalid property name\");\n};\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyNameCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n}\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyValueCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n}\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (!state.eat(0x5D /* ] */ )) {\n            state.raise(\"Unterminated character class\");\n        }\n        if (negate && result === CharSetString) {\n            state.raise(\"Negated character class may contain strings\");\n        }\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n    if (state.current() === 0x5D /* ] */ ) {\n        return CharSetOk;\n    }\n    if (state.switchV) {\n        return this.regexp_classSetExpression(state);\n    }\n    this.regexp_nonEmptyClassRanges(state);\n    return CharSetOk;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n    while(this.regexp_eatClassAtom(state)){\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n            var right = state.lastIntValue;\n            if (state.switchU && (left === -1 || right === -1)) {\n                state.raise(\"Invalid character class\");\n            }\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatClassEscape(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            var ch$1 = state.current();\n            if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                state.raise(\"Invalid class escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */ ) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x62 /* b */ )) {\n        state.lastIntValue = 0x08; /* <BS> */ \n        return true;\n    }\n    if (state.switchU && state.eat(0x2D /* - */ )) {\n        state.lastIntValue = 0x2D; /* - */ \n        return true;\n    }\n    if (!state.switchU && state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatClassControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n};\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n    var result = CharSetOk, subResult;\n    if (this.regexp_eatClassSetRange(state)) ;\n    else if (subResult = this.regexp_eatClassSetOperand(state)) {\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n        // https://tc39.es/ecma262/#prod-ClassIntersection\n        var start = state.pos;\n        while(state.eatChars([\n            0x26,\n            0x26\n        ])){\n            if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                if (subResult !== CharSetString) {\n                    result = CharSetOk;\n                }\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n        // https://tc39.es/ecma262/#prod-ClassSubtraction\n        while(state.eatChars([\n            0x2D,\n            0x2D\n        ])){\n            if (this.regexp_eatClassSetOperand(state)) {\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n    } else {\n        state.raise(\"Invalid character in character class\");\n    }\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    for(;;){\n        if (this.regexp_eatClassSetRange(state)) {\n            continue;\n        }\n        subResult = this.regexp_eatClassSetOperand(state);\n        if (!subResult) {\n            return result;\n        }\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n    }\n};\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatClassSetCharacter(state)) {\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n            var right = state.lastIntValue;\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n    if (this.regexp_eatClassSetCharacter(state)) {\n        return CharSetOk;\n    }\n    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n};\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (state.eat(0x5D /* ] */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return result;\n        }\n        state.pos = start;\n    }\n    if (state.eat(0x5C /* \\ */ )) {\n        var result$1 = this.regexp_eatCharacterClassEscape(state);\n        if (result$1) {\n            return result$1;\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n    var start = state.pos;\n    if (state.eatChars([\n        0x5C,\n        0x71\n    ])) {\n        if (state.eat(0x7B /* { */ )) {\n            var result = this.regexp_classStringDisjunctionContents(state);\n            if (state.eat(0x7D /* } */ )) {\n                return result;\n            }\n        } else {\n            // Make the same message as V8.\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n    var result = this.regexp_classString(state);\n    while(state.eat(0x7C /* | */ )){\n        if (this.regexp_classString(state) === CharSetString) {\n            result = CharSetString;\n        }\n    }\n    return result;\n};\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n    var count = 0;\n    while(this.regexp_eatClassSetCharacter(state)){\n        count++;\n    }\n    return count === 1 ? CharSetOk : CharSetString;\n};\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n            return true;\n        }\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        state.pos = start;\n        return false;\n    }\n    var ch = state.current();\n    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n        return false;\n    }\n    if (isClassSetSyntaxCharacter(ch)) {\n        return false;\n    }\n    state.advance();\n    state.lastIntValue = ch;\n    return true;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n    return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n    return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n    var ch = state.current();\n    if (isClassSetReservedPunctuator(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n    return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 2)) {\n            return true;\n        }\n        if (state.switchU) {\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isDecimalDigit(ch = state.current())){\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isHexDigit(ch = state.current())){\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isHexDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n}\nfunction hexToInt(ch) {\n    if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n        return 10 + (ch - 0x41 /* A */ );\n    }\n    if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n        return 10 + (ch - 0x61 /* a */ );\n    }\n    return ch - 0x30 /* 0 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n        var n1 = state.lastIntValue;\n        if (this.regexp_eatOctalDigit(state)) {\n            var n2 = state.lastIntValue;\n            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n            } else {\n                state.lastIntValue = n1 * 8 + n2;\n            }\n        } else {\n            state.lastIntValue = n1;\n        }\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n        state.lastIntValue = ch - 0x30; /* 0 */ \n        state.advance();\n        return true;\n    }\n    state.lastIntValue = 0;\n    return false;\n};\nfunction isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for(var i = 0; i < length; ++i){\n        var ch = state.current();\n        if (!isHexDigit(ch)) {\n            state.pos = start;\n            return false;\n        }\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return true;\n};\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nvar Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) {\n        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    }\n    if (p.options.ranges) {\n        this.range = [\n            p.start,\n            p.end\n        ];\n    }\n};\n// ## Tokenizer\nvar pp = Parser.prototype;\n// Move to the next token\npp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n    }\n    if (this.options.onToken) {\n        this.options.onToken(new Token(this));\n    }\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n};\npp.getToken = function() {\n    this.next();\n    return new Token(this);\n};\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") {\n    pp[Symbol.iterator] = function() {\n        var this$1$1 = this;\n        return {\n            next: function() {\n                var token = this$1$1.getToken();\n                return {\n                    done: token.type === types$1.eof,\n                    value: token\n                };\n            }\n        };\n    };\n}\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n// Read a single token, updating the parser object's token-related\n// properties.\npp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) {\n        this.skipSpace();\n    }\n    this.start = this.pos;\n    if (this.options.locations) {\n        this.startLoc = this.curPosition();\n    }\n    if (this.pos >= this.input.length) {\n        return this.finishToken(types$1.eof);\n    }\n    if (curContext.override) {\n        return curContext.override(this);\n    } else {\n        this.readToken(this.fullCharCodeAtPos());\n    }\n};\npp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n        return this.readWord();\n    }\n    return this.getTokenFromCode(code);\n};\npp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) {\n        return code;\n    }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n};\npp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) {\n        this.raise(this.pos - 2, \"Unterminated comment\");\n    }\n    this.pos = end + 2;\n    if (this.options.locations) {\n        for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n            ++this.curLine;\n            pos = this.lineStart = nextBreak;\n        }\n    }\n    if (this.options.onComment) {\n        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n    }\n};\npp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while(this.pos < this.input.length && !isNewLine(ch)){\n        ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment) {\n        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n    }\n};\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\npp.skipSpace = function() {\n    loop: while(this.pos < this.input.length){\n        var ch = this.input.charCodeAt(this.pos);\n        switch(ch){\n            case 32:\n            case 160:\n                ++this.pos;\n                break;\n            case 13:\n                if (this.input.charCodeAt(this.pos + 1) === 10) {\n                    ++this.pos;\n                }\n            case 10:\n            case 8232:\n            case 8233:\n                ++this.pos;\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                break;\n            case 47:\n                switch(this.input.charCodeAt(this.pos + 1)){\n                    case 42:\n                        this.skipBlockComment();\n                        break;\n                    case 47:\n                        this.skipLineComment(2);\n                        break;\n                    default:\n                        break loop;\n                }\n                break;\n            default:\n                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                    ++this.pos;\n                } else {\n                    break loop;\n                }\n        }\n    }\n};\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\npp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) {\n        this.endLoc = this.curPosition();\n    }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n};\n// ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) {\n        return this.readNumber(true);\n    }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n        this.pos += 3;\n        return this.finishToken(types$1.ellipsis);\n    } else {\n        ++this.pos;\n        return this.finishToken(types$1.dot);\n    }\n};\npp.readToken_slash = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) {\n        ++this.pos;\n        return this.readRegexp();\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.slash, 1);\n};\npp.readToken_mult_modulo_exp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types$1.star : types$1.modulo;\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n        ++size;\n        tokentype = types$1.starstar;\n        next = this.input.charCodeAt(this.pos + 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, size + 1);\n    }\n    return this.finishOp(tokentype, size);\n};\npp.readToken_pipe_amp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (this.options.ecmaVersion >= 12) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 === 61) {\n                return this.finishOp(types$1.assign, 3);\n            }\n        }\n        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n};\npp.readToken_caret = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.bitwiseXOR, 1);\n};\npp.readToken_plus_min = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n            // A `-->` line comment\n            this.skipLineComment(3);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        return this.finishOp(types$1.incDec, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.plusMin, 1);\n};\npp.readToken_lt_gt = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n        if (this.input.charCodeAt(this.pos + size) === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(types$1.bitShift, size);\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n        // `<!--`, an XML-style comment that should be interpreted as a line comment\n        this.skipLineComment(4);\n        this.skipSpace();\n        return this.nextToken();\n    }\n    if (next === 61) {\n        size = 2;\n    }\n    return this.finishOp(types$1.relational, size);\n};\npp.readToken_eq_excl = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n    }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n        this.pos += 2;\n        return this.finishToken(types$1.arrow);\n    }\n    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n};\npp.readToken_question = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 46) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 < 48 || next2 > 57) {\n                return this.finishOp(types$1.questionDot, 2);\n            }\n        }\n        if (next === 63) {\n            if (ecmaVersion >= 12) {\n                var next2$1 = this.input.charCodeAt(this.pos + 2);\n                if (next2$1 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(types$1.coalesce, 2);\n        }\n    }\n    return this.finishOp(types$1.question, 1);\n};\npp.readToken_numberSign = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n        ++this.pos;\n        code = this.fullCharCodeAtPos();\n        if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n            return this.finishToken(types$1.privateId, this.readWord1());\n        }\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.getTokenFromCode = function(code) {\n    switch(code){\n        // The interpretation of a dot depends on whether it is followed\n        // by a digit or another two dots.\n        case 46:\n            return this.readToken_dot();\n        // Punctuation tokens.\n        case 40:\n            ++this.pos;\n            return this.finishToken(types$1.parenL);\n        case 41:\n            ++this.pos;\n            return this.finishToken(types$1.parenR);\n        case 59:\n            ++this.pos;\n            return this.finishToken(types$1.semi);\n        case 44:\n            ++this.pos;\n            return this.finishToken(types$1.comma);\n        case 91:\n            ++this.pos;\n            return this.finishToken(types$1.bracketL);\n        case 93:\n            ++this.pos;\n            return this.finishToken(types$1.bracketR);\n        case 123:\n            ++this.pos;\n            return this.finishToken(types$1.braceL);\n        case 125:\n            ++this.pos;\n            return this.finishToken(types$1.braceR);\n        case 58:\n            ++this.pos;\n            return this.finishToken(types$1.colon);\n        case 96:\n            if (this.options.ecmaVersion < 6) {\n                break;\n            }\n            ++this.pos;\n            return this.finishToken(types$1.backQuote);\n        case 48:\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 120 || next === 88) {\n                return this.readRadixNumber(16);\n            } // '0x', '0X' - hex number\n            if (this.options.ecmaVersion >= 6) {\n                if (next === 111 || next === 79) {\n                    return this.readRadixNumber(8);\n                } // '0o', '0O' - octal number\n                if (next === 98 || next === 66) {\n                    return this.readRadixNumber(2);\n                } // '0b', '0B' - binary number\n            }\n        // Anything else beginning with a digit is an integer, octal\n        // number, or float.\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n            return this.readNumber(false);\n        // Quotes produce strings.\n        case 34:\n        case 39:\n            return this.readString(code);\n        // Operators are parsed inline in tiny state machines. '=' (61) is\n        // often referred to. `finishOp` simply skips the amount of\n        // characters it is given as second argument, and returns a token\n        // of the type given by its first argument.\n        case 47:\n            return this.readToken_slash();\n        case 37:\n        case 42:\n            return this.readToken_mult_modulo_exp(code);\n        case 124:\n        case 38:\n            return this.readToken_pipe_amp(code);\n        case 94:\n            return this.readToken_caret();\n        case 43:\n        case 45:\n            return this.readToken_plus_min(code);\n        case 60:\n        case 62:\n            return this.readToken_lt_gt(code);\n        case 61:\n        case 33:\n            return this.readToken_eq_excl(code);\n        case 63:\n            return this.readToken_question();\n        case 126:\n            return this.finishOp(types$1.prefix, 1);\n        case 35:\n            return this.readToken_numberSign();\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n};\npp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        var ch = this.input.charAt(this.pos);\n        if (lineBreak.test(ch)) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        if (!escaped) {\n            if (ch === \"[\") {\n                inClass = true;\n            } else if (ch === \"]\" && inClass) {\n                inClass = false;\n            } else if (ch === \"/\" && !inClass) {\n                break;\n            }\n            escaped = ch === \"\\\\\";\n        } else {\n            escaped = false;\n        }\n        ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) {\n        this.unexpected(flagsStart);\n    }\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n    // Create Literal#value property value.\n    var value = null;\n    try {\n        value = new RegExp(pattern, flags);\n    } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n    return this.finishToken(types$1.regexp, {\n        pattern: pattern,\n        flags: flags,\n        value: value\n    });\n};\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n    var start = this.pos, total = 0, lastCode = 0;\n    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n        var code = this.input.charCodeAt(this.pos), val = void 0;\n        if (allowSeparators && code === 95) {\n            if (isLegacyOctalNumericLiteral) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n            }\n            if (lastCode === 95) {\n                this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n            }\n            if (i === 0) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n            }\n            lastCode = code;\n            continue;\n        }\n        if (code >= 97) {\n            val = code - 97 + 10;\n        } else if (code >= 65) {\n            val = code - 65 + 10;\n        } else if (code >= 48 && code <= 57) {\n            val = code - 48;\n        } else {\n            val = Infinity;\n        }\n        if (val >= radix) {\n            break;\n        }\n        lastCode = code;\n        total = total * radix + val;\n    }\n    if (allowSeparators && lastCode === 95) {\n        this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) {\n        return null;\n    }\n    return total;\n};\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) {\n        return parseInt(str, 8);\n    }\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"));\n}\nfunction stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") {\n        return null;\n    }\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"));\n}\npp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) {\n        this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n        val = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    return this.finishToken(types$1.num, val);\n};\n// Read an integer, octal integer, or floating-point number.\npp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n        this.raise(start, \"Invalid number\");\n    }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) {\n        this.raise(start, \"Invalid number\");\n    }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n        var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val$1);\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n        octal = false;\n    }\n    if (next === 46 && !octal) {\n        ++this.pos;\n        this.readInt(10);\n        next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) {\n        next = this.input.charCodeAt(++this.pos);\n        if (next === 43 || next === 45) {\n            ++this.pos;\n        } // '+-'\n        if (this.readInt(10) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    var val = stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken(types$1.num, val);\n};\n// Read a string value, interpreting backslash-escapes.\npp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n    if (ch === 123) {\n        if (this.options.ecmaVersion < 6) {\n            this.unexpected();\n        }\n        var codePos = ++this.pos;\n        code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n        ++this.pos;\n        if (code > 0x10FFFF) {\n            this.invalidStringToken(codePos, \"Code point out of bounds\");\n        }\n    } else {\n        code = this.readHexChar(4);\n    }\n    return code;\n};\npp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated string constant\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) {\n            break;\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(false);\n            chunkStart = this.pos;\n        } else if (ch === 0x2028 || ch === 0x2029) {\n            if (this.options.ecmaVersion < 10) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n            if (this.options.locations) {\n                this.curLine++;\n                this.lineStart = this.pos;\n            }\n        } else {\n            if (isNewLine(ch)) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n        }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types$1.string, out);\n};\n// Reads template string tokens.\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\npp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n        this.readTmplToken();\n    } catch (err) {\n        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n            this.readInvalidTemplateToken();\n        } else {\n            throw err;\n        }\n    }\n    this.inTemplateElement = false;\n};\npp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n        throw INVALID_TEMPLATE_ESCAPE_ERROR;\n    } else {\n        this.raise(position, message);\n    }\n};\npp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated template\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                if (ch === 36) {\n                    this.pos += 2;\n                    return this.finishToken(types$1.dollarBraceL);\n                } else {\n                    ++this.pos;\n                    return this.finishToken(types$1.backQuote);\n                }\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(types$1.template, out);\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(true);\n            chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            ++this.pos;\n            switch(ch){\n                case 13:\n                    if (this.input.charCodeAt(this.pos) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                    out += \"\\n\";\n                    break;\n                default:\n                    out += String.fromCharCode(ch);\n                    break;\n            }\n            if (this.options.locations) {\n                ++this.curLine;\n                this.lineStart = this.pos;\n            }\n            chunkStart = this.pos;\n        } else {\n            ++this.pos;\n        }\n    }\n};\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n    for(; this.pos < this.input.length; this.pos++){\n        switch(this.input[this.pos]){\n            case \"\\\\\":\n                ++this.pos;\n                break;\n            case \"$\":\n                if (this.input[this.pos + 1] !== \"{\") {\n                    break;\n                }\n            // falls through\n            case \"`\":\n                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n        }\n    }\n    this.raise(this.start, \"Unterminated template\");\n};\n// Used to read escaped characters\npp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch(ch){\n        case 110:\n            return \"\\n\" // 'n' -> '\\n'\n            ;\n        case 114:\n            return \"\\r\" // 'r' -> '\\r'\n            ;\n        case 120:\n            return String.fromCharCode(this.readHexChar(2)) // 'x'\n            ;\n        case 117:\n            return codePointToString(this.readCodePoint()) // 'u'\n            ;\n        case 116:\n            return \"\t\" // 't' -> '\\t'\n            ;\n        case 98:\n            return \"\\b\" // 'b' -> '\\b'\n            ;\n        case 118:\n            return \"\\v\" // 'v' -> '\\u000b'\n            ;\n        case 102:\n            return \"\\f\" // 'f' -> '\\f'\n            ;\n        case 13:\n            if (this.input.charCodeAt(this.pos) === 10) {\n                ++this.pos;\n            } // '\\r\\n'\n        case 10:\n            if (this.options.locations) {\n                this.lineStart = this.pos;\n                ++this.curLine;\n            }\n            return \"\";\n        case 56:\n        case 57:\n            if (this.strict) {\n                this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n            }\n            if (inTemplate) {\n                var codePos = this.pos - 1;\n                this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n            }\n        default:\n            if (ch >= 48 && ch <= 55) {\n                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                var octal = parseInt(octalStr, 8);\n                if (octal > 255) {\n                    octalStr = octalStr.slice(0, -1);\n                    octal = parseInt(octalStr, 8);\n                }\n                this.pos += octalStr.length - 1;\n                ch = this.input.charCodeAt(this.pos);\n                if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                    this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                }\n                return String.fromCharCode(octal);\n            }\n            if (isNewLine(ch)) {\n                // Unicode new line characters after \\ get removed from output in both\n                // template literals and strings\n                return \"\";\n            }\n            return String.fromCharCode(ch);\n    }\n};\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\npp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) {\n        this.invalidStringToken(codePos, \"Bad character escape sequence\");\n    }\n    return n;\n};\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\npp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while(this.pos < this.input.length){\n        var ch = this.fullCharCodeAtPos();\n        if (isIdentifierChar(ch, astral)) {\n            this.pos += ch <= 0xffff ? 1 : 2;\n        } else if (ch === 92) {\n            this.containsEsc = true;\n            word += this.input.slice(chunkStart, this.pos);\n            var escStart = this.pos;\n            if (this.input.charCodeAt(++this.pos) !== 117) {\n                this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n            }\n            ++this.pos;\n            var esc = this.readCodePoint();\n            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n            }\n            word += codePointToString(esc);\n            chunkStart = this.pos;\n        } else {\n            break;\n        }\n        first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos);\n};\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\npp.readWord = function() {\n    var word = this.readWord1();\n    var type = types$1.name;\n    if (this.keywords.test(word)) {\n        type = keywords[word];\n    }\n    return this.finishToken(type, word);\n};\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\nvar version = \"8.11.2\";\nParser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types$1,\n    keywordTypes: keywords,\n    TokContext: TokContext,\n    tokContexts: types,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n};\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\nfunction parse(input, options) {\n    return Parser.parse(input, options);\n}\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\nfunction parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options);\n}\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\nfunction tokenizer(input, options) {\n    return Parser.tokenizer(input, options);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUFtRDtBQUNuRCxJQUFJQSx3QkFBd0I7SUFBQztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUs7SUFBRztJQUFLO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSztJQUFJO0lBQUs7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFNO0lBQUc7SUFBRztJQUFJO0lBQU87SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFPO0lBQUc7SUFBTTtJQUFJO0lBQUc7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBRztJQUFNO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBTTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUk7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFJO0lBQUs7SUFBSTtJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFNO0lBQUc7SUFBUTtDQUFJO0FBRTVoQyxtREFBbUQ7QUFDbkQsSUFBSUMsNkJBQTZCO0lBQUM7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFLO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSztJQUFHO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSTtJQUFLO0lBQU07SUFBSTtJQUFJO0lBQU07SUFBSTtJQUFHO0lBQU07SUFBSztJQUFNO0lBQUs7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBSTtJQUFLO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBTTtJQUFHO0lBQU07SUFBSTtJQUFHO0lBQU07SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFLO0lBQU07SUFBSztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFNO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7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Q0YsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQyxFQUFFO0FBQ0YsOERBQThEO0FBQzlELEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHVCQUF1QjtBQUd2QixJQUFJRyxVQUFVO0FBRWQxckIsT0FBTzJyQixLQUFLLEdBQUc7SUFDYjNyQixRQUFRQTtJQUNSMHJCLFNBQVNBO0lBQ1RwdkIsZ0JBQWdCQTtJQUNoQmQsVUFBVUE7SUFDVk0sZ0JBQWdCQTtJQUNoQkksYUFBYUE7SUFDYjRnQixNQUFNQTtJQUNOaHBCLFdBQVdBO0lBQ1g4M0IsVUFBVTcyQjtJQUNWODJCLGNBQWNqM0I7SUFDZG1mLFlBQVlBO0lBQ1orWCxhQUFhM1g7SUFDYnRnQixrQkFBa0JBO0lBQ2xCTCxtQkFBbUJBO0lBQ25CdXpCLE9BQU9BO0lBQ1BqdEIsV0FBV0E7SUFDWEgsV0FBV0E7SUFDWEMsWUFBWUE7SUFDWlEsb0JBQW9CQTtBQUN0QjtBQUVBLDhEQUE4RDtBQUM5RCw4REFBOEQ7QUFDOUQsa0VBQWtFO0FBQ2xFLGFBQWE7QUFDYixFQUFFO0FBQ0YsMEVBQTBFO0FBRTFFLFNBQVN5SSxNQUFNMUcsS0FBSyxFQUFFckgsT0FBTztJQUMzQixPQUFPa0wsT0FBTzZDLEtBQUssQ0FBQzFHLE9BQU9ySDtBQUM3QjtBQUVBLDhEQUE4RDtBQUM5RCxnRUFBZ0U7QUFDaEUscUNBQXFDO0FBRXJDLFNBQVNpUCxrQkFBa0I1SCxLQUFLLEVBQUU5SSxHQUFHLEVBQUV5QixPQUFPO0lBQzVDLE9BQU9rTCxPQUFPK0QsaUJBQWlCLENBQUM1SCxPQUFPOUksS0FBS3lCO0FBQzlDO0FBRUEsb0VBQW9FO0FBQ3BFLGlFQUFpRTtBQUVqRSxTQUFTb1AsVUFBVS9ILEtBQUssRUFBRXJILE9BQU87SUFDL0IsT0FBT2tMLE9BQU9rRSxTQUFTLENBQUMvSCxPQUFPckg7QUFDakM7QUFFMlQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pcHQtdzMvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanM/MDg2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDM3MCwgMSwgODEsIDIsIDcxLCAxMCwgNTAsIDMsIDEyMywgMiwgNTQsIDE0LCAzMiwgMTAsIDMsIDEsIDExLCAzLCA0NiwgMTAsIDgsIDAsIDQ2LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAzLCAwLCAxNTgsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDQwNiwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTAsIDEsIDIsIDAsIDQ5LCA2LCA0LCA0LCAxNCwgOSwgNTM1MSwgMCwgNywgMTQsIDEzODM1LCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgMTAxNCwgMCwgMiwgNTQsIDgsIDMsIDgyLCAwLCAxMiwgMSwgMTk2MjgsIDEsIDQ3MDYsIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCA5ODMsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxMywgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCAyLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDY4LCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM0OSwgNDEsIDcsIDEsIDc5LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDE1OSwgNTIsIDE5LCAzLCAyMSwgMiwgMzEsIDQ3LCAyMSwgMSwgMiwgMCwgMTg1LCA0NiwgNDIsIDMsIDM3LCA0NywgMjEsIDAsIDYwLCA0MiwgMTQsIDAsIDcyLCAyNiwgMzgsIDYsIDE4NiwgNDMsIDExNywgNjMsIDMyLCA3LCAzLCAwLCAzLCA3LCAyLCAxLCAyLCAyMywgMTYsIDAsIDIsIDAsIDk1LCA3LCAzLCAzOCwgMTcsIDAsIDIsIDAsIDI5LCAwLCAxMSwgMzksIDgsIDAsIDIyLCAwLCAxMiwgNDUsIDIwLCAwLCAxOSwgNzIsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCA0MDI2LCA1ODIsIDg2MzQsIDU2OCwgOCwgMzAsIDE4LCA3OCwgMTgsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA2ODksIDYzLCAxMjksIDc0LCA2LCAwLCA2NywgMTIsIDY1LCAxLCAyLCAwLCAyOSwgNjEzNSwgOSwgMTIzNywgNDMsIDgsIDg5MzYsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgNzU3LCA2LCAyLCAzLCAyLCAxLCAyLCAxNCwgMiwgMTk2LCA2MCwgNjcsIDgsIDAsIDEyMDUsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzE5LCAzMywgNDE1MywgNywgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMTYsIDYyMSwgMjQ2NywgNTQxLCAxNTA3LCA0OTM4LCA2LCA0MTkxXTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwODk4LVxcdTA4OWZcXHUwOGNhLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTUtXFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNjXFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmM1xcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNlXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNVxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgwZi1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmYtXFx1MWFjZVxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1MzBmYlxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXFx1ZmY2NVwiO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2FcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZDlcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5cbi8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLlxuXG4vLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMkMSA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbi8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG52YXIga2V5d29yZHMgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHNbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyQxID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgcHJpdmF0ZUlkOiBuZXcgVG9rZW5UeXBlKFwicHJpdmF0ZUlkXCIsIHN0YXJ0c0V4cHIpLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgY29hbGVzY2U6IGJpbm9wKFwiPz9cIiwgMSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOVxufVxuXG5mdW5jdGlvbiBuZXh0TGluZUJyZWFrKGNvZGUsIGZyb20sIGVuZCkge1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gY29kZS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBuZXh0ID0gY29kZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpc05ld0xpbmUobmV4dCkpXG4gICAgICB7IHJldHVybiBpIDwgZW5kIC0gMSAmJiBuZXh0ID09PSAxMyAmJiBjb2RlLmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCA/IGkgKyAyIDogaSArIDEgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG52YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QuaGFzT3duIHx8IChmdW5jdGlvbiAob2JqLCBwcm9wTmFtZSkgeyByZXR1cm4gKFxuICBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4pOyB9KTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxudmFyIHJlZ2V4cENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIHJlZ2V4cENhY2hlW3dvcmRzXSB8fCAocmVnZXhwQ2FjaGVbd29yZHNdID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKSlcbn1cblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnZhciBsb25lU3Vycm9nYXRlID0gLyg/OltcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS87XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG59O1xuXG4vLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4vLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbi8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbi8vIGludG8uXG5cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgIHZhciBuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKGlucHV0LCBjdXIsIG9mZnNldCk7XG4gICAgaWYgKG5leHRCcmVhayA8IDApIHsgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpIH1cbiAgICArK2xpbmU7XG4gICAgY3VyID0gbmV4dEJyZWFrO1xuICB9XG59XG5cbi8vIEEgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4gdG8gY29uZmlndXJlIHRoZSBwYXJzZXIgcHJvY2Vzcy5cbi8vIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQgKG9ubHkgYGVjbWFWZXJzaW9uYCBpcyByZXF1aXJlZCk6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAvLyBlaXRoZXIgMywgNSwgNiAob3IgMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIDEwXG4gIC8vICgyMDE5KSwgMTEgKDIwMjApLCAxMiAoMjAyMSksIDEzICgyMDIyKSwgMTQgKDIwMjMpLCBvciBgXCJsYXRlc3RcImBcbiAgLy8gKHRoZSBsYXRlc3QgdmVyc2lvbiB0aGUgbGlicmFyeSBzdXBwb3J0cykuIFRoaXMgaW5mbHVlbmNlc1xuICAvLyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnRcbiAgLy8gZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuXG4gIGVjbWFWZXJzaW9uOiBudWxsLFxuICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuICAvLyBwb3NpdGlvbiBvZiB0aGUgaW5zZXJ0ZWQgc2VtaWNvbG9uIGFzIGFuIG9mZnNldCwgYW5kIGlmXG4gIC8vIGBsb2NhdGlvbnNgIGlzIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSxcbiAgLy8gY29sdW1ufWAgb2JqZWN0IGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbSwgYW5kIGFuIGltcG9ydC5tZXRhIGV4cHJlc3Npb25cbiAgLy8gaW4gYSBzY3JpcHQgaXNuJ3QgY29uc2lkZXJlZCBhbiBlcnJvci5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gQnkgZGVmYXVsdCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUgb25seSBpZiBlY21hVmVyc2lvbiA+PSAyMDIyLlxuICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAvLyBidXQgdGhleSBhcmUgc3RpbGwgbm90IGFsbG93ZWQgaW4gbm9uLWFzeW5jIGZ1bmN0aW9ucy5cbiAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBzdXBlciBpZGVudGlmaWVycyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gIC8vIGFwcGVhcmluZyBpbiBtZXRob2RzIGFuZCBkbyBub3QgcmFpc2UgYW4gZXJyb3Igd2hlbiB0aGV5IGFwcGVhciBlbHNld2hlcmUuXG4gIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGUgaXNcbiAgLy8gYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC4gRW5hYmxlZCBieSBkZWZhdWx0IHdoZW5cbiAgLy8gYGVjbWFWZXJzaW9uYCA+PSAyMDIzLlxuICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgLy8gQnkgZGVmYXVsdCwgdGhlIHBhcnNlciB3aWxsIHZlcmlmeSB0aGF0IHByaXZhdGUgcHJvcGVydGllcyBhcmVcbiAgLy8gb25seSB1c2VkIGluIHBsYWNlcyB3aGVyZSB0aGV5IGFyZSB2YWxpZCBhbmQgaGF2ZSBiZWVuIGRlY2xhcmVkLlxuICAvLyBTZXQgdGhpcyB0byBmYWxzZSB0byB0dXJuIHN1Y2ggY2hlY2tzIG9mZi5cbiAgY2hlY2tQcml2YXRlRmllbGRzOiB0cnVlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgLy8gV2hlbiB0aGlzIG9wdGlvbiBoYXMgYW4gYXJyYXkgYXMgdmFsdWUsIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZVxuICAvLyBjb21tZW50cyBhcmUgcHVzaGVkIHRvIGl0LlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxudmFyIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXNPd24ob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxZTg7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dEVjbWFWZXJzaW9uICYmIHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oXCJTaW5jZSBBY29ybiA4LjAuMCwgb3B0aW9ucy5lY21hVmVyc2lvbiBpcyByZXF1aXJlZC5cXG5EZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMTE7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KSB7XG4gICAgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICBpZiAoIW9wdHMgfHwgb3B0cy5hbGxvd0hhc2hCYW5nID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93SGFzaEJhbmcgPSBvcHRpb25zLmVjbWFWZXJzaW9uID49IDE0OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyOCxcbiAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0s7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG59XG5cbi8vIFVzZWQgaW4gY2hlY2tMVmFsKiBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xudmFyXG4gICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3JkcyQxW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgIHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNSA/IDUgOiAzXTtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgfVxuXG4gIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gIC8vIEl0cyB0eXBlXG4gIHRoaXMudHlwZSA9IHR5cGVzJDEuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcbiAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmYWxzZTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG4gIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuXG4gIC8vIFRoZSBzdGFjayBvZiBwcml2YXRlIG5hbWVzLlxuICAvLyBFYWNoIGVsZW1lbnQgaGFzIHR3byBwcm9wZXJ0aWVzOiAnZGVjbGFyZWQnIGFuZCAndXNlZCcuXG4gIC8vIFdoZW4gaXQgZXhpdGVkIGZyb20gdGhlIG91dGVybW9zdCBjbGFzcyBkZWZpbml0aW9uLCBhbGwgdXNlZCBwcml2YXRlIG5hbWVzIG11c3QgYmUgZGVjbGFyZWQuXG4gIHRoaXMucHJpdmF0ZU5hbWVTdGFjayA9IFtdO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNhbkF3YWl0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93TmV3RG90VGFyZ2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQ2xhc3NTdGF0aWNCbG9jazogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dFRva2VuKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jYW5Bd2FpdC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgfHwgc2NvcGUuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgeyByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9XG4gIH1cbiAgcmV0dXJuICh0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMykgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHJlZi5pbkNsYXNzRmllbGRJbml0O1xuICByZXR1cm4gKGZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB8fCBpbkNsYXNzRmllbGRJbml0IHx8IHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dOZXdEb3RUYXJnZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgIHZhciBpbkNsYXNzRmllbGRJbml0ID0gcmVmLmluQ2xhc3NGaWVsZEluaXQ7XG4gIHJldHVybiAoZmxhZ3MgJiAoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spKSA+IDAgfHwgaW5DbGFzc0ZpZWxkSW5pdFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluQ2xhc3NTdGF0aWNCbG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgPiAwXG59O1xuXG5QYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgdmFyIGNscyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgcmV0dXJuIGNsc1xufTtcblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxufTtcblxuUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwYXJzZXIubmV4dFRva2VuKCk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbn07XG5cblBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbnZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ1xcXFxdKSo/KSd8XCIoKD86XFxcXC58W15cIlxcXFxdKSo/KVwiKS87XG5wcCQ5LnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA1KSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAoOzspIHtcbiAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpLCBlbmQgPSBzcGFjZUFmdGVyLmluZGV4ICsgc3BhY2VBZnRlclswXS5sZW5ndGg7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KGVuZCk7XG4gICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgKGxpbmVCcmVhay50ZXN0KHNwYWNlQWZ0ZXJbMF0pICYmXG4gICAgICAgICAhKC9bKGAuWytcXC0vKiU8Pj0sP14mXS8udGVzdChuZXh0KSB8fCBuZXh0ID09PSBcIiFcIiAmJiB0aGlzLmlucHV0LmNoYXJBdChlbmQgKyAxKSA9PT0gXCI9XCIpKVxuICAgIH1cbiAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICB7IHN0YXJ0Kys7IH1cbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwJDkuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwJDkuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcCQ5LmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAkOS5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxucHAkOS5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2VSIHx8XG4gICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxucHAkOS5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwJDkuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMkMS5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkOS5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxudmFyIERlc3RydWN0dXJpbmdFcnJvcnMgPSBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAtMTtcbn07XG5cbnBwJDkuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBpc0Fzc2lnbiA/IFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiIDogXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwJDkuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbn07XG5cbnBwJDkuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxufTtcblxucHAkOS5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbn07XG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbi8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbi8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbi8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxucHAkOC5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZW9mKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIGlmICh0aGlzLmluTW9kdWxlKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgIH0gfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxudmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG5wcCQ4LmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgaWYgKG5leHRDaCA9PT0gOTEgfHwgbmV4dENoID09PSA5MikgeyByZXR1cm4gdHJ1ZSB9IC8vICdbJywgJy8nXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAneycsIGFzdHJhbFxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQ4LmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBhZnRlcjtcbiAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAhKGlzSWRlbnRpZmllckNoYXIoYWZ0ZXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDgpKSB8fCBhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMCkpXG59O1xuXG4vLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4vL1xuLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4vLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4vLyBkb2VzIG5vdCBoZWxwLlxuXG5wcCQ4LnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICBzdGFydHR5cGUgPSB0eXBlcyQxLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gIGNhc2UgdHlwZXMkMS5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMkMS5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzJDEuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgY2FzZSB0eXBlcyQxLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9leHBvcnQ6XG4gIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzJDEuX2ltcG9ydCkge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQwIHx8IG5leHRDaCA9PT0gNDYpIC8vICcoJyBvciAnLidcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcyQxLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkOC5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBlbHNlIHtcbiAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzJDEuc2VtaSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcCQ4LnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gIH1cbiAgdmFyIHN0YXJ0c1dpdGhMZXQgPSB0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSwgaXNGb3JPZiA9IGZhbHNlO1xuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGF3YWl0QXQgPiAtMSA/IFwiYXdhaXRcIiA6IHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAoaXNGb3JPZiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRzV2l0aExldCAmJiBpc0Zvck9mKSB7IHRoaXMucmFpc2UoaW5pdC5zdGFydCwgXCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ2xldCcuXCIpOyB9XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihpbml0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbn07XG5cbnBwJDgucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG59O1xuXG5wcCQ4LnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcyQxLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jYXNlcyA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXI7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUjspIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXNlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fZGVmYXVsdCkge1xuICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZTtcbiAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkkMSA9IFtdO1xuXG5wcCQ4LnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgdmFyIHNpbXBsZSA9IHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gIHRoaXMuY2hlY2tMVmFsUGF0dGVybihwYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgcmV0dXJuIHBhcmFtXG59O1xuXG5wcCQ4LnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnBhcmVuTCkpIHtcbiAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB9XG4gICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzJDEuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICB9IH1cbiAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAvLyBVcGRhdGUgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXMgbGFiZWxzIG9uIHRoaXMgbm9kZVxuICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQ4LnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gIGlmICggbm9kZSA9PT0gdm9pZCAwICkgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGV4aXRTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSBmYWxzZTsgfVxuICB0aGlzLm5leHQoKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDgucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG5wcCQ4LnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9pbjtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKFxuICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAoXG4gICAgICAhaXNGb3JJbiB8fFxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICApXG4gICkge1xuICAgIHRoaXMucmFpc2UoXG4gICAgICBpbml0LnN0YXJ0LFxuICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICApO1xuICB9XG4gIG5vZGUubGVmdCA9IGluaXQ7XG4gIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcCQ4LnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd01pc3NpbmdJbml0aWFsaXplciAmJiBraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDgucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG59O1xuXG52YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UYCkuXG5cbi8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG5wcCQ4LnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgIC8vIHN1YmplY3QgdG8gQW5uZXggQiBzZW1hbnRpY3MgKEJJTkRfRlVOQ1RJT04pLiBPdGhlcndpc2UsIHRoZSBiaW5kaW5nXG4gICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICB9XG5cbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlLCBmb3JJbml0KTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxucHAkOC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xufTtcblxuLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDgucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgcHJpdmF0ZU5hbWVNYXAgPSB0aGlzLmVudGVyQ2xhc3NCb2R5KCk7XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUikge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQua2V5LnN0YXJ0LCAoXCJJZGVudGlmaWVyICcjXCIgKyAoZWxlbWVudC5rZXkubmFtZSkgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHRoaXMuZXhpdENsYXNzQm9keSgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJzdGF0aWNcIikpIHtcbiAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMyAmJiB0aGlzLmVhdCh0eXBlcyQxLmJyYWNlTCkpIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJzdGF0aWNcIjtcbiAgICB9XG4gIH1cbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICBpZiAoKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJhc3luY1wiO1xuICAgIH1cbiAgfVxuICBpZiAoIWtleU5hbWUgJiYgKGVjbWFWZXJzaW9uID49IDkgfHwgIWlzQXN5bmMpICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcikpIHtcbiAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gIH1cbiAgaWYgKCFrZXlOYW1lICYmICFpc0FzeW5jICYmICFpc0dlbmVyYXRvcikge1xuICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpKSB7XG4gICAgICAgIGtpbmQgPSBsYXN0VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlOYW1lID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGVsZW1lbnQgbmFtZVxuICBpZiAoa2V5TmFtZSkge1xuICAgIC8vICdhc3luYycsICdnZXQnLCAnc2V0Jywgb3IgJ3N0YXRpYycgd2VyZSBub3QgYSBrZXl3b3JkIGNvbnRleHR1YWxseS5cbiAgICAvLyBUaGUgbGFzdCB0b2tlbiBpcyBhbnkgb2YgdGhvc2UuIE1ha2UgaXQgdGhlIGVsZW1lbnQgbmFtZS5cbiAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbm9kZS5rZXkgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7XG4gICAgbm9kZS5rZXkubmFtZSA9IGtleU5hbWU7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzRWxlbWVudE5hbWUobm9kZSk7XG4gIH1cblxuICAvLyBQYXJzZSBlbGVtZW50IHZhbHVlXG4gIGlmIChlY21hVmVyc2lvbiA8IDEzIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwgfHwga2luZCAhPT0gXCJtZXRob2RcIiB8fCBpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7XG4gICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gaXNDb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICAgIC8vIENvdWxkbid0IG1vdmUgdGhpcyBjaGVjayBpbnRvIHRoZSAncGFyc2VDbGFzc01ldGhvZCcgbWV0aG9kIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICBub2RlLmtpbmQgPSBpc0NvbnN0cnVjdG9yID8gXCJjb25zdHJ1Y3RvclwiIDoga2luZDtcbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NGaWVsZChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQ4LmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZFxuICApXG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGVsZW1lbnQpO1xuICB9XG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG1ldGhvZCwgXCJwcm90b3R5cGVcIikpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cblxuICAvLyBQYXJzZSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgLy8gQ2hlY2sgdmFsdWVcbiAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIHZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoY2hlY2tLZXlOYW1lKGZpZWxkLCBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgfSBlbHNlIGlmIChmaWVsZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKGZpZWxkLCBcInByb3RvdHlwZVwiKSkge1xuICAgIHRoaXMucmFpc2UoZmllbGQua2V5LnN0YXJ0LCBcIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhIHN0YXRpYyBmaWVsZCBuYW1lZCAncHJvdG90eXBlJ1wiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgIC8vIFRvIHJhaXNlIFN5bnRheEVycm9yIGlmICdhcmd1bWVudHMnIGV4aXN0cyBpbiB0aGUgaW5pdGlhbGl6ZXIuXG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSBzY29wZS5pbkNsYXNzRmllbGRJbml0O1xuICAgIHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgPSB0cnVlO1xuICAgIGZpZWxkLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCA9IGluQ2xhc3NGaWVsZEluaXQ7XG4gIH0gZWxzZSB7XG4gICAgZmllbGQudmFsdWUgPSBudWxsO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc1N0YXRpY0Jsb2NrID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmJvZHkgPSBbXTtcblxuICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gIHRoaXMubGFiZWxzID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RhdGljQmxvY2tcIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcyQxLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhudWxsLCBmYWxzZSkgOiBudWxsO1xufTtcblxucHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IHtkZWNsYXJlZDogT2JqZWN0LmNyZWF0ZShudWxsKSwgdXNlZDogW119O1xuICB0aGlzLnByaXZhdGVOYW1lU3RhY2sucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbn07XG5cbnBwJDguZXhpdENsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICB2YXIgZGVjbGFyZWQgPSByZWYuZGVjbGFyZWQ7XG4gIHZhciB1c2VkID0gcmVmLnVzZWQ7XG4gIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICB2YXIgbGVuID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aDtcbiAgdmFyIHBhcmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnByaXZhdGVOYW1lU3RhY2tbbGVuIC0gMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IHVzZWRbaV07XG4gICAgaWYgKCFoYXNPd24oZGVjbGFyZWQsIGlkLm5hbWUpKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC51c2VkLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQocHJpdmF0ZU5hbWVNYXAsIGVsZW1lbnQpIHtcbiAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICB2YXIgY3VyciA9IHByaXZhdGVOYW1lTWFwW25hbWVdO1xuXG4gIHZhciBuZXh0ID0gXCJ0cnVlXCI7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgIG5leHQgPSAoZWxlbWVudC5zdGF0aWMgPyBcInNcIiA6IFwiaVwiKSArIGVsZW1lbnQua2luZDtcbiAgfVxuXG4gIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICBpZiAoXG4gICAgY3VyciA9PT0gXCJpZ2V0XCIgJiYgbmV4dCA9PT0gXCJpc2V0XCIgfHxcbiAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgIGN1cnIgPT09IFwic2dldFwiICYmIG5leHQgPT09IFwic3NldFwiIHx8XG4gICAgY3VyciA9PT0gXCJzc2V0XCIgJiYgbmV4dCA9PT0gXCJzZ2V0XCJcbiAgKSB7XG4gICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBcInRydWVcIjtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghY3Vycikge1xuICAgIHByaXZhdGVOYW1lTWFwW25hbWVdID0gbmV4dDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5TmFtZShub2RlLCBuYW1lKSB7XG4gIHZhciBjb21wdXRlZCA9IG5vZGUuY29tcHV0ZWQ7XG4gIHZhciBrZXkgPSBub2RlLmtleTtcbiAgcmV0dXJuICFjb21wdXRlZCAmJiAoXG4gICAga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBuYW1lIHx8XG4gICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICApXG59XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQ4LnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBleHBvcnRzKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcblxuICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uoc3BlYy5sb2NhbC5zdGFydCwgXCJBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGV4cG9ydGVkIGJpbmRpbmcgd2l0aG91dCBgZnJvbWAuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxufTtcblxucHAkOC5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKVxufTtcblxucHAkOC5wYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNBc3luYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKVxuICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2xhc3MpIHtcbiAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gIH1cbn07XG5cbnBwJDguY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICB7IG5hbWUgPSBuYW1lLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gbmFtZS5uYW1lIDogbmFtZS52YWx1ZTsgfVxuICBpZiAoaGFzT3duKGV4cG9ydHMsIG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQ4LmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdCwgcGF0LnN0YXJ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxufTtcblxucHAkOC5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgfVxufTtcblxucHAkOC5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxucHAkOC5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcblxuICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIDogbm9kZS5sb2NhbDtcbiAgdGhpcy5jaGVja0V4cG9ydChcbiAgICBleHBvcnRzLFxuICAgIG5vZGUuZXhwb3J0ZWQsXG4gICAgbm9kZS5leHBvcnRlZC5zdGFydFxuICApO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKGV4cG9ydHMpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDgucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5JDE7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS5pbXBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG5cbiAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUuaW1wb3J0ZWQpO1xuICAgIG5vZGUubG9jYWwgPSBub2RlLmltcG9ydGVkO1xuICB9XG4gIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFNwZWNpZmllclwiKVxufTtcblxucHAkOC5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKVxufTtcblxucHAkOC5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gIH1cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcigpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbnBwJDgucGFyc2VNb2R1bGVFeHBvcnROYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgIHZhciBzdHJpbmdMaXRlcmFsID0gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk7XG4gICAgaWYgKGxvbmVTdXJyb2dhdGUudGVzdChzdHJpbmdMaXRlcmFsLnZhbHVlKSkge1xuICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkOC5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiZcbiAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgKVxufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQ3LnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAvLyBFYXJseSBlcnJvcjpcbiAgICAgICAgLy8gICBBc3NpZ25tZW50UmVzdFByb3BlcnR5W1lpZWxkLCBBd2FpdF0gOlxuICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAvL1xuICAgICAgICAvLyAgIEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIHxEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldHwgaXMgYW4gfEFycmF5TGl0ZXJhbHwgb3IgYW4gfE9iamVjdExpdGVyYWx8LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgfVxuICBpZiAoZW5kKSB7XG4gICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxuLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG5wcCQ3LnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbn07XG5cbnBwJDcucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxufTtcblxuLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxucHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxufTtcblxucHAkNy5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgcmV0dXJuIGVsZW1cbn07XG5cbnBwJDcucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICByZXR1cm4gcGFyYW1cbn07XG5cbi8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbnBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcyQxLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyB0aHJlZSBmdW5jdGlvbnMgYWxsIHZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsdWUg4oCUXG4vLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4vLyBhIHZhcmlldHkgb2YgY2hlY2tzOlxuLy9cbi8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4vLyAtIFJlY29yZCBuYW1lIGRlY2xhcmF0aW9ucyBmb3IgYmluZGluZ3MgaW4gdGhlIGFwcHJvcHJpYXRlIHNjb3BlLlxuLy8gLSBDaGVjayBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMsIGlmIGNoZWNrQ2xhc2hlcyBpcyBzZXQuXG4vL1xuLy8gSWYgYSBjb21wbGV4IGJpbmRpbmcgcGF0dGVybiBpcyBlbmNvdW50ZXJlZCAoZS5nLiwgb2JqZWN0IGFuZCBhcnJheVxuLy8gZGVzdHJ1Y3R1cmluZyksIHRoZSBlbnRpcmUgcGF0dGVybiBpcyByZWN1cnNpdmVseSBjaGVja2VkLlxuLy9cbi8vIFRoZXJlIGFyZSB0aHJlZSB2ZXJzaW9ucyBvZiBjaGVja0xWYWwqKCkgYXBwcm9wcmlhdGUgZm9yIGRpZmZlcmVudFxuLy8gY2lyY3Vtc3RhbmNlczpcbi8vXG4vLyAtIGNoZWNrTFZhbFNpbXBsZSgpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbi8vICAgbm90aGluZyBvdGhlciB0aGFuIGlkZW50aWZpZXJzIGFuZCBtZW1iZXIgZXhwcmVzc2lvbnMuIFBhcmVudGhlc2l6ZWRcbi8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuLy8gICBjb25zdHJ1Y3RzIGZvciB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4vLyAgID4gc2ltcGxlLlxuLy9cbi8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4vLyAgIGRlZmluZWQgZWxzZXdoZXJlLCBsaWtlIGltcG9ydCBkZWNsYXJhdGlvbnMgb3IgZnVuY3Rpb24vY2xhc3MgaWRlbnRpZmllcnMuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICBhICs9IOKApjtcbi8vICAgICBpbXBvcnQgYSBmcm9tICfigKYnO1xuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4vLyAgIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvciBjb25zdHJ1Y3RzIGZvclxuLy8gICB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIFt0aGUgcHJvZHVjdGlvbl0gaXMgbmVpdGhlciBhbiBPYmplY3RMaXRlcmFsIG5vclxuLy8gICA+IGFuIEFycmF5TGl0ZXJhbCBhbmQgQXNzaWdubWVudFRhcmdldFR5cGUgb2YgW3RoZSBwcm9kdWN0aW9uXSBpcyBub3Rcbi8vICAgPiBzaW1wbGUuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICAoYSA9IOKApik7XG4vLyAgICAgY29uc3QgYSA9IOKApjtcbi8vICAgICB0cnkgeyDigKYgfSBjYXRjaCAoYSkgeyDigKYgfVxuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxJbm5lclBhdHRlcm4oKSBzaGFsbCBiZSB1c2VkIGlmIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHN1cHBvcnRzXG4vLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbi8vICAgcGF0dGVybnMsIHJlc3QgZWxlbWVudHMsIGFuZCBvdGhlciBjb25zdHJ1Y3RzIHRoYXQgbWF5IGFwcGVhciB3aXRoaW4gYW5cbi8vICAgb2JqZWN0IG9yIGFycmF5IGRlc3RydWN0dXJpbmcgcGF0dGVybi5cbi8vXG4vLyAgIEFzIGEgc3BlY2lhbCBjYXNlLCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFsc28gdXNlIGNoZWNrTFZhbElubmVyUGF0dGVybigpLFxuLy8gICBhcyB0aGV5IGFsc28gc3VwcG9ydCBkZWZhdWx0cyBhbmQgcmVzdCBjb25zdHJ1Y3RzLlxuLy9cbi8vIFRoZXNlIGZ1bmN0aW9ucyBkZWxpYmVyYXRlbHkgc3VwcG9ydCBib3RoIGFzc2lnbm1lbnQgYW5kIGJpbmRpbmcgY29uc3RydWN0cyxcbi8vIGFzIHRoZSBsb2dpYyBmb3IgYm90aCBpcyBleGNlZWRpbmdseSBzaW1pbGFyLiBJZiB0aGUgbm9kZSBpcyB0aGUgdGFyZ2V0IG9mXG4vLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4vLyBzaG91bGQgYmUgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZSBCSU5EXyogY29uc3RhbnQsIGxpa2UgQklORF9WQVIgb3Jcbi8vIEJJTkRfTEVYSUNBTC5cbi8vXG4vLyBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYSBub24tQklORF9OT05FIGJpbmRpbmdUeXBlLCB0aGVuXG4vLyBhZGRpdGlvbmFsbHkgYSBjaGVja0NsYXNoZXMgb2JqZWN0IG1heSBiZSBzcGVjaWZpZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yXG4vLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3Rcbi8vIGlzIGFuIGFzc2lnbm1lbnQgKGkuZS4sIGJpbmRpbmdUeXBlIGlzIEJJTkRfTk9ORSkuXG5cbnBwJDcuY2hlY2tMVmFsU2ltcGxlID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICB2YXIgaXNCaW5kID0gYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGlmIChpc0JpbmQpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXNPd24oY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG5wcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbn07XG5cbnBwJDcuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgfVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxuXG52YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xufTtcblxudmFyIHR5cGVzID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ2LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMuYl9zdGF0XVxufTtcblxucHAkNi5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG5wcCQ2LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMuZl9zdGF0KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzLmJfc3RhdCB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDYudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzJDEuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBVc2VkIHRvIGhhbmRsZSBlZGdlIGNhc2VzIHdoZW4gdG9rZW4gY29udGV4dCBjb3VsZCBub3QgYmUgaW5mZXJyZWQgY29ycmVjdGx5IGR1cmluZyB0b2tlbml6YXRpb24gcGhhc2VcblxucHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgIT09IHRva2VuQ3R4KSB7XG4gICAgdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXSA9IHRva2VuQ3R4O1xuICB9XG59O1xuXG4vLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbnR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xufTtcblxudHlwZXMkMS5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5iX3RtcGwpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzJDEuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG59O1xuXG50eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLl9lbHNlICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcyQxLnNlbWkgJiYgdGhpcy5jdXJDb250ZXh0KCkgIT09IHR5cGVzLnBfc3RhdCkgJiZcbiAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYl9zdGF0KSlcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmZfZXhwcik7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcyQxLmNvbG9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMkMS5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcy5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG5cbnZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDUuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkge1xuICAgICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2Zcbi8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbnBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChmb3JJbml0KSB9XG4gICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICBlbHNlIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIH1cblxuICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTEsIG9sZERvdWJsZVByb3RvID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGREb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmb3JJbml0ID09PSBcImF3YWl0XCI7XG4gIH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICB7IGxlZnQgPSB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IGxlZnQuc3RhcnQpXG4gICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxKVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFBhdHRlcm4obGVmdCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKGxlZnQpOyB9XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIGlmIChvbGREb3VibGVQcm90byA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBvbGREb3VibGVQcm90bzsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMkMS5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIGZvckluaXQpXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQ1LnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFmb3JJbml0IHx8IHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgY29hbGVzY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29hbGVzY2U7XG4gICAgICBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCBgbm9kZS5yaWdodGAgc2hvdWxkbid0IGNvbnRhaW4gbG9naWNhbCBleHByZXNzaW9ucyBpbiBvcmRlciB0byBjaGVjayB0aGUgbWl4ZWQgZXJyb3IuXG4gICAgICAgIHByZWMgPSB0eXBlcyQxLmxvZ2ljYWxBTkQuYmlub3A7XG4gICAgICB9XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgZm9ySW5pdCk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCB8fCBjb2FsZXNjZSk7XG4gICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJMb2dpY2FsIGV4cHJlc3Npb25zIGFuZCBjb2FsZXNjZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgbWl4ZWQuIFdyYXAgZWl0aGVyIGJ5IHBhcmVudGhlc2VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5wcCQ1LmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbnBwJDUucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnksIGluY0RlYywgZm9ySW5pdCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmIHRoaXMuY2FuQXdhaXQpIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KGZvckluaXQpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW5jRGVjO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmFyZ3VtZW50KSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiUHJpdmF0ZSBmaWVsZHMgY2FuIG5vdCBiZSBkZWxldGVkXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICghc2F3VW5hcnkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgIGlmICgoZm9ySW5pdCB8fCB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgIGlmIChzYXdVbmFyeSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpLCBcIioqXCIsIGZhbHNlKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICBub2RlLnR5cGUgPT09IFwiQ2hhaW5FeHByZXNzaW9uXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5leHByZXNzaW9uKVxuICApXG59XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQ1LnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgZmFsc2UsIGZvckluaXQpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJlxuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgY2hhaW5Ob2RlLmV4cHJlc3Npb24gPSBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGJhc2UgPSBlbGVtZW50O1xuICB9XG59O1xuXG5wcCQ1LnNob3VsZFBhcnNlQXN5bmNBcnJvdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdylcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlLCBmb3JJbml0KVxufTtcblxucHAkNS5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93LCBvcHRpb25hbENoYWluZWQsIGZvckluaXQpIHtcbiAgdmFyIG9wdGlvbmFsU3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgaWYgKG5vQ2FsbHMgJiYgb3B0aW9uYWwpIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zXCIpOyB9XG5cbiAgdmFyIGNvbXB1dGVkID0gdGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCk7XG4gIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICB9XG4gICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIW9wdGlvbmFsICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlJDEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmJhY2tRdW90ZSkge1xuICAgIGlmIChvcHRpb25hbCB8fCBvcHRpb25hbENoYWluZWQpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgIH1cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkNS5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCwgZm9yTmV3KSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciAoIEFyZ3VtZW50cyApXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcyQxLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5mX2V4cHIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlLCBmb3JJbml0KVxuICAgIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgKCF0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCB8fCB0aGlzLnZhbHVlICE9PSBcIm9mXCIgfHwgdGhpcy5jb250YWluc0VzYykpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMkMS5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcyQxLl9udWxsOiBjYXNlIHR5cGVzJDEuX3RydWU6IGNhc2UgdHlwZXMkMS5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMkMS5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzJDEuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5iX2V4cHIpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMkMS5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzJDEuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzJDEuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoZm9yTmV3KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gIH1cbn07XG5cbnBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG5wcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gQ29uc3VtZSBgaW1wb3J0YCBhcyBhbiBpZGVudGlmaWVyIGZvciBgaW1wb3J0Lm1ldGFgLlxuICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgaW1wb3J0XCIpOyB9XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQobm9kZSlcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZG90KSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGEobm9kZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkNS5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpOyAvLyBza2lwIGAoYFxuXG4gIC8vIFBhcnNlIG5vZGUuc291cmNlLlxuICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gIC8vIFZlcmlmeSBlbmRpbmcuXG4gIGlmICghdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5jb21tYSkgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChlcnJvclBvcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VJbXBvcnRNZXRhID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgLmBcblxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwibWV0YVwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgaWYgKGNvbnRhaW5zRXNjKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ2ltcG9ydC5tZXRhJyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiKTsgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbn07XG5cbnBwJDUucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIGlmIChub2RlLnJhdy5jaGFyQ29kZUF0KG5vZGUucmF3Lmxlbmd0aCAtIDEpID09PSAxMTApIHsgbm9kZS5iaWdpbnQgPSBub2RlLnJhdy5zbGljZSgwLCAtMSkucmVwbGFjZSgvXy9nLCBcIlwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDUucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICByZXR1cm4gdmFsXG59O1xuXG5wcCQ1LnNob3VsZFBhcnNlQXJyb3cgPSBmdW5jdGlvbihleHByTGlzdCkge1xuICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKClcbn07XG5cbnBwJDUucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3csIGZvckluaXQpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuUikge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKFxuICAgICAgICAgICAgdGhpcy5zdGFydCxcbiAgICAgICAgICAgIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLmxhc3RUb2tFbmQsIGlubmVyRW5kTG9jID0gdGhpcy5sYXN0VG9rRW5kTG9jO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBcnJvdyhleHByTGlzdCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpXG4gICAgfVxuXG4gICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn07XG5cbnBwJDUucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHJldHVybiBpdGVtXG59O1xuXG5wcCQ1LnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIGZhbHNlLCBmb3JJbml0KVxufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4vLyBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXQgbGVhc3QsXG4vLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4vLyBhcmd1bWVudCBsaXN0LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkNS5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXdcIik7IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5kb3QpIHtcbiAgICB2YXIgbWV0YSA9IHRoaXMuc3RhcnROb2RlQXQobm9kZS5zdGFydCwgbm9kZS5zdGFydExvYyk7XG4gICAgbWV0YS5uYW1lID0gXCJuZXdcIjtcbiAgICBub2RlLm1ldGEgPSB0aGlzLmZpbmlzaE5vZGUobWV0YSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgJ25ldy50YXJnZXQnXCIpOyB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAoIXRoaXMuYWxsb3dOZXdEb3RUYXJnZXQpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3Mgc3RhdGljIGJsb2NrXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20obnVsbCwgZmFsc2UsIHRydWUpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUsIGZhbHNlKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkNS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkge1xuICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICB9XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgIGNvb2tlZDogbnVsbFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDUucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmRvbGxhckJyYWNlTCk7XG4gICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxufTtcblxucHAkNS5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikpICYmXG4gICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbi8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxucHAkNS5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcyQxLmVsbGlwc2lzKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICB9XG4gICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgLy8gRmluaXNoXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgfVxuICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7IH1cbiAgfVxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgfSBlbHNlIHtcbiAgICBpc0FzeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxufTtcblxucHAkNS5wYXJzZUdldHRlclNldHRlciA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgfVxufTtcblxucHAkNS5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbG9uKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBpZiAodGhpcy5lYXQodHlwZXMkMS5jb2xvbikpIHtcbiAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCkge1xuICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuZXEpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB0aGlzLnBhcnNlR2V0dGVyU2V0dGVyKHByb3ApO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgaWYgKHByb3Aua2V5Lm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHRoaXMuY29weU5vZGUocHJvcC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMuY29weU5vZGUocHJvcC5rZXkpO1xuICAgIH1cbiAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcCQ1LnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkNS5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG5wcCQ1LnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbnBwJDUucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuXG4gIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbnBwJDUucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24sIGlzTWV0aG9kLCBmb3JJbml0KSB7XG4gIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlTDtcbiAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICB9XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIW9sZFN0cmljdCAmJiAhdXNlU3RyaWN0ICYmICFpc0Fycm93RnVuY3Rpb24gJiYgIWlzTWV0aG9kICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCB1bmRlZmluZWQsIHVzZVN0cmljdCAmJiAhb2xkU3RyaWN0KTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG59O1xuXG5wcCQ1LmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbnBwJDUuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIG5hbWVIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwYXJhbSwgQklORF9WQVIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcCQ1LnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKVxuICAgICAgeyBlbHQgPSBudWxsOyB9XG4gICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIH1cbiAgICBlbHRzLnB1c2goZWx0KTtcbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkNS5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICBpZiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdCAmJiBuYW1lID09PSBcImFyZ3VtZW50c1wiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2FyZ3VtZW50cycgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXJcIik7IH1cbiAgaWYgKHRoaXMuaW5DbGFzc1N0YXRpY0Jsb2NrICYmIChuYW1lID09PSBcImFyZ3VtZW50c1wiIHx8IG5hbWUgPT09IFwiYXdhaXRcIikpXG4gICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJDYW5ub3QgdXNlIFwiICsgbmFtZSArIFwiIGluIGNsYXNzIHN0YXRpYyBpbml0aWFsaXphdGlvbiBibG9ja1wiKSk7IH1cbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICBpZiAocmUudGVzdChuYW1lKSkge1xuICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIChcIlRoZSBrZXl3b3JkICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIikpO1xuICB9XG59O1xuXG4vLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4vLyBpZGVudGlmaWVycy5cblxucHAkNS5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCkge1xuICB2YXIgbm9kZSA9IHRoaXMucGFyc2VJZGVudE5vZGUoKTtcbiAgdGhpcy5uZXh0KCEhbGliZXJhbCk7XG4gIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIGlmICghbGliZXJhbCkge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDUucGFyc2VJZGVudE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy50eXBlID0gdHlwZXMkMS5uYW1lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQ1LnBhcnNlUHJpdmF0ZUlkZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcml2YXRlSWRlbnRpZmllclwiKTtcblxuICAvLyBGb3IgdmFsaWRhdGluZyBleGlzdGVuY2VcbiAgaWYgKHRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHtcbiAgICBpZiAodGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAobm9kZS5uYW1lKSArIFwiJyBtdXN0IGJlIGRlY2xhcmVkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpdmF0ZU5hbWVTdGFja1t0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoIC0gMV0udXNlZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQ1LnBhcnNlWWllbGQgPSBmdW5jdGlvbihmb3JJbml0KSB7XG4gIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxufTtcblxucHAkNS5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oZm9ySW5pdCkge1xuICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnJcbn07XG5cbnBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbnBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgfVxufTtcblxudmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLnZhciA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5sZXhpY2FsID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMuZnVuY3Rpb25zID0gW107XG4gIC8vIEEgc3dpdGNoIHRvIGRpc2FsbG93IHRoZSBpZGVudGlmaWVyIHJlZmVyZW5jZSAnYXJndW1lbnRzJ1xuICB0aGlzLmluQ2xhc3NGaWVsZEluaXQgPSBmYWxzZTtcbn07XG5cbi8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxucHAkMy5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG59O1xuXG5wcCQzLmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG59O1xuXG4vLyBUaGUgc3BlYyBzYXlzOlxuLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxucHAkMy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxufTtcblxucHAkMy5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxufTtcblxucHAkMy5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gIH1cbn07XG5cbnBwJDMuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG59O1xuXG5wcCQzLmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gIH1cbn07XG5cbi8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxucHAkMy5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkMi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG59O1xuXG5wcCQyLnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxufTtcblxuLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICByZXR1cm4gbm9kZVxufVxuXG5wcCQyLmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDIuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxufTtcblxucHAkMi5jb3B5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIG5ld05vZGUgPSBuZXcgTm9kZSh0aGlzLCBub2RlLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBub2RlKSB7IG5ld05vZGVbcHJvcF0gPSBub2RlW3Byb3BdOyB9XG4gIHJldHVybiBuZXdOb2RlXG59O1xuXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgVW5pY29kZSBwcm9wZXJ0aWVzIGV4dHJhY3RlZCBmcm9tIHRoZSBFQ01BU2NyaXB0IHNwZWNpZmljYXRpb24uXG4vLyBUaGUgbGlzdHMgYXJlIGV4dHJhY3RlZCBsaWtlIHNvOlxuLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4vLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1xudmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG52YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xudmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIGVjbWExMkJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRUJhc2UgRUNvbXAgRU1vZCBFUHJlcyBFeHRQaWN0XCI7XG52YXIgZWNtYTEzQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMkJpbmFyeVByb3BlcnRpZXM7XG52YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllcyA9IGVjbWExM0JpbmFyeVByb3BlcnRpZXM7XG5cbnZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllcyA9IHtcbiAgOTogZWNtYTlCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgMTE6IGVjbWExMUJpbmFyeVByb3BlcnRpZXMsXG4gIDEyOiBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMzogZWNtYTEzQmluYXJ5UHJvcGVydGllcyxcbiAgMTQ6IGVjbWExNEJpbmFyeVByb3BlcnRpZXNcbn07XG5cbi8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzLW9mLXN0cmluZ3NcbnZhciBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzID0gXCJCYXNpY19FbW9qaSBFbW9qaV9LZXljYXBfU2VxdWVuY2UgUkdJX0Vtb2ppX01vZGlmaWVyX1NlcXVlbmNlIFJHSV9FbW9qaV9GbGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9UYWdfU2VxdWVuY2UgUkdJX0Vtb2ppX1pXSl9TZXF1ZW5jZSBSR0lfRW1vamlcIjtcblxudmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzID0ge1xuICA5OiBcIlwiLFxuICAxMDogXCJcIixcbiAgMTE6IFwiXCIsXG4gIDEyOiBcIlwiLFxuICAxMzogXCJcIixcbiAgMTQ6IGVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3Ncbn07XG5cbi8vICN0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXG52YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4vLyAjdGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXG52YXIgZWNtYTlTY3JpcHRWYWx1ZXMgPSBcIkFkbGFtIEFkbG0gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmJcIjtcbnZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG52YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG52YXIgZWNtYTEyU2NyaXB0VmFsdWVzID0gZWNtYTExU2NyaXB0VmFsdWVzICsgXCIgQ2hvcmFzbWlhbiBDaHJzIERpYWsgRGl2ZXNfQWt1cnUgS2hpdGFuX1NtYWxsX1NjcmlwdCBLaXRzIFllemkgWWV6aWRpXCI7XG52YXIgZWNtYTEzU2NyaXB0VmFsdWVzID0gZWNtYTEyU2NyaXB0VmFsdWVzICsgXCIgQ3lwcm9fTWlub2FuIENwbW4gT2xkX1V5Z2h1ciBPdWdyIFRhbmdzYSBUbnNhIFRvdG8gVml0aGt1cWkgVml0aFwiO1xudmFyIGVjbWExNFNjcmlwdFZhbHVlcyA9IGVjbWExM1NjcmlwdFZhbHVlcyArIFwiIEhya3QgS2F0YWthbmFfT3JfSGlyYWdhbmEgS2F3aSBOYWdfTXVuZGFyaSBOYWdtIFVua25vd24gWnp6elwiO1xuXG52YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gIDExOiBlY21hMTFTY3JpcHRWYWx1ZXMsXG4gIDEyOiBlY21hMTJTY3JpcHRWYWx1ZXMsXG4gIDEzOiBlY21hMTNTY3JpcHRWYWx1ZXMsXG4gIDE0OiBlY21hMTRTY3JpcHRWYWx1ZXNcbn07XG5cbnZhciBkYXRhID0ge307XG5mdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgIGJpbmFyeU9mU3RyaW5nczogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3NbZWNtYVZlcnNpb25dKSxcbiAgICBub25CaW5hcnk6IHtcbiAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICB9XG4gIH07XG4gIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xufVxuXG5mb3IgKHZhciBpID0gMCwgbGlzdCA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMTRdOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICB2YXIgZWNtYVZlcnNpb24gPSBsaXN0W2ldO1xuXG4gIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pO1xufVxuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMyA/IFwiZFwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTUgPyBcInZcIiA6IFwiXCIpO1xuICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNCA/IDE0IDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gMDtcbiAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoViA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gIHZhciB1bmljb2RlU2V0cyA9IGZsYWdzLmluZGV4T2YoXCJ2XCIpICE9PSAtMTtcbiAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgaWYgKHVuaWNvZGVTZXRzICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTUpIHtcbiAgICB0aGlzLnN3aXRjaFUgPSB0cnVlO1xuICAgIHRoaXMuc3dpdGNoViA9IHRydWU7XG4gICAgdGhpcy5zd2l0Y2hOID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbiAgfVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xufTtcblxuLy8gSWYgdSBmbGFnIGlzIGdpdmVuLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGluZGV4IChpdCBjb21iaW5lcyBhIHN1cnJvZ2F0ZSBwYWlyKS5cbi8vIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGluZGV4IChjYW4gYmUgYSBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIpLlxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGNcbiAgfVxuICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gbFxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAobmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhEQzAwIHx8IG5leHQgPiAweERGRkYpIHtcbiAgICByZXR1cm4gaSArIDFcbiAgfVxuICByZXR1cm4gaSArIDJcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcywgZm9yY2VVKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKSwgZm9yY2VVKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gsIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICBpZiAodGhpcy5jdXJyZW50KGZvcmNlVSkgPT09IGNoKSB7XG4gICAgdGhpcy5hZHZhbmNlKGZvcmNlVSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0Q2hhcnMgPSBmdW5jdGlvbiBlYXRDaGFycyAoY2hzLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNoczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgY2ggPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXQocG9zLCBmb3JjZVUpO1xuICAgIGlmIChjdXJyZW50ID09PSAtMSB8fCBjdXJyZW50ICE9PSBjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHBvcyA9IHRoaXMubmV4dEluZGV4KHBvcywgZm9yY2VVKTtcbiAgfVxuICB0aGlzLnBvcyA9IHBvcztcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDEudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgdmFyIHUgPSBmYWxzZTtcbiAgdmFyIHYgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgICBpZiAoZmxhZyA9PT0gXCJ1XCIpIHsgdSA9IHRydWU7IH1cbiAgICBpZiAoZmxhZyA9PT0gXCJ2XCIpIHsgdiA9IHRydWU7IH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ICYmIHUgJiYgdikge1xuICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQxLnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxucHAkMS5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLnBvcyA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURpc2p1bmN0aW9uXG5wcCQxLnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB9XG5cbiAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxucHAkMS5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICB7IH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG5wcCQxLnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG5wcCQxLnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gIC8vIF4sICRcbiAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFxcYiBcXEJcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG5wcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbnBwJDEucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gIClcbn07XG5wcCQxLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbnBwJDEucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gIClcbn07XG5wcCQxLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSAmJiBzdGF0ZS5lYXQoMHgzQSAvKiA6ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG5wcCQxLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbnBwJDEucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLyB8fFxuICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUUgLyogXiAqLyB8fFxuICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4vLyBCdXQgZWF0IGVhZ2VyLlxucHAkMS5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG5wcCQxLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChcbiAgICBjaCAhPT0gLTEgJiZcbiAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgIGNoICE9PSAweDJFIC8qIC4gKi8gJiZcbiAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgIGNoICE9PSAweDVFIC8qIF4gKi8gJiZcbiAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gR3JvdXBTcGVjaWZpZXIgOjpcbi8vICAgW2VtcHR5XVxuLy8gICBgP2AgR3JvdXBOYW1lXG5wcCQxLnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgfVxufTtcblxuLy8gR3JvdXBOYW1lIDo6XG4vLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZSBgPmBcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkMS5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJOYW1lIDo6XG4vLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFxuLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZSBSZWdFeHBJZGVudGlmaWVyUGFydFxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyU3RhcnQgOjpcbi8vICAgVW5pY29kZUlEU3RhcnRcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbnBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGZvcmNlVSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZm9yY2VVKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0IDo6XG4vLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4vLyAgIDxaV05KPlxuLy8gICA8WldKPlxucHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqLyB8fCBjaCA9PT0gMHgyMDBDIC8qIDxaV05KPiAqLyB8fCBjaCA9PT0gMHgyMDBEIC8qIDxaV0o+ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1BdG9tRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKFxuICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgLyogYyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBGb3IgU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy1hdG9tZXNjYXBlXG4gICAgICBpZiAobiA+IHN0YXRlLm1heEJhY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdEtHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0WmVybyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZhbHNlKSB8fFxuICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgKVxufTtcbnBwJDEucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG5wcCQxLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbnBwJDEucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlLCBmb3JjZVUpIHtcbiAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIHN3aXRjaFUgPSBmb3JjZVUgfHwgc3RhdGUuc3dpdGNoVTtcblxuICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pICYmIHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBzd2l0Y2hVICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgIGRvIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJldHVybiB2YWx1ZXMgdXNlZCBieSBjaGFyYWN0ZXIgc2V0IHBhcnNpbmcgbWV0aG9kcywgbmVlZGVkIHRvXG4vLyBmb3JiaWQgbmVnYXRpb24gb2Ygc2V0cyB0aGF0IGNhbiBtYXRjaCBzdHJpbmdzLlxudmFyIENoYXJTZXROb25lID0gMDsgLy8gTm90aGluZyBwYXJzZWRcbnZhciBDaGFyU2V0T2sgPSAxOyAvLyBDb25zdHJ1Y3QgcGFyc2VkLCBjYW5ub3QgY29udGFpbiBzdHJpbmdzXG52YXIgQ2hhclNldFN0cmluZyA9IDI7IC8vIENvbnN0cnVjdCBwYXJzZWQsIGNhbiBjb250YWluIHN0cmluZ3NcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gQ2hhclNldE9rXG4gIH1cblxuICB2YXIgbmVnYXRlID0gZmFsc2U7XG4gIGlmIChcbiAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAoKG5lZ2F0ZSA9IGNoID09PSAweDUwIC8qIFAgKi8pIHx8IGNoID09PSAweDcwIC8qIHAgKi8pXG4gICkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICAocmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgKSB7XG4gICAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxuXG4gIHJldHVybiBDaGFyU2V0Tm9uZVxufTtcblxuZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgY2ggPT09IDB4NzMgLyogcyAqLyB8fFxuICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgY2ggPT09IDB4NTcgLyogVyAqL1xuICApXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbnBwJDEucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgLyogPSAqLykpIHtcbiAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIENoYXJTZXRPa1xuICAgIH1cbiAgfVxuICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKVxuICB9XG4gIHJldHVybiBDaGFyU2V0Tm9uZVxufTtcblxucHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFoYXNPd24oc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG59O1xuXG5wcCQxLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gIGlmIChzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gIGlmIChzdGF0ZS5zd2l0Y2hWICYmIHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeU9mU3RyaW5ncy50ZXN0KG5hbWVPclZhbHVlKSkgeyByZXR1cm4gQ2hhclNldFN0cmluZyB9XG4gIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xufTtcblxuLy8gVW5pY29kZVByb3BlcnR5TmFtZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcblxuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxufVxuXG4vLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQxLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc1xucHAkMS5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICB2YXIgbmVnYXRlID0gc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgIGlmICghc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTsgfVxuICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3NcIik7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NDb250ZW50c1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbnBwJDEucmVnZXhwX2NsYXNzQ29udGVudHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDVEIC8qIF0gKi8pIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gIGlmIChzdGF0ZS5zd2l0Y2hWKSB7IHJldHVybiB0aGlzLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24oc3RhdGUpIH1cbiAgdGhpcy5yZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyhzdGF0ZSk7XG4gIHJldHVybiBDaGFyU2V0T2tcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbnBwJDEucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbnBwJDEucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NUQgLyogXSAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldEV4cHJlc3Npb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzVW5pb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzSW50ZXJzZWN0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG5wcCQxLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgcmVzdWx0ID0gQ2hhclNldE9rLCBzdWJSZXN1bHQ7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlKHN0YXRlKSkgOyBlbHNlIGlmIChzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKSB7XG4gICAgaWYgKHN1YlJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NJbnRlcnNlY3Rpb25cbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDI2LCAweDI2XSAvKiAmJiAqLykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuY3VycmVudCgpICE9PSAweDI2IC8qICYgKi8gJiZcbiAgICAgICAgKHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN1YlJlc3VsdCAhPT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0T2s7IH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT09IHN0YXRlLnBvcykgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG4gICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDJELCAweDJEXSAvKiAtLSAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT09IHN0YXRlLnBvcykgeyByZXR1cm4gcmVzdWx0IH1cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgfVxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1VuaW9uXG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShzdGF0ZSkpIHsgY29udGludWUgfVxuICAgIHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSk7XG4gICAgaWYgKCFzdWJSZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgaWYgKHN1YlJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmFuZ2VcbnBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0T3BlcmFuZFxucHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkgeyByZXR1cm4gQ2hhclNldE9rIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24oc3RhdGUpIHx8IHRoaXMucmVnZXhwX2VhdE5lc3RlZENsYXNzKHN0YXRlKVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtTmVzdGVkQ2xhc3NcbnBwJDEucmVnZXhwX2VhdE5lc3RlZENsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICB2YXIgbmVnYXRlID0gc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSkge1xuICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgdmFyIHJlc3VsdCQxID0gdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpO1xuICAgIGlmIChyZXN1bHQkMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdCQxXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0Q2hhcnMoWzB4NUMsIDB4NzFdIC8qIFxccSAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50c1xucHAkMS5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKHN0YXRlKSA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdHJpbmdcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5vbkVtcHR5Q2xhc3NTdHJpbmdcbnBwJDEucmVnZXhwX2NsYXNzU3RyaW5nID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkgeyBjb3VudCsrOyB9XG4gIHJldHVybiBjb3VudCA9PT0gMSA/IENoYXJTZXRPayA6IENoYXJTZXRTdHJpbmdcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0Q2hhcmFjdGVyXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yKHN0YXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA8IDAgfHwgY2ggPT09IHN0YXRlLmxvb2thaGVhZCgpICYmIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICBzdGF0ZS5hZHZhbmNlKCk7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JcbmZ1bmN0aW9uIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHgyMSAvKiAhICovIHx8XG4gICAgY2ggPj0gMHgyMyAvKiAjICovICYmIGNoIDw9IDB4MjYgLyogJiAqLyB8fFxuICAgIGNoID49IDB4MkEgLyogKiAqLyAmJiBjaCA8PSAweDJDIC8qICwgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4NDAgLyogQCAqLyB8fFxuICAgIGNoID09PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0U3ludGF4Q2hhcmFjdGVyXG5mdW5jdGlvbiBpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjggLyogKCAqLyB8fFxuICAgIGNoID09PSAweDI5IC8qICkgKi8gfHxcbiAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgY2ggPT09IDB4MkYgLyogLyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVEIC8qIF0gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3JcbnBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG5mdW5jdGlvbiBpc0NsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgIGNoID09PSAweDIzIC8qICMgKi8gfHxcbiAgICBjaCA9PT0gMHgyNSAvKiAlICovIHx8XG4gICAgY2ggPT09IDB4MjYgLyogJiAqLyB8fFxuICAgIGNoID09PSAweDJDIC8qICwgKi8gfHxcbiAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4M0UgLyogPiAqLyB8fFxuICAgIGNoID09PSAweDQwIC8qIEAgKi8gfHxcbiAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbnBwJDEucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDEucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NzggLyogeCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG5wcCQxLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xucHAkMS5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gIClcbn1cbmZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSAvKiBBICovKVxuICB9XG4gIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSAvKiBhICovKVxuICB9XG4gIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG5wcCQxLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbnBwJDEucmVnZXhwX2VhdE9jdGFsRGlnaXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggLSAweDMwOyAvKiAwICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4vLyBBbmQgSGV4RGlnaXQgSGV4RGlnaXQgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDEucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBPYmplY3QgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCB0b2tlbnMuIE5vdGUgdGhhdCBub3JtYWxseSwgdG9rZW5zXG4vLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4vLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxudmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxufTtcblxuLy8gIyMgVG9rZW5pemVyXG5cbnZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxucHAubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gIGlmICghaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQgJiYgdGhpcy50eXBlLmtleXdvcmQgJiYgdGhpcy5jb250YWluc0VzYylcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgdGhpcy50eXBlLmtleXdvcmQpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiBuZXcgVG9rZW4odGhpcylcbn07XG5cbi8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgeyBwcFtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMSQxLmdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMkMS5lb2YsXG4gICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IH1cblxuLy8gVG9nZ2xlIHN0cmljdCBtb2RlLiBSZS1yZWFkcyB0aGUgbmV4dCBudW1iZXIgb3Igc3RyaW5nIHRvIHBsZWFzZVxuLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmVvZikgfVxuXG4gIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbn07XG5cbnBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG59O1xuXG5wcC5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZGMwMCkgeyByZXR1cm4gY29kZSB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHJldHVybiBuZXh0IDw9IDB4ZGJmZiB8fCBuZXh0ID49IDB4ZTAwMCA/IGNvZGUgOiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG59O1xuXG5wcC5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBmb3IgKHZhciBuZXh0QnJlYWsgPSAodm9pZCAwKSwgcG9zID0gc3RhcnQ7IChuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKHRoaXMuaW5wdXQsIHBvcywgdGhpcy5wb3MpKSA+IC0xOykge1xuICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICBwb3MgPSB0aGlzLmxpbmVTdGFydCA9IG5leHRCcmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxucHAuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4vLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG5wcC5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIHJpZ2h0IHBvc2l0aW9uLlxuXG5wcC5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbn07XG5cbi8vICMjIyBUb2tlbiByZWFkaW5nXG5cbi8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4vLyB0aGFuIGNoYXJhY3RlcnMsIGFuZCBiZWNhdXNlIG9wZXJhdG9yIHBhcnNpbmcgaGFzIGJlZW4gaW5saW5lZFxuLy8gaW50byBpdC5cbi8vXG4vLyBBbGwgaW4gdGhlIG5hbWUgb2Ygc3BlZWQuXG4vL1xucHAucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyAvLyA0NiA9IGRvdCAnLidcbiAgICB0aGlzLnBvcyArPSAzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZWxsaXBzaXMpXG4gIH0gZWxzZSB7XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvdClcbiAgfVxufTtcblxucHAucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5zbGFzaCwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcyQxLnN0YXIgOiB0eXBlcyQxLm1vZHVsbztcblxuICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICsrc2l6ZTtcbiAgICB0b2tlbnR5cGUgPSB0eXBlcyQxLnN0YXJzdGFyO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxufTtcblxucHAucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnfCYnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICBpZiAobmV4dDIgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzJDEubG9naWNhbE9SIDogdHlwZXMkMS5sb2dpY2FsQU5ELCAyKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmJpdHdpc2VPUiA6IHR5cGVzJDEuYml0d2lzZUFORCwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYml0d2lzZVhPUiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmluY0RlYywgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5wbHVzTWluLCAxKVxufTtcblxucHAucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdFNoaWZ0LCBzaXplKVxuICB9XG4gIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucmVsYXRpb25hbCwgc2l6ZSlcbn07XG5cbnBwLnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5hcnJvdylcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzJDEuZXEgOiB0eXBlcyQxLnByZWZpeCwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9xdWVzdGlvbiA9IGZ1bmN0aW9uKCkgeyAvLyAnPydcbiAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICBpZiAoZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA0Nikge1xuICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICBpZiAobmV4dDIgPCA0OCB8fCBuZXh0MiA+IDU3KSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucXVlc3Rpb25Eb3QsIDIpIH1cbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgdmFyIG5leHQyJDEgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgaWYgKG5leHQyJDEgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmNvYWxlc2NlLCAyKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnF1ZXN0aW9uLCAxKVxufTtcblxucHAucmVhZFRva2VuX251bWJlclNpZ24gPSBmdW5jdGlvbigpIHsgLy8gJyMnXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgdmFyIGNvZGUgPSAzNTsgLy8gJyMnXG4gIGlmIChlY21hVmVyc2lvbiA+PSAxMykge1xuICAgICsrdGhpcy5wb3M7XG4gICAgY29kZSA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdHJ1ZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wcml2YXRlSWQsIHRoaXMucmVhZFdvcmQxKCkpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSArIFwiJ1wiKTtcbn07XG5cbnBwLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgY2FzZSA0NjogLy8gJy4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnBhcmVuTClcbiAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlblIpXG4gIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc2VtaSlcbiAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5jb21tYSlcbiAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0TClcbiAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0UilcbiAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VMKVxuICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFjZVIpXG4gIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29sb24pXG5cbiAgY2FzZSA5NjogLy8gJ2AnXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5iYWNrUXVvdGUpXG5cbiAgY2FzZSA0ODogLy8gJzAnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICB9XG5cbiAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgY2FzZSA0NzogLy8gJy8nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgY2FzZSA5NDogLy8gJ14nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gIGNhc2UgNjM6IC8vICc/J1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpXG5cbiAgY2FzZSAxMjY6IC8vICd+J1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucHJlZml4LCAxKVxuXG4gIGNhc2UgMzU6IC8vICcjJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKClcbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcC5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gIHRoaXMucG9zICs9IHNpemU7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbn07XG5cbnBwLnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICBpZiAoY2ggPT09IFwiW1wiKSB7IGluQ2xhc3MgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICsrdGhpcy5wb3M7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gIC8vIFZhbGlkYXRlIHBhdHRlcm5cbiAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbi8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG5wcC5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbiwgbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gIC8vIGBsZW5gIGlzIHVzZWQgZm9yIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzLiBJbiB0aGF0IGNhc2UsIGRpc2FsbG93IHNlcGFyYXRvcnMuXG4gIHZhciBhbGxvd1NlcGFyYXRvcnMgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIgJiYgbGVuID09PSB1bmRlZmluZWQ7XG5cbiAgLy8gYG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbGAgaXMgdHJ1ZSBpZiBpdCBkb2Vzbid0IGhhdmUgcHJlZml4ICgweCwwbywwYilcbiAgLy8gYW5kIGlzbid0IGZyYWN0aW9uIHBhcnQgbm9yIGV4cG9uZW50IHBhcnQuIEluIHRoYXQgY2FzZSwgaWYgdGhlIGZpcnN0IGRpZ2l0XG4gIC8vIGlzIHplcm8gdGhlbiBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICB2YXIgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsID0gbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDQ4O1xuXG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDAsIGxhc3RDb2RlID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpLCArK3RoaXMucG9zKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcblxuICAgIGlmIChhbGxvd1NlcGFyYXRvcnMgJiYgY29kZSA9PT0gOTUpIHtcbiAgICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBvY3RhbCBudW1lcmljIGxpdGVyYWxzXCIpOyB9XG4gICAgICBpZiAobGFzdENvZGUgPT09IDk1KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBtdXN0IGJlIGV4YWN0bHkgb25lIHVuZGVyc2NvcmVcIik7IH1cbiAgICAgIGlmIChpID09PSAwKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgZmlyc3Qgb2YgZGlnaXRzXCIpOyB9XG4gICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IC8vIEFcbiAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IC8vIDAtOVxuICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHsgYnJlYWsgfVxuICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cblxuICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MgLSAxLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBsYXN0IG9mIGRpZ2l0c1wiKTsgfVxuICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgcmV0dXJuIHRvdGFsXG59O1xuXG5mdW5jdGlvbiBzdHJpbmdUb051bWJlcihzdHIsIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgOClcbiAgfVxuXG4gIC8vIGBwYXJzZUZsb2F0KHZhbHVlKWAgc3RvcHMgcGFyc2luZyBhdCB0aGUgZmlyc3QgbnVtZXJpYyBzZXBhcmF0b3IgdGhlbiByZXR1cm5zIGEgd3JvbmcgdmFsdWUuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csIFwiXCIpKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdUb0JpZ0ludChzdHIpIHtcbiAgaWYgKHR5cGVvZiBCaWdJbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBgQmlnSW50KHZhbHVlKWAgdGhyb3dzIHN5bnRheCBlcnJvciBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG51bWVyaWMgc2VwYXJhdG9ycy5cbiAgcmV0dXJuIEJpZ0ludChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbn1cblxucHAucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIHRoaXMucG9zICs9IDI7IC8vIDB4XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMTApIHtcbiAgICB2YWwgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICsrdGhpcy5wb3M7XG4gIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxucHAucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTAsIHVuZGVmaW5lZCwgdHJ1ZSkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgdmFyIHZhbCQxID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsJDEpXG4gIH1cbiAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICsrdGhpcy5wb3M7XG4gICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgfVxuICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIH1cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gIHZhciB2YWwgPSBzdHJpbmdUb051bWJlcih0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksIG9jdGFsKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxucHAucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gIGlmIChjaCA9PT0gMTIzKSB7IC8vICd7J1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICB9IGVsc2Uge1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICB9XG4gIHJldHVybiBjb2RlXG59O1xuXG5wcC5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgIHRoaXMuY3VyTGluZSsrO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbiAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc3RyaW5nLCBvdXQpXG59O1xuXG4vLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG52YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxucHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gIHRyeSB7XG4gICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG59O1xuXG5wcC5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gIH1cbn07XG5cbnBwLnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb2xsYXJCcmFjZUwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJhY2tRdW90ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS50ZW1wbGF0ZSwgb3V0KVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbn07XG5cbi8vIFJlYWRzIGEgdGVtcGxhdGUgdG9rZW4gdG8gc2VhcmNoIGZvciB0aGUgZW5kLCB3aXRob3V0IHZhbGlkYXRpbmcgYW55IGVzY2FwZSBzZXF1ZW5jZXNcbnBwLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiJFwiOlxuICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlIFwiYFwiOlxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5pbnZhbGlkVGVtcGxhdGUsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpKVxuXG4gICAgLy8gbm8gZGVmYXVsdFxuICAgIH1cbiAgfVxuICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xufTtcblxuLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG5wcC5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBjYXNlIDU2OlxuICBjYXNlIDU3OlxuICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgIHRoaXMucG9zIC0gMSxcbiAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICBjb2RlUG9zLFxuICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICApO1xuICAgIH1cbiAgZGVmYXVsdDpcbiAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgfVxuICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICB9XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG5wcC5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICByZXR1cm4gblxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGB0aGlzLmNvbnRhaW5zRXNjYFxuLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4vL1xuLy8gSW5jcmVtZW50YWxseSBhZGRzIG9ubHkgZXNjYXBlZCBjaGFycywgYWRkaW5nIG90aGVyIGNodW5rcyBhcy1pc1xuLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbnBwLnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIC8vIFwidVwiXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbnBwLnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSB0eXBlcyQxLm5hbWU7XG4gIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICB0eXBlID0ga2V5d29yZHNbd29yZF07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbn07XG5cbi8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSwgSW5ndmFyIFN0ZXBhbnlhbiwgYW5kXG4vLyB2YXJpb3VzIGNvbnRyaWJ1dG9ycyBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuLmdpdFxuLy9cbi8vIFBsZWFzZSB1c2UgdGhlIFtnaXRodWIgYnVnIHRyYWNrZXJdW2doYnRdIHRvIHJlcG9ydCBpc3N1ZXMuXG4vL1xuLy8gW2doYnRdOiBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXNcbi8vXG4vLyBbd2Fsa106IHV0aWwvd2Fsay5qc1xuXG5cbnZhciB2ZXJzaW9uID0gXCI4LjExLjJcIjtcblxuUGFyc2VyLmFjb3JuID0ge1xuICBQYXJzZXI6IFBhcnNlcixcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICBQb3NpdGlvbjogUG9zaXRpb24sXG4gIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICBOb2RlOiBOb2RlLFxuICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgdG9rVHlwZXM6IHR5cGVzJDEsXG4gIGtleXdvcmRUeXBlczoga2V5d29yZHMsXG4gIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gIHRva0NvbnRleHRzOiB0eXBlcyxcbiAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgaXNJZGVudGlmaWVyU3RhcnQ6IGlzSWRlbnRpZmllclN0YXJ0LFxuICBUb2tlbjogVG9rZW4sXG4gIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICBsaW5lQnJlYWs6IGxpbmVCcmVhayxcbiAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2Vcbn07XG5cbi8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4vLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4vLyBBUEldW2FwaV0uXG4vL1xuLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uIGF0IGEgZ2l2ZW5cbi8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbi8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG59XG5cbi8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4vLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG5mdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG59XG5cbmV4cG9ydCB7IE5vZGUsIFBhcnNlciwgUG9zaXRpb24sIFNvdXJjZUxvY2F0aW9uLCBUb2tDb250ZXh0LCBUb2tlbiwgVG9rZW5UeXBlLCBkZWZhdWx0T3B0aW9ucywgZ2V0TGluZUluZm8sIGlzSWRlbnRpZmllckNoYXIsIGlzSWRlbnRpZmllclN0YXJ0LCBpc05ld0xpbmUsIGtleXdvcmRzIGFzIGtleXdvcmRUeXBlcywgbGluZUJyZWFrLCBsaW5lQnJlYWtHLCBub25BU0NJSXdoaXRlc3BhY2UsIHBhcnNlLCBwYXJzZUV4cHJlc3Npb25BdCwgdHlwZXMgYXMgdG9rQ29udGV4dHMsIHR5cGVzJDEgYXMgdG9rVHlwZXMsIHRva2VuaXplciwgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbImFzdHJhbElkZW50aWZpZXJDb2RlcyIsImFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzIiwibm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMiLCJub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzIiwicmVzZXJ2ZWRXb3JkcyIsInN0cmljdCIsInN0cmljdEJpbmQiLCJlY21hNUFuZExlc3NLZXl3b3JkcyIsImtleXdvcmRzJDEiLCJrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnQiLCJSZWdFeHAiLCJub25BU0NJSWlkZW50aWZpZXIiLCJpc0luQXN0cmFsU2V0IiwiY29kZSIsInNldCIsInBvcyIsImkiLCJsZW5ndGgiLCJpc0lkZW50aWZpZXJTdGFydCIsImFzdHJhbCIsInRlc3QiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpc0lkZW50aWZpZXJDaGFyIiwiVG9rZW5UeXBlIiwibGFiZWwiLCJjb25mIiwia2V5d29yZCIsImJlZm9yZUV4cHIiLCJzdGFydHNFeHByIiwiaXNMb29wIiwiaXNBc3NpZ24iLCJwcmVmaXgiLCJwb3N0Zml4IiwiYmlub3AiLCJ1cGRhdGVDb250ZXh0IiwibmFtZSIsInByZWMiLCJrZXl3b3JkcyIsImt3Iiwib3B0aW9ucyIsInR5cGVzJDEiLCJudW0iLCJyZWdleHAiLCJzdHJpbmciLCJwcml2YXRlSWQiLCJlb2YiLCJicmFja2V0TCIsImJyYWNrZXRSIiwiYnJhY2VMIiwiYnJhY2VSIiwicGFyZW5MIiwicGFyZW5SIiwiY29tbWEiLCJzZW1pIiwiY29sb24iLCJkb3QiLCJxdWVzdGlvbiIsInF1ZXN0aW9uRG90IiwiYXJyb3ciLCJ0ZW1wbGF0ZSIsImludmFsaWRUZW1wbGF0ZSIsImVsbGlwc2lzIiwiYmFja1F1b3RlIiwiZG9sbGFyQnJhY2VMIiwiZXEiLCJhc3NpZ24iLCJpbmNEZWMiLCJsb2dpY2FsT1IiLCJsb2dpY2FsQU5EIiwiYml0d2lzZU9SIiwiYml0d2lzZVhPUiIsImJpdHdpc2VBTkQiLCJlcXVhbGl0eSIsInJlbGF0aW9uYWwiLCJiaXRTaGlmdCIsInBsdXNNaW4iLCJtb2R1bG8iLCJzdGFyIiwic2xhc2giLCJzdGFyc3RhciIsImNvYWxlc2NlIiwiX2JyZWFrIiwiX2Nhc2UiLCJfY2F0Y2giLCJfY29udGludWUiLCJfZGVidWdnZXIiLCJfZGVmYXVsdCIsIl9kbyIsIl9lbHNlIiwiX2ZpbmFsbHkiLCJfZm9yIiwiX2Z1bmN0aW9uIiwiX2lmIiwiX3JldHVybiIsIl9zd2l0Y2giLCJfdGhyb3ciLCJfdHJ5IiwiX3ZhciIsIl9jb25zdCIsIl93aGlsZSIsIl93aXRoIiwiX25ldyIsIl90aGlzIiwiX3N1cGVyIiwiX2NsYXNzIiwiX2V4dGVuZHMiLCJfZXhwb3J0IiwiX2ltcG9ydCIsIl9udWxsIiwiX3RydWUiLCJfZmFsc2UiLCJfaW4iLCJfaW5zdGFuY2VvZiIsIl90eXBlb2YiLCJfdm9pZCIsIl9kZWxldGUiLCJsaW5lQnJlYWsiLCJsaW5lQnJlYWtHIiwic291cmNlIiwiaXNOZXdMaW5lIiwibmV4dExpbmVCcmVhayIsImZyb20iLCJlbmQiLCJuZXh0IiwiY2hhckNvZGVBdCIsIm5vbkFTQ0lJd2hpdGVzcGFjZSIsInNraXBXaGl0ZVNwYWNlIiwicmVmIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsImhhc093biIsIm9iaiIsInByb3BOYW1lIiwiY2FsbCIsImlzQXJyYXkiLCJBcnJheSIsInJlZ2V4cENhY2hlIiwiY3JlYXRlIiwid29yZHNSZWdleHAiLCJ3b3JkcyIsInJlcGxhY2UiLCJjb2RlUG9pbnRUb1N0cmluZyIsImxvbmVTdXJyb2dhdGUiLCJQb3NpdGlvbiIsImxpbmUiLCJjb2wiLCJjb2x1bW4iLCJvZmZzZXQiLCJuIiwiU291cmNlTG9jYXRpb24iLCJwIiwic3RhcnQiLCJzb3VyY2VGaWxlIiwiZ2V0TGluZUluZm8iLCJpbnB1dCIsImN1ciIsIm5leHRCcmVhayIsImRlZmF1bHRPcHRpb25zIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwib25JbnNlcnRlZFNlbWljb2xvbiIsIm9uVHJhaWxpbmdDb21tYSIsImFsbG93UmVzZXJ2ZWQiLCJhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbiIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24iLCJhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCIsImFsbG93SGFzaEJhbmciLCJjaGVja1ByaXZhdGVGaWVsZHMiLCJsb2NhdGlvbnMiLCJvblRva2VuIiwib25Db21tZW50IiwicmFuZ2VzIiwicHJvZ3JhbSIsImRpcmVjdFNvdXJjZUZpbGUiLCJwcmVzZXJ2ZVBhcmVucyIsIndhcm5lZEFib3V0RWNtYVZlcnNpb24iLCJnZXRPcHRpb25zIiwib3B0cyIsIm9wdCIsImNvbnNvbGUiLCJ3YXJuIiwidG9rZW5zIiwidG9rZW4iLCJwdXNoIiwicHVzaENvbW1lbnQiLCJhcnJheSIsImJsb2NrIiwidGV4dCIsInN0YXJ0TG9jIiwiZW5kTG9jIiwiY29tbWVudCIsInR5cGUiLCJ2YWx1ZSIsImxvYyIsInJhbmdlIiwiU0NPUEVfVE9QIiwiU0NPUEVfRlVOQ1RJT04iLCJTQ09QRV9BU1lOQyIsIlNDT1BFX0dFTkVSQVRPUiIsIlNDT1BFX0FSUk9XIiwiU0NPUEVfU0lNUExFX0NBVENIIiwiU0NPUEVfU1VQRVIiLCJTQ09QRV9ESVJFQ1RfU1VQRVIiLCJTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0siLCJTQ09QRV9WQVIiLCJmdW5jdGlvbkZsYWdzIiwiYXN5bmMiLCJnZW5lcmF0b3IiLCJCSU5EX05PTkUiLCJCSU5EX1ZBUiIsIkJJTkRfTEVYSUNBTCIsIkJJTkRfRlVOQ1RJT04iLCJCSU5EX1NJTVBMRV9DQVRDSCIsIkJJTkRfT1VUU0lERSIsIlBhcnNlciIsInN0YXJ0UG9zIiwicmVzZXJ2ZWQiLCJyZXNlcnZlZFN0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3QiLCJyZXNlcnZlZFdvcmRzU3RyaWN0QmluZCIsImNvbnRhaW5zRXNjIiwibGluZVN0YXJ0IiwibGFzdEluZGV4T2YiLCJjdXJMaW5lIiwic2xpY2UiLCJzcGxpdCIsImN1clBvc2l0aW9uIiwibGFzdFRva0VuZExvYyIsImxhc3RUb2tTdGFydExvYyIsImxhc3RUb2tTdGFydCIsImxhc3RUb2tFbmQiLCJjb250ZXh0IiwiaW5pdGlhbENvbnRleHQiLCJleHByQWxsb3dlZCIsImluTW9kdWxlIiwic3RyaWN0RGlyZWN0aXZlIiwicG90ZW50aWFsQXJyb3dBdCIsInBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCIsInlpZWxkUG9zIiwiYXdhaXRQb3MiLCJhd2FpdElkZW50UG9zIiwibGFiZWxzIiwidW5kZWZpbmVkRXhwb3J0cyIsInNraXBMaW5lQ29tbWVudCIsInNjb3BlU3RhY2siLCJlbnRlclNjb3BlIiwicmVnZXhwU3RhdGUiLCJwcml2YXRlTmFtZVN0YWNrIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiaW5GdW5jdGlvbiIsImNvbmZpZ3VyYWJsZSIsImluR2VuZXJhdG9yIiwiaW5Bc3luYyIsImNhbkF3YWl0IiwiYWxsb3dTdXBlciIsImFsbG93RGlyZWN0U3VwZXIiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFyIiwiYWxsb3dOZXdEb3RUYXJnZXQiLCJpbkNsYXNzU3RhdGljQmxvY2siLCJwYXJzZSIsIm5vZGUiLCJzdGFydE5vZGUiLCJuZXh0VG9rZW4iLCJwYXJzZVRvcExldmVsIiwiZ2V0IiwiY3VycmVudFZhclNjb3BlIiwiZmxhZ3MiLCJpbkNsYXNzRmllbGRJbml0Iiwic2NvcGUiLCJjdXJyZW50VGhpc1Njb3BlIiwidHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUiLCJjdXJyZW50U2NvcGUiLCJleHRlbmQiLCJwbHVnaW5zIiwibGVuIiwiYXJndW1lbnRzIiwiY2xzIiwicGFyc2VFeHByZXNzaW9uQXQiLCJwYXJzZXIiLCJwYXJzZUV4cHJlc3Npb24iLCJ0b2tlbml6ZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHAkOSIsImxpdGVyYWwiLCJsYXN0SW5kZXgiLCJleGVjIiwibWF0Y2giLCJzcGFjZUFmdGVyIiwiaW5kZXgiLCJjaGFyQXQiLCJlYXQiLCJpc0NvbnRleHR1YWwiLCJlYXRDb250ZXh0dWFsIiwiZXhwZWN0Q29udGV4dHVhbCIsInVuZXhwZWN0ZWQiLCJjYW5JbnNlcnRTZW1pY29sb24iLCJpbnNlcnRTZW1pY29sb24iLCJzZW1pY29sb24iLCJhZnRlclRyYWlsaW5nQ29tbWEiLCJ0b2tUeXBlIiwibm90TmV4dCIsImV4cGVjdCIsInJhaXNlIiwiRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInNob3J0aGFuZEFzc2lnbiIsInRyYWlsaW5nQ29tbWEiLCJwYXJlbnRoZXNpemVkQXNzaWduIiwicGFyZW50aGVzaXplZEJpbmQiLCJkb3VibGVQcm90byIsImNoZWNrUGF0dGVybkVycm9ycyIsInJlZkRlc3RydWN0dXJpbmdFcnJvcnMiLCJyYWlzZVJlY292ZXJhYmxlIiwicGFyZW5zIiwiY2hlY2tFeHByZXNzaW9uRXJyb3JzIiwiYW5kVGhyb3ciLCJjaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMiLCJpc1NpbXBsZUFzc2lnblRhcmdldCIsImV4cHIiLCJleHByZXNzaW9uIiwicHAkOCIsImV4cG9ydHMiLCJib2R5Iiwic3RtdCIsInBhcnNlU3RhdGVtZW50IiwibGlzdCIsImtleXMiLCJhZGFwdERpcmVjdGl2ZVByb2xvZ3VlIiwiZmluaXNoTm9kZSIsImxvb3BMYWJlbCIsImtpbmQiLCJzd2l0Y2hMYWJlbCIsImlzTGV0Iiwic2tpcCIsIm5leHRDaCIsImlkZW50IiwiaXNBc3luY0Z1bmN0aW9uIiwiYWZ0ZXIiLCJ0b3BMZXZlbCIsInN0YXJ0dHlwZSIsInBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCIsInBhcnNlRGVidWdnZXJTdGF0ZW1lbnQiLCJwYXJzZURvU3RhdGVtZW50IiwicGFyc2VGb3JTdGF0ZW1lbnQiLCJwYXJzZUZ1bmN0aW9uU3RhdGVtZW50IiwicGFyc2VDbGFzcyIsInBhcnNlSWZTdGF0ZW1lbnQiLCJwYXJzZVJldHVyblN0YXRlbWVudCIsInBhcnNlU3dpdGNoU3RhdGVtZW50IiwicGFyc2VUaHJvd1N0YXRlbWVudCIsInBhcnNlVHJ5U3RhdGVtZW50IiwicGFyc2VWYXJTdGF0ZW1lbnQiLCJwYXJzZVdoaWxlU3RhdGVtZW50IiwicGFyc2VXaXRoU3RhdGVtZW50IiwicGFyc2VCbG9jayIsInBhcnNlRW1wdHlTdGF0ZW1lbnQiLCJwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQiLCJwYXJzZUltcG9ydCIsInBhcnNlRXhwb3J0IiwibWF5YmVOYW1lIiwicGFyc2VMYWJlbGVkU3RhdGVtZW50IiwiaXNCcmVhayIsInBhcnNlSWRlbnQiLCJsYWIiLCJwb3AiLCJwYXJzZVBhcmVuRXhwcmVzc2lvbiIsImF3YWl0QXQiLCJwYXJzZUZvciIsImluaXQkMSIsInBhcnNlVmFyIiwiZGVjbGFyYXRpb25zIiwiYXdhaXQiLCJwYXJzZUZvckluIiwic3RhcnRzV2l0aExldCIsImlzRm9yT2YiLCJpbml0IiwidG9Bc3NpZ25hYmxlIiwiY2hlY2tMVmFsUGF0dGVybiIsImlzQXN5bmMiLCJkZWNsYXJhdGlvblBvc2l0aW9uIiwicGFyc2VGdW5jdGlvbiIsIkZVTkNfU1RBVEVNRU5UIiwiRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJhcmd1bWVudCIsImRpc2NyaW1pbmFudCIsImNhc2VzIiwic2F3RGVmYXVsdCIsImlzQ2FzZSIsImV4aXRTY29wZSIsImVtcHR5JDEiLCJwYXJzZUNhdGNoQ2xhdXNlUGFyYW0iLCJwYXJhbSIsInBhcnNlQmluZGluZ0F0b20iLCJzaW1wbGUiLCJoYW5kbGVyIiwiY2xhdXNlIiwiZmluYWxpemVyIiwiYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIiLCJvYmplY3QiLCJpJDEiLCJsYWJlbCQxIiwic3RhdGVtZW50U3RhcnQiLCJpbmRleE9mIiwiY3JlYXRlTmV3TGV4aWNhbFNjb3BlIiwiZXhpdFN0cmljdCIsInVwZGF0ZSIsImlzRm9ySW4iLCJpZCIsImxlZnQiLCJyaWdodCIsInBhcnNlTWF5YmVBc3NpZ24iLCJpc0ZvciIsImRlY2wiLCJwYXJzZVZhcklkIiwiRlVOQ19OVUxMQUJMRV9JRCIsInN0YXRlbWVudCIsImFsbG93RXhwcmVzc2lvbkJvZHkiLCJmb3JJbml0IiwiaW5pdEZ1bmN0aW9uIiwiY2hlY2tMVmFsU2ltcGxlIiwib2xkWWllbGRQb3MiLCJvbGRBd2FpdFBvcyIsIm9sZEF3YWl0SWRlbnRQb3MiLCJwYXJzZUZ1bmN0aW9uUGFyYW1zIiwicGFyc2VGdW5jdGlvbkJvZHkiLCJwYXJhbXMiLCJwYXJzZUJpbmRpbmdMaXN0IiwiaXNTdGF0ZW1lbnQiLCJvbGRTdHJpY3QiLCJwYXJzZUNsYXNzSWQiLCJwYXJzZUNsYXNzU3VwZXIiLCJwcml2YXRlTmFtZU1hcCIsImVudGVyQ2xhc3NCb2R5IiwiY2xhc3NCb2R5IiwiaGFkQ29uc3RydWN0b3IiLCJlbGVtZW50IiwicGFyc2VDbGFzc0VsZW1lbnQiLCJzdXBlckNsYXNzIiwia2V5IiwiaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQiLCJleGl0Q2xhc3NCb2R5IiwiY29uc3RydWN0b3JBbGxvd3NTdXBlciIsImtleU5hbWUiLCJpc0dlbmVyYXRvciIsImlzU3RhdGljIiwicGFyc2VDbGFzc1N0YXRpY0Jsb2NrIiwiaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQiLCJzdGF0aWMiLCJsYXN0VmFsdWUiLCJjb21wdXRlZCIsInN0YXJ0Tm9kZUF0IiwicGFyc2VDbGFzc0VsZW1lbnROYW1lIiwiaXNDb25zdHJ1Y3RvciIsImNoZWNrS2V5TmFtZSIsImFsbG93c0RpcmVjdFN1cGVyIiwicGFyc2VDbGFzc01ldGhvZCIsInBhcnNlQ2xhc3NGaWVsZCIsInBhcnNlUHJpdmF0ZUlkZW50IiwicGFyc2VQcm9wZXJ0eU5hbWUiLCJtZXRob2QiLCJwYXJzZU1ldGhvZCIsImZpZWxkIiwib2xkTGFiZWxzIiwicGFyc2VFeHByU3Vic2NyaXB0cyIsImRlY2xhcmVkIiwidXNlZCIsInBhcmVudCIsImN1cnIiLCJwYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uIiwiZXhwb3J0ZWQiLCJwYXJzZU1vZHVsZUV4cG9ydE5hbWUiLCJjaGVja0V4cG9ydCIsInBhcnNlRXhwckF0b20iLCJkZWNsYXJhdGlvbiIsInBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIiwic2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQiLCJwYXJzZUV4cG9ydERlY2xhcmF0aW9uIiwiY2hlY2tWYXJpYWJsZUV4cG9ydCIsInNwZWNpZmllcnMiLCJwYXJzZUV4cG9ydFNwZWNpZmllcnMiLCJzcGVjIiwiY2hlY2tVbnJlc2VydmVkIiwibG9jYWwiLCJjaGVja0xvY2FsRXhwb3J0IiwiZk5vZGUiLCJjTm9kZSIsImNoZWNrUGF0dGVybkV4cG9ydCIsInBhdCIsInByb3BlcnRpZXMiLCJwcm9wIiwibGlzdCQxIiwiZWxlbWVudHMiLCJlbHQiLCJkZWNscyIsInBhcnNlRXhwb3J0U3BlY2lmaWVyIiwibm9kZXMiLCJmaXJzdCIsInBhcnNlSW1wb3J0U3BlY2lmaWVycyIsInBhcnNlSW1wb3J0U3BlY2lmaWVyIiwiaW1wb3J0ZWQiLCJwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsInN0cmluZ0xpdGVyYWwiLCJwYXJzZUxpdGVyYWwiLCJzdGF0ZW1lbnRzIiwiaXNEaXJlY3RpdmVDYW5kaWRhdGUiLCJkaXJlY3RpdmUiLCJyYXciLCJwcCQ3IiwiaXNCaW5kaW5nIiwidG9Bc3NpZ25hYmxlTGlzdCIsIm9wZXJhdG9yIiwiZXhwckxpc3QiLCJsYXN0IiwicGFyc2VTcHJlYWQiLCJwYXJzZVJlc3RCaW5kaW5nIiwicGFyc2VPYmoiLCJjbG9zZSIsImFsbG93RW1wdHkiLCJhbGxvd1RyYWlsaW5nQ29tbWEiLCJhbGxvd01vZGlmaWVycyIsImVsdHMiLCJyZXN0IiwicGFyc2VCaW5kaW5nTGlzdEl0ZW0iLCJwYXJzZUFzc2lnbmFibGVMaXN0SXRlbSIsImVsZW0iLCJwYXJzZU1heWJlRGVmYXVsdCIsImJpbmRpbmdUeXBlIiwiY2hlY2tDbGFzaGVzIiwiaXNCaW5kIiwiZGVjbGFyZU5hbWUiLCJjaGVja0xWYWxJbm5lclBhdHRlcm4iLCJUb2tDb250ZXh0IiwiaXNFeHByIiwicHJlc2VydmVTcGFjZSIsIm92ZXJyaWRlIiwidHlwZXMiLCJiX3N0YXQiLCJiX2V4cHIiLCJiX3RtcGwiLCJwX3N0YXQiLCJwX2V4cHIiLCJxX3RtcGwiLCJ0cnlSZWFkVGVtcGxhdGVUb2tlbiIsImZfc3RhdCIsImZfZXhwciIsImZfZXhwcl9nZW4iLCJmX2dlbiIsInBwJDYiLCJjdXJDb250ZXh0IiwiYnJhY2VJc0Jsb2NrIiwicHJldlR5cGUiLCJpbkdlbmVyYXRvckNvbnRleHQiLCJvdmVycmlkZUNvbnRleHQiLCJ0b2tlbkN0eCIsIm91dCIsInN0YXRlbWVudFBhcmVucyIsImFsbG93ZWQiLCJwcCQ1IiwiY2hlY2tQcm9wQ2xhc2giLCJwcm9wSGFzaCIsInNob3J0aGFuZCIsInByb3RvIiwib3RoZXIiLCJyZWRlZmluaXRpb24iLCJleHByZXNzaW9ucyIsImFmdGVyTGVmdFBhcnNlIiwicGFyc2VZaWVsZCIsIm93bkRlc3RydWN0dXJpbmdFcnJvcnMiLCJvbGRQYXJlbkFzc2lnbiIsIm9sZFRyYWlsaW5nQ29tbWEiLCJvbGREb3VibGVQcm90byIsInBhcnNlTWF5YmVDb25kaXRpb25hbCIsInBhcnNlRXhwck9wcyIsInBhcnNlTWF5YmVVbmFyeSIsInBhcnNlRXhwck9wIiwibGVmdFN0YXJ0UG9zIiwibGVmdFN0YXJ0TG9jIiwibWluUHJlYyIsImxvZ2ljYWwiLCJvcCIsImJ1aWxkQmluYXJ5Iiwic2F3VW5hcnkiLCJwYXJzZUF3YWl0IiwiaXNQcml2YXRlRmllbGRBY2Nlc3MiLCJub2RlJDEiLCJwcm9wZXJ0eSIsInJlc3VsdCIsInBhcnNlU3Vic2NyaXB0cyIsImJhc2UiLCJub0NhbGxzIiwibWF5YmVBc3luY0Fycm93Iiwib3B0aW9uYWxDaGFpbmVkIiwicGFyc2VTdWJzY3JpcHQiLCJvcHRpb25hbCIsImNoYWluTm9kZSIsInNob3VsZFBhcnNlQXN5bmNBcnJvdyIsInBhcnNlU3Vic2NyaXB0QXN5bmNBcnJvdyIsInBhcnNlQXJyb3dFeHByZXNzaW9uIiwib3B0aW9uYWxTdXBwb3J0ZWQiLCJwYXJzZUV4cHJMaXN0IiwiY2FsbGVlIiwibm9kZSQyIiwidGFnIiwicXVhc2kiLCJwYXJzZVRlbXBsYXRlIiwiaXNUYWdnZWQiLCJmb3JOZXciLCJyZWFkUmVnZXhwIiwiY2FuQmVBcnJvdyIsInJlZ2V4IiwicGF0dGVybiIsInBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24iLCJwYXJzZU5ldyIsInBhcnNlRXhwckltcG9ydCIsInBhcnNlRXhwckF0b21EZWZhdWx0IiwibWV0YSIsInBhcnNlRHluYW1pY0ltcG9ydCIsInBhcnNlSW1wb3J0TWV0YSIsImVycm9yUG9zIiwiYmlnaW50IiwidmFsIiwic2hvdWxkUGFyc2VBcnJvdyIsImlubmVyU3RhcnRQb3MiLCJpbm5lclN0YXJ0TG9jIiwibGFzdElzQ29tbWEiLCJzcHJlYWRTdGFydCIsInBhcnNlUGFyZW5JdGVtIiwiaW5uZXJFbmRQb3MiLCJpbm5lckVuZExvYyIsInBhcnNlUGFyZW5BcnJvd0xpc3QiLCJmaW5pc2hOb2RlQXQiLCJwYXIiLCJpdGVtIiwiZW1wdHkiLCJwYXJzZVRlbXBsYXRlRWxlbWVudCIsImNvb2tlZCIsInRhaWwiLCJjdXJFbHQiLCJxdWFzaXMiLCJpc0FzeW5jUHJvcCIsImlzUGF0dGVybiIsInBhcnNlUHJvcGVydHkiLCJwYXJzZVByb3BlcnR5VmFsdWUiLCJwYXJzZUdldHRlclNldHRlciIsInBhcmFtQ291bnQiLCJjb3B5Tm9kZSIsImlzQXJyb3dGdW5jdGlvbiIsImlzTWV0aG9kIiwiaXNFeHByZXNzaW9uIiwidXNlU3RyaWN0IiwiY2hlY2tQYXJhbXMiLCJub25TaW1wbGUiLCJpc1NpbXBsZVBhcmFtTGlzdCIsInVuZGVmaW5lZCIsImFsbG93RHVwbGljYXRlcyIsIm5hbWVIYXNoIiwicmUiLCJsaWJlcmFsIiwicGFyc2VJZGVudE5vZGUiLCJkZWxlZ2F0ZSIsInBwJDQiLCJtZXNzYWdlIiwiZXJyIiwiU3ludGF4RXJyb3IiLCJyYWlzZWRBdCIsInBwJDMiLCJTY29wZSIsInZhciIsImxleGljYWwiLCJmdW5jdGlvbnMiLCJyZWRlY2xhcmVkIiwic2NvcGUkMSIsInNjb3BlJDIiLCJzY29wZSQzIiwiTm9kZSIsInBwJDIiLCJuZXdOb2RlIiwiZWNtYTlCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTEwQmluYXJ5UHJvcGVydGllcyIsImVjbWExMUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTJCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTEzQmluYXJ5UHJvcGVydGllcyIsImVjbWExNEJpbmFyeVByb3BlcnRpZXMiLCJ1bmljb2RlQmluYXJ5UHJvcGVydGllcyIsImVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3MiLCJ1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMiLCJlY21hOVNjcmlwdFZhbHVlcyIsImVjbWExMFNjcmlwdFZhbHVlcyIsImVjbWExMVNjcmlwdFZhbHVlcyIsImVjbWExMlNjcmlwdFZhbHVlcyIsImVjbWExM1NjcmlwdFZhbHVlcyIsImVjbWExNFNjcmlwdFZhbHVlcyIsInVuaWNvZGVTY3JpcHRWYWx1ZXMiLCJkYXRhIiwiYnVpbGRVbmljb2RlRGF0YSIsImQiLCJiaW5hcnkiLCJiaW5hcnlPZlN0cmluZ3MiLCJub25CaW5hcnkiLCJHZW5lcmFsX0NhdGVnb3J5IiwiU2NyaXB0IiwiU2NyaXB0X0V4dGVuc2lvbnMiLCJnYyIsInNjIiwic2N4IiwicHAkMSIsIlJlZ0V4cFZhbGlkYXRpb25TdGF0ZSIsInZhbGlkRmxhZ3MiLCJ1bmljb2RlUHJvcGVydGllcyIsInN3aXRjaFUiLCJzd2l0Y2hWIiwic3dpdGNoTiIsImxhc3RJbnRWYWx1ZSIsImxhc3RTdHJpbmdWYWx1ZSIsImxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSIsIm51bUNhcHR1cmluZ1BhcmVucyIsIm1heEJhY2tSZWZlcmVuY2UiLCJncm91cE5hbWVzIiwiYmFja1JlZmVyZW5jZU5hbWVzIiwicmVzZXQiLCJ1bmljb2RlU2V0cyIsInVuaWNvZGUiLCJhdCIsImZvcmNlVSIsInMiLCJsIiwiYyIsIm5leHRJbmRleCIsImN1cnJlbnQiLCJsb29rYWhlYWQiLCJhZHZhbmNlIiwiY2giLCJlYXRDaGFycyIsImNocyIsInZhbGlkYXRlUmVnRXhwRmxhZ3MiLCJzdGF0ZSIsInUiLCJ2IiwiZmxhZyIsInZhbGlkYXRlUmVnRXhwUGF0dGVybiIsInJlZ2V4cF9wYXR0ZXJuIiwicmVnZXhwX2Rpc2p1bmN0aW9uIiwicmVnZXhwX2FsdGVybmF0aXZlIiwicmVnZXhwX2VhdFF1YW50aWZpZXIiLCJyZWdleHBfZWF0VGVybSIsInJlZ2V4cF9lYXRBc3NlcnRpb24iLCJyZWdleHBfZWF0QXRvbSIsInJlZ2V4cF9lYXRFeHRlbmRlZEF0b20iLCJsb29rYmVoaW5kIiwibm9FcnJvciIsInJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4IiwicmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIiLCJtaW4iLCJtYXgiLCJyZWdleHBfZWF0RGVjaW1hbERpZ2l0cyIsInJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyIsInJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUiLCJyZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MiLCJyZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCIsInJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCIsInJlZ2V4cF9lYXRBdG9tRXNjYXBlIiwicmVnZXhwX2dyb3VwU3BlY2lmaWVyIiwicmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyIiwicmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciIsInJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIiLCJpc1N5bnRheENoYXJhY3RlciIsInJlZ2V4cF9lYXRHcm91cE5hbWUiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0IiwicmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0IiwicmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSIsImlzUmVnRXhwSWRlbnRpZmllclN0YXJ0IiwiaXNSZWdFeHBJZGVudGlmaWVyUGFydCIsInJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlIiwicmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlIiwicmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSIsInJlZ2V4cF9lYXRLR3JvdXBOYW1lIiwicmVnZXhwX2VhdERlY2ltYWxFc2NhcGUiLCJyZWdleHBfZWF0Q29udHJvbEVzY2FwZSIsInJlZ2V4cF9lYXRDQ29udHJvbExldHRlciIsInJlZ2V4cF9lYXRaZXJvIiwicmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlIiwicmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UiLCJyZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUiLCJyZWdleHBfZWF0Q29udHJvbExldHRlciIsImlzRGVjaW1hbERpZ2l0IiwiaXNDb250cm9sTGV0dGVyIiwicmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzIiwibGVhZCIsImxlYWRTdXJyb2dhdGVFbmQiLCJ0cmFpbCIsInJlZ2V4cF9lYXRIZXhEaWdpdHMiLCJpc1ZhbGlkVW5pY29kZSIsIkNoYXJTZXROb25lIiwiQ2hhclNldE9rIiwiQ2hhclNldFN0cmluZyIsImlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUiLCJuZWdhdGUiLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIiwicmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUiLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUiLCJyZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUiLCJyZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIiwibmFtZU9yVmFsdWUiLCJyZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSIsImlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlciIsImlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIiLCJyZWdleHBfY2xhc3NDb250ZW50cyIsInJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24iLCJyZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyIsInJlZ2V4cF9lYXRDbGFzc0F0b20iLCJyZWdleHBfZWF0Q2xhc3NFc2NhcGUiLCJjaCQxIiwiaXNPY3RhbERpZ2l0IiwicmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciIsInN1YlJlc3VsdCIsInJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlIiwicmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZCIsInJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlciIsInJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uIiwicmVnZXhwX2VhdE5lc3RlZENsYXNzIiwicmVzdWx0JDEiLCJyZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzIiwicmVnZXhwX2NsYXNzU3RyaW5nIiwiY291bnQiLCJyZWdleHBfZWF0Q2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IiLCJpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyIiwiaXNDbGFzc1NldFN5bnRheENoYXJhY3RlciIsImlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IiLCJpc0hleERpZ2l0IiwiaGV4VG9JbnQiLCJyZWdleHBfZWF0T2N0YWxEaWdpdCIsIm4xIiwibjIiLCJUb2tlbiIsInBwIiwiaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQiLCJnZXRUb2tlbiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidGhpcyQxJDEiLCJkb25lIiwic2tpcFNwYWNlIiwiZmluaXNoVG9rZW4iLCJyZWFkVG9rZW4iLCJmdWxsQ2hhckNvZGVBdFBvcyIsInJlYWRXb3JkIiwiZ2V0VG9rZW5Gcm9tQ29kZSIsInNraXBCbG9ja0NvbW1lbnQiLCJzdGFydFNraXAiLCJsb29wIiwicmVhZFRva2VuX2RvdCIsInJlYWROdW1iZXIiLCJuZXh0MiIsInJlYWRUb2tlbl9zbGFzaCIsImZpbmlzaE9wIiwicmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCIsInNpemUiLCJ0b2tlbnR5cGUiLCJyZWFkVG9rZW5fcGlwZV9hbXAiLCJyZWFkVG9rZW5fY2FyZXQiLCJyZWFkVG9rZW5fcGx1c19taW4iLCJyZWFkVG9rZW5fbHRfZ3QiLCJyZWFkVG9rZW5fZXFfZXhjbCIsInJlYWRUb2tlbl9xdWVzdGlvbiIsIm5leHQyJDEiLCJyZWFkVG9rZW5fbnVtYmVyU2lnbiIsInJlYWRXb3JkMSIsInJlYWRSYWRpeE51bWJlciIsInJlYWRTdHJpbmciLCJzdHIiLCJlc2NhcGVkIiwiaW5DbGFzcyIsImZsYWdzU3RhcnQiLCJlIiwicmVhZEludCIsInJhZGl4IiwibWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsIiwiYWxsb3dTZXBhcmF0b3JzIiwiaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsIiwidG90YWwiLCJsYXN0Q29kZSIsIkluZmluaXR5Iiwic3RyaW5nVG9OdW1iZXIiLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJzdHJpbmdUb0JpZ0ludCIsIkJpZ0ludCIsInN0YXJ0c1dpdGhEb3QiLCJvY3RhbCIsInZhbCQxIiwicmVhZENvZGVQb2ludCIsImNvZGVQb3MiLCJyZWFkSGV4Q2hhciIsImludmFsaWRTdHJpbmdUb2tlbiIsInF1b3RlIiwiY2h1bmtTdGFydCIsInJlYWRFc2NhcGVkQ2hhciIsIklOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SIiwiaW5UZW1wbGF0ZUVsZW1lbnQiLCJyZWFkVG1wbFRva2VuIiwicmVhZEludmFsaWRUZW1wbGF0ZVRva2VuIiwicG9zaXRpb24iLCJpblRlbXBsYXRlIiwib2N0YWxTdHIiLCJzdWJzdHIiLCJ3b3JkIiwiZXNjU3RhcnQiLCJlc2MiLCJ2ZXJzaW9uIiwiYWNvcm4iLCJ0b2tUeXBlcyIsImtleXdvcmRUeXBlcyIsInRva0NvbnRleHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/acorn/dist/acorn.mjs\n");

/***/ })

};
;